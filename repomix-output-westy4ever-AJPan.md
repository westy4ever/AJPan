This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed, line numbers have been added, security check has been disabled.

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Line numbers have been added to the beginning of each line
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
res/
  _changeLog.txt
  _help_cmenu
  _help_fman
  _help_main
  _help_movBr
  _help_picons
  _help_player
  _help_resize
  _help_servBr
  _help_service_filter
  _help_signal
  _help_srvcBr
  _help_subt
  _help_table
  _help_terminal
  _help_txt
  _hlpG
  _sup_codecs
  _sup_genre
  _sup_lib
  ajp.png
  ajp2.png
  ajpanel_cmd_list
  ajpanel_iptv_blacklist
  ajpanel_iptv_prefix
  ajpanel_lang
  ajpanel_menu.xml
  ajpanel_pkg
  ajpanel_res_marker
  ajpanel_services_filter
  aud.png
  bar_sig.png
  cc1.png
  cc2.png
  cc3.png
  data.tar.gz
  data.tar.xz
  deb.png
  dir.png
  dir1.png
  dirInvis.png
  dirLck.png
  dirLckInvis.png
  dirup.png
  dnld.png
  err.png
  fil.png
  frm1.png
  frm2.png
  grp.png
  info.png
  invis.png
  ipk.png
  m3u.png
  mem.png
  menu.png
  menug.png
  menux.png
  mntL.png
  mntN.png
  mov.png
  mrk1.png
  mrk2.png
  mus.png
  noPic.png
  p7z.png
  pic.png
  plugin.png
  py.png
  rar.png
  rpt.png
  scr.png
  slbfil.png
  slwdir.png
  slwfil.png
  tar.png
  teln.png
  tick_1x1.png
  tick.png
  tv.png
  txt.png
  usb.png
  wget.png
  zip.png
  zst.png
__init__.py
icon.png
iconhd.png
keymap.xml
plugin.py
README.md
```

# Files

## File: res/_changeLog.txt
```
   1: # ------------------------------------------------------------------------------------------------------------
   2: [v10.8.5 .. 2025-10-14]
   3: - Fixed online upgrade version change issue.
   4: 
   5: # ------------------------------------------------------------------------------------------------------------
   6: [v10.8.4 .. 2025-08-28]
   7: - Fixed starting the movie from the beginning when it ends on some servers.
   8: 
   9: # ------------------------------------------------------------------------------------------------------------
  10: [v10.8.3 .. 2025-05-13]
  11: - Fixed Posters Mode for some servers where the same PIcon/Poster is shown for all channels.
  12: 
  13: # ------------------------------------------------------------------------------------------------------------
  14: [v10.8.2 .. 2025-05-08]
  15: - Added option to Services Tools to delete DVB channels from system (delete from bouquets and lamedb).
  16: - Renamed the option "Services (Parental-Control + Hidden)" to "Services (Lock, Hide, Delete, Add to Fav)".
  17: - Added the new filter "Reference Type ..." to PIcons page to filter PIcons by Reference Type in file name.
  18: - Improved File Manager conversion from "zip" to "tar.gz" (and vice versa).
  19: - Improved File Manager options "Create New File" and "Create New Directory" to point to the newly created File/Directory.
  20: - Improved Download Manager to highlight storage problems (e.g. if out of storage space).
  21: - Improved File Manager option "Create SymLink" (for file/directory names that include spaces).
  22: - Improved free disk space calculations to show the free and available space.
  23: - Improved "Services/Channels" tables:
  24: .. Improved Service Info (when clicking INFO Button).
  25: .. After playing a channel, zapping up/down in Player-Bar will change channels in tables (not in bouquets).
  26: - Improved AJPanel update process for some images on DreamOS (to fix "dpkg was interrupted" error).
  27: 
  28: # ------------------------------------------------------------------------------------------------------------
  29: [v10.8.1 .. 2025-04-14]
  30: - Added "Radio Services" filter to the table menu in "Services (Parental-Control + Hidden)".
  31: - Improved "Stream Relay Services" filter in "Services (Parental-Control + Hidden)".
  32: - Fixed Screenshot file names to allow Arabic characters when a screenshot is taken for Arabic titled event/video.
  33: - Fixed some DreamOS installation problems.
  34: 
  35: # ------------------------------------------------------------------------------------------------------------
  36: [v10.8.0 .. 2025-04-13]
  37: - Added the option "Change System Fonts Size" to increase/decrease current fonts size for the system (without a restart).
  38: - Added buttons to System Font Changer to increase/decrease System Font size (without a restart).
  39: - Added a new option to Movies Browser to download posters for the listed movies.
  40: - Added a new option to Player Bar second menu to download posters for the playing event/movie.
  41: - Improved error handling in File Manager Copy/Move functions (especially with Permissions issues).
  42: - Improved PIcons "Current Service" (Green Button) to jump to the correct PIcon after zapping.
  43: - Fixed backup files to include DreamOS images (GP4 and Dream-Elite).
  44: - Fixed Subtitle text clipping on the sides (for DreamOS Dream-Elite).
  45: 
  46: # ------------------------------------------------------------------------------------------------------------
  47: [v10.7.1 .. 2025-03-08]
  48: - Fixed a crash on OpenDriod in the new option "Set Local Media PIcons (ALL Bouquets)".
  49: 
  50: # ------------------------------------------------------------------------------------------------------------
  51: [v10.7.0 .. 2025-03-04]
  52: - Added a new option to the Player Bar menu to change the action of Red-Button to:
  53: .. "Close Bar & Recall Last DVB Service" (default action).
  54: .. "Show Signal Monitor".
  55: - Added new option to Bouquet Editor to "Fix Media PIcons (for Movies in ALL Bouquets)".
  56: .. To process bouquets and assign PIcons for local media services (if posters exist with the media).
  57: - Improved restoring tuner to utilize backups between images:
  58: .. Example: Create backups on OpenATV and restore them on OpenATV (and vice versa).
  59: - Added "Save to M3U (Live/VOD)" to save M3U for servers that do not provide M3U files.
  60: - Added "Save to M3U (Live/VOD/Series)" to save M3U for servers that do not provide M3U files.
  61: .. Better Series/Episodes categorization (but slower than downloading the server M3U).
  62: - Added "Play URL" (Blue Button) to the Download Manager to play the server URL.
  63: - Modified some options to save the result files to the "/ajpanel_iptv/" (in the backup directory):
  64: .. When saving channels to M3U file (from IPTV tables and Bouquet Editor).
  65: .. When Merging Playlist/Portal files.
  66: - Improved Playlist files reader to handle files exported from Playlist lines table.
  67: - Improved Playlist/Portal files menu to be updated with new files (after exporting their lines to txt file).
  68: - Improved Posters Mode title to show Category Name.
  69: - Improved IPTV Channel Name Prefix removal for names with Unicode symbols.
  70: - Added General Guide help for Player Bar "Launching", "Shortcuts (OK & Exit)" and "Stopping Current Channel".
  71: - Fixed the error "HTTP Error 403: Forbidden" (for some Playlist servers).
  72: 
  73: # ------------------------------------------------------------------------------------------------------------
  74: [v10.6.0 .. 2025-02-11]
  75: - Added a second menu to the Player-Bar for quick access to more options.
  76: .. "Stop Current Service"
  77: .. "Stop Current Service & Close AJPanel"
  78: .. "Play Last Stopped Channel"
  79: .. "Channel Selection"
  80: .. "Channels Browser"
  81: .. "Zap History"
  82: .. "Close AJPanel"
  83: - Improved launching "Channel Selection" to point to the current channel.
  84: - Improved Channels Browser:
  85: .. Added INFO Button to show channel info.
  86: .. Zapping will add the newly played service to the Zap History.
  87: .. Rearranged the buttons and their usage (OK/Red/Green/Blue Buttons).
  88: - Improved Channels Binder:
  89: .. Added the options "Next Chained Service" and "Previous Chained Service" Channels Binder to locate chained channels.
  90: .. Will allow binding a source channel to multiple target channels.
  91: .. Title will show current service mode (TV/Radio).
  92: - Fixed "Share Reference with DVB Channels (from xml file)" to prevent changing duplicate reference in bouquet file.
  93: - Fixed the problem of skipping pyo/pyc files when creating ipk/deb packages.
  94: 
  95: # ------------------------------------------------------------------------------------------------------------
  96: [v10.5.1 .. 2025-01-30]
  97: - Fixed Custom Menu when loading an invalid wallpaper picture file..
  98: - Improved AJPanel instllation and update for DreamOS.
  99: - Improved "AJPanel Optional Dependencies" table for DreamOS.
 100: - Fixed a crash when starting subtitle on DreamOS.
 101: - Fixed Main Page font size on DreamOS (it gets a bit smaller when returning from IPTV Page).
 102: 
 103: # ------------------------------------------------------------------------------------------------------------
 104: [v10.5.0 .. 2025-01-26]
 105: - Added "Rename" (Blue Button) to rename the local servers in "Local Servers & M3U Cache" page.
 106: - Improved Subtitle Line/Delay Changer (which opens with Left & Right keys):
 107: .. Will not change the delay until the arrows are used.
 108: .. Will not timeout and can be closed with Exit or OK.
 109: .. Added Up/Down Buttons to change the delay.
 110: .. Added "Reset" (Yellow Button) to reset the delay.
 111: .. Shows auto-updated line number and line time.
 112: - Can now download from IPTV Catchup programs.
 113: - Improved searching in Playlist option "Find in Selected" (Blue Button) for slow servers.
 114: - Improved Player-Bar:
 115: .. If hidden, Cancel/Exit Button will show it back (instead of closing the bar).
 116: .. Subtitle indicator will show different icons for embedded subtitles, file-subtitles or both.
 117: .. The subtitle indicator works with DVB channels now.
 118: .. Added new Audio-Track icon if the current channel has more than one Audio-Track.
 119: - Improved File Manager process and error handling for the options "Create New File" and "Create New Directory".
 120: - Improved File Manager option "Create New Directory" to offer a name that matches the selected file (useful for managing movies paths).
 121: - Improved Settings to automatically separate saved files to separate paths in the backup directory.
 122: .. Removed "Created Package Files (IPK/DEB/etc.) + Package Projects"
 123: .. Removed "Downloaded Packages (from feeds)"
 124: .. Removed "Exported Tables"
 125: .. Removed "Exported PIcons/Screenshots/Pictures"
 126: - Improved exiting from "Find" and "Channels Tools" to overcome hanging (reported on a specific skin).
 127: - Fixed XML-TV page reaction (when there is no Channel-Reference File).
 128: - Fixed Subtitle where it asks to save changes when exiting a newly started subtitle.
 129: 
 130: # ------------------------------------------------------------------------------------------------------------
 131: [v10.4.0 .. 2025-01-04]
 132: - Improved refreshing IPTV frozen channels.
 133: ... Added new settings : "Refresh + Notify" and "Silent Refresh" (to show/hide "Refreshing" message).
 134: .. Improved the process for VOD/Series streams.
 135: - Fixed some portal servers which stopped working on v10.3.0.
 136: - Fixed the error "dpkg was interrupted" after installing AJPanel DEB package (on some DreamOS images).
 137: 
 138: # ------------------------------------------------------------------------------------------------------------
 139: [v10.3.0 .. 2025-01-01]
 140: - Added the option "Merge All Files" (Blue Button) to Playlist file browser (to merge the listed files into one file for easier processing).
 141: - Improved Playlist option "Check & Filter" to add the Expiry Date to the result table.
 142: - General IPTV improvements:
 143: .. Improved reading Playlist lines from files to accept user custom remarks (separated by "#").
 144: .. Improved reading Playlist and Portal lines from files to skip duplicate servers data.
 145: .. Improved IPTV Channel Name Prefix removal.
 146: .. Improved servers filter options for Portal & Playlist to refresh the files list to show the new file.
 147: .. Fixed handling some Portal servers that show the error "Forbidden".
 148: .. Fixed a type of Portal Server which was not providing categories.
 149: .. Fixed Playlist IPTV Servers timeout error when reading VOD categories from some servers.
 150: - Improved INFO page to translate Current and Next events.
 151: - Added "Save" option (Yellow Button) to the "Play with ..." menu (to save current player as default player).
 152: - Improved Terminal.
 153: .. Improved to handle Progress-Bars and color-codes from Shell and Python scripts.
 154: .. Added "Delete File" (Yellow Button) to the Terminal option "Change Custom Commands File".
 155: - Improved reading packages/feed on VTi.
 156: - Improved Local Servers handling:
 157: .. Added "Find" (Yellow Button) option to search in Live/VOD/Series.
 158: .. Improved adding channels to bouquets (to include Server host name in bouquet name).
 159: .. Improved M3U files handling (when opened from File Manager or M3U/M3U8 File Browser).
 160: - Improved File Manager:
 161: .. Add shortcut key Back/Recall to move to parent directory.
 162: .. Add shortcut key FAV to save current/selected directory as the startup directory.
 163: .. Add option "Keys (Shortcuts)" too File Manager "More Options" menu.
 164: - Fixed Subtitle option "Set Maximum Delay" to apply changes immediately (no need to exit then reopen then subtitle).
 165: - Fixed a crash in the option "Tuners Info" (in "Dev. Info" page).
 166: - Fixed a crash when opening "XML-TV Tools" with the presence of bad xmltv file format.
 167: 
 168: # ------------------------------------------------------------------------------------------------------------
 169: [v10.2.3 .. 2024-12-05]
 170: - Fixed the option "IPTV Server Browser (from Current Channel)".
 171: - Fixed IPTV Service Info.
 172: 
 173: # ------------------------------------------------------------------------------------------------------------
 174: [v10.2.2 .. 2024-12-05]
 175: - Improved File Manager to execute Python script files (py/pyo/pyc) in the Terminal.
 176: .. Note: Currently does not interact with input() function.
 177: - Improved Subtitle-Search method.
 178: - Improved IPTV PIcons/Posters Download for some images.
 179: 
 180: # ------------------------------------------------------------------------------------------------------------
 181: [v10.2.1 .. 2024-12-02]
 182: - Fixed a crash on DreamBox (reported on DreamBox-920 with Merlin image OE2.5).
 183: 
 184: # ------------------------------------------------------------------------------------------------------------
 185: [v10.2.0 .. 2024-12-01]
 186: - Added Long-PVR (Long-Playlist) key to take a screenshot.
 187: - Added "Delete Reader" (Red Button) to the option "NCam/OSCam Readers" to delete readers.
 188: - Added new options to "OSCam/NCam Status" (in Blue Button) to delete a reader and clean inactive and duplicate readers.
 189: - Improved Download Manager resume process.
 190: - Improved Filter in "Download/Install Packages (from image feeds)" to filter packages per feed.
 191: - Improved Player Bar to forward/rewind while subtitle is running (without showing the bar).
 192: - Improved Player-Bar Buttons.
 193: .. Added PVR/Playlist button to show System Channel Selection.
 194: .. OK-Button will show Channel List (if no active service).
 195: .. Long-Stop and Long-Power buttons will stop current service and zap to the last used service (or show Channel List).
 196: - Improved Stream Relay handling for images with Stream Relay Patch (to handle PIcons/Signal/Data/etc.).
 197: - Fixed changing AJPanel font on DreamOS.
 198: - Fixed "M3U/M3U8 File Browser" to handle unicode files.
 199: - Fixed Playlist timeout problem (when reading categories for some servers).
 200: - Fixed File Manager error when converting .mvi files to jpg/png.
 201: .. Note: this option may not work on some images if the provided ffmpeg does not support mvi.
 202: 
 203: # ------------------------------------------------------------------------------------------------------------
 204: [v10.1.0 .. 2024-10-14]
 205: - Added the option "Export ALL to M3U File ..." to IPTV tables to save channles to M3U file (including PIcon URLs).
 206: - Added a new option to Bouquet Editor to "Export Selected Bouquets to M3U File".
 207: - Added options to add a font to the system (without changing system fonts).
 208: .. Usage Example: to add Arabic font if missing from Images/Skins.
 209: .. The new options in "Color/Font" (Blue Button in Main page):
 210: ... 1- "Add Extra Font to System" : Adds a font to the system (no restart requierd).
 211: ... 2- "Replace Extra Font" : Replaces the added font with another one (no restart requierd).
 212: ... 3- "Remove Extra Font" : Removes the the added font (requires GUI Restart).
 213: ... Note: The panel does not provide font files (it uses the fonts in /usr/share/fonts).
 214: - Added a yellow icon to Player Bar to highlight movies with subtitle tracks.
 215: - Added options to download M3U files from servers (with different formats).
 216: - Added an option to download XML-TV (EPG) from from servers.
 217: - Added options to download server resources to browse the server locally.
 218: .. Use the new option "Local Servers & M3U Cache" to access Local Cached Servers.
 219: - Improved "M3U/M3U8 File Browser" to be cached for much faster browsing.
 220: - Improved File Manager to play M3U/M3U8 files.
 221: - Improved the option "IPTV Server Browser (from Playlists)" to read URL/Username/Passwrod from 3 separated lines.
 222: - Added option to Playlist Categories window menu to sort by "Server Default Sorting".
 223: - Replaced "Check & Filter" (Blue Button) in Portal table with two options:
 224: .. "Filter Responsive Servers" (same as previous "Check & Filter").
 225: .. "Find Servers with Playlist Access" (to create Playlist URLs from Portal servers).
 226: - Improved "All to Playlist" in "IPTV Server Browser (from M3U/M3U8 Subscription File)".
 227: .. This option creates a file with Playlist URLs from all the listed M3U.
 228: .. Now runs with a progress bar with the ability to stop at any point.
 229: - Improved Movies Browser:
 230: .. The Player can zap from the Movies Browser now.
 231: .. The option "Change Poster (locate manually) ..." will now open File Manager to (to preview the posters).
 232: .. When the Movies Browser starts, it will move the cursor to the current playing movie.
 233: - Improved frozen-channel auto-refresh.
 234: .. Improved to refresh all types of frozen IPTV Channels (Live/VOD/Series).
 235: .. Fixed the case where System Info-Bar is shown during the refresh process.
 236: - Improved media metadata for portal channels (in INFO page).
 237: - Improved "M3U/M3U8 File Browser".
 238: .. Handles files with satellite channels.
 239: .. Prevents replaying chan if already playing (when clicking OK).
 240: - Improved Player Bar to stop the playing service with Long-Power and Long-Stop buttons.
 241: - Fixed "General Guide" option (show no info).
 242: - Fixed Portal server handling of some server types (which were giving errors).
 243: - Fixed some issues with Movies Resume for slow IPTV servers and Ref. Type 4097 (servicemp3).
 244: - Fixed DreamOS issues:
 245: .. Fixed DreamOS Hotkeys detection by the panel to launch the Player Bar.
 246: .. Fixed Screenshot to use Long-PVR to take scfreenshots (test on Dream-Two / Gemini-4.2).
 247: .. Fixed changing Subtitle font size.
 248: .. Fixed Plugins options which were not working on DreamOS.
 249: ... "Download/Install Packages (from image feeds)"
 250: ... "Remove Packages (show all)"
 251: ... "Remove Packages (Plugins/SoftCams/Skins)"
 252: ... "Upgradable Packages"
 253: ... "Active Feeds"
 254: .. Fixed DreamOS freezing when AJPanel displays a picture on some screens.
 255: .. Fixed DreamOS freezing when using Bouquet Importer.
 256: .. Fixed a crash on DreamOS when clicking "Audio" Button in Player bar.
 257: - Fixed VTi issues:
 258: .. Fixed changing Subtitle font size.
 259: .. Fixed Player Hotkeys (were not working).
 260: .. Menus wrap-around scrolling.
 261: .. Fixed a crash in Channel Binding/Chaining.
 262: 
 263: # ------------------------------------------------------------------------------------------------------------
 264: [v10.0.0 .. 2024-08-30]
 265: - Added Resume functionality to auto restore last watched movies position.
 266: .. Resume points are saved when the movie is stopped, zapping, restarting GUI, etc.
 267: .. It works regardless of where the movie is played from (bouquets, players, etc.).
 268: .. It can be enabled/disabled in the settings for "All", "IPTV Only" and "All (Except IPTV)".
 269: .. Resume points are only saved after the first minutes.
 270: .. The "Movies Resume History" is in the Main page, Player-Bar, and system Extensions Menu.
 271: .. The history files are saved in the directory "ajpanel_resume" (in your backup directory).
 272: - Improved File Manager
 273: .. Added preview of picture files when the cursor points to them.
 274: .. Added the option "Rotate Image" to rotate a picture (with rotation angle selection).
 275: .. Added the option "Flip Image" to flip a picture horizontally and vertically.
 276: .. Added the option "Save as ..." to convert between png/jpg/gif/tif/bmp.
 277: .. Converting from tif/gif will save all their frames/pages to files..
 278: .. Improved to view svg picture files.
 279: .. Improved File-Propererties to show Video Metadate for local media files (video streams info).
 280: .. Improved the option "Move" to be much faster when moving files/directories within the same mount.
 281: - Improved PIcons Manager layout and portrait pictures dimension ratio.
 282: - Improved Portal servers handling:
 283: .. Faster starting/changing portal channels in the tables and from the bouquets.
 284: .. Catch-up channels will be flagged in the table, and their events can be selected in the Player-Bar.
 285: .. Using OK Button (to play a channel from tables), will not replay it if already playing.
 286: .. Improved Live Auto-Refresh to wait for 10 seconds untill next refresh (for slow servers).
 287: .. Improve downloading Movies from Portal servers.
 288: .. Improved starting portal channels with Reference Type 4097 (servicemp3).
 289: .. Fixed handling some portals (which were not working).
 290: - Improved Player-Bar:
 291: .. Added Signal Bars (for Satellite channels).
 292: .. Added "Cut-List" (Blue Button) for movies default mark points (if the movie has no chapters).
 293: .. Improved Cut-List table to preview screenshots from local movies.
 294: .. Added "Catch-up" (Yellow Button) which appears if archived events are available.
 295: .. Added Catch-up for Portal servers (depends on availability on servers).
 296: .. Added field to show the type of channel (DVB, Local, Portal, FTP, Catch-up, Playlist, IPTV).
 297: - Improved IPTV Service Information:
 298: .. Faster launch of the window + will search for EPG/PIcon/Poster in the background.
 299: .. Downloads EPG for IPTV (Live/VOD/Series) from Portal and Playlist servers.
 300: .. Improved IPTV Posters Mode layout + faster picture loading.
 301: .. Faster Posters/PIcons download from IPTV tables.
 302: .. The EPG/PIcon/Poster received from servers will automatically update the system EPG/PIcon.
 303: - Improved Service Information page:
 304: .. Current event from System EPG will be translated (to the language selected by user in EPG page).
 305: .. Added Video Metadate for local and IPTV movies.
 306: - Improved Movies Browser:
 307: .. Added Resume Points Progress-Bar indicating the last watched position.
 308: .. Added the option "Go to Current Movie" to jump to the playing movie (if listed).
 309: .. Added options to add a movie (or all movies) to a bouquet.
 310: .. Improved layout.
 311: - Improved subtitle:
 312: .. Added progress-bar to similarity-search (stoppable during the search).
 313: .. Changing the delay with left/right arrows will show the changed delay and line time.
 314: .. When start, the Lines Table will point to the current line.
 315: .. Fixed Subtitle similarity search (sometimes shows the message "No event Name").
 316: - Improved Custom Menu:
 317: .. Added a new option to Settings page (to change the default Custom Menu files path).
 318: .. Fixed the issue of encoded non-English text in menu files after changing icons/colors/etc.
 319: .. Disable the option "Delete Current Item" for List-Menus.
 320: - Added new option to "Update Current Bouquet EPG/PIcons (from IPTV Server)" to update both EPG and PIcons (removed old options).
 321: - Added the option "Fix Media Path (for All Bouquets)" to Bouquets Editor to fix "/media/xx/movie/" path for bouquets.
 322: - Improved Screenshot with a menu button to delete the taken screenshot file (during the preview).
 323: - Improved IPTV Channel Name Prefix removal.
 324: - Added Key-0 to jump to first/last item, and Channel-Up/Downs to scroll pages in:
 325: .. Movies Broswer
 326: .. Channel Broswer
 327: .. Plugins Broswer
 328: .. PIcons Manager
 329: .. Custom Menu (Grid Mode)
 330: .. IPTV Posters Mode
 331: - Improved Console window:
 332: .. Fixed the option "Save to File" which was only saving the line "Processing ...".
 333: .. Fixed the menu to return to the previous window when closed with Exit button.
 334: - Fixed "HTTP Error 461:" when trying to access some Playlist servers (or sometimes Error 403).
 335: - Fixed downloading Series Episodes to save the files to a separate directory with Series name.
 336: - Fixed Posters Mode (was not showing PIcons from server with .jpeg files).
 337: - Fixed crash on Dream-Two (newnigma2) when changing the fonts.
 338: 
 339: # ------------------------------------------------------------------------------------------------------------
 340: [v9.4.0 .. 2024-06-07]
 341: - Added new option "Move Selected Item" to Custom Menu (to change the position of items in main menu).
 342: - Added "General Guide" to main page menu to show some AJPanel general help.
 343: - Improved AJPanel Update to internally use the new URL ( https://github.com/AMAJamry/AJPanel ).
 344: .. The file "ajpanel_update_url" is no longer needed for the update process.
 345: - Added the option "EPG Events Counter" to EPG Page (to count the events for all DVB & IPTV channels).
 346: - Improved "M3U/M3U8 File Browser":
 347: .. To play M3U/M3U8 files that contain DVB channels and Local media files.
 348: .. To show current file name in INFO.
 349: - Improved File Manager to handle ".m3u" files in "M3U/M3U8 File Browser" (instead of trying to play it).
 350: - Improved IPTV Favourite menu items to show server host when Menu button is clicked.
 351: - Improved reading portal Host/MAC from files wih more formats.
 352: - Improved skipping adults channels and categories.
 353: - Improved "XML-TV Tools".
 354: .. Improved the Green Button to pick a Channel-Reference file (if file is not initially set).
 355: .. Improved the process to cache the total tags per XML file (for faster process).
 356: - Improved PIcons page (Green Button) to locate the current PIcon (if current channel name is used as file name).
 357: - Improved "Restore" pages:
 358: .. Added "Rename" (Blue Button) to partially rename backup files.
 359: .. Added INFO Button to show selected file information.
 360: - Improved Player Bar option ("Start Download") to be available for some URL structures.
 361: - Improved "Dev. Info." >> "Settings File" data to be tabulated.
 362: - Fixed Portal Files Editor to point to the current line number.
 363: - Fixed portal download from tables options "Download Current Movie" and "Download Current Series".
 364: - Fixed the problem of showing "Processing ..." followed by no action.
 365: - Fixed a crash on VTi (in File Manager) when browsing a directory with file extension ".7z" or ".7".
 366: - Fixed File Manager Multi-Select counter (when selecting/unselecting all).
 367: 
 368: # ------------------------------------------------------------------------------------------------------------
 369: [v9.3.1 .. 2024-03-04]
 370: - Improved INFO button in Context Menu ("Find") to show Bouquet-Name for IPTV channels.
 371: - Improved the option "Suggest PIcons for Current Channel" to find partaial file names.
 372: - Fixed the warning message that appears when opening AJPanel.
 373: - Fixed the problems of saving the backup-directory on some images.
 374: 
 375: # ------------------------------------------------------------------------------------------------------------
 376: [v9.3.0 .. 2024-03-01]
 377: - Improved "Backup SoftCAM Files" to include more softcam related files (e.g. PowerCam/SupCam/etc.).
 378: - Added Subtitle menu option "Set Maximum Delay (Minutes)" to increase the maximum delay.
 379: - Improved File Manager.
 380: .. Added options to convert bootlogo mvi files to jpg/png.
 381: .. Added options to convetr "tar.gz" to "tar.xz" (and vice versa).
 382: .. Added options to convetr "tar.zst" to "tar.gz" and "tar.xz" (requires "zstd" package).
 383: .. Improved the option "Unbuild Package" to handle ".tar.zst" files in the ipk/deb (requires "zstd" package).
 384: - Added functionality to the option "Copy EPG between Channels (from xml file)" to chain DVB to DVB Channels.
 385: - Improved Custom Menu:
 386: .. The menu options will now open the last directories (for pictures and xml files separately).
 387: .. You can change the Grid-Mode font size with the attribure font_size="x" (x is in range 10-50).
 388: .. You can add "About" to show author/version/etc. for your custom menu (see more in template file "ajpanel_menu.xml").
 389: - Improved Binder:
 390: .. The option "Show Chains" (Green Button) will show more informative list.
 391: .. Will show transponder data for the selected channel.
 392: .. You can switch between TV and Radio modes (with RCU TV Button).
 393: - Improved AJPanel Settings to create and use a default backup directory "../ajpanel_backup/" (if not set by user).
 394: - Improved PIcons option "Suggest PIcons for Current Channel" to use case-insensitive search (for better result).
 395: - Improved IPTV "Find" result to show the root category name in info. (with INFO button).
 396: - Rearranged edit-options to use the Menu Button for more options (besides the Yellow Button).
 397: - Fixed portal zapping in bouquets to point to the right name in Channel List (for duplicate Reference Codes in bouquet).
 398: - Fixed the error "Cannot access the path" when accessing the Terminal from a Hotkey.
 399: 
 400: # ------------------------------------------------------------------------------------------------------------
 401: [v9.2.0 .. 2024-01-25]
 402: - Added new window with split menus (DVB and IPTV Channels) to easily chain channels in:
 403: .. "Share Reference with DVB Channels (from xml file)"
 404: .. "Copy EPG/PIcons between Channels (from xml file)"
 405: - Added the new option "Chain References to File Channels" in XML-TV page (to link DVB References to names in XML-TV files).
 406: - Improved File Editor with Lines Multi-Selection (to copy/paste/delete).
 407: .. Note: All edit-options hve been moved from the Yellow Button to the Menu Button.
 408: - Improved Custom Menu:
 409: .. Added menu options to import other custom menus, delete menu items and change wallpaper/icons.
 410: ... Note: If the imported xml includes main icon (e.g. <ajp_menu icon="xx"...>), the icon will be set automatically.
 411: .. Added menu options to change the wallpaper/shade/cursor picture and colors.
 412: .. Added menu options to delete the cached picture files.
 413: .. Added new xml attribute "picpath" to add a common path for icons and wallpaper. This way you can use file name witout path in all icons.
 414: .. Added new xml attribute "box_gap" to Grid-Menu to increase the gap between boxes (vertically/horizontally).
 415: .. Improved to play IPTV channels from a menu item.
 416: .. External menu files can be added from any directory. If full path is not used, the backup directory is used.
 417: .. Wallperaprs can be added List-Menus.
 418: .. Menu wallperapr image (bg="") accepts Base65 fromat now.
 419: .. Added Base64 pictures caching for faster loading.
 420: .. Cached picture files will be saved into the cache directory "ajpanel_menu" (in the backup directory).
 421: .. Deleting the cache directory will not harm. The panel will created it if necessary.
 422: .. Fixed the crash on DreamTwo (Merlin) in the when aligning text.
 423: - Improved Subtitle:
 424: .. Increased Subtitle Min/Max delay time to 20 minutes.
 425: .. Improved Subtitle settings value-picker.
 426: - Fixed EPG option "Read Current Channel EPG" (epg is not imported after adjusting time).
 427: - Fixed Search-by-Typing in Bouquet Editor.
 428: 
 429: # ------------------------------------------------------------------------------------------------------------
 430: [v9.1.0 .. 2023-12-19]
 431: - Added "Custom Menu" functionality to create a custom panel from xml file "ajpanel_menu.xml".
 432: .. The menu can be accessed from Main Page menu and from Extensions Menu (normally Blue Button).
 433: .. The custom menu can be in a List or Grid layout and sizes and colors are fully customizable.
 434: .. Read the brief guide in Main Page menu option "Custom Menu Help".
 435: .. See the detailed description and sample menu layouts in the sample file "ajpanel_menu.xml".
 436: - Added new Page to handle XML-TV files with the following main features:
 437: .. Find EPG from XML-TV files for the current channel and import it to system.
 438: .. Use channels.xml and XML-TV files to automatically import EPG to several channels.
 439: .. Download and process XML-TV files (xml/gz/xz). URLs should be provided by the users.
 440: .. Separate channels from large xml files into smaller files (with channels Multi-Select).
 441: .. Import EPG from XML-TV files to the system.
 442: .. Show EPG list and adjust its time before importing to system.
 443: .. Check and validate xml files (tags validation + Statistic).
 444: - Added options to EPG page to save EPG to XML-TV file.
 445: .. Read Current Channel EPG : To save it to a file or adjust EPG time offset and send back to the system.
 446: .. Save EPG (from Current Channel) : To save the EPG from the playing channel.
 447: .. Save EPG (from Current Group) : To save the EPG from the playing channel and all its group Current Root (All / Satellites / Provider / Favourites).
 448: - Added two options to Terminal to change the font size of the Commands/History windows.
 449: - Added a new option to File Manager to "Convert to Base64 String".
 450: - Improved the Terminal to handle script file paths that include "#" or spaces (to automatically chmod 755 then run the script file).
 451: - Fixed Text-Wrapping option "Enable/ Disable Text Wrapping" for the Terminal (and other text windows).
 452: - Improved File Manager to extract .xz files (not .tar.xz).
 453: - Improved "Check & Filter" for portal servers to show more detailed result.
 454: - Fixed Plugins Browser options "Remove Plugins" and "Download New Plugins" for Egami-10.4-R14.
 455: - Fixed a crash on some images at the end EPG Translation (before showing result message).
 456: - Fixed a crash when reading package info for some packages.
 457: 
 458: # ------------------------------------------------------------------------------------------------------------
 459: [v9.0.0 .. 2023-10-28]
 460: - Improved the panel installation to automatically install the optional dependencies.
 461: .. This depends on availability of the dependencies on your updated feed.
 462: - Moved Download Manager process file to the Backup directory (to be able to use it on other images).
 463: - Improved Local IPTV Services:
 464: .. Added "Delete Current List (from all Bouquets)" to delete a filtered list.
 465: .. Improved the filtering function.
 466: .. Improved Table contents and Channel Info.
 467: - Redesigned the code for Backup/Restore functions for better performance and results.
 468: - Fixed the Tuner Restore problem (for big list of LNBs)
 469: - Improved "Tuners Info" option to show more details.
 470: - Improved "Package Info." to show better details for installed packages and ipk/deb files.
 471: - Improved Plugins page tables:
 472: .. Modified "Download/Install Packages (from image feeds)" table to highlight the installed packages.
 473: .. Added Blue Button to "Remove Packages" and "Upgradable Packages" tables to toggle update-hold-flag for packages.
 474: .. Modified "Remove Packages" tables to show the removal effect in table (instead of exiting the table).
 475: .. Added new filters to "Download/Install Packages (from image feeds)" table.
 476: - Improved Bouquets Importer:
 477: .. Handles Stream Relay Services and imports the necessary data to the system.
 478: .. Shows progress bar for lengthy functions (to see the progress and be able to cancel the process).
 479: - Improved File Manager:
 480: .. Introduced new methods to Copy/Move items (with 2 progress bars to monitor the process).
 481: .. Added the option "Show Related Package" to show Package Info for directories in Extensions/Systemplugins.
 482: .. Added option to convert IPK to DEB (and vice versa).
 483: .. Added option to convert IPK and DEB files to tar.gz file.
 484: .. Added icons for local and network mount points.
 485: .. Executing a script file now runs directly in the Terminal.
 486: - Improved Player Bar:
 487: .. Redesigned the menu options.
 488: .. Added menu option to change the timeout (to hide the bar automatically).
 489: .. Improved Player Bar to handle services played as Stream Relay.
 490: .. "Play with" Menu can now be opened with Long-Press on the PLAY button.
 491: .. Fixed "Refresh" (Green Button) to restore last playing position (when the Bar is hidden).
 492: - Improved Subtitle:
 493: .. Redesigned Subtitle Menu + improved functionality.
 494: .. Added the option "Change Suggestion Search Path" to Subtitle menu (to set a custom Suggestion Search Path).
 495: .. Added Subtitle option "Event Name Search Language" to search for srt files with the original or English translated name.
 496: - Improved to temporarily disable auto-start for local movies (until the next manual start from Player Bar menu).
 497: - Added new options to backup and restore /etc/enigma2/settings file.
 498: .. The backup file name includes the image name.
 499: .. When restoring, it will warn the user if the file is for a different Image.
 500: .. Before restoring a file, the panel will backup the settings file (to setting.bak).
 501: - Improved Package Creator:
 502: .. More analysis of resource and control fields to highlight problems.
 503: .. Output package file will include "_py2" / "_py3" if the project name includes "Py2" or ""Py3"".
 504: .. Added new option:
 505: ... "Add Resource Files/Dirs" (now imports multiple files/dirs).
 506: ... "Import Files/Dirs List from an Installed Package".
 507: ... "Add Control Field"
 508: ... "Delete All Resources".
 509: ... "Delete Invalid Resources".
 510: ... "Undo Last Project File Changes".
 511: - Improved Terminal:
 512: .. Added option to endable/disable Terminal-Exit Confirmation.
 513: .. Added option to endable/disable Text Wrapping.
 514: .. Added functionality to Terminal to change the Commands Table colors per line or group of lines block.
 515: .. Improved Terminal layout and buttons usage. Check the detail in in Terminal INFO button.
 516: .. Added Green Button to Minimiza/Maximize Terminal window (minimized to top left corner with one line).
 517: .. You can run a script file from its path in the Custom-Commands file. Line Example: /media/usb/backup/my_script.sh
 518: - Added options to "Dev. Info" to show detailed information about the device drivers.
 519: .. "Drivers (Kernel Object)"
 520: .. "Drivers (Loadable Kernel Modules - LKM)"
 521: .. "Drivers (Built-in Kernel Modules)"
 522: - Added new option to "Dev. Info." to check if the current Image supports the new Stream Relay patch.
 523: - Added new Stream Relay services filter to "Services (Change Parental-Control & Hidden)" table.
 524: - Redesigned the data presentation "Dev. Info" fo:
 525: .. "Box Info"
 526: .. "Disk Usage"
 527: .. "File System Table (FSTAB)"
 528: .. "Block-Devices List"
 529: - Merged "xCam Live Status" and "xCam Live Readers" data into one table the refreshes every 3 seconds.
 530: - Redesigned the code for packages handling (ipk/deb/tar).
 531: - Improved Archive Files handling (tar/tar.gz/tar.xz/tar.bz2/gz/zip/rar/7z).
 532: - Improved mount points data presentation in "Dev. Info".
 533: - Improved connections timeout for to some slow playlist servers (in Catch-up TV).
 534: - Improved "Check & Filter" for portal servers.
 535: - General improvements and bug fixes.
 536: 
 537: # ------------------------------------------------------------------------------------------------------------
 538: [v8.8.8 .. 2023-08-25]
 539: - Added the option "Bouquets Importer" to the "Bouquet Editor".
 540: - Added new options to help Feed/Repo owners to generate packages list files:
 541: .. Added "Generate Feed Listing Info." to File Manager (for ipk/deb files).
 542: .. Added "Generate Package.gz (from ipk/deb directory)" to Plugins page.
 543: - Added last modification time to EPG Cache File info.
 544: - Increased the timeout for connections to some slow playlist servers.
 545: - Improved SoftCam tools to handle OSCam-iCam.
 546: 
 547: # ------------------------------------------------------------------------------------------------------------
 548: [v8.8.7 .. 2023-07-17]
 549: - Improved Plugins Browser to handle the new "Download/Remove Plugins" on the latest OpenATV-7.3.
 550: - Fixed some issues with reading xml files on some images (e.g. when reading stellites.xml).
 551: - Fixed the tables for some images where last column is not updated.
 552: 
 553: # ------------------------------------------------------------------------------------------------------------
 554: [v8.8.6 .. 2023-07-04]
 555: - Improved IPTV channels refreshing to hide the InfoBar (for some images).
 556: - Fixed the problem of AJPanel not installing on DM900 (Image="satdreamgr").
 557: - Fixed IPTV option "IPTV Server Browser (from Current Channel)" for Python-3.11.2.
 558: - Fixed Bouquet Editor Multi-Select function (for Egami-10.4-R2 and Pure2-7.3).
 559: - General improvements and bug fixes.
 560: 
 561: # ------------------------------------------------------------------------------------------------------------
 562: [v8.8.5 .. 2023-05-06]
 563: - Fixed Plugins Browser to run AJPanel (if called from Extensions Menu).
 564: 
 565: # ------------------------------------------------------------------------------------------------------------
 566: [v8.8.4 .. 2023-05-05]
 567: - Added functionality to extrct 7z files.
 568: - Improved "Plugins Browser".
 569: .. Added "Plugins Browser" option to "Extensions Menu".
 570: .. Added new options to "Remove Plugins" and "Download new Plugins" (Red & Green Buttons).
 571: - Improved "Bouquet Editor".
 572: .. Added a new option to "Copy to Main Bouquets List".
 573: .. Added a new option to "Delete Unused .del Bouquets Files".
 574: .. Will now delete all related files when a bouquet is deleted.
 575: - Fixed "Posters Mode" to handle special PIcon name formats (for some IPTV servers).
 576: - General improvements and bug fixes.
 577: 
 578: # ------------------------------------------------------------------------------------------------------------
 579: [v8.8.3 .. 2023-03-22]
 580: - Fixed settings option "Portal Servers Connection Timeout (seconds)" (showing "<not-a-string>" on Open-ATV).
 581: - Fixed the restarts on VTi-v15.0.02 when opening "AJPanel Requirements" and "Network Devices".
 582: - Fixed the marker icon (not shown in Bouquet Editor on some images).
 583: - General improvements and bug fixes.
 584: 
 585: # ------------------------------------------------------------------------------------------------------------
 586: [v8.8.2 .. 2023-03-17]
 587: - Fixed the crash that occurs after deleting channels in Bouquet Editor.
 588: 
 589: # ------------------------------------------------------------------------------------------------------------
 590: [v8.8.1 .. 2023-03-16]
 591: - Added access to Terminal from Extension Menu (so that a hotkey can be assigned to it).
 592: - Improved Bouquet Editor to clean the remaining files after deleting sub-bouquets.
 593: - Fixed the crash on some images that occurs when trying to access the Bouquet Editor.
 594: 
 595: # ------------------------------------------------------------------------------------------------------------
 596: [v8.8.0 .. 2023-03-16]
 597: 
 598: - Improved "Bouquet Editor".
 599: .. The Bouquet Editor can now be accessed from Channel List Context Menu.
 600: .. Added "Add Empty Bouquet" to create a new empty bouquet in main bouquets list.
 601: .. Added options to Hide/Unhide Bouquets.
 602: .. Added options Protect/Unprotect Bouquets (Parental Control).
 603: .. Added "Copy to Bouquet" to copy bouquets/channels services to other bouquets in main bouquets list.
 604: .. Note: Copying bouquets into other bouquets will create sub-bouquets (bouquets-in-bouquets).
 605: - Added "Find and Replace" to File Editor (currently replaces all occurrences).
 606: - Fixed File Editor to maintain the leading spaces in lines.
 607: - Improved the performance of "List Archived Files" in File Manager (when working with big .tar.gz files).
 608: - General improvements and bug fixes.
 609: 
 610: # ------------------------------------------------------------------------------------------------------------
 611: [v8.7.0 .. 2023-03-08]
 612: - Added "Bouquet Editor" with Multi-Selection Delete/Move/Sort.
 613: .. Can also rename bouquets/services and add/edit markers.
 614: - Fixed a crash on Dream-Two (when saving settings).
 615: - General improvements and bug fixes.
 616: 
 617: # ------------------------------------------------------------------------------------------------------------
 618: [v8.6.3 .. 2023-03-02]
 619: - Fixed a crash when exiting File Manager after creating a SymLink.
 620: 
 621: # ------------------------------------------------------------------------------------------------------------
 622: [v8.6.2 .. 2023-03-02]
 623: - Improved Portal Channel-Info to update system EPG.
 624: .. Note: Opening Info-Window while playing IPTV channels, the received EPG and PIcon will be imported into the system. This works for Portal/Playlist servers.
 625: - Fixed portal zapping in bouquets to point to the right name in Channel List.
 626: .. The problem was encountered with old bouquets that were added prior to v8.6.1.
 627: - Improved portal tables to point to the current source of the playing channel (if the channel is from the same server).
 628: .. This means that when you start browsing the portal server for the current playing channel, the tables will point to the source of the channel all the way to the last table.
 629: .. This feature will work on bouquets that will be added from now on (starting with this version).
 630: - Improved "Channels Browser" to handle PIcons with spaces removed from their file names.
 631: 
 632: # ------------------------------------------------------------------------------------------------------------
 633: [v8.6.1 .. 2023-02-27]
 634: - Improved "Channels Browser" to find the PIcon with capital/small letter name if original name is not found.
 635: - Fixed "Restore Channels" showing the wrong result message "Error while restoring: ...".
 636: - Fixed setting option "Backup AJPanel Settings" (was not working).
 637: - Fixed some minor reported issues.
 638: 
 639: # ------------------------------------------------------------------------------------------------------------
 640: [v8.6.0 .. 2023-02-26]
 641: - Added "Package Creator" in Plugins page to create ipk/deb/tar.gz packages from a custom project file.
 642: .. This creates a project directory & project with everything you needed to create ipk/deb/tar.gz packages.
 643: .. Once the project is created, start collecting the paths of the directories/files need in the include.
 644: .. Adding a directoring to the project will automatically add all its contents when creating the package.
 645: .. The control parameters for ipk/deb packages are initially added added from a template.
 646: .. You can copy the control parameters from any installed packages.
 647: .. You can import your custom control script files into the project directory (using the menu).
 648: .. The menu will help you pick the Dependencies from a list. Removing a dependancy is also possible.
 649: .. Pre and Post actions like Restart/Reboot can also be set.
 650: .. Note: This can be utilized to create a .tar.gz backup for your selection of directories and files that are scattered in the system.
 651: - Improved Portal Servers handling:
 652: .. Improved Portal Servers EPG handling.
 653: .. Improved playing Live channels on some portal servers which did not work before.
 654: .. Added new settings option "Portal Servers Connection Timeout (seconds)" for custom connection timeout. Increasing the timeout to 4 seconds helped with some portal servers.
 655: - Added new IPTV option "Change Bouquet References to Unique Codes .." to handle one bouquet at a time.
 656: - You can add you blacklist of words you need to hide in IPTV tables.
 657: .. This works along with the settings "Skip Adults Channels (from IPTV Server)" to hide words.
 658: .. Example: Adding "acbd" will hide all IPTV Catogries/Channels that include "acbd" from IPTV tables.
 659: .. How to set it:
 660: ... 1- Create the file "ajpanel_iptv_blacklist" in the panel's backup directory.
 661: ... 2- Start adding the words you need to hide (each word in a separate line and is case-insensitive).
 662: - You can add your custom IPTV prefix words to remove from IPTV tables.
 663: .. This works along with the settings option "Remove IPTV Channel Name Prefix (|EN| , |AR|Drama|)".
 664: .. Example: Adding the word "Sport | En:" will remove it from all IPTV channel names in the tables.
 665: .. How:
 666: ... 1- Create the file "ajpanel_iptv_prefix" in the panel's backup directory.
 667: ... 2- Start adding the prefixes you need to remove (each in a separate line and is case-insensitive).
 668: - Improved the option "Active Feeds" to show the feed in a table with number of packages in each feed.
 669: - Improved File Manager to refresh the file list after editing a file (to show the new x.bak file).
 670: - Fixed the problem of incomplete download of PIcons/EPG when updating for current bouquet.
 671: - Fixed the crash that occurs after downloading PIcons from IPTV tables.
 672: - Fixed the crash that occurs on Dream-Two-OE2.6 when opening subtitle font selection menu.
 673: - Fixed a crash on OpenATV-7-2 when opening "Download Manager" (if ehe files in progress have been deleted).
 674: - General improvements and bug fixes.
 675: 
 676: # ------------------------------------------------------------------------------------------------------------
 677: [v8.5.0 .. 2023-02-04]
 678: - Added "Plugins Browser" to the Plugins page (with plugin icons and group selection).
 679: .. This will replace the functionality of "Plugins Additional Menus" , "Startup Plugins" , "Extensions and System Plugins".
 680: - Added "Upgradable Packages" to the Plugins page (to upgrade packages).
 681: .. It is recommended that you use the option "Update Packages List from Feed" to get the latest list.
 682: - Added the option "Change Custom Commands File" to Terminal Custom Commands Options (Yellow Button).
 683: .. You can load any file that start with "ajpanel_cmd" or "LinuxCommands" (case insensitive).
 684: .. File name examples:
 685: ... ajpanel_cmd
 686: ... ajpanel_cmd_20012023.txt
 687: ... ajpanel_cmd_myPlugins_commands_2023_01_20
 688: ... LinuxCommands
 689: ... LinuxCommands.txt
 690: ... linuxcommands_install_20_plugins.myFile
 691: - Improved "Restore Tuner Settings" for VTi to be able to restore from backups from other images.
 692: .. This feature is already available for other STBs and images.
 693: - Improved File Manager:
 694: .. Added progress bar during the process of copying/moving files and directories.
 695: .. Added functionality to process M3U8 files "M3U/M3U8 File Browser".
 696: .. Added functionality to extract ".gz" single compressed file.
 697: - Added new Setting "Subtitle Files Encoding Priority" to set the first encoding to use with .srt files.
 698: - Improved changing Subtitle Delay (with Left/Right arrows) to show current delay in a popup message.
 699: - Improved the Player-Bar to show the current running player.
 700: - Improved "M3U/M3U8 File Browser" grouping and filtering + handling of different M3U/M3U8 formats.
 701: - Improved Terminal "Info" button in Custom Commands table to show more command info.
 702: - Fixed incorrect text viewer height on VTi.
 703: - Fixed FTP file-upload to stop properly when the user cancels the upload.
 704: 
 705: # ------------------------------------------------------------------------------------------------------------
 706: [v8.4.0 .. 2023-01-09]
 707: - Added "Channels Browser" option to the System "Channel Context Menu" to browse channels with PIcons.
 708: .. From System "Channel selection", click menu then "AJPanel - Channels Browser".
 709: .. It works on all types of groups (All, Satellites, Provider, Favourites) including IPTV bouquets.
 710: - Added menu option "Add FTP Media to Bouquet" to Player menu (to add the streamed media from FTP to local bouquets).
 711: - Improved Portal channels zap.
 712: - Fixed FTP Exit (cannot exit if "File Manager Exit-Button Action" setting is set to "Directory Up").
 713: - Fixed the crash reported on systems with low resources when scanning the network.
 714: 
 715: # ------------------------------------------------------------------------------------------------------------
 716: [v8.3.0 .. 2023-01-01]
 717: - Added Network option to Main Page to handle network functions.
 718: .. Added Network and Port Scanner options.
 719: .. Moved the option "Check Internet Connection" to the new Network option.
 720: - Added FTP File Browser (remote File Manager on network devices) with the following features:
 721: .. Transfer files between local and remote storage.
 722: .. Play remote movies (if streaming is active on remote devices).
 723: .. View remote picture files.
 724: .. Create directories and Rename/Delete files/directories on remote device.
 725: .. Tested on network attached devices such as NAS, Receivers, Laptops/PCs and Router USBs.
 726: - Improved portal handling to access more portal servers versions.
 727: 
 728: # ------------------------------------------------------------------------------------------------------------
 729: [v8.2.0 .. 2022-12-16]
 730: - File Manager:
 731: .. Added Multi-Select to Archive/Copy/Move/Delete user selected files and directories.
 732: .. Improved file deletion to force delete some undeletable files.
 733: .. Fixed shortcuts (showing search-by-typing instead of selecting the options).
 734: .. Fixed properties (for empty directories).
 735: - Improved portal handling for more portal servers (including old servers versions).
 736: - Added option to Server Browser (Poster Mode) to use the selected poster for a Local Media file.
 737: - Added "0" key to Movies/Poster/PIcons Browsers to jump to first/last item in the listed items.
 738: - Added "Help (Keys)" menu option to Movies/Poster Browsers.
 739: - Added menu to IPTV Page to delete Favourite Server Menu Option.
 740: - Improved tables to show green column title (if sorted in ascending order) and blue (if descending order).
 741: - Fixed Tables not sorting the same column in ascending after sorting it in descending order.
 742: 
 743: # ------------------------------------------------------------------------------------------------------------
 744: [v8.1.0 .. 2022-12-03]
 745: - Added options to Movies Browser to change the poster for a movie.
 746: - Fixed crashes on DM900 and Dream-Two:
 747: .. When trying to access AJPanel Settings.
 748: .. When applying the changes in the option "Copy EPG between Channels (from xml file)".
 749: - Improved AJPanel internal update.
 750: 
 751: # ------------------------------------------------------------------------------------------------------------
 752: [v8.0.0 .. 2022-12-01]
 753: - Added "Movies Browser" to main page. It read the movies from the directory set in the Settings (+ all its sub-directories).
 754: - Added "EPG" option to main page. The option is also available in Channel List Context Menu >> AJPanel - Channels Tools.
 755: - Added EPG Translation (experimental). This feature works fine on OpenPLi-8.3. However, some images may reset the EPG after restarts.
 756: - Added feature to AJPanel Channel Info to translate the EPG part (based on the EPG Translation Language settings).
 757: - Added multi-select feature to Terminal to run multiple commands.
 758: - Added the option "Replay with" to Player Bar to replay the media with a different media-player.
 759: - File Manager:
 760: .. Added the option "Set as PIcon for current channel" to convert a picture file to PIcon.
 761: .. Added the option "Play with" to select the player of the selected media file.
 762: .. Added capability to play recorded IPTV stream (file extension ".stream").
 763: .. Added Encoding Review (when viewing or changing file encoding).
 764: .. Added menu options shortcuts to some common options.
 765: .. Improved Picture Viewer to move the cursor to the last viewed file.
 766: .. Added "Info" Button to Picture Viewer to show file properties.
 767: - IPTV:
 768: .. Improved access to old versions of Portal Servers.
 769: .. Added option to IPTV options to save to bouquet name with provider name.
 770: .. Added new filter to Local IPTV table (to filter Stream-Relay channels).
 771: .. Improved IPTV main server page to show the current host by clicking the "Info" Button.
 772: .. Improved M3U/M3U8 Browser for more m3u8 file formats.
 773: .. Fixed "M3U/M3U8 File Browser" zap showing incorrect channel name in Player-Bar.
 774: - Main Page:
 775: .. Moved the option "Check Internet Connection" to Main page menu.
 776: .. Added "AJPanel Requirements" option to Main page menu to check/install the packages required by some features in AJPanel.
 777: .. Added "Help" option to Main page menu to list the shortcuts keys used in the page.
 778: .. Added shortcuts to access all options in Main page with digis 1-9 and "<" ">". See details in Menu >> Keys Help.
 779: - Added the option "Delete File" (Yellow Button) to "Bouquets Importer".
 780: - Added a feature to all menus/options to jump to the row with a letter typed by RCU.
 781: - Improved settings to use OK Button to show a menu with the available options (for easy selection).
 782: - Improved AJPanel Settings Import ("Restore AJPanel Settings").
 783: - Added ScrollBar to PIcons and Posters Browsers.
 784: - Improved PIcons and Posters Browsers to hide the empty boxes.
 785: - Fixed AJPanel installation GUI Restart command for Egami (in "postinst").
 786: - Fixed Restore-Tuner for VTi (freezing after GUI Restart).
 787: 
 788: # ------------------------------------------------------------------------------------------------------------
 789: [v7.4.0 .. 2022-10-21]
 790: - Added Font Previw to font selector.
 791: - Added screenshot:
 792: .. All screen contents can be captured with the keys : F1 , Long-Tv , Long-Tv/Radio.
 793: .. Video contents can be captured with the keys : F2 , Long-Radio , Long-0 : .
 794: .. OSD contents can be captured with the keys : F3 , Long-Help : Screenshot of video part.
 795: .. The screeshot service can be switched off from settings.
 796: .. The image type can also be changed to jpg/png/bmp.
 797: .. The result files witll be saved in your Export-Path.
 798: - Improved File Manager Picture Viewer to browse the picutre files in the same directory with Left/Right and Up/Down keys.
 799: - Improved "Sat. List" (Yellow Button) in the option "Restore Tuner Settings" (to show the satellites in separate lines).
 800: - Fixed empty screens (or incorrect text viewer height) on VTi and some DreamOS images.
 801: - Fixed a crash casued when clicking "Info" after searching in IPTV >> Series with "Find in Series".
 802: - Fixed some issues with the panel update/resinstall for DreamOS.
 803: 
 804: # ------------------------------------------------------------------------------------------------------------
 805: [v7.3.0 .. 2022-10-11]
 806: - Fixed IPTV Poster/PIcons Browser (not showing the images on Pure2-6.5/OpenATV-6.4 which have problems with jpg files).
 807: - Fixed a crash caused by browsing M3U8 file from File Manager (with the option "Browse IPTV Channels").
 808: - Improved adding favourite server to IPTV Menu to apply the change without exiting to main page.
 809: - Imporved IPTV prefix removal for more new cases.
 810: - Minor changes/fixes/imporvements.
 811: 
 812: # ------------------------------------------------------------------------------------------------------------
 813: [v7.2.0 .. 2022-10-06]
 814: - Added options in Main Page menu to change the fonts for the System/AJPanel/Terminal.
 815: .. This offer the fonts from "/usr/share/fonts/" where you can add otf/ttf fonts.
 816: .. Changing the fonts take place immediately (no restarts required).
 817: .. The only case you need a restart is when you want to return the system fonts to their defaults.
 818: - Added IPTV Browser (with PIcons/Posters).
 819: - Added IPTV option to add favourite Playlist/Portal server to IPTV menu (for easy access).
 820: - Added separate options to open the Player Bar and Signal Monitor (as alternative access for images with no Hotkeys).
 821: .. The options are available in "Services/Channels" page and system "Extensions menu".
 822: - Improved Subtitle:
 823: .. The option "Suggest srt files" is now faster and with better sensitivity.
 824: .. Add functionality to remove Arabic Diacritics (Tashkeel) to prevent gaps between the letters.
 825: .. Added RCU keys to control a playing movie (Pause, Play, Audio, SUBT, Forward, Rewind).
 826: .. Added Left/Right keys to synchronize the subtitle (to jump back and forth in lines).
 827: .. Added "OK" Button to subtitle settings to show a menu with values for each setting item.
 828: .. Improved Subtitle Line Picker (Blue Button) to highlight the current line.
 829: .. Improved Font selector to offer the fonts from "/usr/share/fonts/" where you can add otf/ttf fonts (no restarts required).
 830: .. Fixed Subtitle layout for HD-Skins.
 831: - Improved PIcons Manager to be able to change PIcons background transparency color.
 832: - Added options to File Manager to view MVI files + Convert jpg/png to mvi (for bootlogo).
 833: - Improved Tables: Added "Edit Filter" (Yellow Button) to Find-in-Table to be able to edit the filter file in all tables.
 834: - Improved IPTV prefix removal (for more new cases).
 835: - Fixed the issues with toggling the Readers State (ON/OFF) for the original and patched OSCam variants.
 836: - Fixed a crash during Channels Backup (caused by Unicode characters in the names of bouquets files).
 837: 
 838: # ------------------------------------------------------------------------------------------------------------
 839: [v7.1.0 .. 2022-09-20]
 840: - Introduced a totally new subtitle handler with more features.
 841: .. New settings menu layout.
 842: .. Info Button show details of current subtitle.
 843: .. Blue Button lets you select the current translation line.
 844: - Added the new option "Copy EPG/PIcons between Channels (from xml file)".
 845: .. This will copy PIcons/EPG between all types of channels (IPTV/DVB-S/C/T).
 846: - Added the new option "Share Reference with DVB Channels (from xml file)".
 847: .. This will change the references for a group of IPTV channels to references from DVB channels.
 848: .. Result: IPTV channels will use the PIcons and the updated EPG from DVB channels.
 849: - Improved SoftCam menu.
 850: .. Added option to convert "/etc/CCcam.cfg" to OSCam/NCam Readers.
 851: .. Improved handling of modified OSCam/NCam variants.
 852: .. Improved SoftCam Live Log text coloring.
 853: - Improved IPK/DEB creator to prevent overwriting the custom "postinst" file (if exists).
 854: - Fixed menu crash when opening IPK/DEB creator.
 855: - Fixed PIcons page filter crash (Blue Button).
 856: - Fixed Player "Stop Current Service" not working on DreamOS with original image.
 857: - Fixed AJPanel update from the Settings (for DEB System).
 858: 
 859: # ------------------------------------------------------------------------------------------------------------
 860: [v7.0.0 .. 2022-09-01]
 861: - Added "Bouquets Importer" to import bouquets from backup files (.tar.gz) or any zip files (with settings files).
 862: - Added the new option "Delete Empty Bouquets" to delete empty bouquets (including those with Markers only).
 863: - Improved File Manager:
 864: .. Added option to "Convert .zip to .tar.gz".
 865: .. Added option to "Convert .tar.gz to .zip".
 866: .. Added option to convert text files Line-Breaks to Unix/Linux format.
 867: .. Added option to to archive/compress individual files.
 868: .. Improved "Add all Media in Directory to a Bouquet" to sort the list before adding it to bouquets.
 869: .. Fixed the problem of not listing "Internal Flash" if running from external image (on Multi-Boot).
 870: .. Fixed tar Archive/Extract errors when dealing with directories/files names with spaces.
 871: .. Improved Sort options.
 872: - Improved Download Manager:
 873: .. Added the option "Open in File Manager" to Download Manager menu (to open the File Manager with the selected file).
 874: .. Fixed file extension for downloaded movies appearing as ".php" on one of portal servers.
 875: - Added "Satellites Services Cleaner" to remove all services related to selected satellite/s.
 876: - Added the new option "Invalid Services Cleaner" to remove services not referenced by Tuner Configuration.
 877: - Rearranged "Services/Channels" menu and added a sub-menu for more tables.
 878: - Improved Player Bar:
 879: .. Added "TEXT" Button to Player Bar as a shortcut to "Start Subtitle".
 880: .. Added Red Button to Player as a shortcut to open the Signal Monitor.
 881: .. Improved subtitle to stop when zapping channels from Player.
 882: .. Fixed Player crash when using the hotkey while subtitle is running.
 883: - Improved IPTV handling:
 884: .. Added the option "Find in Selected" (Blue Button) to search for names in Playlist VOD/Series within a Category.
 885: .. Added filter to "M3U/M3U8 File Browser".
 886: .. Added a column to IPTV Servers tables to show the availability of PIcons in the server.
 887: .. Added a column to Playlist (Live) tables to show the availability of "Catch-up" services.
 888: .. Improved portal Zap in bouquets to ensure moving the cursor in the Channels List to the right name.
 889: .. Improved Unicode names handling for IPTV channels on OpenVision v12 r458.
 890: - Improved Terminal to point to the last used command in the Custom Commands Table.
 891: - Improved "Restoring Channels" to validate the backup tar files and delete all old files before restoring.
 892: - Improved "Date/Time" (manual mode) to show current Date/Time.
 893: - Fixed a crash on Dream-Two caused by missing python command when changing text wrapping.
 894: - Fixed the problem of AJPanel disappearing from Plugins list due to missing library "difflib" (for Vu Solo with BlackHole v3.1.0).
 895: 
 896: # ------------------------------------------------------------------------------------------------------------
 897: [v6.0.0 .. 2022-08-01]
 898: - Added the option "Find in Selected" (Blue Button) to search for names in Portal VOD/Series within a Category.
 899: - Added a new column ("Category/Genre") in Portal Live/VOD/Series tables.
 900: - Added option to download the M3U file from portal servers.
 901: - Added Find/Next/Prev menu options to all the tables in the panel to search for text in table rows.
 902: .. After entering the text that you need to find, use "<" and ">" buttons as shortcuts for Next/Previous.
 903: .. You can also search for word from your custom filter file (see filter rules).
 904: - Added the new option "satellites.xml (Statistics)" to Services/Channels Tools (to analyse satellites.xml file).
 905: - Added more methods to Subtitle menu to search for local .srt files. The new menu will now show:
 906: .. Manual Search (with File Manager)
 907: .. Suggest srt files (25% similar)
 908: .. Suggest srt files (50% similar)
 909: .. Suggest srt files (75% similar)
 910: .. Find srt Files (in all directories)
 911: .. Find srt Files (in Current Directory)
 912: - Added a new Setting item to change the action for the Exit button in File Manager.
 913: - Added new options to File Manager to save text files with different file encoding.
 914: - Added new option to File Manager Yellow Button ("More options"):
 915: .. Added Sort-Options to sort contents by Name/Date/Type.
 916: .. Added Find-Files (supports Pattern Matching Search).
 917: - Added the option "Open in File Manager" (Blue Button) to some Plugins Tables to open the plugin path in File Manager.
 918: - Added new options to the File Manager to add media files to bouquets. The options appear if the cursor is on a media file.
 919: .. The new options "Add Media File to a Bouquet" will add the selected media file to a bouquet.
 920: .. The new options "Add all Media in Directory to a Bouquet" will add all the media file from current directory to a bouquet.
 921: .. If a jpg/png poster file exists (with the same name as the media file), a PIcon will be added.
 922: - Added new option to PIcons Tools to export a list of all files (or filtered files) to a text file.
 923: - Improved PIcons Tools Statistics function to include Service Type details (in a table).
 924: - Added new filters to PIcons Tools:
 925: .. To filter PIcons files by date (Today/Yesterday/Last-7-Days).
 926: .. To filter PIcons files by Service Type.
 927: - Added IPTV menu option "Update Current Bouquet PIcons (from IPTV Server)".
 928: - Added new filter to Local IPTV Table to filter refCodes "x:x:x:x:0:0:0:0:0:0:".
 929: - Added new IPTV option to change Reference Type for a bouquet.
 930: .. See: 'Change Bouquet Ref. Types to (1/4097/5001/5002/8192/8193) ..'.
 931: - Added Filter-in-Filter to "Local IPTV Services" and "Services/Channels" table.
 932: .. The OK button filters the main list whereas the Green Button filters the filtered list.
 933: - Improved changing Reference Type (1/4097/5001/5002/8192/8193) to rename PIcons files as well.
 934: - Improved filtering of IPTV channel name prefixes to include more patterns.
 935: - Improved Subtitle vertical position to move up more.
 936: - Improved subtitle list table to show separated paths/files to locate files easier.
 937: - Fixed Subtitle Alignment not moving to Left/Right.
 938: - Improved File Editor to search in editor + option go to line number.
 939: - Improved Player Bar to show PIcon and transmission information for DVB-S/C/T services.
 940: - Improved Player Bar option "Add to Bouquet" to select the bouquet from existing list or add to a new bouquet.
 941: - Improved Player Bar to change color depending on the playing service:
 942: .. Dark Blue >> DVB (Satellite/Cable/Terrestrial).
 943: .. Dark Red >> Local Media.
 944: .. Green >> Playlist.
 945: .. Purple or Dark Purple >> Portal Servers (server version dependent).
 946: - Improved the names of backup files created by the panel to include Enigma2 Image Name.
 947: - Improved Multi-Select to move cursor down when selecting a row with OK.
 948: - Fixed some issues with disabling active subtitle (including crashes).
 949: - Fixed download failure on some portal servers.
 950: - Removed my Built-in Input method.
 951: - Improved all bouquet list menus to include Radio Bouquets.
 952: - Added Home/End Keyboard buttons to jump to First/Last rows in tables (for attached keyboards).
 953: - Moved some IPTV menu items to the new sub-menu "Reference Tools"
 954: - Added IPTV menu option "Reload Channels and Bouquets". This is the same option as in "Channels/Services" menu.
 955: - General improvements and bug fixes.
 956: 
 957: # ------------------------------------------------------------------------------------------------------------
 958: [v5.5.0 .. 2022-06-26]
 959: - Enabled Player Bar "Refresh" (Green Button) for all types of services.
 960: .. Refreshing a movie/series should restore the last playing position (server dependent).
 961: .. Note: The Menu option "Restart Current Service" resets the service without restoring the movie/series position.
 962: - Added a simple Download Monitor to show brief download info on top left of the screen (even outside AJPanel).
 963: .. It can be enabled/disabled from Download Manager options (Yellow Button).
 964: - Improved the Settings option "IPTV Hosts Files Path (Playlist, Portal, M3U)" to have more than one custom directory.
 965: .. This should fix the search slownes on devices with external media, multi-boot (with huge number of files).
 966: .. You can edit your favourite search-paths list (for Playlist/Portal/Stalker/M3u/M3u8 files).
 967: - Changed Hotkey access to AJPanel to always open the Player Bar.
 968: .. This is for faster access to options like Subtitle/IPTV/Download Manager, etc.
 969: .. The Signal Monitor can also be opened from the bar menu (or from within AJPanel).
 970: - Improved Subtitle handling.
 971: .. Fixed system subtitle not showing after refreshing a service.
 972: .. Added Subtitle background (black with transparency level selection).
 973: .. Added menu to subtitle settings to reset the delay to 0 (faster reset if delay is far from 0).
 974: .. Increased maximum Subtitle Font Size (from 80 to 100)
 975: .. Increased maximum Subtitle Delay seconds (from 60 to 300)
 976: - Added a menu to Text Viewing Window with option to Enable/Disable Wrapping, Align (Left/Right/Center) and Save to File.
 977: - Improved filtering of IPTV channel name prefixes to include more patterns.
 978: - Improved reading server data form Playlist/Portal files with non-ASCII characters.
 979: - Fixed AJPanel update from Settings (for Debian system).
 980: - Fixed the crash that occurs when "lamedb" file is not in "UTF-8" Encoding.
 981: - Fixed the crash that occurs when trying to find a service from Channel Context Menu.
 982: 
 983: # ------------------------------------------------------------------------------------------------------------
 984: [v5.4.2 .. 2022-06-16]
 985: - Improved the new option 'Export Services to "channels.xml"' to produce a sorted list.
 986: - Fixed IPTV Option "M3U/M3U8 File Browser" which was not shown if there is no Local IPTV service.
 987: - Fixed the crash that occurs when using "Info" function.
 988: - Fixed the crashes caused by Component changes in the latest versions of OpenATV-7.0.
 989: 
 990: # ------------------------------------------------------------------------------------------------------------
 991: [v5.4.1 .. 2022-06-15]
 992: - Fixed the crash that occurs when zapping portal channels (reported on OpenPLi-8.2).
 993: 
 994: # ------------------------------------------------------------------------------------------------------------
 995: [v5.4.0 .. 2022-06-14]
 996: - Added Subtitle to run ".srt" files for Satellite channels and IPTV movies/series.
 997: - Added support for more Stalker-Portal servers versions.
 998: - Added new option to export services to xml file (export a bouquet or all Satellite/Cable/Terrestrial).
 999: - Fixed refreshing of frozen Live Channels (for servers from Playlists).
1000: - Fixed Series Episodes names prefix filtering.
1001: - Added file name to title (when browsing URLs for Playlist/Portal files).
1002: 
1003: # ------------------------------------------------------------------------------------------------------------
1004: [v5.3.0 .. 2022-06-02]
1005: - Added "Check & Filter" option to filter accessible portals.
1006: - Improved the plugin to handle new portal versions.
1007: - Improved "Info" EPG for Satellite services to show Genre and Parental Rating (if provided by service).
1008: - Improved "Dev. Info." >> "Disk Usage" to show the File System Type.
1009: - Improved IPTV channel name prefix cleaning.
1010: - Renamed IPTV menu option "M3U/M3U8 Channels Browser" to "M3U/M3U8 File Browser".
1011: - Fixed player bar (sometimes hangs when playing unstable Live portal channels).
1012: - Fixed copying a directory to another one where same name exists (in File Manager).
1013: 
1014: # ------------------------------------------------------------------------------------------------------------
1015: [v5.2.0 .. 2022-05-12]
1016: - Improvements and fixes for more Stalker-Portal servers versions (playing and downloading).
1017: - Improved reading portal lines from files (added more formats).
1018: - Fixed File Manager "Properties" for some directories with names that include space.
1019: - Fixed Terminal History on Python-3 where it shows the letter "b" in front of newly added history commands.
1020: - Fixed picture viewer in File Manager (for DreamBox).
1021: - Improved IPTV channel name prefix cleaning.
1022: - General improvements and bug fixes.
1023: 
1024: # ------------------------------------------------------------------------------------------------------------
1025: [v5.1.0 .. 2022-05-01]
1026: - Improved portal handling for some servers that only work on Windows software.
1027: - Ready for the new image "VU+ Update".
1028: - Fixed the issue of some portals (on Python-3).
1029: - Improvements and bug fixes.
1030: 
1031: # ------------------------------------------------------------------------------------------------------------
1032: [v5.0.1 .. 2022-04-23]
1033: - Fixed the problem of AJPanel not appearing in the Plugins List (reported on DM900).
1034: 
1035: # ------------------------------------------------------------------------------------------------------------
1036: [v5.0.0 .. 2022-04-20]
1037: - Added Subtitle for Local/Recorded Movies to run srt files.
1038: .. You can start the subtitle from the Player Bar menu option "Start Subtitle".
1039: .. If you have a subtitle (srt file) in the same directory, clicking "OK" from the Player Bar will automatically run it.
1040: .. Once a subtitle starts, it can be started again on the same movie just by clicking "OK" from the Player Bar.
1041: .. If a subtitle is running, use the Menu key to change the delay, style, encoding, srt file or disable subtitle.
1042: - Added Multi-Selection option to all IPTV Tables (to add selected services to a bouquet and download selected PIcons).
1043: - Added Multi-Selection option to "Services (Parental-Control & Hidden)" table (to add selected services to a bouquet.
1044: - Added "View (Select Encoder)" option to File Manager menu to view files with a specific encoder.
1045: - Added Auto-Repeat option to the Player Bar (works as long as player bar is showing or hidden).
1046: - Using Key-0 in the Player Bar will switch to 10 seconds jump (instead of 10 minutes).
1047: - Improved "Dev. Info." Language/Locale information to show more details.
1048: - Improved file viewer to align Left/Center/Right with RCU keys "<", "0", ">"
1049: - Improved viewing "SoftCam.Key" file to look for "SoftCam.Key" and "SoftCam.key" (capital and small-letter "k").
1050: - Main Fixes (for reported problems):
1051: .. Fixed Auto-Refreshing on some Portal-Live channels.
1052: .. Fixed AJPanel Update problem on DM900 with NewNigma2.
1053: .. Fixed "IPTV Server Browser (from Current Channel)" not working with some portal servers.
1054: .. Fixed crashes on OpenVision-11.2 (Python-3.10.4) when accessing PIcons, Services options and processing channels with unicode characters.
1055: 
1056: # ------------------------------------------------------------------------------------------------------------
1057: [v4.3.0 .. 2022-03-21]
1058: - Added Multi-Selection option to hide/unhide channels and change the state of Parental Control.
1059: - Fixed a crash on Vu+ Duo2 (BlackHole 3.1.0) when opening the settings page.
1060: 
1061: # ------------------------------------------------------------------------------------------------------------
1062: [v4.2.1 .. 2022-03-18]
1063: - Fixed the settings Left/Right keys.
1064: 
1065: # ------------------------------------------------------------------------------------------------------------
1066: [v4.2.0 .. 2022-03-17]
1067: - Added menu option to Player menu to add the playing local movie to the the bouquet "My Movies".
1068: - Added "Bookmark Server" (Blue Button) to add the current server to favourite list files.
1069: .. In "IPTV Server Resources", current server will be saved to "Playlist_Bookmarks.txt"
1070: .. In "Portal Resources", current server will be saved to "Portal_Bookmarks.txt".
1071: - Improved portal handling for some servers that only work on Windows/Phone software.
1072: .. Example: Servers with the error "Old firmware, missing metrics or hash. Your device is not supported."
1073: - Improved reading portal URLs from files to handle more formats.
1074: .. http://portal.com:80/playlist.m3u?deviceMac=00:1A:79:...
1075: .. http://portal.com:80/playlist?type=m3u?deviceMac=00:1A:79:...
1076: - Fixed a crash when trying to download a movie on Dreambox-One (Gemini 4.1) due to missing directory "/home/root/".
1077: - Fixed Settings "OK" Button not working on OpenPLi-9.0.
1078: 
1079: # ------------------------------------------------------------------------------------------------------------
1080: [v4.1.1 .. 2022-02-19]
1081: - Fixed some issues with some Portal Servers access.
1082: - More filtering to remove IPTV Channel Name prefix.
1083: 
1084: # ------------------------------------------------------------------------------------------------------------
1085: [v4.1.0 .. 2022-02-17]
1086: - Added a new IPTV option to browse channels from M3U/M3U8 files with the following features:
1087: .. Play a channel from within the table.
1088: .. Add a group of channels or all channels to bouquets
1089: .. Download PIcons for a group of channels or all channels.
1090: .. Files can be opened from IPTV Menu and File Manager.
1091: - Added "Download Movie Poster" to Download Manager.
1092: - Added Green Button to Playlist URLs Table to "Download M3U File" from the server.
1093: - Added "Install Package (force overwrite)" option to packages menu.
1094: - Improved the option "Remove IPTV Channel Name Prefix (|EN| , |AR|Drama|)" to remove more prefixes.
1095: - Improved Channel "Info" for Local Recordings to show local poster (if exists)
1096: - Improved handling of some Portal servers.
1097: - General improvements and fixes.
1098: 
1099: # ------------------------------------------------------------------------------------------------------------
1100: [v4.0.0 .. 2022-02-02]
1101: - Added Download Manager to download Movies/Series from servers. Some features are:
1102: .. Direct download and M3U8 Segmented Streams with various resolutions.
1103: .. Pause/Resume (server dependent).
1104: .. Multiple downloads can run simultaneously on different servers and on the same server if it allows.
1105: .. Options to either start the download immediately or add to the list to download it later.
1106: .. Download from IPTV Server Browser or from bouquets (via Player Bar).
1107: .. You can add full Series (all Episodes) to download list (and can be downloaded at any time).
1108: .. Episodes will be downloaded in a separate directory with the Series name.
1109: .. Progress and download speed are shown during the download.
1110: - Added Setting Option to "Auto Reset Frozen Live Channels (player dependent)".
1111: - Added option to the Player Bar menu to get the file size of the current playing movie/series.
1112: - Added option to Player Bar and File Manager to open the current path location of a local playing movie.
1113: - Added the Blue Button in the Signal Monitor to switch to the Player Bar.
1114: - Added "Subt" & "Audio" keys to the Player to open System Subtitle and Audio windows.
1115: - Added number of "Audio Tracks" and "Subtitles" to the Channel Info.
1116: - Changed "Exit" key in File Manager to point to the parent directory (instead of jumping to first directory).
1117: - Improved reading Playlist and Portal files with various encodings.
1118: - Improved Properties in File Manager to show total/free/used space (for mounts only).
1119: - Improved Player Pause/Resume Button for some images.
1120: - Fixed GUI-Restart on OpenATV-7.0 after using "Share Reference with Satellite/C/T Service".
1121: 
1122: # ------------------------------------------------------------------------------------------------------------
1123: [v3.3.0 .. 2021-12-26]
1124: - Added option to browse a portal server in M3U mode:
1125: .. It converts the portal Host/MAC to User/Password, and then opens the server browser.
1126: .. See the option "Open as M3U" (Green Button) in "IPTV Server Browser (from Portal File)".
1127: .. Note: Some portals will allow the access but will not stream unless in portal mode.
1128: - Added Yellow Button to all "Restore" windows (to delete a backup file).
1129: - Added Yellow Button to Playlist/Portal/M3U files menu (to delete a file).
1130: - Added new plugins information to Plugins menu:
1131: .. "Plugins Browser List" : To list the plugins with their connected external menus.
1132: .. "Plugins Additional Menus" : To list the plugins that are launched at startup.
1133: - Improved the table for the option "IPTV Server Browser (from Playlists)":
1134: .. Clearer data in the table with options to sort, export and edit the file.
1135: .. Added a column to show row number of duplicate URLs.
1136: - Improved Settings:
1137: .. Added new option to enable/disable "AJ Info." in "Events Info Menu".
1138: .. Improved AJPanel menu items in Extension Menu to be enabled/disabled without a restart.
1139: .. Note: You may experience a crash during the installation restart (just ignore it). This is due to a bug in some images (not handling plugins parameters changes correctly).
1140: - Removed "AJPanel" and "AJ Live Log (OSCam/NCam)" from Extension Menu.
1141: - Changed Channel Info EPG Summary and Description colors from Grey to Bright Cyan.
1142: - Fixed Portal file processing to handle lines that contain "/stalker_portal/c".
1143: - Fixed a crash (occurs when zapping portal channels from Player very quickly then exiting).
1144: 
1145: # ------------------------------------------------------------------------------------------------------------
1146: [v3.2.4 .. 2021-12-20]
1147: - You can add IPTV EPG to the System EPG (without sharing the Reference).
1148: .. Works for M3U and Portal servers (if EPG is supported by the server).
1149: .. Opening Channel Info. on IPTV service will update the system with the EPG from server.
1150: .. Added a new option "Update Current Bouquet EPG (from IPTV Server)" to update the system for all the channels in the current bouquet.
1151: - File Manager can extract ".rar" files.
1152: - Added two options for the filtered "Unused PIcons" to be moved or deleted.
1153: .. 1- "Move Unused PIcons to a Directory"
1154: .. 2- "DELETE Unused PIcons".
1155: - Improved Player Controller:
1156: .. Added option to "Stop Current Service".
1157: .. Added option to "Restart Current Service" (note: for Portal services, refresh with the Green Button).
1158: .. Added Red button to Pause/Play.
1159: .. Improved "Pause" to work on IPTV Live TV.
1160: - IPTV Menu can now be accessed directly from AJPanel Menu in the Channel List Context.
1161: - Improved reading Portal files to process huge file much faster.
1162: 
1163: # ------------------------------------------------------------------------------------------------------------
1164: [v3.2.3 .. 2021-12-08]
1165: - Added Catchup TV for Playlist/M3U Servers.
1166: .. Catchup TV Programs can also be listed in the Player with Yellow Button (or from Player Menu).
1167: - Added Player keys (Pause/Rewind/Forward) for DM800SE.
1168: - Added option to set the IPTV Host Search path (for faster file search).
1169: .. See the option "IPTV Hosts Files Path (Playlist, Portal, M3U)" in Settings.
1170: .. The default is "AUTO FIND" and can be changed to a custom directory.
1171: - Improved "Share Reference with Satellite/C/T Service (auto-find)"
1172: .. During search progress, you can cancel the process and get the found servcies (no need to wait to the end of search).
1173: - Improved File Manager:
1174: .. Shows Files and Directories Attributes in the File Properties.
1175: .. Can delete immutable Files and Directories (those which cannot be modified, deleted, renamed or linked).
1176: 
1177: # ------------------------------------------------------------------------------------------------------------
1178: [v3.2.2 .. 2021-11-25]
1179: - Added "AJ Info." option to "Events info menu" and "Event View Context Menu".
1180: .. This is to access AJPanel-Channel-Info from device default info (Long-Info or Info >> Menu).
1181: - Improved "Share Reference with Satellite/C/T Service (manual entry)":
1182: .. Fixed "Name not found" if the IPTV channel name includes a prefix (example : "(FR) " , "VIP " , etc).
1183: .. Fixed the search to be case-insensitive.
1184: .. The result list is now sorted by the closest name.
1185: .. The table shows full satellite name instead of the short satellite code.
1186: - Fixed crash on DM800SE when trying to get Packages list (No Enough Memory).
1187: - Increased font size and width of some tables.
1188: - General improvements.
1189: 
1190: # ------------------------------------------------------------------------------------------------------------
1191: [v3.2.1  .. 2021-11-18]
1192: - Improved the Player Controller:
1193: .. Added info. to the bar (Date, Time, Resoultion, FPS, Remaining Time).
1194: .. Added Menu to change position to Top/Bottom of the screen.
1195: .. Added menu option to launch IPTV page (if the player is opened by the Hotkey or from Extension Menu).
1196: - Added "AJ IPTV" to Extension Menu (for easy access to IPTV options).
1197: - Improved "Share Reference with Satellite/C/T Channel".
1198: .. Added new option "Share Reference with Satellite/C/T Service (manual entry)" to enter name with keyboard.
1199: .. Fixed "Share Reference with Satellite/C/T Channel" (sometimes hangs on DreamOS).
1200: - Improved Portal IPTV Channels.
1201: .. Faster Zap from bouquets.
1202: .. Channel Info will show Host, MAC, Mode, and a shorter URL.
1203: - Fixed response when list is empty in:
1204: .. "Services (Hidden List)"
1205: .. "Services (Parental-Control List)"
1206: - Improved PIcons >> "Suggest PIcons for Current Channel". Now works with Progress Bar (you can cancel at any point).
1207: - Improved Progress Bar to show number of found items and the total processed records.
1208: 
1209: # ------------------------------------------------------------------------------------------------------------
1210: [v3.2.0  .. 2021-11-11]
1211: - Zap Portal channel from bouquets (without using the Hotkey). Currently not working on DreamOS with official image.
1212: - Added "AJ Signal/Player" to Extension Menu to open the Signal Monitor or Player Controller (depending on the current channel).
1213: .. This can be used by DreamOS users as a quick access to the Player Controller (to zap portal channels from bouqutes).
1214: - Added Search function (Yellow Button) to find name in VOD and Series Categories in Portal Servers.
1215: .. Current search in portal servers works with a word or sentence (no words separated by commas yet).
1216: - Added Color Changer for Main Page (click Menu in Main Page).
1217: - Improved Player Controller bar:
1218: .. Added Up/Down to the Player Controller (to zap the same way with Chan-Up/Down and Page-Up/down).
1219: .. Fixed Zapping from bouquet to start the stream from the beginning.
1220: - Improved Terminal.
1221: .. Added Red Button to save Terminal text to a file.
1222: .. Use Exit Button to stop a running command (same as Ctrl-C in Telnet).
1223: .. Exiting the Terminal needs confirmation now (in case you need to save the results).
1224: .. Opening commands editor will point to the current selected line number in the original file.
1225: .. Added Yellow Button to clear Commands History.
1226: - Improved Channel Info (for all channel types).
1227: - Rearranged File Manager buttons (Red Button = Exit, and Cancel/Exit Button = go up to parent directory).
1228: - Added Red Button to save text from almost all text windows.
1229: - Improved IPTV Categories tables + added different color per page.
1230: - Added "Row Number" and Total Rows to all Services/IPTV Tables (will be shown with Info. Button).
1231: - Fixed internet connectivity-checking function for "Vu+ Duo4K Se" and "OpenDroid".
1232: - Redesigned some options to work with Progress Bar (you can cancel at any point).
1233: .. 1- "Share Reference with Satellite/C/T Channel".
1234: .. 2- "Analyse m3u File".
1235: - Fixed a crash caused by corrupted channel file (lamedb file).
1236: 
1237: # ------------------------------------------------------------------------------------------------------------
1238: [v3.1.0  .. 2021-10-22]
1239: - Fixed an issue with some portal servers when adding channels to a new bouquet.
1240: .. NOTE:
1241: ..   Previously created portal bouquets will not work with this version.
1242: ..   Please create new ones.
1243: - Improved refreshing portal frozen movie/series to restore the last played position.
1244: - Improved IPTV handling:
1245: .. Faster search for IPTV files (Portal/Stalker, Playlist, M3U).
1246: .. Reading server data from Playlist/Portal/Stalker files including mixed data.
1247: .. Checking/Filtering Authorized Servers.
1248: .. Finding a name in Live/VOD/Series.
1249: .. Channel Info.
1250: .. User Account Info.
1251: .. Channel name prefix removal.
1252: - Fixed the issue of getting no internet connectivity on "Vu+ Duo 4K Se".
1253: - Moved some long processes into Progress Bar (so that they can be cancelled at any point).
1254: 
1255: # ------------------------------------------------------------------------------------------------------------
1256: [v3.0.0  .. 2021-10-15]
1257: - Added Stalker-Middleware support.
1258: .. Can import portal data from most portal/stalker file formats (one-line portal or multi-MAC lines).
1259: .. The panel will search for all .txt/.conf files with names that include the words "portal" or "stalker".
1260: .. You can add channels to a bouquet and play channels directly from bouquets + download PIcons.
1261: .. To play a frozen channel from bouquets, just launch the Player Controller from hotkey (even for 1 second).
1262: .. When the streaming starts, you can exit the Player Bar (or hide it with OK Button).
1263: .. Use the Green Button in the Player Controller to refresh the streaming when it freezes.
1264: - Enabled Channel-Up/Down in the Player Controller to zap in all IPTV tables.
1265: - Added option to search for a name in M3U Servers (search in Live, VOD and Series).
1266: .. Find a full name or a word in the name (can use multi words separated by commas).
1267: .. Find names that start with a word (example: ^,word1,word2).
1268: - Added settings option to hide Adult Channels from IPTV-Servers.
1269: - Added settings option to remove IPTV Channel Name Tag (|EN| , |AR|Drama|) when browsing servers.
1270: - Added settings options to Backup/Restore AJPanel Settings.
1271: - You can now create IPK/DEB packages with multiple directories as follows:
1272: .. 1- Collect your directories with their full puth into any temporary directory.
1273: .. 2- Set "Installation Path" to "Root '/' (Multiple Directories Package)"
1274: .. 3- Create the IPK/DEB.
1275: 
1276: # ------------------------------------------------------------------------------------------------------------
1277: [v2.5.1  .. 2021-09-17]
1278: - Zap channels with Channel-Up and Channel-Down from:
1279: .. Signal Monitor.
1280: .. Player Controller.
1281: .. PIcons Manager.
1282: - Added the option "All to Playlist" to create one playlist file for all m3u files. Available in:
1283: .. 1- IPTV >> IPTV Server Browser (from M3U File) >> Blue button.
1284: .. 2- IPTV >> Convert m3u File to Bouquet (from m3u File List) >> Blue button.
1285: - Added the option "Share Reference with Satellite/C/T Channel" to change individua IPTV reference to an existing channel (to share PIcon and EPG).
1286: - Added "Save" (Red button) to save Package Installation result to the Export Directory.
1287: - Added the option "Remove Package (show all)" to "Plugins" (to remove any installed package).
1288: - Improved text colors in some tables (for DreamOS).
1289: - Click Menu key for help on Keys in Signal Monitor, Player Controller and PIcons Manager.
1290: 
1291: # ------------------------------------------------------------------------------------------------------------
1292: [v2.5.0  .. 2021-08-30]
1293: - New AJPanel logo (by Oktus).
1294: - Added Media/Stream Player Controller (for IPTV and recorded media files).
1295: .. Play video/audio files from File Manager.
1296: .. Features: Forward, Rewind, Pause, Replay, Cutlist, Info/PIcon.
1297: .. Added Media Player Controller .
1298: .. Click RCU "Info" button for Channel Info, PIcon and EPG (use "Help" key for Vu+).
1299: .. Click RCU "Menu" button for keys usage.
1300: - Improved IPTV PIcons downloader:
1301: .. Download progress is shown with capability to stop the download and resume later.
1302: .. PIcon-download will automatically stop when it detects major problems.
1303: .. PIcon-download will skips PIcon files with size = 0 bytes.
1304: - Current Service (Info.):
1305: .. Added simple EPG (for Current/Next Event in Sat/C/T channels).
1306: .. Added "Save" (Red Button) to save Channel Info Text to your Export Directory.
1307: .. PIcon image is auto-resized to fit movie posters/covers (requires "ffmpeg").
1308: .. IPTV Channel PIcon is automaticlly added to PIcons directory (requires "ffmpeg").
1309: - IPTV:
1310: .. Default Reference Type can be changed from Setting (types = 1, 4097, 5001, 5002, 8192, 8193).
1311: .. Added option to browse the server from playing IPTV channel.
1312: .. Added option to check and filter the Authorized Servers from playlist files.
1313: .. Fixed the crash caused by adding IPTV bouquet name that includes restricted symbols.
1314: - PIcons Manager:
1315: .. Added new filter in PIcons Manager for IPTV PIcons.
1316: .. Fixed chName not shown for IPTV PIcons.
1317: - Improved Terminal handling of comments from commands files + different colors for comments.
1318: - Changed default Hotkey to Long-Exit.
1319: - Signal Monitor:
1320: .. Click RCU "Info" button for Channel Info, PIcon and EPG (use "Help" key for Vu+).
1321: .. Click RCU "Menu" button for keys usage.
1322: 
1323: # ------------------------------------------------------------------------------------------------------------
1324: [v2.4.1  .. 2021-08-05]
1325: - Added option to Browse IPTV Server from Subscription M3U file.
1326: .. Now, you don't need to convert the M3U file with thousands of channels to a bouquet.
1327: .. Browse the server and pick what you need and convert them to bouquets + download PIcons.
1328: - Replaced the filters for "Channels with No-Names" with a new option to "Delete Channels with no names".
1329: - Improved "Current Service (Info.)" layout and performance.
1330: 
1331: # ------------------------------------------------------------------------------------------------------------
1332: [v2.4.0  .. 2021-08-03]
1333: - Improved "Signal Monitor":
1334: .. Added more Hotkey Options (Long-OK , Long-Exit , Long-Red).
1335: .. The monitor will show a message about invalid channels (Tuner failure, etc.).
1336: .. Click RCU "Info" button from the Signal Monitor to get "Current Service Info".
1337: - Improved "Current Service (info.)"
1338: .. Increased the size of PIcon.
1339: .. Added "State" to show the status of current channel (e.g. tuner failed, etc.).
1340: .. Will download and display simple EPG for IPTV (Live and Movies Channels).
1341: - Added "Download PIcons" (Green Button) to Server IPTV channels.
1342: .. You can download PIcons for Live, Movie and Series channels.
1343: .. When you use "Add ALL to Bouquet" (Yellow), click "Download PIcons" (Green) to download the related PIcons.
1344: .. The downloaded PIcons will appear in Channel List and Info-Bar.
1345: - Added filters to Channels Tables to list channels with no names or no provider names.
1346: - Improved Packages Download to check internet connectivity before downloading.
1347: - Fixed "Connection Timeout" problem when requesting IPTV info from the server.
1348: - Fixed IPTV "Series" List (not showing Episodes from some servers).
1349: 
1350: # ------------------------------------------------------------------------------------------------------------
1351: [v2.3.2  .. 2021-07-28]
1352: - Added notification of new update:
1353: .. Notification is shown in main title (if url is provided in "ajpanel_update_url").
1354: .. Enable/Disable checking for update in Settings Menu.
1355: - Fixed another crash on DreamOS (when using "Find").
1356: 
1357: # ------------------------------------------------------------------------------------------------------------
1358: [v2.3.1  .. 2021-07-27]
1359: - Improved AJPanel Update to download and install ipk/deb packages.
1360: - Fixed the crashes from "Find" and "Rest Parental Control Settings".
1361: 
1362: # ------------------------------------------------------------------------------------------------------------
1363: [v2.3.0  .. 2021-07-25]
1364: - You can restore Channels without a restart.
1365: - You can change the State of the Hidden Channels List without a restart.
1366: - Added "Post Install" (Green Button) to select the action taken after package installation:
1367: .. IPK/DEB Post Install Options : No action / Restart GUI / Reboot Device.
1368: - Added feature to change the main page colors from the file "ajpanel_colors".
1369: .. Copy the file from "AJPan" dir to your Backup dir and set your own colors.
1370: - Fixed "Find" (in Channel List Context Menu) for DreamOS.
1371: - Fixed hanging DreamOS after AJPanel installation.
1372: - Fixed DreamOS problem of not showing AJPanel in the plugins after installation.
1373: - Fixed "Channel Restore" (not restoring from directories names with spaces).
1374: - Fixed the problem of transparent text on some images.
1375: .. If you still see transparent text, change the coloring scheme from the Settings.
1376: 
1377: # ------------------------------------------------------------------------------------------------------------
1378: [v2.2.0  .. 2021-07-20]
1379: - Improve Signal Monitor:
1380: .. Resize the screen with RCU buttons ("<", "0, ">").
1381: .. Change position with RCU digits 1-9 (in addition to the arrows).
1382: .. Signal Bar colors appear on DreamOS now.
1383: .. Fixed DreamOS crash when trying to open Signal Monitor.
1384: - Fixed the problem of not launching AJPanel on OpenNFR-6.5 (Python 3.8.5).
1385: .. AJPanel should work on all Python versions now.
1386: - Fixed DreamOS crash when trying to open "Find" in channels list.
1387: .. However, "Find" does not open the Keyboard on DreamOS (working on it).
1388: - General improvements + less package size and files.
1389: 
1390: # ------------------------------------------------------------------------------------------------------------
1391: [v2.1.1  .. 2021-07-17]
1392: - Fixed the problems of showing the Signal Monitor from the Long-OK Hotkey.
1393: - Improved handling of Markers in Local IPTV tables.
1394: - Added playing channel name in Local IPTV channels table.
1395: 
1396: # ------------------------------------------------------------------------------------------------------------
1397: [v2.1.0  .. 2021-07-16]
1398: - Added IPTV Server Browser (watch IPTV channels before converting to bouquets).
1399: - Added "Long-OK" Hotkey to show Signal Monitor (Enable/Disable in Setting).
1400: - Fixed some reported crashes.
1401: - Added "Update/Reinstall" AJPanel to the Setting Menu.
1402: .. This is a custom server URL (server not provided by AJPanel yet).
1403: .. 1- Add your server as one line in the file "ajpanel_update_url".
1404: .. 2- Copy file to AJPanel Backup directory.
1405: .. 3- The "Update" and "Reinstall" options will appear in the Settings Menu.
1406: 
1407: # ------------------------------------------------------------------------------------------------------------
1408: [v2.0.0  .. 2021-07-07]
1409: - Ready for Python-v3.9.5 (tested on OpenATV-7 and OpenVix-v5.5).
1410: - Signal Strength can be repositioned on the screen.
1411: - Added "Reload Services" option to reload channels and bouquets from files.
1412: - Added PIcon Tools:
1413: .. Suggest and Change PIcon for Current Channel.
1414: .. Browse PIcons, Zap, Filters.
1415: - Added IPTV Tools:
1416: .. List all IPTV channels even if they are not loaded into Enigma2.
1417: .. Convert "m3u" files to Bouquets.
1418: .. Download and Convert "m3u" files from URLs in "playlists.txt".
1419: .. Change References of IPTV channels (0001/4097/5001/5002/8192/8193).
1420: .. Filter Movies, Series, etc. then add them to a bouquet.
1421: .. Automatic change of References to match channels from Sat/C/T channels.
1422:      (this allows IPTV channels to get the same benefit of PIcons, EPG, etc.).
1423: 
1424: # ------------------------------------------------------------------------------------------------------------
1425: [v1.4.2  .. 2021-05-26]
1426: - Added option to change PIcons path.
1427: - Added Network Backup/Restore.
1428: - Added SCam files to Softcam Backup/Restore.
1429: 
1430: # ------------------------------------------------------------------------------------------------------------
1431: [v1.4.1  .. 2021-05-22]
1432: - Improved "Channels with no Transponder" filter.
1433: - Fixed crash when moving File Manager bookmark up/down.
1434: 
1435: # ------------------------------------------------------------------------------------------------------------
1436: [v1.4.0  .. 2021-05-08]
1437: - Added IPTV Services Table.
1438: - Added Multi-Select to some tables (to add to channels to a bouquet).
1439: - Added filters to Services (Transponders and ID) tables with more sorting options.
1440: - Added more info when exporting from Services (Transponders) table.
1441: - Improved listing and information for Terrestrial/Cable/ATSC/IPTV channels.
1442: - More detailed transponders calculations in "Transponders (Statistics)".
1443: - Faster process when changing PC/Hidden states in Services (Reference) Table.
1444: - Faster filters loading.
1445: - Can create new Bouquet when adding services to a bouquet.
1446: - Fixed some issues.
1447: 
1448: # ------------------------------------------------------------------------------------------------------------
1449: [v1.3.2  .. 2021-04-24]
1450: - Added Transponders table to Services/Channels Tools.
1451: - Added Transponders information to Service Finder table.
1452: - Improved Service Finder to include IPTV channels.
1453: - Improved "Add to Bouquet" to opt for adding one or all services to a bouquet.
1454: 
1455: # ------------------------------------------------------------------------------------------------------------
1456: [v1.3.1  .. 2021-04-15]
1457: - Fixed font related crash on DM920.
1458: 
1459: # ------------------------------------------------------------------------------------------------------------
1460: [v1.3.0  .. 2021-04-15]
1461: - Added "Zap History" to Channel Context Menu.
1462: - Enabled "Zap" in "Services (Parental Control List)" even if PC is active.
1463: - Improved IPTV Channels information.
1464: 
1465: # ------------------------------------------------------------------------------------------------------------
1466: [v1.2.9  .. 2021-04-11]
1467: - Added "Hide Channel" to Channel Context Menu (to hide a selected channel).
1468: - Updated Service Types database.
1469: - Updated Video Type in "Current Service (info.)"
1470: 
1471: # ------------------------------------------------------------------------------------------------------------
1472: [v1.2.8  .. 2021-04-02]
1473: - Added transponder information to the Signal Strength Monitor.
1474: - Fixed the crash when using "Current Service (Info.)".
1475: 
1476: # ------------------------------------------------------------------------------------------------------------
1477: [v1.2.7  .. 2021-04-01]
1478: - Fixed reported crashes on DM7080.
1479: 
1480: # ------------------------------------------------------------------------------------------------------------
1481: [v1.2.6  .. 2021-03-31]
1482: - Added "Find" and "Service Tools" to Channel Context Menu (found list can be added to bouquets).
1483: - Added "Parental Control" and "Hidden Services" columns to "Services (All)" with filtering and ability to set them on/off for any service.
1484: - Added "Edit Filter" (Yellow Button) to edit Service Filter file within the table.
1485: - Added more "Box Info."
1486: - "Current Service (info)" will show all bouquets for the current service.
1487: 
1488: # ------------------------------------------------------------------------------------------------------------
1489: [v1.2.5  .. 2021-03-16]
1490: - Changed Tuner Info. method for some images.
1491: - Fixed GUI Restart methods (some images hang after restarts).
1492: 
1493: # ------------------------------------------------------------------------------------------------------------
1494: [v1.2.4  .. 2021-03-15]
1495: - Terminal will use Fixed-Width Font if the font exists in your firmware.
1496: - Fixed the appearance of Tables and File Edit for OpenViX.
1497: - Moved the "Download/Install Packages" filter to the Blue Button inside the table.
1498: - Added Service Filter (Blue Button) to "Services (All)" to filter Satellites and custom words. You can change the custom words in the file "ajpanel_services_filter" (in the backup directory).
1499: - Added Box and Tuners Info.
1500: 
1501: # ------------------------------------------------------------------------------------------------------------
1502: [v1.2.3  .. 2021-03-08]
1503: - Added File Editor to File Manager. The "Edit" option will appear if pointed to non-binary files (regardless of file extension).
1504: - Added "Input Type" to Confi. (Options = Virtual Keyboard, System Default, Built-in). It will fall back to the Built-in method (e.g. if Virtual Keyboard is not installed).
1505: - Improved Built-in input with new feature (e.g. Key Mapping review, Copy/Paste feature).
1506: - Rearranged buttons usage in tables. "OK" button replaces the Blue button to zap. "Info" button shows row info.
1507: - Custom commands file can be edited within the Terminal.
1508: 
1509: # ------------------------------------------------------------------------------------------------------------
1510: [v1.2.2  .. 2021-02-28]
1511: - Improved Terminal commands history handling.
1512: - Terminal will use Virtual Keyboard (if exists) for command entry.
1513: - Terminal custom command file "LinuxCommands.lst" will be automatically moved from the plugin path to your backup directory when you launch the Terminal.
1514: - Fixed some issues.
1515: 
1516: # ------------------------------------------------------------------------------------------------------------
1517: [v1.2.1  .. 2021-02-25]
1518: - Added Simple Terminal to run Linux commands.
1519: - Added "Update List of Available Packages" (in Plugins Tools).
1520: - Fixed DreamOS crash when opening Signal Monitor.
1521: - Fixed some reported problems on DreamOS and Vu+Zero4k.
1522: - Fixed Logo size not fully shown on some images.
1523: 
1524: # ------------------------------------------------------------------------------------------------------------
1525: [v1.2.0  .. 2021-02-23]
1526: - Added Signal Strength monitor in Service Tools (also shown hen zapping).
1527: - Moved Extensions and SystemPlugins lists to a new table.
1528: - Added Satellite column to all Services Tables.
1529: - Added Green Button to Services Tables to find the current service in the list.
1530: - "Downlod/Install Packages" will show a list of keywords to filter from packages.
1531: - Main Menu items can be accessed by RCU digits (1-9).
1532: - Directories for plugins installed with .tar.gz can be removed from Plugin Tools.
1533: - Plugins Browser list is auto-updated after Install/Remove (no restarts required).
1534: - Enabled all the functions for Debian system.
1535: - "deb" packages can be installed on non-Debinan system (especially Python-based).
1536: - Enter "0000" in the Main Menu to enable "Delete/Rename/Move/Permission" on system directories.
1537: - Fixed crashes on DreamOS.
1538: 
1539: # ------------------------------------------------------------------------------------------------------------
1540: [v1.1.8  .. 2021-02-14]
1541: - Added "Install" (Red Button) to Plugin Tools ("Download" table).
1542: - Added "Export Table to HTML".
1543: - Service Reference Code separator in Exported Tables is "_" (instead of ":").
1544: - Fixed DreamOS crashes (created a separate console for DreamOS).
1545: - Note: Few functions are currently disabled on Debian system (coming soon).
1546: 
1547: # ------------------------------------------------------------------------------------------------------------
1548: [v1.1.7  .. 2021-02-11]
1549: - Added options to export tables to ".txt" and ".csv" files.
1550: - Added options to Configuration to customize the Download and Export paths.
1551: - Added "Change Log" to Plugin Version info.
1552: - Fixed latest reported crashes.
1553: 
1554: # ------------------------------------------------------------------------------------------------------------
1555: [v1.1.6  .. 2021-02-09]
1556: - Improved Search-by-Typing to show the typed char highlighted within its group of characters.
1557: - Fixed "Process Failed. in ipk/deb package creation when the target path name includes spaces.
1558: - Fixed DreamOS Crash (the GUI Skin does not accept the commands "setBorderColor" and "setBorderWidth".
1559: - Fixed crash on OpenVision (missing some Service info.).
1560: 
1561: # ------------------------------------------------------------------------------------------------------------
1562: [v1.1.5  .. 2021-02-07]
1563: - Added the Green Button to READERs table (to switch a subscription On and Off.
1564: - Added a new option to the panel Configuration menu to select the output path for the created IPK/DEB Package files:
1565: - SoftCAM Info. is now tabulated.
1566: - Fixed DreamOS Crash (the GUI Skin does not accept the command "setFont")
1567: 
1568: # ------------------------------------------------------------------------------------------------------------
1569: [v1.1.4  .. 2021-02-05]
1570: - IPK/DEB Package creation will automatically detect if previous control files exit in CONTROL or DEBIAN directory.
1571: - All the table in Plugins Tools will now show the first column as the plugin name (for easy filtering/searching).
1572: - Fixed text alignment in commands console.
1573: 
1574: # ------------------------------------------------------------------------------------------------------------
1575: [v1.1.3  .. 2021-02-03]
1576: - IPK/DEB Package creation window will validate and highlight non-standard package parameters (with warnings).
1577: - Added the Blue Button to the IPK/DEB Package creation window to Package Version.
1578: - Fixed the crash on some GUI Skins (not accepting the commands "setVAlign" and "setHAlign").
1579: 
1580: # ------------------------------------------------------------------------------------------------------------
1581: [v1.1.2  .. 2021-02-03]
1582: - Added "Root Path" to the Installation Target Path list in the IPK/DEB Package for firmware that do not show the root directory.
1583: 
1584: # ------------------------------------------------------------------------------------------------------------
1585: [v1.1.1  .. 2021-02-02]
1586: - Added a "Wait ..." message when entering a directory with many files in File Manager.
1587: - Added new window to handle IPK/DEB Packages with the ability to change the Installation Target Path.
1588: - Removed the limit of data directory size when creating IPK/DEB packages.
1589: - Fixed icons issue. GUI Skins on Vu+Zero4k (BlackHole 3.1.0B) does not have the function BT_KEEP_ASPECT_RATIO.
1590: - Fixed the Console screen not showing data on PLi-FullNightHD GUI Skin.
1591: 
1592: # ------------------------------------------------------------------------------------------------------------
1593: [v1.1.0  .. 2021-01-30]
1594: - Added Row Number to tables info. (when OK is clicked).
1595: - Channel-Up button jumps to first row in all tables.
1596: - About the Plugin is shown in the main menu when clicking RCU "Menu" or "Info"  or "Help" buttons.
1597: - Showing Parental Control Service List is much faster now.
1598: - Add Current Bouquet (of the running service).
1599: - Added Directory Archive/Unarchive formats (.tar , .tar.gz , .tar.bz2 , .tar.xz , .zip).
1600: - Added option to Reset Parental Control Settings.
1601: - Disk Usage is shown as a table now.
1602: - Added "List Package Files" to list the contents of the ipk/deb Packages.
1603: - Added "Extract Files" to unpack ipk/deb files.
1604: - Added DEB Install () Remove / Remove (Force) for Debian system.
1605: - Removed Console font with fixed-width characters because it affects Arabic language on some firmware.
1606: - The plugin now attempts to install "ar" command from feed (if the correct version is not found).
1607: - Fixed Python3 compatibility.
1608: 
1609: # ------------------------------------------------------------------------------------------------------------
1610: [v1.0.0  .. 2021-01-15]
1611: - First release.
```

## File: res/_help_cmenu
```
 1: The #Y#Custom Menu#W# is a menu that you can create to suit your requiremens.
 2: #G#
 3: When available, the menu can be accessed from:
 4: - Main Page menu.
 5: - System Extensions Menu. A Hotkey can be assigned from System Hotkey Settings.
 6: 
 7: #Y#How:#W#
 8:   1- Start the menu (from Main Page menu or from Extensions menu).
 9:   2- The panel will ask to copy the sample files to your backup directory and will start the menu.
10:   3- Customize the file #Gn#ajpanel_menu.xml#W# to your needs (it includes description and many samples).
11: 
12: #Y#Main Features:#W#
13: - Recursive submenus can be added (unlimited recursion depth).
14: - You can customize your favourite AJPanel options into a submenu.
15: - You can direct a command, multiple commands and script files to the Terminal.
16: - The menu can be accessed from Main Page menu and from System Extensions Menu.
17: - A Hotkey can be assigned from System Hotkey Settings for easy access to the menu.
```

## File: res/_help_fman
```
 1: #Y#Menu#W#	File/directory related options
 2: 
 3: #Y#OK#W#	- Go to parent directory (if at top directory)
 4: 	- Enter directory (if pointer is on a directory)
 5: 	- View file (if pointer is on a text file)
 6: 	- Show file options (if pointer is on a non-text file)
 7: 	- Select file/directory (if in Multi-Select mode)
 8: 
 9: #Y#cancel#W#	Exit or Go to parent directory (depends on Settings)
10: 
11: #Y#Red#W#	Exit
12: #Y#Green#W#	Select file/directory (in picker mode)
13: #Y#Yellow#W#	General options
14: #Y#Blue#W#	Directory Bookmarks
15: 
16: #Y#FAV#W#	Save selected/current directory as a start-up directory
17: 
18: #Y#Info#W#	Properties of selected File/directory
19: #Y#EPG#W#	Same as "Info" Button (on some RCUs).
20: #Y#Help#W#	Same as "Info" Button (e.g. for Vu+)
21: 
22: #Y#Back#W#	Go to parent directory
23: #Y#Recall#W#	Same as "Back" Button
24: 
25: #Y#Page-Up#W#	- Go to parent directory
26: 	- Toggle selection and move pointer to next row (in Multi-Select mode)
27: 
28: #Y#Page-Down#W#	- Enter directory (if pointer is on a directory)
29: 	- Toggle selection and move pointer to previous row (in Multi-Select mode)
30: 
31: #Y#CH-Up#W#	Same as "Page-Up" Button
32: #Y#CH-Down#W#	Same as "Page-Down" Button
33: 
34: #Y#<#W#	Move pointer to top of list
35: #Y#>#W#	Move pointer to end of list
36: 
37: #Y#Left#W#	Go up one page
38: #Y#Right#W#	Go down one page
39: 
40: #Y#0 - 9#W#	Type the first character of name to move the pointer to
```

## File: res/_help_main
```
 1: #Y#1#W#	File Manager
 2: #Y#2#W#	IPTV
 3: #Y#3#W#	Movies Browser
 4: #Y#4#W#	Services/Channels
 5: #Y#5#W#	Bouquet Editor
 6: #Y#6#W#	PIcons
 7: #Y#7#W#	EPG
 8: #Y#8#W#	Terminal
 9: #Y#9#W#	SoftCam
10: #Y#<#W#	Plugins
11: #Y#>#W#	Backup & Restore
12: 
13: #Y#0000#W#	Typing 0000 in the Main page will enable the following:
14: 	#G#1- File Manage commands are enabled on system directories.
15: 	#G#2- Portal Live Category "All" will be listed in categories.
16: 	#G#3- AJPanel "Info" will show bouquet file name.
17: 
18: #Y#OK#W#	Select the option
19: #Y#Info#W#	Change Log
20: #Y#Menu#W#	Main menu options
21: 
22: #Y#Red#W#	Exit AJPanel
23: #Y#Green#W#	Settings
24: #Y#Yellow#W#	Device Information
25: #Y#Blue#W#	Colors and Fonts
```

## File: res/_help_movBr
```
 1: #Y#OK#W#	Play selected media
 2: 
 3: #Y#<#W#	Page up
 4: #Y#>#W#	Page down
 5: #Y#0#W#	Jump to first/last item
 6: 
 7: #Y#Up#W#	Move cursor up
 8: #Y#Down#W#	Move cursor down
 9: #Y#Left#W#	Move cursor left
10: #Y#Right#W#	Move cursor right
11: 
12: #Y#Info#W#	Media file information
13: 
14: #Y#Menu#W#	Movies Browser options
15: #Y#Exit#W#	Exit Movies Browser
```

## File: res/_help_picons
```
 1: #Y#Left#W#	Moves cursor Left
 2: #Y#Right#W#	Moves cursor Right
 3: #Y#Up#W#	Moves cursor Up
 4: #Y#Down#W#	Moves cursor Down
 5: 
 6: #Y#<#W#	Page Up
 7: #Y#>#W#	Page Down
 8: #Y#0#W#	Jump to first/last item
 9: 
10: #Y#CH-UP#W#	Zap Down
11: #Y#CH-DOWN#W#	Zap Up
12: 
13: #Y#OK#W#	Zap to channel that uses the selected PIcon
14: 	#G#Works only if the selected PIcon is attached to a channel
15: 
16: #Y#Green#W#	Jump to the PIcon used by current playing channel
17: 	#G#Works only if current playing channel has a PIcon
18: 
19: #Y#Yellow#W#	Page options (sort, find,  Jump to first/last page)
20: 
21: #Y#Blue#W#	Filter PIcons List
22: 
23: #Y#Info#W#	Information about selected PIcon
24: #Y#Help#W#	= Info (e.g. for Vu+)
25: 
26: #Y#Menu#W#	PIcons Tools
27: 
28: #Y#Exit#W#	Exit PIcon Manager
```

## File: res/_help_player
```
 1: #Y#Left#W#	Activate Manual Skip Mode + Jumps Backward
 2: #Y#Right#W#	Activate Manual Skip Mode + Jumps Forward
 3: 
 4: #Y#<#W#	Jump to beginning
 5: #Y#>#W#	Jump to end
 6: 
 7: #Y#<<#W#	Jump Forward (minutes)
 8: #Y#>>#W#	Jump Backward (minues)
 9: 
10: #Y#||#W#	Toggle Play/Pause
11: #Y#Play#W#	Toggle Play/Pause
12: #Y#Pause#W#	Toggle Play/Pause
13: #Y#Stop#W#	Toggle Play/Pause
14: 
15: #Y#Long Stop#W#	Stop Current Service
16: #Y#Long Power#W#	Stop Current Service
17: 
18: #Y#PVR#W#	Show System Channel Selection
19: #Y#Playlist#W#	Show System Channel Selection
20: 
21: #Y#Long Play#W#	Open "Play with" menu
22: 
23: #Y#OK#W#	#Y#1-#W# Hide/Show the Bar + Start Subtitle #G#(if not in Manual Skip mode)#W#
24: 	#Y#2-#W# Jump to selected time #G#(if in Manual Skip mode)#W#
25: 	#Y#3-#W# Show System Channel Selection #G#(if no active service)#W#
26: 	#Y#Note: you can still use the Bar keys if the Bar is hidden.#W#
27: 
28: #Y#Exit#W#	- Exit Manual Skip mode #G#(if active)#W#
29: 	- Exit Subtitle #G#(if subtitle is active)#W#
30: 	- Exit Player Bar #G#(if Bar is shown and not in Manual Skip mode)#W#
31: 
32: #Y#Up-Arrow#W#	Zap Up
33: #Y#Down-Arrow#W#	Zap Down
34: 
35: #Y#CH-UP#W#	Zap Down (same as "Page-up" on some RCUs)
36: #Y#CH-DOWN#W#	Zap Up (same as "Page-down" on some RCUs)
37: 
38: #Y#Info#W#	Show information/PIcon for the playing stream
39: #Y#EPG#W#	Same as "Info" Button (on some RCUs)
40: #Y#Help#W#	Same as "Info" Button (e.g. for Vu+)
41: 
42: #Y#TEXT#W#	Shortcut to "Start Subtitle"
43: #Y#Audio#W#	Open system "Select audio track"
44: #Y#SUBT#W#	Open system "Subtitle selection" window
45: 
46: #Y#Red#W#	"Show Signal Monitor"  #C#or#W#  "Close Bar & Recall Last DVB Service"
47: #Y#Green#W#	Refresh ... Resume Portal Channel Streaming (when it freezes)
48: #Y#Yellow#W#	Show Catchup TV Programs (if available for current channel)
49: #Y#Blue#W#	Show Cut-List (if available in current stream)
50: 
51: #Y#1 - 9#W#	Change Seek/Jump time to 1-9 minutes
52: #Y#0#W#	Change Jump time to 10 seconds
53: 
54: #Y#Menu#W#	Player Bar Menu
55: #Y#Menu > Menu#W#	More Player Options
```

## File: res/_help_resize
```
1: #Y#OK Button#W#
2: Will resize the picture so that the result dimension is within the selected size.
3: 
4: #Y#Blue Button#W#
5: Will resize the picture so that the result dimension is exactly equal to the selected size (will stretch to fit the size).
```

## File: res/_help_servBr
```
 1: #Y#OK#W#	Play selected stream
 2: 
 3: #Y#<#W#	Page up
 4: #Y#>#W#	Page down
 5: #Y#0#W#	Jump to first/last item
 6: 
 7: #Y#Up#W#	Move cursor up
 8: #Y#Down#W#	Move cursor down
 9: #Y#Left#W#	Move cursor left
10: #Y#Right#W#	Move cursor right
11: 
12: #Y#Info#W#	Service information
13: 
14: #Y#Menu#W#	Server Browser options
15: #Y#Exit#W#	Exit Movies Browser
```

## File: res/_help_service_filter
```
 1: #Y#Service Filter File ("#C#ajpanel_services_filter#Y#"):
 2: #W#- The file  is used to store yor favourite words.
 3: - It is automatically copied to your Backup directory when you launch the filter.
 4: - You can modify it within the Filter (Yellow Button) or use any text editor.
 5: 
 6: #Y#Rules:#W#
 7: - To find words, create line with a word (or list of words separate by commas).
 8: - Searching is case-insensitive (capital and small letters or a mix of both).
 9: - To find names that start with a word, add "^" as the first letter in line.
10: - Comments are ignored (any text starting with "#" is ignored).
11: - Empty lines are ignored.
12: 
13: #Y#Examples:
14: #W#Sport	#G## Find names that contain the word "sport".
15: #W#sport, kass	#G## Find names that contain any of the words "sport" and "kass".
16: #W#^k	#G## Find names that start with the letter "K" (or "k").
17: #W#^sport,beIN	#G## Find names that start with the words "sport" or "beIN".
```

## File: res/_help_signal
```
 1: #Y#Left#W#	Move window left
 2: #Y#Right#W#	Move window right
 3: #Y#Up#W#	Move window up
 4: #Y#Down#W#	Move window down
 5: #Y#1 - 9#W#	Move window to position of keys 0-9
 6: 
 7: #Y#<#W#	Decrease window size
 8: #Y#>#W#	Increase window size
 9: 
10: #Y#CH-UP#W#	Zap Down
11: #Y#CH-DOWN#W#	Zap Up
12: 
13: #Y#Info#W#	Show Current Channel Information
14: #Y#EPG#W#	Show Current Channel Information
15: #Y#Help#W#	Show Current Channel Information
16: 
17: #Y#OK#W#	Exit Signal Monitor
18: #Y#Red#W#	Exit Signal Monitor
19: #Y#Exit#W#	Exit Signal Monitor
```

## File: res/_help_srvcBr
```
 1: #Y#OK#W#	Zap and hide table (change to Review Mode)
 2: 	#G#- If in Review Mode, it returns back to table#W#
 3: 
 4: #Y#Exit#W#	Exit Bouquet Browser
 5: 	#G#- If in Review Mode, it returns back to table#W#
 6: 
 7: #Y#Green#W#	Zap and exit table
 8: #Y#Yellow#W#	Locate current channel in table
 9: 
10: #Y#<#W#	Page up
11: #Y#>#W#	Page down
12: #Y#0#W#	Jump to first/last item
13: 
14: #Y#Up#W#	Move cursor up
15: #Y#Down#W#	Move cursor down
16: #Y#Left#W#	Move cursor left
17: #Y#Right#W#	Move cursor right
18: 
19: #Y#Menu#W#	Bouquet Browser options
```

## File: res/_help_subt
```
 1: -------------------------------------------------------------------
 2: #C#In Subtitle Mode
 3: -------------------------------------------------------------------
 4: #Y#Left#W#	Open Subtitle Line changer
 5: #Y#Right#W#	Open Subtitle Line changer
 6: 
 7: #Y#Blue#W#	Pick a subtitle line (to change current line)
 8: 
 9: #Y#Info#W#	Show information about current subtitle file/timing
10: 
11: #Y#OK#W#	Exit Subtitle
12: #Y#Exit#W#	Exit Subtitle
13: 
14: -------------------------------------------------------------------
15: #C#In Settings Window
16: -------------------------------------------------------------------
17: 
18: #Y#OK#W#	Show list of values to pick from
19: #Y#0#W#	Reset the selected setting item to its default value
20: 
21: #Y#Up#W#	Change setting item to previous value
22: #Y#Down#W#	Change setting item to next value
23: 
24: #Y#<#W#	Change setting item to first value
25: #Y#>#W#	Change setting item to last value
26: 
27: #Y#Red#W#	Reset all settings to default
28: #Y#Green#W#	Save settings
29: #Y#Yellow#W#	Reset delay to '0'
30: #Y#Blue#W#	Pick a subtitle line (to change current line)
31: 
32: #Y#Info#W#	Show information about current subtitle file/timing
33: 
34: #Y#Menu#W#	Open Subtitle Settings
35: 	Show More Options
```

## File: res/_help_table
```
 1: #Y#<#W#	Find Previous
 2: #Y#>#W#	Find Next
 3: 
 4: #Y#Up#W#	Cursor Up
 5: #Y#Down#W#	Cursor Down
 6: 
 7: #Y#Left#W#	Page Up
 8: #Y#Right#W#	Page Down
 9: 
10: #Y#HOME#W#	Go to first row
11: #Y#END#W#	Go to last row
12: 
13: #Y#CH-UP#W#	Go to first row
14: #Y#CH-DOWN#W#	Go to last row
15: 
16: #Y#PAGE-UP#W#	Go to first row
17: #Y#PAGE-DOWN#W#	Go to last row
18: 
19: #Y#OK#W#	Info/Zap/Select (depends on table)
20: 
21: #Y#Info#W#	Information about selected row
22: 
23: #Y#Menu#W#	Table Options
24: 
25: #Y#Exit#W#	Exit (on most table)
```

## File: res/_help_terminal
```
 1: #P#RCU Keys:#W#
 2: 
 3: #Y#Menu#W#	User's Custom Commands Table
 4: #Y#OK#W#	Command History Table
 5: 
 6: #Y#<#W#	Decrease Font Size
 7: #Y#>#W#	Increase Font Size
 8: #Y#0#W#	Reset Font Size (to default)
 9: 
10: #Y#Green#W#	Minimize window to top left corner
11: #Y#Yellow#W#	Terminal Options/Settings
12: #Y#Blue#W#	Open Keyboard to enter new command
13: 
14: #Y#Up#W#	Page Up
15: #Y#Down#W#	Page Down
16: 
17: #Y#Left#W#	Page Up
18: #Y#Right#W#	Page Down
19: 
20: #Y#Ch Up#W#	Go to First Page
21: #Y#Ch Down#W#	Go to Last Page
22: 
23: #Y#Exit#W#	Exit Terminal
24: 
25: #Y#Info#W#	This Window
26: 
27: #G#-------------------------------------------------------------------#W#
28: #P#Terminal Custom Commands:#W#
29: - You can divide your commands in groups (each in a file).
30: - You can divide your commands in groups (same file with different colors).
31: - Commands file name must start with "#Gn#ajpanel_cmd#W#" or "#Gn#linuxcommands#W#".
32: - The files will be found automatically by the panel if saved in the backup direcory.
33: - File names examples: "ajpanel_cmd-Admin-Commands" , "ajpanel_cmd_07-10-2023.txt".
34: - Empty lines will not be displayed.
35: - Lines that start with symbols are considered comments (except the char "_").
36: - Comments can be added at the end of command line. E.g. : ls # list files.
37: - Empty lines will not be displayed in the Terminal.
38: - Lines that start with symbols are considered comments (except the char "_").
39: - Comments can be added at the end of command line. E.g. : ls # list files.
40: 
41: #G#-------------------------------------------------------------------#W#
42: #P#Commands Coloring:#W#
43: - The Terminal can change the default colors based on user's custom colors.
44: - Syntax:	#Gn#[foreground_color1, background_color2]#W#
45: - Colors:	black, red, green, blue, yellow, cyan, purple, grey, gray, white.
46: - RGB:	RRGGBB or AARRGGBB (Alpha_channel, Red, Green, Blue).
47:  	E.g. : 00FF8000 (Opaque Orange), 55FFFF00 (Transparent Yellow).
48: - Colors can be added at beginnig of line (or at the end after "#").
49: - Examples:
50:  #C#ls  #[red,blue]#W#	   Show "ls" in Green (on Blue backround).
51:  #C#[red,blue] ls#W#	   Show "ls" in Green (on Blue backround).
52:  #C#[00FFFF00] ls#W#	   Show "ls" in Yellow (on default Terminal backround).
53:  #C#[, blue] ls#W#	   Show "ls" in default Terminal forecround color (on Blue backround).
54:  #C#[red, yellow]#W#	   With no command line = change colors for all next lines.
55:  #C#[ ]#W#	   Reset the colors for next lines to Terminal defaul colors.
```

## File: res/_help_txt
```
 1: #Y#Green#W#	Reset Font Size (to default)
 2: #Y#Yellow#W#	Decrease Font Size
 3: #Y#Blue#W#	Increase Font Size
 4: 
 5: #Y#<#W#	Align Left
 6: #Y#>#W#	Align Right
 7: #Y#0#W#	Align Center
 8: 
 9: #Y#Up#W#	Page Up
10: #Y#Down#W#	Page Down
11: 
12: #Y#Left#W#	Page Up
13: #Y#Right#W#	Page Down
14: 
15: #Y#Ch Up#W#	Go to First Page
16: #Y#Ch Down#W#	Go to Last Page
17: 
18: #Y#OK#W#	Exit
19: #Y#Exit#W#	Exit
20: 
21: #Y#Menu#W#	This Window
```

## File: res/_hlpG
```
 1: Archive Files & Directories from Different Paths@Archive_from_different_paths.jpg
 2: Channels Browser@ChannelsBrowser.jpg
 3: Custom Menu - Samples@Custom_Menu_Samples.jpg
 4: File Manager - Remove a Plugin Related to a Package File@Remove_package_using_pkg_file.jpg
 5: File Manager - View Non-UTF8 Encoded Text Files@View_non_UTF8_file.jpg
 6: Hotkeys - Assign to Fucntions@HotkeysAssign.jpg
 7: IPTV - Change Reference for a Bouquet@IPTV_ChangeReferenceForBouquets.jpg
 8: IPTV - Favourite Servers@IPTV_FavouriteServers.jpg
 9: Player Bar - Colors@PlayerBarColors.jpg
10: Player Bar - Launching@PlayerBar_Launching.jpg
11: Player Bar - Seek Jump Time@PlayerBar_SeekJumpTime.jpg
12: Player Bar - Shortcuts (OK & Exit)@PlayerBar_Shortcuts_OK_Exit.jpg
13: Player Bar - Stopping Current Channel@PlayerBar_Stopping_Channels.jpg
14: Screenshot - Hotkeys@Screenshot_Hotkeys.jpg
15: Screenshot - OSD File Name@Screenshot_OSDFileName.jpg
16: Share EPG@ShareEPG.jpg
17: Signal Monitor - Access Methods@SignalMonitor_accees.jpg
18: Subtitle - Searching Local Files for Suitable Subtitle (srt file)@Subtitle_find_local_srt.jpg
19: Subtitle - Subtitle Text Color@SubtitleTextColor.jpg
20: Terminal - Custom Commands File@CustomCommandsFile.jpg
```

## File: res/_sup_codecs
```
 1: All languages (Unicode)	utf32,UTF-32BE,UTF-32LE,utf16,UTF-16BE,UTF-16LE,unicode-1-1-utf-7,UTF,utf8,cp65001,utf_8_sig
 2: Arabic	p720,IBM864,windows-1256,iso-8859-6,arabic
 3: Baltic languages	IBM775,windows-1257,iso-8859-4,latin4,iso-8859-13,latin7
 4: Bulgarian	IBM855,windows-1251,iso-8859-5,cyrillic,maccyrillic
 5: Byelorussian	IBM855,windows-1251,iso-8859-5,cyrillic,maccyrillic
 6: Canadian	IBM863
 7: Celtic languages	iso-8859-14,latin8
 8: Central and Eastern Europe	IBM852,windows-1250,iso-8859-2,latin2,maclatin2,maccentraleurope,mac_centeuro
 9: Chinese Simplified 	chinese,csiso58gb231280,euc-cn,euccn,eucgb2312-cn,gb2312-1980,gb2312-80,iso-ir-58,hzgb,hz-gb,hz-gb-2312,iso-8859-16,latin10
10: Chinese Traditional	big5-tw,csbig5,big5-hkscs,hkscs,950,ms950
11: Chinese Unified	cp936,ms936,gb18030-2000
12: Danish	IBM865
13: English	646,us-ascii,IBM037,IBM039,IBM437
14: Esperanto	iso-8859-3,latin3
15: German	IBM273,csIBM273
16: Greek	cp737,CP-GR,IBM869,cp875,windows-1253,iso-8859-7,greek,greek8,macgreek
17: Greek	iso-2022-jp-2
18: Hebrew	EBCDIC-CP-HE,IBM424,cp856,IBM862,windows-1255,iso-8859-8,hebrew
19: Icelandic	CP-IS,IBM861,maciceland
20: Japanese	ms932,mskanji,ms-kanji,eucjp,ujis,u-jis,jisx0213,eucjis2004,eucjisx0213,iso2022jp,iso-2022-jp,iso-2022-jp-1,iso-2022-jp-2004,iso-2022-jp-3,iso-2022-jp-ext,csshiftjis,shiftjis,sjis,s_jis,shiftjis2004,sjis_2004,shiftjisx0213,s_jisx0213
21: Japanese	iso-2022-jp-2
22: Kazakh	csptcp154,pt154,cp154,cyrillic-asian,kz_1048,strk1048_2002,rk1048
23: Korean	ms949,uhc,euckr,korean,ksc5601,ks_c-5601-1987,ks_x-1001,iso-2022-kr,cp1361,ms1361
24: Korean	iso-2022-jp-2
25: Macedonian	IBM855,windows-1251,iso-8859-5,cyrillic,maccyrillic
26: Maltese	iso-8859-3,latin3
27: Nordic languages	iso-8859-10,latin6
28: Norwegian	IBM865
29: Portuguese	IBM860
30: Russian	IBM855,windows-1251,iso-8859-5,cyrillic,maccyrillic
31: Russian	IBM866,koi8_r,windows-1251,iso-8859-5,IBM855,IBM866,maccyrillic
32: Simplified Chinese	iso-2022-jp-2
33: Tajik	koi8_t
34: Thai	cp874,iso-8859-11,thai
35: Turkish	IBM857,ibm1026,windows-1254,iso-8859-9,latin5,macturkish
36: Ukrainian	koi8_u,ibm1125,cp866u,ruscii
37: Urdu	cp1006
38: Vietnamese	windows-1258
39: Western Europe	EBCDIC-CP-BE,EBCDIC-CP-CH,IBM500,IBM850,IBM858,ibm1140,windows-1252,iso8859-1,8859,cp819,latin,latin1,iso-8859-15,latin9,macroman,macintosh
40: Western Europe	iso-2022-jp-2
```

## File: res/_sup_genre
```
 1: 1,0;movie/drama (general)
 2: 1,1;detective/thriller
 3: 1,2;adventure/western/war
 4: 1,3;science fiction/fantasy/horror
 5: 1,4;comedy
 6: 1,5;soap/melodrama/folkloric
 7: 1,6;romance
 8: 1,7;serious/classical/religious/historical movie/drama
 9: 1,8;adult movie/drama
10: 2,0;news/current affairs (general)
11: 2,1;news/weather report
12: 2,2;news magazine
13: 2,3;documentary
14: 2,4;discussion/interview/debate
15: 3,0;show/game show (general)
16: 3,1;game show/quiz/contest
17: 3,2;variety show
18: 3,3;talk show
19: 4,0;sports (general)
20: 4,1;special events (Olympic Games, World Cup, etc.)
21: 4,2;sports magazines
22: 4,3;football/soccer
23: 4,4;tennis/squash
24: 4,5;team sports (excluding football)
25: 4,6;athletics
26: 4,7;motor sport
27: 4,8;water sport
28: 4,9;winter sports
29: 4,10;equestrian
30: 4,11;martial sports
31: 5,0;children's/youth programmes (general)
32: 5,1;pre-school children's programmes
33: 5,2;entertainment programmes for 6 to 14
34: 5,3;entertainment programmes for 10 to 16
35: 5,4;informational/educational/school programmes
36: 5,5;cartoons/puppets
37: 6,0;music/ballet/dance (general)
38: 6,1;rock/pop
39: 6,2;serious music/classical music
40: 6,3;folk/traditional music
41: 6,4;jazz
42: 6,5;musical/opera
43: 6,6;ballet
44: 7,0;arts/culture (without music, general)
45: 7,1;performing arts
46: 7,2;fine arts
47: 7,3;religion
48: 7,4;popular culture/traditional arts
49: 7,5;literature
50: 7,6;film/cinema
51: 7,7;experimental film/video
52: 7,8;broadcasting/press
53: 7,9;new media
54: 7,10;arts/culture magazines
55: 7,11;fashion
56: 8,0;social/political issues/economics (general)
57: 8,1;magazines/reports/documentary
58: 8,2;economics/social advisory
59: 8,3;remarkable people
60: 9,0;education/science/factual topics (general)
61: 9,1;nature/animals/environment
62: 9,2;technology/natural sciences
63: 9,3;medicine/physiology/psychology
64: 9,4;foreign countries/expeditions
65: 9,5;social/spiritual sciences
66: 9,6;further education
67: 9,7;languages
68: 10,0;leisure hobbies (general)
69: 10,1;tourism/travel
70: 10,2;handicraft
71: 10,3;motoring
72: 10,4;fitness and health
73: 10,5;cooking
74: 10,6;advertisement/shopping
75: 10,7;gardening
76: 11,0;original language
77: 11,1;black and white
78: 11,2;unpublished
79: 11,3;live broadcast
80: 11,4;plano-stereoscopic
81: 11,5;local or regional
82: 12,0;adult (general)
```

## File: res/_sup_lib
```
1: ar=ipk/deb
2: bzip2=bz2 files
3: ffmpeg=PIcons conversion + Some file types download
4: Imaging=OSD-Screenshot + Convert picture to PIcon
5: p7zip=7z files
6: requests=Portal communication + IPTV Download
7: unrar=rar files
8: xz=deb packages
9: zip=zip files
```

## File: res/ajpanel_cmd_list
```
 1: # Directory
 2: pwd                 # Current Dir
 3: cd                   # Home
 4: cd ..                # Up
 5: cd /                 # Root
 6: cd /home          # Home
 7: cd /home/root   # User Dir
 8: cd /tmp            # /tmp
 9: cd ~                # Home
10: 
11: # File List
12: ls
13: ls --full-time
14: ls -1
15: ls -als
16: ls -ls
17: 
18: # Search
19: find / -iname FILE_NAME
20: find / -size +10000k
21: grep -r PATTERN dir
22: grep PATTERN FILES
23: 
24: # System
25: date
26: hostname
27: hostname -i
28: uname
29: uptime
30: whoami
31: 
32: # User
33: id
34: last
35: who
36: 
37: # Network
38: ifconfig
39: netstat
40: ping google.com -c 3        # 3 seconds
41: 
42: # File Permission
43: chmod 755 /tmp/FILE_NAME
44: chmod 766 /tmp/FILE_NAME
45: chmod 777 /tmp/FILE_NAME
46: 
47: # Disk usage
48: df -h
```

## File: res/ajpanel_iptv_blacklist
```
1: dorosych
2: hot ch
3: hot club
4: 
5: 
6: 
7: 
8: 
```

## File: res/ajpanel_iptv_prefix
```
 1: Ex-Yu:
 2: YU:
 3: Afg:
 4: Af:
 5: Alb:
 6: Plus:
 7: Sport|
 8: Alb:
 9: Alb:
10: F1-
11: Sport | Ar:
12: A+ -
13: D+ -
14: H265:
15: 4K|
```

## File: res/ajpanel_lang
```
  1: af,Afrikaans
  2: sq,Albanian
  3: am,Amharic
  4: ar,Arabic
  5: hy,Armenian
  6: as,Assamese
  7: ay,Aymara
  8: az,Azerbaijani
  9: bm,Bambara
 10: eu,Basque
 11: be,Belarusian
 12: bn,Bengali
 13: bho,Bhojpuri
 14: bs,Bosnian
 15: bg,Bulgarian
 16: ca,Catalan
 17: ceb,Cebuano
 18: ny,Chichewa
 19: zh-CN,Chinese (Simplified)
 20: zh-TW,Chinese (Traditional)
 21: co,Corsican
 22: hr,Croatian
 23: cs,Czech
 24: da,Danish
 25: dv,Dhivehi
 26: doi,Dogri
 27: nl,Dutch
 28: en,English
 29: eo,Esperanto
 30: et,Estonian
 31: ee,Ewe
 32: tl,Filipino
 33: fi,Finnish
 34: fr,French
 35: fy,Frisian
 36: gl,Galician
 37: ka,Georgian
 38: de,German
 39: el,Greek
 40: gn,Guarani
 41: gu,Gujarati
 42: ht,Haitian Creole
 43: ha,Hausa
 44: haw,Hawaiian
 45: iw,Hebrew
 46: hi,Hindi
 47: hmn,Hmong
 48: hu,Hungarian
 49: is,Icelandic
 50: ig,Igbo
 51: ilo,Ilocano
 52: id,Indonesian
 53: ga,Irish
 54: it,Italian
 55: ja,Japanese
 56: jw,Javanese
 57: kn,Kannada
 58: kk,Kazakh
 59: km,Khmer
 60: rw,Kinyarwanda
 61: gom,Konkani
 62: ko,Korean
 63: kri,Krio
 64: ku,Kurdish (Kurmanji)
 65: ckb,Kurdish (Sorani)
 66: ky,Kyrgyz
 67: lo,Lao
 68: la,Latin
 69: lv,Latvian
 70: ln,Lingala
 71: lt,Lithuanian
 72: lg,Luganda
 73: lb,Luxembourgish
 74: mk,Macedonian
 75: mai,Maithili
 76: mg,Malagasy
 77: ms,Malay
 78: ml,Malayalam
 79: mt,Maltese
 80: mi,Maori
 81: mr,Marathi
 82: mni-Mtei,Meiteilon (Manipuri)
 83: lus,Mizo
 84: mn,Mongolian
 85: my,Myanmar (Burmese)
 86: ne,Nepali
 87: no,Norwegian
 88: or,Odia (Oriya)
 89: om,Oromo
 90: ps,Pashto
 91: fa,Persian
 92: pl,Polish
 93: pt,Portuguese
 94: pa,Punjabi
 95: qu,Quechua
 96: ro,Romanian
 97: ru,Russian
 98: sm,Samoan
 99: sa,Sanskrit
100: gd,Scots Gaelic
101: nso,Sepedi
102: sr,Serbian
103: st,Sesotho
104: sn,Shona
105: sd,Sindhi
106: si,Sinhala
107: sk,Slovak
108: sl,Slovenian
109: so,Somali
110: es,Spanish
111: su,Sundanese
112: sw,Swahili
113: sv,Swedish
114: tg,Tajik
115: ta,Tamil
116: tt,Tatar
117: te,Telugu
118: th,Thai
119: ti,Tigrinya
120: ts,Tsonga
121: tr,Turkish
122: tk,Turkmen
123: ak,Twi
124: uk,Ukrainian
125: ur,Urdu
126: ug,Uyghur
127: uz,Uzbek
128: vi,Vietnamese
129: cy,Welsh
130: xh,Xhosa
131: yi,Yiddish
132: yo,Yoruba
133: zu,Zulu
```

## File: res/ajpanel_menu.xml
```xml
  1: <?xml version="1.0" encoding="utf-8"?>
  2: <ajp_menu title="Custom Tools" mode="grid" shade="yes" box_gap="40" icon="/usr/lib/enigma2/python/Plugins/Extensions/AJPan/res/ajp.png">
  3: 	<submenu title="AJPanel Options (Grid)" info="AJPanel - Enigma2 Tools" width="1600" height="950" mode="grid" shade="yes" bg="#0a222522" icon="ajp.png">
  4: 		<item name="File Manager">ajp_fman</item>
  5: 		<item name="IPTV">ajp_iptv</item>
  6: 		<item name="Movies Browser">ajp_movie</item>
  7: 		<item name="Services/Channels">ajp_chan</item>
  8: 		<item name="Channels Browser">ajp_chanBr</item>
  9: 		<item name="Bouquet Editor">ajp_bouq</item>
 10: 		<item name="PIcons">ajp_picon</item>
 11: 		<item name="EPG">ajp_epg</item>
 12: 		<item name="XML-TV Tools">ajp_xmltv</item>
 13: 		<item name="Terminal">ajp_term</item>
 14: 		<item name="SoftCam">ajp_soft</item>
 15: 		<item name="Plugins">ajp_plugin</item>
 16: 		<item name="Plugins Browser">ajp_plugBr</item>
 17: 		<item name="Backup &amp; Restore">ajp_bakup</item>
 18: 		<item name="Date/Time">ajp_date</item>
 19: 		<item name="Network">ajp_net</item>
 20: 		<item name="Device Info">ajp_info</item>
 21: 		<item name="Check Internet">ajp_inet</item>
 22: 	</submenu>
 23: 	<submenu title="AJPanel Options (List)" info="AJPanel Options (List Mode Menu)" icon="ajp.png" >
 24: 		<item name="File Manager">ajp_fman</item>
 25: 		<separator />
 26: 		<item name="IPTV">ajp_iptv</item>
 27: 		<item name="Movies Browser">ajp_movie</item>
 28: 		<item name="Services/Channels">ajp_chan</item>
 29: 		<item name="Channels Browser">ajp_chanBr</item>
 30: 		<item name="Bouquet Editor">ajp_bouq</item>
 31: 		<item name="PIcons">ajp_picon</item>
 32: 		<item name="EPG">ajp_epg</item>
 33: 		<item name="XML-TV Tools">ajp_xmltv</item>
 34: 		<separator />
 35: 		<item name="Terminal">ajp_term</item>
 36: 		<item name="SoftCam">ajp_soft</item>
 37: 		<item name="Plugins">ajp_plugin</item>
 38: 		<item name="Plugins Browser">ajp_plugBr</item>
 39: 		<item name="Backup &amp; Restore">ajp_bakup</item>
 40: 		<separator />
 41: 		<item name="Date/Time">ajp_date</item>
 42: 		<item name="Network">ajp_net</item>
 43: 		<separator />
 44: 		<item name="Device Info">ajp_info</item>
 45: 		<item name="Check Internet">ajp_inet</item>
 46: 	</submenu>
 47: 	<submenu title="Recursive Menus" info="Cascaded menus + Menu Alignment Test" bg="#06006666" title_bg="#06004444" width="800">
 48: 		<submenu title="Test Commands (Center List Items)" align_items="center" bg="#06770077" title_bg="#06aa00aa" width="1100">
 49: 			<submenu title=" Right-to-Left" width="800" height="500" fg="#22ffffff" bg="#22003322" font_size="35" align_items="right" title_fg="#33ffffaa" title_bg="#11003333" title_font_size="50" cursor_fg="#11ff8000" cursor_bg="#11442244">
 50: 				<item name=" AJPanel - v9.0.0" ask="">wget https://raw.githubusercontent.com/biko-73/AjPanel/main/installer.sh -O - | /bin/sh</item>
 51: 				<item name=" AJPanel - Latest" ask="">wget https://raw.githubusercontent.com/biko-73/AjPanel/main/installer.sh -O - | /bin/sh</item>
 52: 			</submenu>
 53: 			<item name="Using Special Characters (E.g. : &amp;) ... Method-1"> ls /home &amp;&amp; echo '' &amp;&amp; df </item>
 54: 			<item name="Using Special Characters (E.g. : &amp;) ... Method-2">
 55: 				<![CDATA[
 56: 					ls /home && echo '' && df
 57: 				]]>
 58: 			</item>
 59: 		</submenu>
 60: 		<item name="Disk Usage">df</item>
 61: 		<item name="LSOF">lsof</item>
 62: 		<item name="Uptime">uptime</item>
 63: 	</submenu>
 64: 	<!-- ============================================================================================== -->
 65: 	<!-- Simple GRID Submenu (small icons are will stretched to the picture area)						-->
 66: 	<!-- ============================================================================================== -->
 67: 	<submenu title="GRID Menu (mode='grid_3x1')" info="Simple GRID Submenu (will stretch small icons to fit the picture area)" mode="grid_3x3" title_font_size="30">
 68: 		<item name="Disk Usage">df</item>
 69: 		<item name="LSOF">lsof</item>
 70: 		<item name="Uptime">uptime</item>
 71: 	</submenu>
 72: 	<submenu title="GRID Menu (mode='grid1_3x3')" info="Simple GRID Submenu (will not stretch small icons to fit the picture area)" mode="grid1_3x3">
 73: 		<item name="Disk Usage">df</item>
 74: 		<item name="LSOF">lsof</item>
 75: 		<item name="Uptime">uptime</item>
 76: 	</submenu>
 77: 	<submenu title="Install AJPanel" info="Simple List Menu (with a custom Icon)" line_gap="50" font_size="40" icon="/usr/lib/enigma2/python/Plugins/Extensions/AJPan/res/dnld.png">
 78: 		<item name="AJPanel - v9.0.0" ask="Start Installation ?">wget https://raw.githubusercontent.com/biko-73/AjPanel/main/installer.sh -O - | /bin/sh</item>
 79: 		<item name="AJPanel - Latest" ask="Update AJPanel ?">wget https://raw.githubusercontent.com/biko-73/AjPanel/main/installer.sh -O - | /bin/sh</item>
 80: 	</submenu>
 81: 	<item name="Run a Script File" ask="">/media/usb/AAA/Test_Files/long_process_script.sh</item>
 82: 	<!-- ============================================================================================== -->
 83: 	<!-- Installing multiple packages (Exmaple: xz and zip)												-->
 84: 	<!-- ============================================================================================== -->
 85: 	<item name="Multiple Install (xz and zip)" ask="Install 2 packaes (xz/zip) ?">opkg install xz zip</item>
 86: 	<!-- ============================================================================================== -->
 87: 	<!-- Testing Multiple Commands																		-->
 88: 	<!-- ============================================================================================== -->
 89: 	<item name="Internal Script" info="Simple Script within the Custom Menu XML file">
 90: 		<![CDATA[
 91: 			# ==========================================================
 92: 			echo
 93: 			echo ">>>> [  Testing delayed commands  ] <<<<"
 94: 			SLEEP=0.3
 95: 			ls -d /bin/busybox	; sleep $SLEEP
 96: 			ls -d /bin/cat		; sleep $SLEEP
 97: 			ls -d /bin/chmod	; sleep $SLEEP
 98: 			ls -d /bin/df		; sleep $SLEEP
 99: 			ls -d /bin/echo		; sleep $SLEEP
100: 			ls -d /bin/ls		; sleep $SLEEP
101: 			ls -d /bin/ln		; sleep $SLEEP
102: 			ls -d /bin/mount	; sleep $SLEEP
103: 			ls -d /bin/sh		; sleep $SLEEP
104: 			ls -d /bin/uname
105: 			# Check if opkg status file exists
106: 			echo
107: 			echo ">>>> [  Checking OPKG Status File  ] <<<<"
108: 			if test -f /var/lib/opkg/status; then
109: 				echo "File exists."
110: 			else
111: 				echo "File NOT FOUND"
112: 			fi
113: 			# Check if xz is installed
114: 			echo
115: 			echo ">>>> [  Checking 'xz' Package  ] <<<<"
116: 			if which xz >/dev/null; then echo xz is already installed; else echo 'xz' not installed; fi
117: 			# ==========================================================
118: 		]]>
119: 	</item>
120: 	<submenu title="Pictures Menu" info="Favourite Pictures" mode="grid_4x4" icon="/usr/lib/enigma2/python/Plugins/Extensions/AJPan/res/pic.png">
121: 		<item name="View Picture">/usr/share/enigma2/skin_default/testscreen.png</item>
122: 	</submenu>
123: 	<submenu title="Movies (Grid)" mode="grid_3x3" icon="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAApCAYAAAB3LnrpAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX8VGAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAGGklEQVRo3t2ZS4wcRxnHf9VV3dM979mx92VwjIOSSHHkOBGyLFsIELFNUAQ4cMmJKEqUhANIEYKTj1w4cUoEQsslCIQNQUEczMEBh+CwXkcQr43leB282XjXuzOzO4+dV3cVh56dR/yAeGedWb7TTE9N/+vXVd9XM99fHDz8+ByQYHNHSQHja++MLZH5MjJfxijZHiUCjfYcgpEUxrJQC8tY5VrvGD8gGIoTbE1iVerI+WUwBoRo3Tx8HYyk0HEXuVhcn85QHNEM1i4nFFBaWxFZqFB/aDuNB7cjytX2l43rIJeKeKcvIfyA1S/uwt82hFitd8bEXZxzs7jvXMEfz1B56gAoCX5LTEowBvftS9izS9T27KSx69OISu1j6ng401eJnJtFx92eFWmHXCxS23sf+W9/HVW93r4eeCnc6UtE3ziPKFUpHdlLZe8jqGquPcb3hhn6xWskfvs2jfvHKXz3qxgvgqjW25Mk0Iy88FOif55m+cXD69KJnpzuBqEHBAxIC4MCW3VdVe3lFbcZg7RAGwyArTAohB2uiBEKVAAC0H3QCVVuDhJkk7hnLpM1x7GKna2low5qfhnj2mgrRvwPU0TOzWKVO9tCJz3cqRn8e7YiyzXSr5zA2LK9j40KIWWhgr9jeN06QTbZAyIOHn68iBAJtA63V66EzJUx9k2ScDQdJuF84cYkbAYE2QTBcApRqaGuFcInb3UlO4JgLI1OeMiFFWSudIc6cYJsIlwUaYExpQ5I0w9X3XPCCQxyWAKr2gifj63AmDDZreUyjQe2sfLMlxH1JsIP1qWz4SEEfiZGeuIk7uR7BNlEmCOi4ePvGAEg/coJdMLt1P9BC2OQ+TK5Hx6h8dkxom9eIGAt2a2wCthzOSLnZwnSscEGuV7EvrqE0BojLaC7ammDURKd8ML6PMAgotYMi0RXLlv9un/M9tn/YPwT4+sbyKhX5Mi+BPsfuXdzg6zk5tmVuMjRr+R4+ftf4IHPjGxOEOW4YCkoXGDnyq/4yVM2R5/9PNl0bHOBCMKTGycNyoOFt9hvv84vv7eD57+1d8NrR99AOmFASIhkwQTwwR/5xtib/O7o53jysd2bCaQLyHIgsgXqBby54zz30AV+/oMD7N+zc5BBbrV3DKgYRIag/D6fyv+ao4eK/OiFA2wfzw4iyO2idXDZKbATsHSaR2Nv8OKTD/dNQa3/Fh8jLAO2Q9Ns49Rknt9M/4l+Pcu7B+JI0IILV2pM/E3xj/nhvt5+40FsCyzJwvUaE28JTs6kN0Rm40CkAKUoFZscm2xw7N0Uvt64w6RvIBaEhcsCIopG3XBiapVXz8bIVzf+x2TfQARNiNqwqjn1ToVXpyJcWc5sOEDfQS6vJPnxxBxltnJ69u4B9B1EekP8fbZMkehdh+griLIjFIl8IhC9IEJAoBG1BsK1B/yvbgMC3TPHEEQbjLTQQ3GCbJIgFR1oELRBZ+OY2SXWGoshiJLYVxepHHqY/EtPtD4cUBAMwkCQiWG/vxg26FhrmUKCQGM8B530IDB8tEk8OCFACqxSLbQbwnZQy1YQAoTAWq2jPsghC5XenqyvMZ6NP5wCy0IuLGOt1m/syWZiHaPn+kpv71cbEBAMdxk969DRmThGhvPGmNbWMqGgqPrUH72Xxv3jiEqXueLayFwJ9+wM+AGrB3fjj2YQrf4rgIlFcC5+SOSf/8YfTVN5bDcoC/xwDyMFGIicncGey69bx/nXHCYWaTXHP1J+5eIK1ae/RP7pr2FXOgaMH0vhnruE99eLiHKV0jf3Ud63B7uSb49pxoYZmvg98dcmadw3RuGlJ9CxCFZrotp1IAgY+c7PiP7lPMvPH1qXjnfqPDrW+QXde45oA8rC4KBdu/MUsDFOaxcag3HUTcY4LaNHYwRo18Zgo91wRYy0w8+F6DJ67DvTaXkt3dFr9GxZM3qO3d6Aef0MkXev3mjAnLlM856tyFKNzMv/xeiZfI8sx+9MZ2qGYMuNRk8bzdgKmSu2DJius9IPK5o/1jJgrhWwKrcyelrJfq2A0AbTSnbR2sv+aAadvIXR8z/p+KFONolo+j0g/xc++38ABu5BVNc8lQYAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjMtMTItMTNUMTk6NTE6MTErMDA6MDBki658AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIzLTEyLTEzVDIwOjAzOjQ0KzAwOjAwgVhkTwAAAABJRU5ErkJggg==" info="Movies (shows posters if exists in same directory)">
124: 		<item icon="/media/usb/movie/Animation/Bugs_Life_1998.jpg" name="Bugs_Life ">/media/usb/movie/Animation/Bugs_Life_1998.mp4</item>
125: 		<item name="Jungle Book (1967)">/media/usb/movie/Animation/Jungle_Book_1967.mp4</item>
126: 	</submenu>
127: 	<submenu title="Movies (List)" info="Movies (shows posters if exists in same directory)" width="1000" font_size="40" line_gap="100" icon="/usr/lib/enigma2/python/Plugins/Extensions/AJPan/res/mov.png">
128: 		<item icon="/media/usb/movie/Animation/Bugs_Life_1998.jpg" name="Bugs_Life ">/media/usb/movie/Animation/Bugs_Life_1998.mp4</item>
129: 		<item name="Jungle Book (1967)">/media/usb/movie/Animation/Jungle_Book_1967.mp4</item>
130: 	</submenu>
131: 	<submenu title="Channels Menu" info="Favourite Channels Menu" mode="grid_4x4" icon="/usr/lib/enigma2/python/Plugins/Extensions/AJPan/res/tv.png">
132: 		<item name="Baby TV" info="Play a channel" >1:0:1:421d:2f44:13E:820000:0:0:0</item>
133: 		<item name="MiniMini+ HD" info="Play a channel">1_0_1_32e0_190_13E_820000_0_0_0</item>
134: 		<item name="Sports Connect" info="Play IPTV channel">5001:0:0:0:0:0:0:0:0:0:https%3a//origin3.afxp.telemedia.co.za/PremiumFree/sportsconnect/abr_satellitechannel/satch_sportsconnect_720p/chunks.m3u8:Sports Connect</item>
135: 	</submenu>
136: 	<item name="/media/" info="Open the directory &quot;/media/&quot; in File Manager">/media</item>
137: 	<item info="Locate CCcam.cfg in File Manager" name="Go to skin.xml">/usr/share/enigma2/skin_default/skin.xml</item>
138: 	<item name="About This Panel">This is a test panel (v1.0)</item>
139: </ajp_menu>
```

## File: res/ajpanel_pkg
```
 1: REQ1:Package: enigma2-plugin-extensions-xx1
 2: REQ1:Version: v1.0
 3: REQ1:Description: xx2
 4: REQ1:Maintainer: xx2
 5: OPT1:Architecture: all
 6: OPT1:Priority: optional
 7: OPT1:Section: base
 8: OPT2:License: none
 9: OPT2:Source: none
10: OPT2:Essential: no
11: OPT2:Origin:
12: OPT2:Bugs: url
13: OPT2:Homepage: url
14: OPT2:Tag:
15: OPT2:Multi-Arch: allowed
16: OPT2:Subarchitecture: all
17: OPT2:Kernel-Version:
18: OPT2:Installer-Menu-Item:
19: OPT2:Breaks:
20: OPT2:Conflicts:
21: OPT2:Depends:
22: OPT2:Enhances:
23: OPT2:Pre-Depends:
24: OPT2:Provides:
25: OPT2:Recommends:
26: OPT2:Replaces:
27: OPT2:Suggests:
28: OPT2:Built-Using:
```

## File: res/ajpanel_res_marker
```
1: 
```

## File: res/ajpanel_services_filter
```
 1: # Service Filter File ("ajpanel_services_filter"):
 2: # - The file  is used to store yor favourite words.
 3: # - It is automatically copied to your Backup directory when you launch the filter.
 4: # - You can modify it within the Filter (Yellow Button) or use any text editor.
 5: #
 6: # Rules:
 7: # - To find words, create line with a word (or list of words separate by commas).
 8: # - Searching is case-insensitive (capital and small letters or a mix of both).
 9: # - Starting the line with "^" will order the search for names starting with the words.
10: # - To find names that start with a word, add "^" as the first letter in line.
11: # - Comments are ignored (any text starting with "#" is ignored).
12: # - Empty lines are ignored.
13: #
14: # Examples:
15: # Sport			# Find names that contain the word "sport".
16: # sport, kass		# Find names that contain any of the words "sport" and "kass".
17: # ^k				# Find names that start with the letter "K" (or "k").
18: # ^sport,beIN		# Find names that start with the words "sport" or "beIN".
19: 
20: Sport, Motor, Kass, Golf, Fotboll, ESP	# Sports
21: Edu, Doc, Dok, Kult, cult, Earth, Anim, Planet, Geo, Histor, Discovery	# Educational
22: Movie, Cine, Drama
23: Toon, Kids, Bambini, Nick, Disney, Baby	# Kids
24: News, Notizie
25: Food
26: Test
27: HD
28: 4K, UHD, HEVC
29: ^,OSN
30: osn
```

## File: __init__.py
```python
1: 
```

## File: keymap.xml
```xml
 1: <keymap>
 2: 	<map context="KeyMap_HK">
 3: 		<key id="KEY_OK"			mapto="longOK"			flags="l"/>
 4: 		<key id="KEY_EXIT"			mapto="longCancel"		flags="l" />
 5: 		<key id="KEY_ESC"			mapto="longCancel"		flags="l" />
 6: 		<key id="KEY_RED"			mapto="longRed"			flags="l" />
 7: 		<key id="KEY_F1"			mapto="all"				flags="m" />
 8: 		<key id="KEY_F2"			mapto="vid"				flags="m" />
 9: 		<key id="KEY_F3"			mapto="osd"				flags="m" />
10: 		<key id="KEY_TV"			mapto="all"				flags="l" />
11: 		<key id="KEY_TV2"			mapto="all"				flags="l" />
12: 		<key id="KEY_VIDEO"			mapto="all"				flags="l" />
13: 		<key id="KEY_RADIO"			mapto="vid"				flags="l" />
14: 		<key id="KEY_0"				mapto="vid"				flags="l" />
15: 		<key id="KEY_HELP"			mapto="osd"				flags="l" />
16: 	</map>
17: 	<map context="GlobalActions">
18: 		<key id="KEY_OK"			mapto="longOK"			flags="l"/>
19: 		<key id="KEY_EXIT"			mapto="longCancel"		flags="l" />
20: 		<key id="KEY_ESC"			mapto="longCancel"		flags="l" />
21: 		<key id="KEY_RED"			mapto="longRed"			flags="l" />
22: 		<key id="KEY_VIDEO"			mapto="all"				flags="l" />
23: 	</map>
24: 	<map context="KeyMap_RC">
25: 		<key id="KEY_VIDEO"			mapto="pvr"				flags="b" />
26: 		<key id="KEY_POWER"			mapto="powerLong"		flags="l" />
27: 		<key id="KEY_MENU"			mapto="menu"			flags="m" />
28: 		<key id="KEY_HELP"			mapto="help"			flags="m"/>
29: 		<key id="KEY_ENTER"			mapto="ok"				flags="m" />
30: 		<key id="KEY_OK"			mapto="ok"				flags="m" />
31: 		<key id="KEY_EXIT"			mapto="cancel"			flags="m" />
32: 		<key id="KEY_ESC"			mapto="cancel"			flags="m" />
33: 		<key id="KEY_LEFT"			mapto="left"			flags="mr" />
34: 		<key id="KEY_RIGHT"			mapto="right"			flags="mr" />
35: 		<key id="KEY_UP"			mapto="up"				flags="mr" />
36: 		<key id="KEY_DOWN"			mapto="down"			flags="mr" />
37: 		<key id="KEY_RED"			mapto="red"				flags="m" />
38: 		<key id="KEY_GREEN"			mapto="green"			flags="m" />
39: 		<key id="KEY_YELLOW"		mapto="yellow"			flags="m" />
40: 		<key id="KEY_BLUE"			mapto="blue"			flags="m" />
41: 		<key id="KEY_INFO"			mapto="info"			flags="m"/>
42: 		<key id="KEY_EPG"			mapto="epg"				flags="m"/>
43: 		<key id="KEY_HOME"			mapto="home" 			flags="m"/>
44: 		<key id="KEY_END"			mapto="end" 			flags="m"/>
45: 		<key id="KEY_PAGEUP"		mapto="pageUp" 			flags="mr"/>
46: 		<key id="KEY_PAGEDOWN"		mapto="pageDown"		flags="mr"/>
47: 		<key id="KEY_CHANNELUP"		mapto="chanUp"			flags="mr"/>
48: 		<key id="KEY_CHANNELDOWN"	mapto="chanDown"		flags="mr"/>
49: 		<key id="KEY_DELETE"		mapto="deleteForward"	flags="mr" />
50: 		<key id="KEY_BACKSPACE"		mapto="deleteBackward"	flags="mr" />
51: 		<key id="KEY_BACK"			mapto="back"			flags="m" />
52: 		<key id="KEY_FAVORITES"		mapto="fav"				flags="m" />
53: 		<key id="KEY_1"				mapto="1"				flags="m" />
54: 		<key id="KEY_2"				mapto="2"				flags="m" />
55: 		<key id="KEY_3"				mapto="3"				flags="m" />
56: 		<key id="KEY_4"				mapto="4"				flags="m" />
57: 		<key id="KEY_5"				mapto="5"				flags="m" />
58: 		<key id="KEY_6"				mapto="6"				flags="m" />
59: 		<key id="KEY_7"				mapto="7"				flags="m" />
60: 		<key id="KEY_8"				mapto="8"				flags="m" />
61: 		<key id="KEY_9"				mapto="9"				flags="m" />
62: 		<key id="KEY_0"				mapto="0"				flags="m" />
63: 		<key id="KEY_F4"			mapto="f4"				flags="m" />
64: 		<key id="KEY_NEXT"			mapto="next"			flags="mr" />
65: 		<key id="KEY_PREVIOUS"		mapto="last"			flags="mr" />
66: 		<key id="KEY_PLAY"			mapto="play"			flags="b" />
67: 		<key id="KEY_PLAY"			mapto="longPlay"		flags="l" />
68: 		<key id="KEY_PAUSE"			mapto="pause"			flags="m" />
69: 		<key id="KEY_PLAYPAUSE"		mapto="playPause"		flags="m" />
70: 		<key id="KEY_STOP"			mapto="stop"			flags="m" />
71: 		<key id="KEY_STOP"			mapto="stopLong"		flags="l" />
72: 		<key id="KEY_REWIND"		mapto="rewind"			flags="m" />
73: 		<key id="KEY_PREVIOUSSONG"	mapto="rewindDm"		flags="m" />
74: 		<key id="KEY_FASTFORWARD"	mapto="forward"			flags="m" />
75: 		<key id="KEY_NEXTSONG"		mapto="forwardDm"		flags="m" />
76: 		<key id="KEY_AUDIO"			mapto="audio"			flags="m" />
77: 		<key id="KEY_SUBTITLE"		mapto="subtitle"		flags="m" />
78: 		<key id="KEY_TEXT"			mapto="text"			flags="m" />
79: 		<key id="KEY_TV"			mapto="tv"				flags="m" />
80: 		<key id="KEY_TV2"			mapto="tv"				flags="m" />
81: 	</map>
82: </keymap>
```

## File: plugin.py
```python
    1: import os
    2: import hashlib
    3: from io       import open as ioOpen
    4: from json      import loads as jLoads, dumps as jDumps
    5: from glob      import glob as iGlob
    6: from re       import match as iMatch, escape as iEscape
    7: from re       import sub as iSub, subn as iSubn, split as iSplit
    8: from re       import search as iSearch, compile as iCompile
    9: from re       import findall as iFindall, finditer as iFinditer
   10: from re       import IGNORECASE
   11: from math      import floor as iFloor, ceil as iCeil, log as iLog
   12: from time      import localtime, mktime, strftime, time as iTime
   13: from time      import sleep as iSleep, timezone as iTimezone
   14: from threading     import Thread as iThread, enumerate as iEnumerate
   15: from threading     import currentThread
   16: from datetime     import datetime, timedelta
   17: from collections    import Counter as iCounter
   18: from base64      import b64encode, b64decode
   19: from sys      import version_info as pyVersion
   20: from skin      import parseColor
   21: from Tools.Directories   import resolveFilename, SCOPE_PLUGINS, SCOPE_FONTS
   22: from Tools.Directories   import SCOPE_CURRENT_SKIN, SCOPE_SKIN
   23: from Plugins.Plugin    import PluginDescriptor
   24: from Screens.Screen    import Screen
   25: from Screens.ChannelSelection import ChannelContextMenu, ChannelSelectionBase
   26: from Screens.ChannelSelection import service_types_tv, service_types_radio
   27: from Screens.InfoBar   import InfoBar
   28: from Tools.BoundFunction  import boundFunction as BF
   29: from Tools.LoadPixmap   import LoadPixmap
   30: from Components.PluginComponent import plugins as iPlugins
   31: from Components.Harddisk  import harddiskmanager
   32: from Components.Label   import Label
   33: from Components.ScrollLabel  import ScrollLabel
   34: from Components.Button   import Button
   35: from Components.MenuList  import MenuList
   36: from Components.ActionMap  import ActionMap
   37: from Components.Pixmap   import Pixmap
   38: from Components.NimManager  import nimmanager
   39: from Components.Slider   import Slider
   40: from enigma      import getDesktop, ePoint, eSize, gFont, eRect
   41: from enigma      import eTimer, eDVBDB, addFont, fontRenderClass
   42: from enigma      import iServiceInformation
   43: from enigma      import eServiceReference, eServiceCenter
   44: from enigma      import eListboxPythonMultiContent
   45: from enigma      import RT_HALIGN_LEFT as LEFT
   46: from enigma      import RT_HALIGN_RIGHT as RIGHT
   47: from enigma      import RT_HALIGN_CENTER as CENTER
   48: from enigma      import RT_VALIGN_CENTER
   49: from Components.ConfigList  import ConfigListScreen
   50: from Components.config   import config, ConfigSubsection, configfile
   51: from Components.config   import getConfigListEntry, ConfigDirectory
   52: from Components.config   import ConfigYesNo, ConfigElement, ConfigText
   53: from Components.config   import ConfigSelection, ConfigSelectionNumber
   54: from Components.config   import ConfigSubList, ConfigInteger
   55: try:  import tarfile as iTar
   56: except: iTar = None
   57: try:  import zipfile as iZip
   58: except: iZip = None
   59: try: from xml.etree import ElementTree as iElem
   60: except: iElem = None
   61: try: from shutil import move as iMove, rmtree, copyfile as iCopyfile, copymode as iCopymode
   62: except: iMove = iCopyfile = iCopymode = None
   63: try:
   64:  from urllib2 import Request as iRequest, urlopen as iUrlopen, URLError as iURLError, build_opener, install_opener, HTTPPasswordMgrWithDefaultRealm, HTTPDigestAuthHandler, HTTPHandler
   65:  from urllib  import unquote as iUnquote, quote as iQuote
   66:  from urlparse import urlparse as iUrlparse, parse_qs as iUrlparse_qs
   67: except:
   68:  try:
   69:   from urllib.request import Request as iRequest, urlopen as iUrlopen, build_opener, install_opener, HTTPPasswordMgrWithDefaultRealm, HTTPDigestAuthHandler, HTTPHandler
   70:   from urllib.error import URLError as iURLError
   71:   from urllib.parse import unquote as iUnquote, quote as iQuote, urlparse as iUrlparse, parse_qs as iUrlparse_qs
   72:  except:
   73:   iRequest = iUrlopen = iURLError = iUnquote = iQuote = iUrlparse = build_opener = install_opener = HTTPPasswordMgrWithDefaultRealm = HTTPDigestAuthHandler = HTTPHandler = None
   74: VVh9hj    = "AJPanel"
   75: VVzOp7  = "Enigma2 Tools"
   76: VVJ6zn   = "v10.8.5"
   77: VVPAan    = "14-10-2025"
   78: VV5xkJ    = 0
   79: VVNA43   = 0
   80: VVS9Q2   = 0
   81: VVUytA  = resolveFilename(SCOPE_PLUGINS, base="Extensions/")
   82: VVhDOZ  = resolveFilename(SCOPE_PLUGINS, base="SystemPlugins/")
   83: VVXRGG   = "AJPan"
   84: VVSBbs  = "AUTO FIND"
   85: VVoeMl  = "Custom"
   86: VVTCq1    = "/usr/share/enigma2/picon/"
   87: VVQe79   = "/etc/enigma2/"
   88: VVfBVj   = VVQe79 + "settings"
   89: VV3W4d = VVQe79 + "blacklist"
   90: VVl57H = VVQe79 + "whitelist_streamrelay"
   91: VVLtQt    = ""
   92: VV8nt5 = "Regular"
   93: VV2DFQ = "Fixed"
   94: VVNj6e  = "AJP_Main"
   95: VVUm9t = "AJP_Terminal"
   96: VVLn2O  = "AJP_Added"
   97: VVnvzh = "AJP_System"
   98: VVNhAq  = VV8nt5
   99: VV3knk    = ""
  100: VV1jg5   = " && echo 'Successful' || echo 'Failed!'"
  101: VVfDY7  = "Cannot continue (No Enough Memory) !"
  102: VVq9cv  = ["
  103: VVzu3t    = ["KeyMap_RC"]
  104: VV9iuh  = "utf8"
  105: VV8oe7  = False
  106: VVAL3j    = ("-" * 100, )
  107: SEP      = "-" * 80
  108: VVWe5f = 0
  109: VVBvqf = 0
  110: VVWp3I     = 0
  111: VVibAL    = 1
  112: VVvJlJ    = 2
  113: VVkFCt   = 3
  114: VVHfYH   = 4
  115: VVDEl1 = 5
  116: VVUcno    = 6
  117: VVsVfC    = 7
  118: VVmSQ6 = 8
  119: VVf2e8 = 9
  120: VVQrjc  = 10
  121: VV5jiO   = 11
  122: VVnhJ8  = 12
  123: VVujxw  = 13
  124: VVpLGo   = 14
  125: VVakGB    = 15
  126: VVnUU2   = 16
  127: VVsg3D   = 17
  128: VVrQU9    = 18
  129: VVspuu    = 19
  130: VVoNDw  = 20
  131: VVlrZA    = 21
  132: VVje9A   = 0
  133: VV5jA8   = 1
  134: VVYAtm   = 2
  135: if not "VVG5aE" in globals(): VVG5aE = set()
  136: def FFXcbU(path, alias, scale=100, isRepl=0, save=True):
  137:  try:
  138:   addFont(path, alias, scale, isRepl)
  139:   if save: VVG5aE.add(alias)
  140:   return True
  141:  except:
  142:   try:
  143:    addFont(path, alias, scale, isRepl, 0)
  144:    if save: VVG5aE.add(alias)
  145:    return True
  146:   except:
  147:    pass
  148:  return False
  149: VVmJwX = os.path.exists
  150: def FFCyVu(f, mode="r"):
  151:  return os.access(f, {"r": os.R_OK, "w":os.W_OK}.get(mode, os.F_OK)) if f else False
  152: def FFq2rn(f):
  153:  return (os.path.exists(f) or os.path.islink(f)) if f else False
  154: def FF7YkR(path):
  155:  lst = []
  156:  try:
  157:   for ndx, (event, elem) in enumerate(iElem.iterparse(path, events=("start", ))):
  158:    if elem.tag == "include":
  159:     incF = elem.get("filename", "")
  160:     incF = incF and resolveFilename(SCOPE_CURRENT_SKIN, incF)
  161:     if FFCyVu(incF):
  162:      lst.append(incF)
  163:  except:
  164:   pass
  165:  return lst
  166: def FF85qp():
  167:  defSk = resolveFilename(SCOPE_SKIN, "skin_default/skin.xml")
  168:  subSk = resolveFilename(SCOPE_CURRENT_SKIN, "skin_subtitles.xml")
  169:  curSk = resolveFilename(SCOPE_CURRENT_SKIN, "skin.xml")
  170:  lst = []
  171:  for f in set((defSk, subSk, curSk)):
  172:   if FFCyVu(f):
  173:    lst.append(f)
  174:    lst.extend(FF7YkR(f))
  175:  return list(set(lst))
  176: def FFcFmA():
  177:  lst = []
  178:  for skinF in FF85qp():
  179:   try:
  180:    for ndx, (event, elem) in enumerate(iElem.iterparse(skinF, events=("start", ))):
  181:     if elem.tag == "fonts":
  182:      for fnt in elem.findall("font"):
  183:       name = fnt.get("name", "Regular")
  184:       scale = fnt.get("scale", "100")
  185:       repl = fnt.get("replacement", "")
  186:       fName = fnt.get("filename", "")
  187:       if fName and scale.isdigit():
  188:        if fName.startswith("/"): fPath = fName
  189:        else     : fPath = resolveFilename(SCOPE_FONTS, fName)
  190:        if FFCyVu(fPath): lst.append((name, scale, repl, fName, fPath, skinF))
  191:      break
  192:   except:
  193:    pass
  194:  return lst
  195: def FFNEkd(isSort=True):
  196:  lst = []
  197:  for name, scale, repl, fName, fPath, skinF in FFcFmA():
  198:   lst.append(name)
  199:  curSk = resolveFilename(SCOPE_CURRENT_SKIN, "skin.xml")
  200:  fbFnt = resolveFilename(SCOPE_FONTS, "fallback.font", path_prefix=curSk)
  201:  if FFCyVu(fbFnt): lst.append("Fallback")
  202:  if isSort: return list(set(lst))
  203:  else  : return lst
  204: def FFPaMe(isSort=True):
  205:  lst = []
  206:  try:
  207:   from enigma import getFontFaces
  208:   lst = getFontFaces()
  209:  except:
  210:   try:
  211:    from skin import getFontFaces
  212:    lst = getFontFaces()
  213:   except:
  214:    lst = FFNEkd(isSort)
  215:  if isSort: return list(set(lst))
  216:  else  : return lst
  217: def FFNOP7():
  218:  lst = FFPaMe()
  219:  lst.extend(VVG5aE)
  220:  if lst:
  221:   global VVNhAq
  222:   if VVNj6e in lst and CFG.fontPathMain.getValue(): VVNhAq = VVNj6e
  223:   else               : VVNhAq = VV8nt5
  224:   return sorted(list(set(lst)))
  225:  else:
  226:   return [VV8nt5]
  227: config.plugins.AJPanel = ConfigSubsection()
  228: CFG = config.plugins.AJPanel
  229: CFG.showInMainMenu    = ConfigYesNo(default=False)
  230: CFG.showInExtensionMenu   = ConfigYesNo(default=True)
  231: CFG.showInChannelListMenu  = ConfigYesNo(default=True)
  232: CFG.EventsInfoMenu    = ConfigYesNo(default=True)
  233: CFG.keyboard     = ConfigSelection(default="v", choices=[("v", "Virtual Keyboard"),("s", "System Default")])
  234: CFG.FileManagerExit    = ConfigSelection(default="d", choices=[("d", "Directory Up"),("e", "Exit")])
  235: CFG.hotkey_signal    = ConfigSelection(default="lesc", choices=[("off", "Disable"),("lok", "Long-OK"),("lesc", "Long-Exit"),("lred", "Long-Red")])
  236: CFG.subtDefaultEnc    = ConfigDirectory(default=VV9iuh)
  237: CFG.screenshotFType    = ConfigSelection(default="jpg", choices=[("off", "Disable"),("jpg", "JPG"),("png", "PNG"),("bmp", "BMP")])
  238: CFG.iptvAddToBouquetRefType  = ConfigSelection(default="4097", choices=[("1", "1     (DVB Stream)"),("4097", "4097 (ServiceMp3)"),("5001", "5001 (GST Player)"),("5002", "5002 (Ext-3 EPlayer)"),("8192", "8192 (HDMI input)"),("8193", "8193 (eServiceUri)"),("8793", "8793 (ServiceUrl)")])
  239: CFG.autoResetFrozenIptvChan  = ConfigSelection(default="1", choices=[("off", "Off"),("on+", "Refresh + Notify"),("on", "Silent Refresh")])
  240: CFG.hideIptvServerAdultWords = ConfigYesNo(default=False)
  241: CFG.hideIptvServerChannPrefix = ConfigYesNo(default=False)
  242: CFG.iptvHostsMode    = ConfigDirectory(default=VVSBbs, visible_width=45)
  243: CFG.resumeMovies    = ConfigSelection(default="a", choices=[("off", "Disabled"),("a", "All"),("i", "IPTV Only"),("l", "All (Except IPTV)")])
  244: CFG.MovieDownloadPath   = ConfigDirectory(default="/media/hdd/movie/", visible_width=45)
  245: CFG.portalConnTimeout   = ConfigSelectionNumber(default=2, stepwidth=1, min=1, max=5, wraparound=False)
  246: CFG.PIconsPath     = ConfigDirectory(default=VVTCq1, visible_width=45)
  247: CFG.customMenuPath    = ConfigDirectory(default="/", visible_width=45)
  248: CFG.backupPath     = ConfigDirectory(default="/", visible_width=45)
  249: CFG.iptvHostsDirs    = ConfigText(default="")
  250: CFG.subtitleEventLang   = ConfigSelection(default="o", choices=[("o", "Original"),("s", "English")])
  251: CFG.subtitleFavPath    = ConfigText(default="/")
  252: CFG.favServerPlaylist   = ConfigText(default="")
  253: CFG.favServerPortal    = ConfigText(default="")
  254: CFG.simplePortal    = ConfigYesNo(default=False)
  255: CFG.browserStartPath   = ConfigText(default="/")
  256: CFG.browserBookmarks    = ConfigText(default="/media/,/tmp/,/")
  257: CFG.browserSortMode    = ConfigInteger(default=0, limits=(0, 5))
  258: CFG.browserSortMix    = ConfigYesNo(default=False)
  259: CFG.signalPos     = ConfigInteger(default=5, limits=(1, 9))
  260: CFG.signalSize     = ConfigInteger(default=3, limits=(1, 13))
  261: CFG.mixedColorScheme   = ConfigInteger(default=4, limits=(0, 4))
  262: CFG.checkForUpdateAtStartup  = ConfigYesNo(default=False)
  263: CFG.downloadAutoResume   = ConfigYesNo(default=True)
  264: CFG.downloadMonitor    = ConfigYesNo(default=False)
  265: CFG.lastTerminalCustCmdLineNum = ConfigInteger(default=0)
  266: CFG.lastFileManFindPatt   = ConfigText(default="")
  267: CFG.lastSubtFManFindDir   = ConfigText(default="/media/")
  268: CFG.lastPkgProjDir    = ConfigText(default="/media/")
  269: CFG.lastFeedPkgsDir    = ConfigText(default="/media/")
  270: CFG.lastCustMenuPicDir   = ConfigText(default="")
  271: CFG.lastCustMenuXmlDir   = ConfigText(default="")
  272: CFG.lastCopyMoveDir    = ConfigText(default="")
  273: CFG.lastFindTerminal   = ConfigText(default="")
  274: CFG.lastFindServers    = ConfigText(default="")
  275: CFG.lastFindIptv    = ConfigText(default="")
  276: CFG.lastFindMovie    = ConfigText(default="")
  277: CFG.lastFindSubtitle   = ConfigText(default="")
  278: CFG.lastFindPackages   = ConfigText(default="")
  279: CFG.lastFindServices   = ConfigText(default="")
  280: CFG.lastFindSatName    = ConfigText(default="")
  281: CFG.lastFindContextFind   = ConfigText(default="")
  282: CFG.lastFindEditor    = ConfigText(default="")
  283: CFG.lastFindGeneral    = ConfigText(default="")
  284: CFG.lastFindRepl_fnd   = ConfigText(default="")
  285: CFG.lastFindRepl_rpl   = ConfigText(default="")
  286: CFG.fontPathMain    = ConfigText(default="")
  287: CFG.fontPathTerm    = ConfigText(default="")
  288: CFG.fontPathAdd     = ConfigText(default="")
  289: CFG.fontPathSys     = ConfigText(default="")
  290: CFG.fontScaleSys    = ConfigInteger(default=100)
  291: CFG.fontAllPerc     = ConfigInteger(default=0)
  292: CFG.transpColorPicons   = ConfigText(default="
  293: CFG.transpColorChannels   = ConfigText(default="#88004040")
  294: CFG.epgLangTitle    = ConfigText(default="")
  295: CFG.epgLangDescr    = ConfigText(default="")
  296: CFG.lastFtpLocalPath   = ConfigText(default="")
  297: CFG.lastNetworkDevice   = ConfigInteger(default=0)
  298: CFG.terminalCmdFile    = ConfigText(default="ajpanel_cmd")
  299: CFG.ConfirmTerminalExit   = ConfigYesNo(default=False)
  300: CFG.terminalTextWrap   = ConfigYesNo(default=True)
  301: CFG.terminalFontSizeCmd   = ConfigInteger(default=26, limits=(22, 35))
  302: CFG.terminalFontSizeHist  = ConfigInteger(default=26, limits=(22, 35))
  303: CFG.xmlTvNameCompRatio   = ConfigSelectionNumber(default=50, stepwidth=10, min=40, max=100)
  304: CFG.xmlTvChannelRefFile   = ConfigText(default="")
  305: CFG.wsAutoStart     = ConfigYesNo(default=True)
  306: CFG.wsPort      = ConfigInteger(default=8383)
  307: tmp = [("0", "No Timeout")]
  308: for i in range(3,11): tmp.append((str(i), str(i)))
  309: tmp.extend((("15", "15"), ("20", "20")))
  310: CFG.playerPos     = ConfigInteger(default=0, limits=(0, 1))
  311: CFG.playerJumpMin    = ConfigInteger(default=5, limits=(1, 10))
  312: CFG.playerTimeout     = ConfigSelection(default="0", choices=tmp)
  313: CFG.playerRedBtn    = ConfigSelection(default="e", choices=[("e", "Close Bar & Recall Last DVB Service"),("s", "Show Signal Monitor")])
  314: tmp = [("srt","FROM SRT FILE"),("#00FFFF","Aqua"),("#000000","Black"),("#0000FF","Blue"),("#FF00FF","Fuchsia"),("#808080","Gray"),("#008000","Green"),("#00FF00","Lime"),("#800000","Maroon"),("#000080","Navy"),("#808000","Olive"),("#800080","Purple"),("#FF0000","Red"),("#C0C0C0","Silver"),("#008080","Teal"),("#FFFFFF","White"),("#FFFF00","Yellow")]
  315: CFG.subtBGTransp    = ConfigSelectionNumber(default=100, stepwidth=10, min=0, max=100, wraparound=False)
  316: CFG.subtTextFg     = ConfigSelection(default="#FFFFFF", choices=tmp)
  317: CFG.subtTextFont    = ConfigSelection(default=VVNhAq, choices=[(x,  x) for x in FFNOP7()])
  318: CFG.subtTextSize    = ConfigSelectionNumber(default=50, stepwidth=5, min=30, max=100, wraparound=False)
  319: CFG.subtTextAlign    = ConfigSelection(default="1", choices=[("0", "Left"),("1", "Center"),("2", "Right")])
  320: CFG.subtShadowColor    = ConfigSelection(default="#000080", choices=tmp[1:])
  321: CFG.subtShadowSize    = ConfigSelectionNumber(default=5, stepwidth=1, min=0, max=10, wraparound=False)
  322: CFG.subtVerticalPos    = ConfigSelectionNumber(default=90, stepwidth=1, min=0, max=100, wraparound=False)
  323: CFG.subtDelayMax    = ConfigSelectionNumber(default=10, stepwidth=10, min=10, max=60, wraparound=False)
  324: CFG.subtDelaySec    = ConfigSelectionNumber(default=0, stepwidth=1, min=-CFG.subtDelayMax.getValue() * 60, max=CFG.subtDelayMax.getValue() * 60, wraparound=False)
  325: del tmp
  326: def FFE2vO():
  327:  mode = CFG.mixedColorScheme.getValue()
  328:  if mode == 4:
  329:   if os.path.isfile("/etc/apt/apt.conf"): return 0
  330:   try:
  331:    with open("/etc/issue", "r") as f:
  332:     if iMatch(r"open.*vision", f.read(), IGNORECASE):
  333:      return 1
  334:   except: pass
  335:   return 3
  336:  else:
  337:   return max(min(3, mode), 0)
  338: VVHByN = FFE2vO()
  339: VVo7S9 = VVA4XU = VVYjI5 = VVyFI2 = VVz22H = VVIH76 = VV9nWG = VVMibI = VVSGsk = VVJEMb = VV1fx4 = VVFuwR = VVGCYL = VVZtfx = VVcPtB = VVwdUw = ""
  340: def FFR9If()  : FFonTy(FF5V4z())
  341: def FFNKC6()  : FFonTy(FFBcJb())
  342: def FFNXJk(tDict): FFonTy(jDumps(tDict, indent=4, sort_keys=True))
  343: def FFEcpq(*args): FFNX0y(1, 1,  *args)
  344: def FFonTy(*args) : FFNX0y(1 ,0,  *args)
  345: def FFU8n7(*args): FFNX0y(0, 0,  *args)
  346: def FFNX0y(addSep=1, isArray=1, *args):
  347:  if not VVNA43: return
  348:  sep = (">>>> %s\n" % ("#" * 80)) if addSep else ""
  349:  txt = sep
  350:  if isArray:
  351:   for item in args:
  352:    if type(item) in (list, tuple, set):
  353:     txt += ">>>> --> LIST START <--\n"
  354:     for itm in item: txt += ".... %s\n" % str(itm)
  355:     txt += ">>>> --> LIST END <--\n"
  356:    elif isinstance(item, dict):
  357:     txt += ">>>> LIST START <--\n"
  358:     Len = 0
  359:     for key, val in item.items(): Len = max(Len, len(str(key)))
  360:     for key, val in item.items(): txt += ".... %s: %s\n" % (str(str(key).ljust(Len)), str(val))
  361:     txt += ">>>> LIST END <--\n"
  362:    else:
  363:     txt += "---> %s\n" % str(item)
  364:  else:
  365:   cr = "\n" if addSep else ""
  366:   txt += ">>>> %s%s" % (" , ".join(list(map(str, args))), cr)
  367:  txt += sep.replace("#", "-")
  368:  os.system("cat << '_EOF' \n" + str(txt) + "\n_EOF")
  369: def FFdDxT(fnc):
  370:  def VVuE0i(*args, **kwargs):
  371:   t1 = iTime()
  372:   fnc(*args, **kwargs)
  373:   FFonTy(">>>>>> Elapsed : %s sec\nargs = %s\nkwargs = %s" % (("%.6f" % (iTime() - t1)).rstrip("0"), args, kwargs))
  374:  return VVuE0i
  375: def FFGlWm(*args):
  376:  t = "[%s] %s >> %s" % (VVh9hj, datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f'), " , ".join(list(map(str, args))))
  377:  os.system("cat << '_EOF' \n%s\n_EOF" % t)
  378: def FFA8G3(*args):
  379:  with open("/tmp/ajpanel_log.txt", "a") as f:
  380:   t =  datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')
  381:   f.write("%s %s\n" % (t, " , ".join(list(map(str, args)))))
  382: def FFllYj(tDict): FFH9VS(jDumps(tDict, indent=4, sort_keys=True))
  383: def FFH9VS(*args):
  384:  if not VVNA43: return
  385:  path = "/tmp/ajp_log.txt"
  386:  with open(path, "a") as f:
  387:   f.write(">>>> %s\n" % (" , ".join(list(map(str, args)))))
  388:  FFU8n7("Added to : %s" % path)
  389: def FFLUsX(txt, isAppend=True, ignoreErr=False):
  390:  if not VVNA43: return
  391:  tm = FFRvLH()
  392:  err = "" if not ignoreErr else FFBcJb()
  393:  fileName = "/tmp/ajp_log.txt"
  394:  with open(fileName, "a" if isAppend else "w") as f:
  395:   if err: f.write(err)
  396:   f.write("%s >> %s\n" % (tm, str(txt)))
  397:  if err: FFonTy(err)
  398:  FFonTy("Output Log File : %s" % fileName)
  399: def FFBcJb():
  400:  try:
  401:   from traceback import format_exc, format_stack
  402:   trace = format_exc()
  403:   if trace and len(trace) > 5:
  404:    tm = FFRvLH()
  405:    stack = format_stack()[:-1]
  406:    sep = "*" * 70
  407:    err = "\n%s\n*** %s\n%s\n\n" % (sep, tm, sep)
  408:    err += "%s\n\n%s\n%s\n" % ("".join(stack), trace, sep)
  409:    return err
  410:  except:
  411:   return "Cannot Trace !"
  412: def FF5V4z():
  413:  import inspect
  414:  lst = []
  415:  for ndx, f in enumerate(inspect.stack()):
  416:   if ndx > 0:
  417:    lst.append("%s\t>> %s" % (os.path.basename(f[1]).ljust(20), f[3]))
  418:  return "Last Fncs:\n" + "\n".join(lst)
  419: VVNXcy = 0
  420: def FFUNbz():
  421:  global VVNXcy
  422:  VVNXcy = iTime()
  423: def FFp2S4(txt=""):
  424:  FFonTy(">>>>>> Elapsed : %s sec\t%s" % (("%.6f" % (iTime() - VVNXcy)).rstrip("0"), txt))
  425: def FFlpqQ(*args):
  426:  for arg in args:
  427:   if VVh9hj[:5].lower() in os.path.basename(arg).lower():
  428:    return True
  429:  return False
  430: def FFPCZY(SELF, keep=""):
  431:  lst = []
  432:  try:
  433:   for w in SELF.session.dialog_stack[::-1]:
  434:    w = w[0]
  435:    if keep and keep in str(w): break
  436:    elif "Plugins.Extensions.AJPan." in str(w): lst.append(w)
  437:  except:
  438:   pass
  439:  return lst
  440: def FFHxAC(SELF):  FFWCqk(SELF, "")
  441: def FF8lJ1(*args): FFWCqk(args[0], ".CC6cFV")
  442: def FFWCqk(SELF, keep):
  443:  SELF.close()
  444:  for w in FFPCZY(SELF, keep):
  445:   try: w.close()
  446:   except: pass
  447: def FFYDZ6(vTxt):
  448:  if vTxt in globals(): del globals()[vTxt]
  449: def FFXpOB():
  450:  BT_SCALE = BT_KEEP_ASPECT_RATIO = None
  451:  try:
  452:   from enigma import BT_SCALE, BT_KEEP_ASPECT_RATIO
  453:  except:
  454:   try  : from enigma import BT_SCALE, BT_FIXRATIO as BT_KEEP_ASPECT_RATIO
  455:   except : pass
  456:  if BT_SCALE and BT_KEEP_ASPECT_RATIO: return BT_SCALE | BT_KEEP_ASPECT_RATIO
  457:  else        : return None
  458: VVGpHg = FFXpOB()
  459: def getDescriptor(fnc, where, name, descr="", needsRestart=False):
  460:  w = getDesktop(0).size().width()
  461:  if w and w < 1920 : icon="icon.png"
  462:  else    : icon="iconhd.png"
  463:  if name == VVh9hj:
  464:   descr = VVzOp7
  465:  else:
  466:   if not descr:
  467:    descr = "%s %s" % (VVh9hj, name or VVzOp7)
  468:   name = "AJ - %s" % name
  469:  return PluginDescriptor(fnc=fnc, where=where, needsRestart=needsRestart, name=name, description=descr, icon=icon)
  470: def FFsfSz()  : return getDescriptor(FFPyES , [ PluginDescriptor.WHERE_EXTENSIONSMENU ], "File Manager")
  471: def FFttL1() : return getDescriptor(FFNt2R  , [ PluginDescriptor.WHERE_EXTENSIONSMENU ], "IPTV Menu")
  472: def FF2V0Y()  : return getDescriptor(FFuMiy   , [ PluginDescriptor.WHERE_EXTENSIONSMENU ], "Movies Resume History")
  473: def FF2aef()  : return getDescriptor(FFCORE  , [ PluginDescriptor.WHERE_EXTENSIONSMENU ], "Player Bar")
  474: def FFQRKB(): return getDescriptor(FFdgj8, [ PluginDescriptor.WHERE_EXTENSIONSMENU ], "Plugin Browser")
  475: def FFT9Fx()  : return getDescriptor(FFFp5I   , [ PluginDescriptor.WHERE_EXTENSIONSMENU ], "Signal Monitor")
  476: def FFYbQt() : return getDescriptor(FFhx52  , [ PluginDescriptor.WHERE_EXTENSIONSMENU ], "Terminal")
  477: def FFpUEE() : return getDescriptor(FFLedO  , [ PluginDescriptor.WHERE_EXTENSIONSMENU ], CCRlkm.VVazeJ())
  478: def FFxu4x()      : return getDescriptor(FF9dNV , [ PluginDescriptor.WHERE_EVENTINFO  ], "Service Information")
  479: def Plugins(**kwargs):
  480:  lst = [ getDescriptor(FFtmfS , [PluginDescriptor.WHERE_PLUGINMENU], VVh9hj, needsRestart=True)
  481:   ,   getDescriptor(FFsQm4 , [PluginDescriptor.WHERE_MENU]   , VVh9hj)
  482:   ,   PluginDescriptor(fnc=FFTqiW, where=[PluginDescriptor.WHERE_SESSIONSTART], needsRestart=True, description="AJPanel Startup")
  483:   ]
  484:  if CFG.showInExtensionMenu.getValue():
  485:   lst.append(FFsfSz())
  486:   lst.append(FFttL1())
  487:   lst.append(FF2aef())
  488:   lst.append(FFQRKB())
  489:   lst.append(FFT9Fx())
  490:   lst.append(FFYbQt())
  491:   lst.append(FFpUEE())
  492:   lst.append(FF2V0Y())
  493:  if CFG.EventsInfoMenu.getValue():
  494:   lst.append(FFxu4x())
  495:  return lst
  496: def FFTqiW(reason, **kwargs):
  497:  if reason == 0:
  498:   FFzcnD()
  499:   CC9hzi.VV3xGy()
  500:   CC6cFV.VVAeob()
  501:   if "session" in kwargs:
  502:    session = kwargs["session"]
  503:    FFBJ7Q(session)
  504:    CCo1b7(session)
  505:    if CFG.wsAutoStart.getValue():
  506:     CCMTfv(session).VVeTpx(True)
  507: def FFsQm4(menuid, **kwargs):
  508:  if menuid == "mainmenu" and CFG.showInMainMenu.getValue():
  509:   return [(VVh9hj, FFtmfS, VVh9hj, 1)]
  510:  else:
  511:   return []
  512: def FFtmfS(session, **kwargs):
  513:  session.open(CC6cFV)
  514: def FFPyES(session, **kwargs) : session.open(CClYaF)
  515: def FFNt2R(session, **kwargs)  : session.open(CCkEI5)
  516: def FFuMiy(session, **kwargs)    : session.open(CC6F0F)
  517: def FFCORE(session, **kwargs)  : CCqWM2.VVHc02(session, VV1rS5=2)
  518: def FFdgj8(session, **kwargs): CCFZr4.VVsCNi(session)
  519: def FFFp5I(session, **kwargs)   : FFdXBl(session, reopen=True)
  520: def FFhx52(session, **kwargs)  : session.open(CCtzVm)
  521: def FFLedO(session, **kwargs)  : CCRlkm.VVEYRT(session, True)
  522: def FF9dNV(session, **kwargs):
  523:  CCvjVs.VVUxTg(session)
  524: def FFBJ7Q(session):
  525:  hk = None
  526:  dm = FFgrjX()
  527:  if dm:
  528:   try:
  529:    from keymapparser import readKeymap
  530:    readKeymap(VV231J + "keymap.xml")
  531:    from GlobalActions import globalActionMap as hk
  532:   except:
  533:    pass
  534:  else:
  535:   cont = ["KeyMap_HK"]
  536:   try: hk = ActionMap(contexts=cont, prio=1, parentScreen=session.screen)
  537:   except: hk = ActionMap(contexts=cont, prio=0 if CC674y.VV1LWx() else 1)
  538:   hk.execBegin()
  539:  if hk:
  540:   hk.actions["longOK"] = BF(FFmlMt, session, "lok")
  541:   hk.actions["longCancel"]= BF(FFmlMt, session, "lesc")
  542:   hk.actions["longRed"] = BF(FFmlMt, session, "lred")
  543:   for k in (CC6u6z.VVjbK6, CC6u6z.VVOdU6, CC6u6z.VV9Iya):
  544:    hk.actions[k] = BF(CC6u6z.VVTqPs, session, k, dm)
  545: def FFmlMt(session, key):
  546:  if CC6u6z.VVgrEx(session) or CFG.hotkey_signal.getValue() != key:
  547:   return
  548:  try:
  549:   if CCtKqU.VV0DI2:
  550:    CCtKqU.VV0DI2.close()
  551:   if not CCqWM2.VVyLCv:
  552:    CCqWM2.VVHc02(session, VV1rS5=1)
  553:  except:
  554:   pass
  555: def FFjt1c(confItem, val):
  556:  confItem.setValue(val)
  557:  confItem.save()
  558:  configfile.save()
  559: def FFI3NO(confItem):
  560:  if isinstance(confItem, ConfigSelectionNumber):
  561:   if confItem.saved_value is None and str(confItem.value) == str(confItem.default):
  562:    return False
  563:   return str(confItem.value) != str(confItem.saved_value)
  564:  else:
  565:   return confItem.isChanged()
  566: def FFZMxC(SELF, title="", addLabel=False, addScrollLabel=False, VV3wat=None, addCloser=False):
  567:  Screen.__init__(SELF, SELF.session)
  568:  if title: title = "  %s  " % title
  569:  else : title = "" if SELF.VVfOli["VVON3k"] == VVlrZA else FFGNZA()
  570:  SELF["myTitle"] = Label(title)
  571:  SELF["myBody"] = Label()
  572:  SELF["myWP"] = Pixmap()
  573:  SELF["myInfoFrame"] = Label()
  574:  SELF["myInfoBody"] = Label()
  575:  SELF.VV0bxL = eTimer()
  576:  try: SELF.VVYnJH = SELF.VV0bxL.timeout.connect(BF(FFxjE5, SELF))
  577:  except: SELF.VV0bxL.callback.append(BF(FFxjE5, SELF))
  578:  SELF.onClose.append(SELF.VV0bxL.stop)
  579:  FFxjE5(SELF)
  580:  btnMode = SELF.VVfOli["VV0Ay7"]
  581:  if btnMode in (1, 2): SELF["keyMenu"] = Pixmap()
  582:  if btnMode in (2, 3): SELF["keyInfo"] = Pixmap()
  583:  if SELF.VVfOli["VVeFSs"] > 0:
  584:   SELF["myBar"]  = Label()
  585:   SELF["myLine"]  = Label()
  586:   SELF["keyRed"]  = Label()
  587:   SELF["keyGreen"] = Label()
  588:   SELF["keyYellow"] = Label()
  589:   SELF["keyBlue"]  = Label()
  590:   SELF["keyRed"].hide()
  591:   SELF["keyGreen"].hide()
  592:   SELF["keyYellow"].hide()
  593:   SELF["keyBlue"].hide()
  594:  if addLabel:
  595:   SELF["myLabel"] = Label()
  596:  if addScrollLabel:
  597:   SELF["myLabel"] = CCyjWK(SELF)
  598:  if VV3wat:
  599:   SELF["myMenu"] = MenuList(VV3wat, True)
  600:   FFHlAU(SELF,
  601:   {
  602:    "ok" : SELF.VVPr1F ,
  603:    "cancel": SELF.close ,
  604:   })
  605:  if addCloser:
  606:   FFHlAU(SELF,
  607:   {
  608:    "ok" : SELF.close,
  609:    "cancel": SELF.close,
  610:    "red" : SELF.close
  611:   })
  612: def FFHlAU(SELF, tDict, name="", prio=-1):
  613:  name = name or "myActionMap"
  614:  try: SELF[name] = ActionMap(contexts=VVzu3t, actions=tDict, prio=prio, parentScreen=SELF.session.screen)
  615:  except: SELF[name] = ActionMap(contexts=VVzu3t, actions=tDict, prio=prio)
  616: def FFBep1(SELF, tDict, name=""):
  617:  SELF[name or "myActionMap"].actions.update(tDict)
  618: def FFDuEn(SELF, name=""):
  619:  SELF[name or "myActionMap"].actions.clear()
  620: def FFGNZA():
  621:  return ("  %s" % VV3knk)
  622: def FFTmHZ(SELF):
  623:  global VV3knk
  624:  VV3knk = SELF["myMenu"].l.getCurrentSelection()[0]
  625:  return SELF["myMenu"].l.getCurrentSelection()[1]
  626: def FFRLNq(btn, txt):
  627:  btn.setText(txt)
  628:  if txt : btn.show()
  629:  else : btn.hide()
  630: def FFzBfi(txt):
  631:  if r"\c" in txt:
  632:   txt = iSub(r"\\c(.){8}" ,"" , txt, flags=IGNORECASE)
  633:  return txt
  634: def FFd1WZ(txt):
  635:  while txt.startswith(("
  636:   txt = txt[12:]
  637:  return txt
  638: def FFRUST(color):
  639:  return parseColor(color).argb()
  640: def FFGUI5(obj, fg): FF7hy1(obj, fg, "", inv=True)
  641: def FFZ0AC(obj, bg): FF7hy1(obj, "", bg, inv=True)
  642: def FF7hy1(obj, fg, bg, inv=True):
  643:  if fg: obj.instance.setForegroundColor(parseColor(fg))
  644:  if bg: obj.instance.setBackgroundColor(parseColor(bg))
  645:  if inv: obj.instance.invalidate()
  646: def FFSPDv(txt, color):
  647:  if color:
  648:   if "/" in txt: txt = txt.replace("/", r"\/")
  649:   return r" | sed 's/%s/\\%s&\%s/gI'" % (txt, color, VVwdUw)
  650:  else:
  651:   return ""
  652: def FFGTFw(word, color):
  653:  if color: return r"echo -e '\%s%s\n--- %s\n%s\%s';" % (color, SEP, word, SEP, VVwdUw)
  654:  else : return r"echo -e '%s\n--- %s\n%s';" % (SEP, word, SEP)
  655: def FFjt5L(word, color, backToColor=None):
  656:  if backToColor : return color + str(word) + backToColor
  657:  else   : return color + str(word) + VVwdUw
  658: def FFyiTS(color):
  659:  if color: return "echo -e '%s' %s;" % (SEP, FFSPDv(SEP, VV1fx4))
  660:  else : return "echo -e '%s';" % SEP
  661: def FFGEAF(title, color):
  662:  title = "%s\n%s\n%s\n" % (SEP, title, SEP)
  663:  return FFjt5L(title, color)
  664: def FF4IPF(menuObj, fg="#00ffffff", bg="#08005555"):
  665:  menuObj.instance.setForegroundColorSelected(parseColor(fg))
  666:  menuObj.instance.setBackgroundColorSelected(parseColor(bg))
  667: def FFIElK(fncCB):
  668:  FF4iwG(":", BF(FFmfNh, fncCB))
  669: def FFmfNh(fncCB, result, retval):
  670:  fncCB()
  671: def FFOKt0(SELF, delay, fnc):
  672:  SELF.timedFncTimer = eTimer()
  673:  try: SELF.timedFncTimer_conn = SELF.timedFncTimer.timeout.connect(fnc)
  674:  except: SELF.timedFncTimer.callback.append(fnc)
  675:  SELF.timedFncTimer.start(delay, True)
  676: def FFimQ3(SELF, fnc, title="Processing ...", clearMsg=True):
  677:  FF28n1(SELF, title)
  678:  FF4iwG(":", BF(FFqMON, SELF, fnc, clearMsg))
  679: def FFqMON(SELF, fnc, clearMsg, result, retval):
  680:  fnc()
  681:  if clearMsg:
  682:   FF28n1(SELF)
  683: def FF2JFr(session, fnc, title="Processing ..."):
  684:  session.open(CCtm4v, fnc, title)
  685: def FFOAKH(title="Processing ...", clearMsg=True, par=0, tNdx=-1):
  686:  def VV7A8E(fnc):
  687:   def VVuE0i(*args, **kwargs):
  688:    FFimQ3(args[par], BF(fnc, *args, **kwargs), args[tNdx] if tNdx > -1 else title, clearMsg)
  689:   return VVuE0i
  690:  return VV7A8E
  691: def FFQ45w(cmd):
  692:  from subprocess import Popen, PIPE
  693:  try:
  694:   process = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE, universal_newlines=True, shell=True)
  695:   stdout, stderr = process.communicate()
  696:   stdout = stdout.strip()
  697:   stderr = stderr.strip()
  698:   if stderr : return stderr
  699:   else  : return stdout
  700:  except Exception as e:
  701:   if "memory" in str(e).lower(): return VVfDY7
  702:   else       : return ""
  703: def FF3xOt(cmd, trim=True):
  704:  lst = FFQ45w(cmd).splitlines()
  705:  if trim : return list(map(str.strip, lst))
  706:  else : return lst
  707: def FFTKR0(cmd):
  708:  lines = FF3xOt(cmd)
  709:  if lines: return lines[0]
  710:  else : return ""
  711: def FFycDu(cmd):
  712:  tFile = "/tmp/ajp_lines"
  713:  FFwgGB(tFile)
  714:  FFQ45w("%s > %s" % (cmd, tFile))
  715:  lst = FFL19l(tFile)
  716:  FFwgGB(tFile)
  717:  return lst
  718: def FF4iwG(cmd, cbFnc):
  719:  global VVAVHg
  720:  VVAVHg = CCaTk8()
  721:  VVAVHg.VVtIZD(cmd, cbFnc)
  722: def FFpwZS(cmd):
  723:  return os.system(FFb2oQ(cmd)) == 0
  724: def FF7ymp(cmd):
  725:  return os.system(FFMdhJ(cmd)) == 0
  726: def FFb2oQ(cmd)  : return cmd.rstrip("\t; ") + " > /dev/null 2>&1;"
  727: def FFMdhJ(cmd) : return cmd.rstrip("\t; ") + " 2> /dev/null;"
  728: def FFZQVC(    SELF, cmd, **kwargs): SELF.session.open(CCp90q, VVmbsE=cmd, VVgoZo=True, VV47Xm=VV5jA8, **kwargs)
  729: def FFIdSm(  SELF, cmd, **kwargs): SELF.session.open(CCp90q, VVmbsE=cmd, **kwargs)
  730: def FFXD60(   SELF, cmd, **kwargs): SELF.session.open(CCp90q, VVmbsE=cmd, VVB4JK=True, VVS7yC=True, VV47Xm=VV5jA8, **kwargs)
  731: def FFiOUV(  SELF, cmd, **kwargs): SELF.session.open(CCp90q, VVmbsE=cmd, VVB4JK=True, VVS7yC=True, VV47Xm=VVYAtm, **kwargs)
  732: def FFbi5l(  SELF, cmd, **kwargs): SELF.session.open(CCp90q, VVmbsE=cmd, VV4naX=True , **kwargs)
  733: def FF7yGJ(  session, cmd, **kwargs):      session.open(CCp90q, VVmbsE=cmd, VV4naX=True , **kwargs)
  734: def FF28Zd( SELF, cmd, **kwargs): SELF.session.open(CCp90q, VVmbsE=cmd, VVIk01=True  , **kwargs)
  735: def FFayeZ(cmd):
  736:  return FFpwZS("which %s" % cmd)
  737: def FFmCnY(cmd):
  738:  if FFayeZ(cmd): return True, "BusyBox" in FFQ45w("%s --help" % cmd)
  739:  else   : return False, False
  740: def FFUaC8():
  741:  cmd = "if [ -f /etc/apt/apt.conf ]; then echo dpkg; else if [ -f /etc/opkg/opkg.conf ]; then echo opkg; else if which dpkg; then echo dpkg; else if which opkg; then echo opkg; else if which ipkg; then echo ipkg; else echo ''; fi; fi; fi; fi; fi"
  742:  return FFTKR0(cmd)
  743: def FFgrjX():
  744:  return FFCyVu("/etc/apt/apt.conf")
  745: def FF5W9s(mode, moreDirs=None):
  746:  if mode == 0:
  747:   dirs = [ "*boot*", "*/ba", "/proc" ]
  748:  else:
  749:   dirs = [  "*boot*"
  750:     , "*picon*"
  751:     , "*/ba"
  752:     , "/bin"
  753:     , "/dev"
  754:     , "/hdd"
  755:     , "/lib"
  756:     , "/linuxrc"
  757:     , "/mnt"
  758:     , "/newroot"
  759:     , "/proc"
  760:     , "/run"
  761:     , "/sbin"
  762:     , "/sys"
  763:     , "/usr"
  764:     ]
  765:  if moreDirs:
  766:   dirs.extend(moreDirs)
  767:  paths = []
  768:  for item in dirs:
  769:   paths.append("-ipath '%s'" % item)
  770:  txt = " -o ".join(paths)
  771:  return r"-type d \( %s \) -prune -o " % txt
  772: VVaNvq     = 0
  773: VVZDGE      = 1
  774: VVaS8u      = 2
  775: VVjZ1L      = 3
  776: VV0RRE     = 4
  777: VVUty9     = 5
  778: VVwFAi     = 6
  779: VVj9MD = 7
  780: VVD9EU = 8
  781: VVRA2G = 9
  782: VVA8Es  = 10
  783: VVAdjB     = 11
  784: VV9Fg4  = 12
  785: VVYJEp  = 13
  786: VVofV3      = 14
  787: VVw6qo     = 15
  788: def FFoY7E(parmNum, grepTxt=""):
  789:  if   parmNum == VVaNvq: param = ["update" , "apt-get update" ]
  790:  elif parmNum == VVZDGE : param = ["list" , "apt list"  ]
  791:  pkg = FFUaC8()
  792:  if   pkg in ("ipkg", "opkg"): return "%s %s %s" % (pkg, param[0], grepTxt)
  793:  elif pkg == "dpkg"   : return "%s %s" % (param[1]  , grepTxt)
  794:  return ""
  795: def FF5sZa(mode, package):
  796:  if   mode == VVaS8u      : param = ["info"      , "apt show"]
  797:  elif mode == VVjZ1L     : param = ["files"      , "dpkg -L"]
  798:  elif mode == VV0RRE     : param = ["search"      , "dpkg -S"]
  799:  elif mode == VVUty9     : param = ["download"     , "apt-get download"]
  800:  elif mode == VVwFAi     : param = ["install"     , "apt-get install -y"]
  801:  elif mode == VVj9MD : param = ["install --force-reinstall" , "apt-get install --reinstall -y"]
  802:  elif mode == VVD9EU : param = ["install --force-overwrite" , "dpkg -i --force-all"]
  803:  elif mode == VVRA2G : param = ["install --force-downgrade" , "apt-get install --allow-downgrades -y"]
  804:  elif mode == VVA8Es : param = ["install --force-depends" , "apt-get install --no-install-recommends -y"]
  805:  elif mode == VVAdjB     : param = ["remove"      , "apt-get purge --auto-remove -y"]
  806:  elif mode == VV9Fg4  : param = ["remove --force-remove"  , "dpkg --purge --force-all"]
  807:  elif mode == VVYJEp : param = ["remove --force-depends"  , "dpkg --remove --force-depends"]
  808:  elif mode == VVofV3      : param = ["flag hold"     , "apt-mark hold"]
  809:  elif mode == VVw6qo     : param = ["flag user"     , "apt-mark unhold"]
  810:  else           : return ""
  811:  if package:
  812:   package = "'%s'" % package
  813:  pkg = FFUaC8()
  814:  if   pkg in ("ipkg", "opkg"): return "%s %s %s" % (pkg, param[0], package)
  815:  elif pkg == "dpkg"   : return "%s %s" % (param[1], package)
  816: def FFvQ9y():
  817:  result = FFTKR0("ar -V 2> /dev/null | grep 'GNU ar'")
  818:  if result.startswith("GNU ar"):
  819:   cmd = " allOK='1';"
  820:  else:
  821:   notFoundCmd = " echo -e 'GNU \"ar\" command not found!';"
  822:   installCmd = FF5sZa(VVwFAi, "")
  823:   if installCmd:
  824:    verCmd = "FOUND=$(ar -V 2> /dev/null | grep 'GNU ar');"
  825:    failed1 = "Please update your software or manually install \"ar\" command and try again."
  826:    failed2 = "(\"ar\" is available in the packages : \"opkg-tools\" or \"binutils\")"
  827:    failed3 = "Process Failed."
  828:    cmd  = " allOK='0';"
  829:    cmd += verCmd
  830:    cmd += 'if [[ -z "$FOUND" ]]; then '
  831:    cmd +=   notFoundCmd
  832:    cmd += "  echo -e 'Trying to install \"opkg-Tools\" ...';"
  833:    cmd +=    FFb2oQ("%s enigma2-plugin-extensions-opkg-tools" % installCmd)
  834:    cmd +=   verCmd
  835:    cmd += ' if [[ -z "$FOUND" ]]; then '
  836:    cmd += " echo -e 'Trying to install \"binutils\" ...';"
  837:    cmd +=   FFb2oQ("%s binutils" % installCmd)
  838:    cmd += " fi;"
  839:    cmd +=   verCmd
  840:    cmd += ' if [[ -z "$FOUND" ]]; then '
  841:    cmd += "  echo -e 'Installation failed !';"
  842:    cmd += "  echo -e '%s' %s;"  % (failed1, FFSPDv(failed1, VV1fx4))
  843:    cmd += "  echo -e '%s' %s;"  % (failed2, FFSPDv(failed2, VV1fx4))
  844:    cmd += "  echo -e '\n%s' %s;" % (failed3, FFSPDv(failed3, VVYjI5))
  845:    cmd += " else"
  846:    cmd += "  echo -e 'Installed successfully.';"
  847:    cmd += "  allOK='1';"
  848:    cmd += " fi;"
  849:    cmd += "else"
  850:    cmd += "  allOK='1';"
  851:    cmd += "fi;"
  852:   else:
  853:    cmd = " allOK='0';"
  854:    cmd += notFoundCmd
  855:  return cmd
  856: def FFMAzK(commandTool, toolPkgName, displayedName):
  857:  cmd1 = ""
  858:  installCmd = FF5sZa(VVwFAi , "")
  859:  if installCmd:
  860:   failed1 = "Please update your software and try again."
  861:   failed2 = "Process Failed."
  862:   cmd1 += " echo -e '%s not found.';" % displayedName
  863:   cmd1 += " echo -e 'Trying to install ...';"
  864:   cmd1 +=   FFb2oQ("%s %s" % (installCmd, toolPkgName))
  865:   cmd1 += " FOUND=$(which  %s);"  % commandTool
  866:   cmd1 += ' if [[ -z "$FOUND" ]]; then '
  867:   cmd1 += "  echo -e 'Installation failed !';"
  868:   cmd1 += "  echo -e '%s\n' %s;" % (failed1, FFSPDv(failed1, VV1fx4))
  869:   cmd1 += "  echo -e '%s' %s;" % (failed2, FFSPDv(failed2, VVYjI5))
  870:   cmd1 += " else"
  871:   cmd1 += "  echo -e 'Installed successfully.';"
  872:   cmd1 += "  allOK='1';"
  873:   cmd1 += " fi;"
  874:  else:
  875:   cmd1 += " echo -e '%s not found.';" % displayedName
  876:  cmd  = " allOK='0';"
  877:  cmd += "FOUND=$(which %s);" % commandTool
  878:  cmd += 'if [[ -z "$FOUND" ]]; then '
  879:  cmd +=   cmd1
  880:  cmd += "else"
  881:  cmd += "  allOK='1';"
  882:  cmd += "fi;"
  883:  return cmd
  884: def FFKbNE():
  885:  pFound, pBBox = FFmCnY("xz")
  886:  if pFound:
  887:   if pBBox:
  888:    failed1 = "Please update your software and try again."
  889:    failed2 = "Process Failed."
  890:    cmd  = " allOK='0';"
  891:    cmd += "echo -e 'Found BusyBox xz';"
  892:    cmd += "echo -e 'Upgrading xz ...';"
  893:    cmd +=  FFb2oQ("%s" % FF5sZa(VVwFAi , "xz"))
  894:    cmd += "if [ $? -eq 0 ]; then"
  895:    cmd += " echo -e 'Installed successfully.';"
  896:    cmd += " allOK='1';"
  897:    cmd += "else"
  898:    cmd += " echo -e 'Installation failed !';"
  899:    cmd += " echo -e '%s' %s;" % (failed1, FFSPDv(failed1, VV1fx4))
  900:    cmd += " echo -e '\n\n%s' %s;" % (failed2, FFSPDv(failed2, VVYjI5))
  901:    cmd += "fi;"
  902:    return cmd
  903:   else:
  904:    return " allOK='1';"
  905:  else:
  906:   return FFMAzK("xz", "xz", "XZ")
  907: def FFYVq0(path, maxSize=-1, encLst=None):
  908:  if   encLst is None    : encLst = CC7ocD.VVmFe6()
  909:  elif isinstance(encLst, str) : encLst = [encLst]
  910:  txt = ""
  911:  for enc in encLst:
  912:   try:
  913:    with ioOpen(path, "r", encoding=enc) as f:
  914:     txt = f.read(maxSize)
  915:     txt = str(txt)
  916:    break
  917:   except:
  918:    pass
  919:  if txt.startswith(chr(239) + chr(187) + chr(191)):
  920:   txt = txt[3:]
  921:  return txt
  922: def FFL19l(path, keepends=False, maxSize=-1, encLst=None):
  923:  txt = FFYVq0(path, maxSize, encLst=encLst)
  924:  return txt.splitlines(keepends)
  925: def FFaOUK(SELF, path, encLst=None):
  926:  title = os.path.basename(path)
  927:  if FFCyVu(path):
  928:   maxSize = 60000
  929:   if (FFXhoc(path) > maxSize):
  930:    title="File too big (showing first 60kB only)"
  931:   else:
  932:    maxSize = -1
  933:   lines = FFYVq0(path, maxSize=maxSize, encLst=encLst)
  934:   if lines: FF4lCP(SELF, lines, title=title, VV47Xm=VV5jA8, width=1600, height=1000, VVllEU=30, resize=False)
  935:   else : FFNICS(SELF, path, title=title)
  936:  else:
  937:   FF8Wsn(SELF, path, title)
  938: def FFw2rR(SELF, fName, title):
  939:  path = VVIp2p + fName
  940:  if FFCyVu(path):
  941:   txt = FFYVq0(path)
  942:   for k, v in {"#W#":VVwdUw,"#Y#":VVFuwR,"#G#":VVA4XU,"#Gn#":VVSGsk,"#C#":VVZtfx,"#P#":VVz22H}.items():
  943:    txt = txt.replace(k, v)
  944:   FF4lCP(SELF, txt, title=title, width=1600)
  945:  else:
  946:   FF8Wsn(SELF, path, title)
  947: def FFkES0(path):
  948:  if VVmJwX(path):
  949:   tList = os.listdir(path)
  950:   if tList:
  951:    dirs = []
  952:    for item in tList:
  953:     if os.path.isdir(path + item):
  954:      dirs.append(item)
  955:    if dirs:
  956:     dirs.sort()
  957:     return dirs
  958:  return []
  959: def FFx9pN(path, addTrailingSlash):
  960:  parent = os.path.abspath(os.path.join(path, os.pardir))
  961:  if addTrailingSlash : return FFoWxR(parent)
  962:  else    : return FFVc4H(parent)
  963: def FFxtW5(path):
  964:  return os.path.basename(os.path.normpath(path))
  965: def FFENxa(path):
  966:  try:
  967:   os.mkdir(path)
  968:   return "" if VVmJwX(path) else "Cannot create dir !"
  969:  except Exception as e:
  970:   return str(e)
  971: def FFXhoc(path):
  972:  try:
  973:   if os.path.islink(FFVc4H(path)): return os.lstat(path).st_size
  974:   elif os.path.isfile(path)    : return os.path.getsize(path)
  975:  except:
  976:   pass
  977:  return -1
  978: def FFTWKU(path):
  979:  p = FFVc4H(path)
  980:  if   os.path.islink(p) : return "SymLink"
  981:  elif os.path.ismount(p) : return "Mount"
  982:  elif os.path.isfile(p) : return "File"
  983:  elif os.path.isdir(p) : return "Directory"
  984:  else     : return ""
  985: def FF4oMa(path):
  986:  size = 0
  987:  for Dir, dirs, files in os.walk(path):
  988:   files = os.listdir(Dir)
  989:   for f in files:
  990:    fp = os.path.join(Dir, f)
  991:    try:
  992:     if os.path.islink(FFVc4H(fp)) : size += os.lstat(fp).st_size
  993:     elif os.path.isfile(fp)     : size += os.path.getsize(fp)
  994:    except:
  995:     pass
  996:  return size
  997: def FFK6he(path):
  998:  totDir = totFile = totLink = 0
  999:  for Dir, dirs, files in os.walk(path):
 1000:   files = os.listdir(Dir)
 1001:   for f in files:
 1002:    fp = os.path.join(Dir, f)
 1003:    if os.path.islink(FFVc4H(fp)) : totLink += 1
 1004:    elif os.path.isfile(fp)     : totFile += 1
 1005:    else         : totDir += 1
 1006:  return totDir, totFile, totLink
 1007: def FFwgGB(path):
 1008:  try: os.remove(path)
 1009:  except: pass
 1010: def FFVyW4(path):
 1011:  try: rmtree(path)
 1012:  except: pass
 1013: def FFOzbr(path):
 1014:  FFpwZS("chattr -AacDdijsStu '%s' &> /dev/null; rm -fr '%s'" % (path, path))
 1015:  FFwgGB(path)
 1016:  FFVyW4(path)
 1017: def FFIFeD():
 1018:  FFpwZS("rm -rf /tmp/ajp_*")
 1019: def FFJvhj(path):
 1020:  with open(path, "rb+") as f:
 1021:   try:
 1022:    f.seek(-1, 2)
 1023:    if ord(f.read(1)) not in (10, 13):
 1024:     f.write(b"\n")
 1025:   except:
 1026:    pass
 1027: def FFj2hO(path):
 1028:  return FFpwZS("cp -f '%s' '%s.bak'" % (path, path))
 1029: def FFoWxR(path):
 1030:  if not path.endswith("/"):
 1031:   path += "/"
 1032:  return path
 1033: def FFVc4H(path):
 1034:  if not path == "/":
 1035:   path = path.rstrip("/")
 1036:  return path
 1037: def FFkzic(path, patt):
 1038:  if "[" in path or "]" in path:
 1039:   newPath = ""
 1040:   for char in path:
 1041:    if   char == "[": char = "[[]"
 1042:    elif char == "]": char = "[]]"
 1043:    newPath += char
 1044:  else:
 1045:   newPath = path
 1046:  return iGlob("%s%s" % (FFoWxR(newPath), patt))
 1047: def FFIUAb():
 1048:  sigFile = "ajpanel_res_marker"
 1049:  try:
 1050:   p = os.path.abspath(os.path.dirname(__file__))
 1051:   if p:
 1052:    mainP = os.path.join(p, "")
 1053:    resP = os.path.join(p, "res", "")
 1054:    if FFCyVu(os.path.join(resP, sigFile)):
 1055:     return mainP, resP
 1056:  except:
 1057:   pass
 1058:  paths = []
 1059:  paths.append(VVUytA)
 1060:  paths.append(VVUytA.replace("lib", "lib64"))
 1061:  ba = "/media/ba/ba/"
 1062:  list = FFkES0(ba)
 1063:  for p in list:
 1064:   p = ba + p + VVUytA
 1065:   paths.append(p)
 1066:  for p in paths:
 1067:   p = os.path.join(p, VVXRGG, "")
 1068:   if FFCyVu(os.path.join(p, "res", sigFile)):
 1069:    mainP = os.path.join(p, "")
 1070:    resP = os.path.join(mainP, "res", "")
 1071:    return mainP, resP
 1072:  mainP = os.path.join(VVUytA, VVXRGG , "")
 1073:  resP = os.path.join(mainP, "res", "")
 1074:  return mainP, resP
 1075: VV231J, VVIp2p = FFIUAb()
 1076: def FFzcnD(SELF=None):
 1077:  tLst = ("/media/hdd/", "/media/usb/", "/media/mmc/", "/media/", "/")
 1078:  bDir = FF0cqc()
 1079:  if not VVmJwX(bDir) or bDir in tLst:
 1080:   for p in tLst:
 1081:    newP = p + "ajpanel_backup/"
 1082:    if VVmJwX(p) and FFpwZS("mkdir -p %s" % newP):
 1083:     bDir = newP
 1084:     break
 1085:  VVrgp4 = ""
 1086:  mvDir = FFoWxR(CFG.MovieDownloadPath.getValue())
 1087:  if not VVmJwX(mvDir) or not mvDir.endswith("/movie/"):
 1088:   for p in ("/media/hdd/", "/media/usb/", "/media/mmc/", "/media/", bDir, "/"):
 1089:    tmpP = p + "movie/"
 1090:    if VVmJwX(p) and FFpwZS("mkdir -p %s" % tmpP):
 1091:     CFG.MovieDownloadPath.setValue(tmpP)
 1092:     CFG.MovieDownloadPath.save()
 1093:     VVrgp4 = mvDir
 1094:     break
 1095:  def VVzSlC(item):
 1096:   path = item.getValue()
 1097:   if not VVmJwX(path) or path in tLst:
 1098:    item.setValue(bDir)
 1099:    item.save()
 1100:    return path
 1101:   return ""
 1102:  VV7hAV  = VVzSlC(CFG.backupPath)
 1103:  VV4p3V = VVzSlC(CFG.customMenuPath)
 1104:  if any((VV7hAV or VV4p3V or VVrgp4)):
 1105:   configfile.save()
 1106:   if SELF:
 1107:    VVJi7Q = lambda subj, oldP, newP: "%s:\n    From\t: %s\n    To\t: %s\n\n" % (FFjt5L(subj, VVFuwR), FFjt5L(oldP, VVYjI5), FFjt5L(newP, VVJEMb)) if oldP and newP and oldP != "/" and oldP != newP else ""
 1108:    txt  = VVJi7Q("Backup/Restore Path"    , VV7hAV   , CFG.backupPath.getValue())
 1109:    txt += VVJi7Q("Custom Menu"      , VV4p3V  , CFG.customMenuPath.getValue())
 1110:    txt += VVJi7Q("Movie/Series Download"   , VVrgp4 , CFG.MovieDownloadPath.getValue())
 1111:    if txt.strip():
 1112:     txt = "The following directories were reset to default:\n\n%s\nYou can change paths from Settings.\n" % txt
 1113:     FF4lCP(SELF, txt, title="Settings Paths")
 1114: def FF0cqc():    return FFoWxR(CFG.backupPath.getValue())
 1115: def FFeAlZ():  return FFBmjd("export")
 1116: def FF7BT0():   return FFBmjd("iptv")
 1117: def FFriZ7():     return FFBmjd("logo")
 1118: def FFzQP1(): return FFBmjd("pkg_download")
 1119: def FFoUor():  return FFBmjd("pkg_project")
 1120: def FFCq6F():   return FFBmjd("screenshot")
 1121: def FF7TOv():  return FFBmjd("share")
 1122: def FFBmjd(p):
 1123:  bPath = FF0cqc()
 1124:  p = bPath + FFoWxR("ajpanel_" + p)
 1125:  return p if (VVmJwX(p) or FFpwZS("mkdir -p '%s'" % p)) else bPath
 1126: def FFf6kX():
 1127:  lst = []
 1128:  for nm in ("Portal", "Playlist"): lst.extend(FFkzic(FF0cqc(), "%s_Bookmarks*.txt" % nm))
 1129:  for oldF in lst:
 1130:   if os.path.isfile(oldF):
 1131:    newF = FF7BT0() + os.path.basename(oldF)
 1132:    if not FFCyVu(newF): FFpwZS("mv '%s' '%s'" % (oldF, newF))
 1133: def FFb0NN():
 1134:  lst = []
 1135:  for nm in ("ref", "data"): lst.extend(FFkzic(FF0cqc(), "ajpanel_share_%s_*.xml" % nm))
 1136:  for oldF in lst:
 1137:   if os.path.isfile(oldF):
 1138:    newF = FF7TOv() + os.path.basename(oldF)
 1139:    if not FFCyVu(newF): FFpwZS("mv '%s' '%s'" % (oldF, newF))
 1140: def FFHQjU():
 1141:  lst = FFkzic(FF0cqc(), "ajpanel_package_*")
 1142:  for oldP in lst:
 1143:   if os.path.isdir(oldP):
 1144:    newP = FFoUor() + os.path.basename(oldP)
 1145:    if not VVmJwX(newP):
 1146:     FFpwZS("cp -r '%s' '%s' && rm -r '%s'" % (oldP, newP, oldP))
 1147: def FFtu2k(path):
 1148:  path = FFVc4H(path)
 1149:  target = ""
 1150:  try:
 1151:   if VVmJwX(path) and os.path.islink(path):
 1152:    target = os.readlink(path)
 1153:  except:
 1154:   pass
 1155:  return target
 1156: def FF6W0I(SELF):
 1157:  btnMode = SELF.VVfOli["VV0Ay7"]
 1158:  if btnMode in (1, 2): FFkDgm(SELF["keyMenu"], "menu")
 1159:  if btnMode in (2, 3): FFkDgm(SELF["keyInfo"], "info")
 1160: def FFBFPY(pixmap, path):
 1161:  p = FFmNfu(path)
 1162:  if p:
 1163:   pixmap.instance.setScale(1)
 1164:   pixmap.instance.setPixmap(p)
 1165:  return p
 1166: def FFkDgm(pixmap, fName):
 1167:  return FFBFPY(pixmap, "%s%s%s" % (VVIp2p, fName, ".png"))
 1168: def FFmNfu(path):
 1169:  try:
 1170:   p = LoadPixmap(path)
 1171:   if p: return p
 1172:  except:
 1173:   pass
 1174:  return None
 1175: def FFycBE(satNum):
 1176:  satNum  = int(satNum)
 1177:  if   satNum == 0xeeee: return "DVB-T"
 1178:  elif satNum == 0xffff: return "DVB-C"
 1179:  else:
 1180:   satName = ""
 1181:   try:
 1182:    satName = nimmanager.getSatName(satNum)
 1183:   except:
 1184:    pass
 1185:   if not satName or "N/A" in satName:
 1186:    satName = FFS0T2(satNum)
 1187:   return satName
 1188: def FFS0T2(satNum):
 1189:  satNum  = int(satNum)
 1190:  if   satNum == 0xeeee: return "DVB-T"
 1191:  elif satNum == 0xffff: return "DVB-C"
 1192:  else:
 1193:   satDir = "E"
 1194:   if satNum > 1800:
 1195:    satDir = "W"
 1196:    satNum = 3600 - satNum
 1197:   satNum /= 10.0
 1198:   return "%s%s" % (str(satNum), satDir)
 1199: def FFec0y(VVPxk5, isLong):
 1200:  sat = ""
 1201:  if VVPxk5.count(":") > 8:
 1202:   nameSpace = VVPxk5.split(":")[6]
 1203:   s   = nameSpace.zfill(8)[:4]
 1204:   val   = int(s, 16)
 1205:   if isLong : sat = FFycBE(val)
 1206:   else  : sat = FFS0T2(val)
 1207:  return sat
 1208: def FFR9yH(sat):
 1209:  try:
 1210:   s = sat.upper()
 1211:   if s.endswith("E") or s.endswith("W"):
 1212:    num = float(sat[:-1]) * 10
 1213:    if s.endswith("W"):
 1214:     num = 3600 - num
 1215:    return FFycBE(num)
 1216:  except:
 1217:   pass
 1218:  return sat
 1219: def FF2qmC(satNumStr):
 1220:  satDir = "E"
 1221:  satNum = int(satNumStr)
 1222:  if satNum < 0:
 1223:   satDir = "W"
 1224:  satNum /= 10.0
 1225:  return "%s%s" % (str(abs(satNum)), satDir)
 1226: def FFIBUH(SELF):
 1227:  s = CC3rDi(SELF.session)
 1228:  return s.VVPxk5, s.VVZcRP, s.VV57TX, s.VVfaDB, s.VV1wIO
 1229: def FFMzWf(info, param):
 1230:  if info:
 1231:   v = info.getInfo(param)
 1232:   if   v == -1  : return ""
 1233:   elif v in (-2, 1) : return info.getInfoString(param)
 1234:   else    : return str(v)
 1235:  else:
 1236:   return ""
 1237: def FFxWB5(info, param):
 1238:  if info:
 1239:   v = info.getInfo(param)
 1240:   if   v == -1: return ""
 1241:   elif v == -2: return info.getInfoString(param)
 1242:   else  : return str(v)
 1243:  else:
 1244:   return ""
 1245: def FFtCD7(VVPxk5, VVfaDB, VV1wIO):
 1246:  if VVfaDB : return VVfaDB.replace(":" + VV1wIO, "")
 1247:  else  : return VVPxk5
 1248: def FFCjjv(VVPxk5):
 1249:  info = FFKDjv(VVPxk5)
 1250:  return info and info.getName(eServiceReference(VVPxk5)) or ""
 1251: def FFARk6(VVPxk5):
 1252:  try:
 1253:   ns = VVPxk5.split(":")[6]
 1254:   ns = ns.zfill(8)[:4]
 1255:  except:
 1256:   ns = ""
 1257:  return ns.upper()
 1258: def FFZK2V(path, fName):
 1259:  if os.path.isfile(path + fName):
 1260:   return fName
 1261:  else:
 1262:   if fName.count("_") > 8:
 1263:    parts = fName.split("_")
 1264:    parts[2] = "1"
 1265:    fName = "_".join(parts)
 1266:    if os.path.isfile(path + fName):
 1267:     return fName
 1268:  return ""
 1269: def FFKDjv(VVPxk5):
 1270:  service = eServiceReference(VVPxk5)
 1271:  info = None
 1272:  if service:
 1273:   VVX5XV = eServiceCenter.getInstance()
 1274:   if VVX5XV:
 1275:    info = VVX5XV.info(service)
 1276:  return info
 1277: def FFnfiC(session, VVPxk5, checkParentalControl=False, VV9rup=False):
 1278:  if VVPxk5.count(":") > 8:
 1279:   serviceRef = eServiceReference(str(VVPxk5))
 1280:   servRef = eServiceReference(VVPxk5)
 1281:   session.nav.playService(servRef, checkParentalControl=checkParentalControl)
 1282:  try:
 1283:   VVCy6c = InfoBar.instance
 1284:   if VVCy6c:
 1285:    VVFp6v = VVCy6c.servicelist
 1286:    if VVFp6v:
 1287:     servRef = eServiceReference(VVPxk5)
 1288:     VVFp6v.saveChannel(servRef)
 1289:     if VV9rup: VVFp6v.VVeI3W(servRef)
 1290:  except:
 1291:   pass
 1292: def FFqb3C(session, serviceRef, checkParentalControl=False):
 1293:  session.nav.playService(serviceRef, checkParentalControl=checkParentalControl)
 1294: def FFUPnc(VVPxk5):
 1295:  return iMatch(r"([A-Fa-f0-9]+[:]){10}.+\/\/.+", VVPxk5)
 1296: def FFhPtm(ref):
 1297:  return bool(iMatch(r"^[A-Fa-f0-9]+:64:", ref or ""))
 1298: def FFWpih(ref):
 1299:  return "FROM BOUQUET " in ref.upper()
 1300: def FFHgaY(ref):
 1301:  if "chcm=" in ref.lower(): return False
 1302:  else      : return bool(iMatch(r".*https?(:|%3a)\/\/((127|0)\.\d+\.\d+\.\d+|localhost)(:|%3a)\d+\/.*", ref, IGNORECASE))
 1303: def FFBYGm(url)  : return CCjZbZ.VVZXSg(url)
 1304: def FFKxIH(url)  : return FFBYGm(url) == "VOD"
 1305: def FF1BEt(url)  : return FFBYGm(url) == "Series"
 1306: def FFUl6q(url): return FFBYGm(url) in ("VOD", "Series")
 1307: def FFXarh(url):
 1308:  if url and iUnquote : return iUnquote(url)
 1309:  else    : return url
 1310: def FFSiPR(url):
 1311:  if url and iQuote : return iQuote(url)
 1312:  else    : return url
 1313: def FFbhOc(txt):
 1314:  return hashlib.md5(txt.encode("UTF-8")).hexdigest()
 1315: def FFiPNn(txt):
 1316:  try:
 1317:   return str(b64encode(txt.encode("utf-8")).decode("utf-8"))
 1318:  except:
 1319:   return txt
 1320: def FFQqEJ(txt):
 1321:  try:
 1322:   return str(b64decode(txt).decode("utf-8"))
 1323:  except:
 1324:   return txt
 1325: def FFBAsJ(txt):
 1326:  try:
 1327:   return FFiPNn(FFQqEJ(txt)) == txt
 1328:  except:
 1329:   return False
 1330: def FFdXBl(session, reopen=False):
 1331:  if reopen:
 1332:   try:
 1333:    session.openWithCallback(BF(FFdXBl, session), CCtKqU)
 1334:   except:
 1335:    try:
 1336:     FFzcnp(session, "Cannot launch Signal Monitor !", title="Signal Monitor")
 1337:    except:
 1338:     pass
 1339: def FF4qbN(VVPxk5):
 1340:  tp = CC3Z54()
 1341:  if tp.VVoQfv(VVPxk5) : return True
 1342:  else        : return False
 1343: def FFz2bQ(VVPxk5, isHide, skipReload=False):
 1344:  if VVPxk5.count(":") > 8:
 1345:   sRef = eServiceReference(VVPxk5)
 1346:   if sRef:
 1347:    db = eDVBDB.getInstance()
 1348:    if db:
 1349:     if isHide : ret = db.addFlag(sRef , 0x2)
 1350:     else  : ret = db.removeFlag(sRef, 0x2)
 1351:     if skipReload:
 1352:      return True if ret == 0 else False
 1353:     elif ret == 0:
 1354:      FFfpyJ(True)
 1355:      return True
 1356:  return False
 1357: def FFfpyJ(save=False):
 1358:  db = eDVBDB.getInstance()
 1359:  if db:
 1360:   if save:
 1361:    db.saveServicelist()
 1362:   db.reloadServicelist()
 1363:   db.reloadBouquets()
 1364:  FF9PMc()
 1365: def FF9PMc():
 1366:  VVCy6c = InfoBar.instance
 1367:  if VVCy6c:
 1368:   VVFp6v = VVCy6c.servicelist
 1369:   if VVFp6v:
 1370:    VVFp6v.setMode()
 1371: def FFZcDI(root, mode=0):
 1372:  lst = []
 1373:  try:
 1374:   servicelist  = root and eServiceCenter.getInstance().list(root)
 1375:   VVX5XV = eServiceCenter.getInstance()
 1376:   if servicelist:
 1377:    while True:
 1378:     service = servicelist.getNext()
 1379:     if not service.valid():
 1380:      break
 1381:     flags = service.flags
 1382:     if mode == 0 and service.flags & (eServiceReference.isDirectory | eServiceReference.isMarker):
 1383:      continue
 1384:     ref, info = service.toString(), VVX5XV.info(service)
 1385:     name = info.getName(service)
 1386:     if   mode == 0: lst.append((ref, name))
 1387:     elif mode == 1: lst.append((ref, name, flags))
 1388:  except:
 1389:   pass
 1390:  return lst
 1391: def FF07Sg():
 1392:  VVvwHc = {0x01:"TV MPEG-2 SD",0x02:"Radio MPEG-1",0x03:"Teletext",0x04:"NVOD SD",0x05:"NVOD SD T.Shift",0x06:"Mosaic",0x07:"FM Radio",0x08:"DVB SRM",0x09:"Res. 9",0x0A:"Radio Adv. Codec",0x0B:"AVC Mosaic",0x0C:"Data",0x0D:"CI",0x0E:"RCS Map",0x0F:"RCS FLS",0x10:"DVB MHP",0x11:"TV HD MPEG-2",0x16:"TV SD H.264",0x17:"NVOD SD T.Sh.",0x18:"NVOD SD Ref.",0x19:"TV HD H.264",0x1A:"NVOD HD T.Sh.",0x1B:"NVOD HD Ref.",0x1C:"TV HD H.264",0x1D:"NVOD HD T.Sh.",0x1E:"NVOD HD Ref.",0x1F:"TV HEVC",0x20:"TV HEVC (HDR)",0x80:"User Def.",0x64:"Custom",0x81:"Custom",0x82:"Custom",0x84:"Custom",0x95:"Custom",0x98:"Custom",0x9B:"Custom",0xAB:"Custom",0xB4:"Custom",0xB5:"Custom",0xC6:"Custom",0xFA:"Custom",0xFB:"Custom",0xFC:"Custom"}
 1393:  VVY1oT = list(VVvwHc)
 1394:  return VVY1oT, VVvwHc
 1395: def FF2Wqb():
 1396:  try:
 1397:   iPlugins.clearPluginList()
 1398:   iPlugins.readPluginList(resolveFilename(SCOPE_PLUGINS))
 1399:  except:
 1400:   pass
 1401: def FFZVA0(delta=0):
 1402:  Time = datetime.now() + timedelta(delta)
 1403:  midnight = Time.replace(hour=0, minute=0, second=0, microsecond=0)
 1404:  return mktime(midnight.timetuple())
 1405: def FFTS4w(unixTime, wDay=False):
 1406:  return datetime.fromtimestamp(unixTime).strftime("%Y-%m-%d %H:%M:%S" + (" %a" if wDay else ""))
 1407: def FFIPdt():
 1408:  year, month, day, hour, minute, second, weekDay, yearDay, dayLight = localtime()
 1409:  return "%04d-%02d-%02d %02d:%02d:%02d" % (year, month, day, hour, minute, second)
 1410: def FFwjLg(): return datetime.now().strftime("%Y-%m-%d %H:%M:%S")
 1411: def FFRvLH(): return datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")
 1412: def FFjTQe():
 1413:  return FFIPdt().replace(" ", "_").replace("-", "").replace(":", "")
 1414: def FFFHEC(secs):
 1415:  m, s = divmod(secs, 60)
 1416:  h, m = divmod(m   , 60)
 1417:  return "%02d:%02d:%02d" % (h, m, s)
 1418: def FFvTve(head, fixName=True):
 1419:  try : cont = head.get("content-disposition")
 1420:  except: cont = None
 1421:  if cont:
 1422:   span = iSearch(r'filename=([^;]+)', str(cont), IGNORECASE)
 1423:   if span:
 1424:    fName = span.group(1).strip('" ')
 1425:    if fixName : return FFOu5Y(fName)
 1426:    else  : return fName
 1427:  return ""
 1428: def FFx9uM(url, outFile, timeout=3, VVzHui=False, tmpPath="", VVf6G8=True):
 1429:  tmpDir = tmpPath or "/tmp/"
 1430:  outFile = tmpDir + outFile
 1431:  span = iSearch(r".*data.+base64,(.+)", url, IGNORECASE)
 1432:  if span:
 1433:   b64 = span.group(1)
 1434:   with open(outFile, "wb") as f:
 1435:    f.write(b64decode(b64))
 1436:   return outFile, ""
 1437:  if not CCkEI5.VVNeuG(url, justValidate=True):
 1438:   return "", "Invalid URL"
 1439:  if not iRequest:
 1440:   return "" , "Cannot import URLLIB/URLLIB2 !"
 1441:  try:
 1442:   req = iRequest(url.strip())
 1443:   req.add_header("User-Agent", CCkEI5.VVQNEW())
 1444:   res = iUrlopen(req, timeout=timeout)
 1445:   resCode = res.code
 1446:   if resCode == 200 :
 1447:    if VVzHui and "text/html" in res.headers.get("Content-Type"):
 1448:     return "", "Received TEXT/HTML (instead of image)"
 1449:    with open(outFile, "wb") as f:
 1450:     f.write(res.read())
 1451:    if VVf6G8:
 1452:     fName = FFvTve(res.headers)
 1453:     if fName:
 1454:      newPath = tmpDir + fName
 1455:      if FFpwZS("mv -f '%s' '%s'" % (outFile, newPath)):
 1456:       outFile = newPath
 1457:    if FFCyVu(outFile) : return outFile, ""
 1458:    else     : return "", "Cannot create file."
 1459:   else:
 1460:    if   resCode == 401 : err = "Unauthorized"
 1461:    elif resCode == 402 : err = "Payment Required"
 1462:    elif resCode == 408 : err = "Request Timeout"
 1463:    else    : err = "err=%d" % resCode
 1464:    return "", "Download Failed (%s)" % err
 1465:  except iURLError as e:
 1466:   return "",  FFWVTk(e)
 1467:  except Exception as e:
 1468:   return "", str(e)
 1469: def FFWVTk(e):
 1470:  err = ""
 1471:  if hasattr(e, "code") : err = "Error Code : %s\n" % str(e.code)
 1472:  if hasattr(e, "reason") : err += "Reason : %s\n" % str(e.reason)
 1473:  if not err    : err += "Error : %s"  % str(e)
 1474:  return err.strip()
 1475: def FFajKn(numStr):
 1476:  return iMatch(r"^([-+]?\d+(\.\d*)?$)", numStr) is not None
 1477: def FFcacr(num):
 1478:  return "s" if num > 1 else ""
 1479: def FFsRWN(num, minNum, maxNum):
 1480:  return max(min(maxNum, num), minNum)
 1481: def FFqmPQ(s):
 1482:  return ''.join([chr(int(s[i:i+2], 16)) for i in range(0, len(s), 2)])
 1483: def FFWEt2(txt, repl):
 1484:  return iSub(r"[^\x00-\x7F]", repl, txt)
 1485: def FFfCtV(txt, repl):
 1486:  return iSub(r"[^A-Za-z0-9._-]", repl, txt)
 1487: def FFOu5Y(txt, repl="_"):
 1488:  for ch in " ():/\\,;*/:*?<>|\"'": txt = txt.replace(ch, repl)
 1489:  txt = txt.replace("_-_", repl).replace("-_-", repl)
 1490:  txt = FFMYNg(txt, repl)
 1491:  return txt.strip(".") or "File"
 1492: def FFMYNg(txt, repl):
 1493:  while repl * 2 in txt: txt = txt.replace(repl * 2, repl)
 1494:  return txt.strip(repl) or repl
 1495: def FFjFSv(OldValue, OldMin, OldMax, NewMin, NewMax):
 1496:  return (((OldValue - OldMin) * (NewMax - NewMin)) / (OldMax - OldMin)) + NewMin
 1497: def FFyH6N(a, b):
 1498:  return (a > b) - (a < b)
 1499: def FFa9eD(a, b):
 1500:  def VVjU8e(var):
 1501:   return [ (int(c) if c.isdigit() else c) for c in iSplit(r'(\d+)', var) ]
 1502:  a = VVjU8e(a)
 1503:  b = VVjU8e(b)
 1504:  return (a > b) - (a < b)
 1505: def FFgEff(mycmp):
 1506:  class CC3MqF(object):
 1507:   def __init__(self, obj, *args) : self.obj = obj
 1508:   def __lt__(self, other): return mycmp(self.obj, other.obj) < 0
 1509:   def __gt__(self, other): return mycmp(self.obj, other.obj) > 0
 1510:   def __eq__(self, other): return mycmp(self.obj, other.obj) == 0
 1511:   def __le__(self, other): return mycmp(self.obj, other.obj) <= 0
 1512:   def __ge__(self, other): return mycmp(self.obj, other.obj) >= 0
 1513:   def __ne__(self, other): return mycmp(self.obj, other.obj) != 0
 1514:  return CC3MqF
 1515: def FFax4p(elem):
 1516:  return str(elem.text.encode("UTF-8").decode()).strip() if elem is not None and elem.text else ""
 1517: def FFwW5m(elem, attrib):
 1518:  return str(elem.attrib.get(attrib, "").encode("UTF-8").decode()).strip() if elem is not None else ""
 1519: def FF6Tbq(elem, child):
 1520:  return FFax4p(elem.find(child))
 1521: def FFaJfl(elem, child, attrib):
 1522:  x = elem.find(child)
 1523:  if not x is None:
 1524:   return str(x.attrib.get(attrib, "").encode("UTF-8").decode()).strip()
 1525:  return ""
 1526: def FFFE2m(elem, child):
 1527:  lst = []
 1528:  for el in elem.findall(child):
 1529:   lst.append(FFax4p(el))
 1530:  return lst
 1531: def FFT8ma(elem):
 1532:  return str(iElem.tostring(elem, encoding="utf-8").decode()).strip()
 1533: def FFYjVd(item, key, isDate=False, is_base64=False, isToHHMMSS=False):
 1534:  if key in item:
 1535:   val = str(item[key])
 1536:   try:
 1537:    if   isDate  : val = FFTS4w(int(val))
 1538:    elif is_base64 : val = FFQqEJ(val)
 1539:    elif isToHHMMSS : val = FFFHEC(float(val))
 1540:   except:
 1541:    pass
 1542:   if val == "None": return ""
 1543:   else   : return val.strip()
 1544:  else:
 1545:   return ""
 1546: def FFipXT(SELF, message, title="", VVbYwR=None):
 1547:  SELF.session.openWithCallback(VVbYwR, CCn30s, title=title, message=message, VViOjF=True)
 1548: def FF4lCP(SELF, message, title="", VV47Xm=VV5jA8, VVbYwR=None, **kwargs):
 1549:  return SELF.session.openWithCallback(VVbYwR, CCn30s, title=title, message=message, VV47Xm=VV47Xm, **kwargs)
 1550: def FFSqRh(SELF, txt):
 1551:  SELF.session.open(CCea0a, txt)
 1552: def FF8D5P(session, *args, **kwargs):
 1553:  session.open(CC8Nur, *args, **kwargs)
 1554: def FFdw58(SELF, message, title="")  : FFzcnp(SELF.session, message, title)
 1555: def FF8Wsn(SELF, path, title="") : FFzcnp(SELF.session, "File not found:\n\n%s" % path, title)
 1556: def FFNICS(SELF, path, title="") : FFzcnp(SELF.session, "File is empty !\n\n%s"  % path, title)
 1557: def FFfone(SELF, title="")  : FFzcnp(SELF.session, "No Packaging Tools:\n\n(OPKG / IPKG / DPKG )", title)
 1558: def FFzcnp(session, message, title="") : session.open(CCtjms, title=title, message=message)
 1559: def FF28n1(SELF, txt="", timeout=0, isGrn=False):
 1560:  if len(txt) > 0:
 1561:   try:
 1562:    FFZ0AC(SELF["myInfoBody"], "#00004040" if isGrn else "#00550000")
 1563:    SELF["myInfoFrame"].show()
 1564:    SELF["myInfoBody"].show()
 1565:    SELF["myInfoBody"].setText(str(txt))
 1566:    if timeout > 0: SELF.VV0bxL.start(timeout, True)
 1567:   except: pass
 1568:  else: FFxjE5(SELF)
 1569: def FF1mVE(SELF, txt="", timeout=1000):
 1570:  FF28n1(SELF, txt, timeout=timeout, isGrn=True)
 1571: def FFG2sB(SELF, txt="", timeout=1000):
 1572:  FFIElK(BF(FF28n1, SELF, txt=txt, timeout=timeout, isGrn=True))
 1573: def FFjADj(*kargs, **kwargs):
 1574:  FFIElK(BF(FF28n1, *kargs, **kwargs))
 1575: def FFxjE5(SELF):
 1576:  try:
 1577:   SELF.VV0bxL.stop()
 1578:   SELF["myInfoFrame"].hide()
 1579:   SELF["myInfoBody"].hide()
 1580:  except:
 1581:   pass
 1582: def FFmZaT(SELF):
 1583:  try: return SELF["myInfoBody"].visible
 1584:  except: return False
 1585: def FF4z45(SELF, VVbYwR, title="", defaultText="", message=""):
 1586:  mode = CFG.keyboard.getValue()
 1587:  allOK = False
 1588:  if mode == "v":
 1589:   try:
 1590:    from Screens.VirtualKeyBoard import VirtualKeyBoard
 1591:    obj = SELF.session.openWithCallback(VVbYwR, VirtualKeyBoard, title=message, text=defaultText)
 1592:    allOK = True
 1593:    obj.setTitle(title)
 1594:   except:
 1595:    pass
 1596:  elif mode == "s":
 1597:   try:
 1598:    from Screens.InputBox import InputBox
 1599:    SELF.session.openWithCallback(VVbYwR, InputBox, windowTitle=title, title=message.replace("\n", " "), text=defaultText)
 1600:    allOK = True
 1601:   except:
 1602:    pass
 1603:  if not allOK:
 1604:   try:
 1605:    FFdw58(SELF, "Cannot run the Input Dialog (keyboard) !", title="Keyboard Error")
 1606:   except:
 1607:    pass
 1608: def FFRMYv(SELF, callBack_Yes, VVsWSA, callBack_No=None, title="", VVAgUy=False, VV4Moq=True, VV1rS5=False):
 1609:  session = SELF if VV1rS5 else SELF.session
 1610:  return session.openWithCallback(BF(FFqrO8, callBack_Yes, callBack_No)
 1611:          , BF(CC032e, title=title, VVsWSA=VVsWSA, VV4Moq=VV4Moq, VVAgUy=VVAgUy))
 1612: def FFqrO8(callBack_Yes, callBack_No, FFRMYved):
 1613:  if FFRMYved : callBack_Yes()
 1614:  elif callBack_No: callBack_No()
 1615: def FFUQ0v(SELF, callBackFunc, **kwargs):
 1616:  try:
 1617:   if callBackFunc : return SELF.session.openWithCallback(callBackFunc, BF(CCnES5, **kwargs))
 1618:   else   : return SELF.session.open(CCnES5, **kwargs)
 1619:  except:
 1620:   return None
 1621: def FFLFTC(SELF, callBackFunc, **kwargs):
 1622:  return SELF.session.openWithCallback(callBackFunc, BF(CCUwDo, **kwargs))
 1623: def FF0TBx(pixmapObj, path, VVemyB=None, fncCb_ok=None, fncCb_fail=None):
 1624:  return CCWhOL(pixmapObj, path, VVemyB, fncCb_ok, fncCb_fail).VVcRk2()
 1625: def FF0bQE(txt):
 1626:  return ("--[ %s ]%s" % (txt,  "-" * 100), )
 1627: def FFsLU5(txt, ref, cond, color=""):
 1628:  return (color + txt, ref) if cond else (txt,)
 1629: def FFWgBS(SELF, isTopBar=False):
 1630:  if isTopBar : names = [ "keyRedTop" , "keyGreenTop" , "keyYellowTop", "keyBlueTop"  ]
 1631:  else  : names = [ "keyRed" , "keyGreen" , "keyYellow" , "keyBlue"  ]
 1632:  for name in names:
 1633:   try:
 1634:    FFK4PQ(SELF[name], "#000000", 3)
 1635:   except:
 1636:    pass
 1637: def FFK4PQ(label, color, w):
 1638:  try:
 1639:   inst = label.instance
 1640:   inst.setBorderColor(parseColor(color))
 1641:   inst.setBorderWidth(w)
 1642:  except:
 1643:   try:
 1644:    inst = label.instance
 1645:    inst.setShadowColor(parseColor(color))
 1646:    inst.setShadowOffset(ePoint(-2, -2))
 1647:   except:
 1648:    pass
 1649: def FFJmzh(SELF, menuObj):
 1650:  try:
 1651:   menuObj.instance.setFont(gFont(VVNhAq, SELF.VVfOli["VVgbF2"]))
 1652:  except:
 1653:   try: menuObj.l.setFont(gFont(VVNhAq, SELF.VVfOli["VVgbF2"]))
 1654:   except: pass
 1655: def FFzKEr(menuObj, offset):
 1656:  if hasattr(menuObj.instance, "setTextOffset"):
 1657:   menuObj.instance.setTextOffset(ePoint(offset, 0))
 1658:  else:
 1659:   try:
 1660:    menuObj.l.setLeftOffset(offset)
 1661:    menuObj.l.setRightOffset(offset)
 1662:   except:
 1663:    pass
 1664: def FF2GM8(SELF, menuObj=None, VVyRCy=0, offset=20):
 1665:  if not menuObj:
 1666:   menuObj = SELF["myMenu"]
 1667:  FFJmzh(SELF, menuObj)
 1668:  FFzKEr(menuObj, offset)
 1669:  winInst  = SELF.instance
 1670:  menuInst = menuObj.instance
 1671:  maxH = SELF.VVfOli["height"]
 1672:  winW = winInst.size().width()
 1673:  winH = winInst.size().height()
 1674:  menuW = menuInst.size().width()
 1675:  menuH = menuInst.size().height()
 1676:  lineH = menuObj.l.getItemSize().height()
 1677:  menuH1 = (max(VVyRCy, len(menuObj.list))) * lineH
 1678:  diff = menuH1 - menuH
 1679:  winNewH = winH + diff
 1680:  btnDiff = diff
 1681:  if winNewH > winH:
 1682:   if winH + lineH <= maxH:
 1683:    btnDiff = lineH
 1684:    menuH = menuH + lineH
 1685:    menuInst.resize(eSize(*(menuW, menuH)))
 1686:    winInst.resize(eSize(*(winW, winH + lineH)))
 1687:   else:
 1688:    btnDiff = 0
 1689:   pos  = menuObj.getPosition()
 1690:   part = menuInst.size().height() % lineH
 1691:   half = int(part / 2)
 1692:   menuInst.resize(eSize(*(menuW, menuH - part)))
 1693:   menuInst.move(ePoint(pos[0], pos[1] + half))
 1694:  else:
 1695:   menuInst.resize(eSize(*(menuW, menuH + diff)))
 1696:   winInst.resize(eSize(*(winW, winNewH)))
 1697:  winH = winInst.size().height()
 1698:  screenSize = getDesktop(0).size()
 1699:  winInst.move(ePoint((screenSize.width() - winW) // 2, (screenSize.height() - winH) // 2))
 1700:  names = [ "keyRed", "keyGreen", "keyYellow", "keyBlue", "myBar", "myLine" ]
 1701:  for name in names:
 1702:   try:
 1703:    obj = SELF[name]
 1704:    pos = obj.getPosition()
 1705:    obj.instance.move(ePoint(pos[0], pos[1] + btnDiff))
 1706:   except:
 1707:    pass
 1708:  winSize = winInst.size()
 1709:  w, h = winSize.width(), winSize.height()
 1710:  SELF["myWP"].instance.resize(eSize(*(w, h)))
 1711:  FF9sDw(SELF, w, h)
 1712: def FF9sDw(SELF, w, h):
 1713:  fSize = SELF["myInfoFrame"].instance.size()
 1714:  bSize = SELF["myInfoBody"].instance.size()
 1715:  SELF["myInfoFrame"].instance.move(ePoint((w - fSize.width()) // 2, (h - fSize.height()) // 2))
 1716:  SELF["myInfoBody"].instance.move(ePoint((w - bSize.width()) // 2, (h - bSize.height()) // 2))
 1717: def FFIGbj(win, mode):
 1718:  inst = win.instance
 1719:  pos, sz = inst.position(), inst.size()
 1720:  x, y = pos.x(), pos.y()
 1721:  w, h = sz.width(), sz.height()
 1722:  sz = getDesktop(0).size()
 1723:  sW, sH = sz.width(), sz.height()
 1724:  if   mode == 0: x = (sW - w) // 2
 1725:  elif mode == 1: y = (sH - h) // 2
 1726:  elif mode == 2: x, y = (sW - w) // 2,  (sH - h) // 2
 1727:  inst.move(ePoint(int(x), int(y)))
 1728: def FFpMtN(w):
 1729:  pos, sz = w.instance.position(), w.instance.size()
 1730:  return pos.x(), pos.y(), sz.width(), sz.height()
 1731: def FFrPd1():
 1732:  s = getDesktop(0).size()
 1733:  return (s.width(), s.height())
 1734: def FFqCn5(VVwdmN):
 1735:  screenSize  = FFrPd1()
 1736:  screenH   = screenSize[1]
 1737:  ratioH   = screenH / 1080.0
 1738:  VVgbF2 = int(ratioH  * VVwdmN)
 1739:  return VVgbF2
 1740: def FFGrBZ(VVwdmN, extraSpace):
 1741:  font = gFont(VVNhAq, VVwdmN)
 1742:  VV8c7y = fontRenderClass.getInstance().getLineHeight(font) or (VVwdmN * 1.25)
 1743:  return int(VV8c7y + VV8c7y * extraSpace)
 1744: def FFiNEe(VVON3k, width, height, VVllEU, VVSZWt, VVpeQE, VVOJKe, VVPTnB, VVgbF2, VVeFSs=0, VVt3Ak=0, VV0Ay7=0, VVptue=0.15, VVdrEC=None, VVOde7=False, VVFz5T=1, VVU4ws=True, VVrz9u=0, VVUuJZ={}):
 1745:  screenSize = FFrPd1()
 1746:  screenW = int(screenSize[0] * VVFz5T)
 1747:  screenH = int(screenSize[1] * VVFz5T)
 1748:  if width == 0 : width  = screenW
 1749:  if height == 0: height = screenH
 1750:  retPar   = None
 1751:  ratioW   = screenW / 1920.0
 1752:  ratioH   = screenH / 1080.0
 1753:  width   = int(ratioW  * width)
 1754:  height   = int(ratioH  * height)
 1755:  titleH   = int(ratioH  * 50)
 1756:  VVSZWt  = int(ratioW  * VVSZWt)
 1757:  VVpeQE  = int(ratioH  * VVpeQE)
 1758:  VVgbF2 = int(ratioH  * VVgbF2)
 1759:  VVeFSs  = int(ratioH  * VVeFSs)
 1760:  VVt3Ak  = int(ratioW  * VVt3Ak)
 1761:  VVpeQE  = max(1, VVpeQE)
 1762:  scrollBarW  = int(ratioW * 15)
 1763:  bodyFontStr  = 'font="%s;%d"' % (VVNhAq, VVgbF2)
 1764:  alignCenter  = 'halign="center" valign="center"'
 1765:  alignLeftTop = 'halign="left" valign="top"'
 1766:  alignLeftCenter = 'halign="left" valign="center"'
 1767:  alignRightCenter= 'halign="right" valign="center"'
 1768:  VVllEU = min(int(ratioH  * VVllEU), int(0.7  * titleH))
 1769:  bodyLineH  = FFGrBZ(VVgbF2, VVptue)
 1770:  bodyW   = width - VVSZWt * 2
 1771:  bodyTop   = titleH + 1 + VVpeQE
 1772:  bodyH   = height - bodyTop - VVpeQE
 1773:  if VVeFSs > 0: bodyH -= VVeFSs
 1774:  zPos = 'zPosition="10000000"' if VVON3k == VVoNDw else ""
 1775:  tmp  = '<screen position="center,center" size="%d,%d" backgroundColor="%s" title="%s" flags="wfNoBorder" %s >' % (width, height, VVPTnB, VVh9hj, zPos)
 1776:  tmp += '<widget  name="myBody" position="0,0" size="%d,%d" zPosition="-1" backgroundColor="%s" />' % (width, height, VVPTnB)
 1777:  if VVU4ws:
 1778:   tmp += '<eLabel position="0,%d" size="%d,1" zPosition="1" backgroundColor="#00666666" />' % (titleH + 1, width)
 1779:  tmp += '<widget name="myTitle" position="0,0" size="%d,%d" zPosition="2" noWrap="1" backgroundColor="%s" font="%s;%d" foregroundColor="#ffffbb" %s />' % (width, titleH, VVOJKe, VVNhAq, VVllEU, alignLeftCenter)
 1780:  tmp += '<widget name="myWP" position="0,0" size="%d,%d" alphatest="blend" />' % (width, height)
 1781:  if VVON3k == VVlrZA:
 1782:   pass
 1783:  elif VVON3k in (VVWp3I, VVibAL):
 1784:   if VVON3k == VVibAL : menuName = "config"
 1785:   else      : menuName = "myMenu"
 1786:   menuW = bodyW - int(bodyW * VVrz9u / 100.0) - VVSZWt if VVrz9u else bodyW
 1787:   tmp += '<widget name="%s" position="%d,%d" size="%d,%d" zPosition="3" foregroundColor="#eeeeee" backgroundColor="%s" itemHeight="%d" scrollbarMode="showOnDemand" />' % (menuName, VVSZWt, bodyTop, menuW, bodyH, VVPTnB, bodyLineH)
 1788:   if VVrz9u:
 1789:    param = 'backgroundColor="%s" foregroundColor="#ffffff" %s' % (VVPTnB, bodyFontStr)
 1790:    x, w, gap = menuW + VVSZWt * 2, bodyW - menuW - VVSZWt, int(VVSZWt / 2.0)
 1791:    tmp += '<widget name="myLabelFrm" position="%d,%d" size="%d,%d" zPosition="3" %s />' % (x - gap, bodyTop, w + gap * 2, bodyH, param)
 1792:    tmp += '<widget name="myLabelTit" position="%d,%d" size="%d,%d" zPosition="4" %s %s />' % (x, bodyTop + 10, w, titleH, alignCenter, param)
 1793:    tmp += '<widget name="myLabelTxt" position="%d,%d" size="%d,%d" zPosition="4" noWrap="1" %s %s />' % (x, bodyTop + titleH + gap , w, bodyH - titleH - gap * 2, alignLeftCenter, param)
 1794:  elif VVON3k == VVoNDw:
 1795:   tmp += '<widget name="myWinTitle" position="0,0" size="%d,%d" zPosition="3" noWrap="1" transparent="1" foregroundColor="#ffffff" shadowColor="#440000" shadowOffset="-2,-2" %s %s />' % (width, titleH, bodyFontStr, alignCenter)
 1796:  elif VVON3k == VVspuu:
 1797:   names = ("Red", "Green", "Yellow", "Blue")
 1798:   colors = [ "#229f1313", "#22005500", "#22a08000", "#2218188b"]
 1799:   totBtns = len(names)
 1800:   gap  = 5
 1801:   btnW = int(width * 0.09)
 1802:   btnH = int(titleH * 0.7)
 1803:   left = width - btnW - titleH * 2
 1804:   top  = int((titleH - btnH) / 2.0)
 1805:   fSize = int(0.45  * titleH)
 1806:   for i in range(totBtns-1, -1, -1):
 1807:    tmp += '<widget name="key%s" position="%d,%d" size="%d,%d" zPosition="3" font="%s;%d" backgroundColor="%s" %s />' % (names[i], left, top, btnW, btnH, VVNhAq, fSize, colors[i], alignCenter)
 1808:    left -= (btnW + gap)
 1809:   names = ("Del", "BGTr", "TxtFg", "TxtFnt", "TxtSiz", "Align", "ShadFg", "ShadSiz", "Pos")
 1810:   totBtns = len(names)
 1811:   btnW = int((width - gap * (totBtns + 1)) / totBtns)
 1812:   btnH = titleH
 1813:   left = gap
 1814:   param = 'size="%d,%d" zPosition="3" backgroundColor="#33222222" %s %s ' % (btnW, btnH, bodyFontStr, alignCenter)
 1815:   for i in range(totBtns):
 1816:    tmp += '<widget name="mySubt%s"  position="%d,%d" foregroundColor="#00cccccc" %s />' % (names[i], left, titleH + gap  , param)
 1817:    tmp += '<widget name="mySubt%s1" position="%d,%d" foregroundColor="#00ffff88" %s />' % (names[i], left, titleH + btnH + 1, param)
 1818:    left += btnW + gap
 1819:   tmp += '<widget name="mySubtCursor" position="0,%d" size="%d,%d" zPosition="2" backgroundColor="#00ffff00" />' % (titleH + 1, btnW + gap * 2, btnH * 2 + gap - 1)
 1820:   top = titleH + 1 + btnH * 2 + gap
 1821:   tmp += '<widget name="mySubtCover" position="0,0" size="%d,%d" zPosition="5" backgroundColor="#ff000000" />' % (width, top - 1)
 1822:   tmp += '<widget name="mySubtFr" position="0,%d" size="%d,%d" zPosition="3" backgroundColor="#ff002233" />' % (top, width, height - top)
 1823:   for i in range(4):
 1824:    tmp += '<widget name="mySubtSep%d" position="1,%d" size="%d,1" zPosition="7" backgroundColor="#00555555" />' % (i, top + 1, width - 2)
 1825:    if i < 3:
 1826:     tmp += '<widget name="mySubt%d" position="1,%d" size="%d,%d" zPosition="6" noWrap="1" backgroundColor="#00000000" %s %s />' % (i, top + 1, width - 2, titleH - 2, bodyFontStr, alignCenter)
 1827:    top += titleH
 1828:   y, w1, = 1, int(width / 3.0)
 1829:   x = int((width - w1) / 2.0)
 1830:   tmp += '<widget name="mySubtChng0" position="%d,0" size="%d,%d" zPosition="8" backgroundColor="#22555555" />' % (x-1, w1+2, btnH*3 + 5)
 1831:   fnt = 'font="%s;%d"' % (VVNhAq, int(btnH * 0.63))
 1832:   for i in range(1, 4):
 1833:    fg, bg = ("#00FFFF00", "#22220000") if i == 1 else ("#00ffffff", "#33002233")
 1834:    tmp += '<widget name="mySubtChng%d" position="%d,%d" size="%d,%d" zPosition="9" foregroundColor="%s" backgroundColor="%s" %s %s />' % (i, x, y, w1, btnH, fg, bg, fnt, alignCenter)
 1835:    y += btnH + 1
 1836:   w = int(w1 / 6.5)
 1837:   h = int(btnH * 0.65)
 1838:   gap = int((btnH - h)/ 2)
 1839:   x += w1 - w - gap
 1840:   y = y - btnH + gap
 1841:   tmp += '<widget name="myRest1" position="%d,%d" size="%d,%d" zPosition="90" backgroundColor="#22a08000" font="%s;%d" %s />' % (x, y, w, h, VVNhAq, int(h * 0.7), alignCenter)
 1842:  elif VVON3k == VVakGB:
 1843:   barH = int((bodyH + VVpeQE - VVpeQE * 3.0) / 3.0)
 1844:   picW = int(bodyW * 0.07)
 1845:   barW = bodyW - picW - VVSZWt
 1846:   b1Top = bodyTop
 1847:   b2Top = b1Top + barH + VVpeQE
 1848:   b3Top = b2Top + barH + VVpeQE
 1849:   timeW = int(barW * 0.1)
 1850:   b2Left1 = VVSZWt
 1851:   b2Left2 = timeW + VVSZWt * 2
 1852:   b2Left4 = barW - timeW + VVSZWt
 1853:   b2Left3 = b2Left4 - VVSZWt - timeW
 1854:   pLeft = width - picW - VVSZWt
 1855:   FFipXTL = b2Left2 + timeW + VVSZWt
 1856:   FFipXTW = b2Left3 - VVSZWt - FFipXTL
 1857:   name = "myPlay"
 1858:   tmp += '<widget name="%sBarF"  position="%d,%d" size="%d,%d" zPosition="1" backgroundColor="#0a444444" />' % (name, VVSZWt, b1Top, barW, barH)
 1859:   tmp += '<widget name="%sBarBG" position="%d,%d" size="%d,%d" zPosition="2" backgroundColor="#11000000" />' % (name, VVSZWt + 1, b1Top + 1, barW - 2, barH - 2)
 1860:   tmp += '<widget name="%sBar"   position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="#06445566" />' % (name, VVSZWt + 1, b1Top + 1, barW - 2, barH - 2)
 1861:   tmp += '<widget name="%sMov"   position="%d,%d" size="%d,%d" zPosition="4" backgroundColor="#0aff8000" />' % (name, VVSZWt + 1, b1Top - 4, 3, barH + 8)
 1862:   tmp += '<widget name="%sVal"   position="%d,%d" size="%d,%d" zPosition="5" backgroundColor="#0a005555" foregroundColor="#ffffff" transparent="1" shadowColor="#00000000" shadowOffset="-1,-1" %s %s />' % (name, VVSZWt + 1, b1Top + 1, barW - 2, barH - 2, bodyFontStr, alignCenter)
 1863:   param = 'zPosition="1" noWrap="1" backgroundColor="%s" %s' % (VVPTnB, bodyFontStr)
 1864:   tmp += '<widget name="%sPos"  position="%d,%d" size="%d,%d" %s foregroundColor="#00aacccc" %s />' % (name, b2Left1, b2Top, timeW, barH, param, alignLeftCenter)
 1865:   tmp += '<widget name="%sSkp"  position="%d,%d" size="%d,%d" %s foregroundColor="#00ffff00" %s />' % (name, b2Left2, b2Top, timeW, barH, param, alignCenter)
 1866:   tmp += '<widget name="%sMsg"  position="%d,%d" size="%d,%d" %s foregroundColor="#00ffffff" %s />' % (name, FFipXTL , b2Top, FFipXTW , barH, param, alignCenter)
 1867:   tmp += '<widget name="%sRem"  position="%d,%d" size="%d,%d" %s foregroundColor="#00CDAE77" %s />' % (name, b2Left3, b2Top, timeW, barH, param, alignCenter)
 1868:   tmp += '<widget name="%sDur"  position="%d,%d" size="%d,%d" %s foregroundColor="#00B1C177" %s />' % (name, b2Left4, b2Top, timeW, barH, param, alignRightCenter)
 1869:   sepTop = int(b3Top - VVpeQE / 2.0)
 1870:   tmp += '<widget name="myPlaySep" position="0,%d" size="%d,1" zPosition="1" backgroundColor="#11444444" />' % (sepTop, pLeft)
 1871:   color = ["#0a004400", "#00555555", "#00bbbb55", "#00bbbb55", "#00999999", "#00999999", "#00999999", "#00FFFF88" , "#0a18188b"]
 1872:   names = ["Grn"  , "Jmp"   , "Dat"   , "Tim"    , "Res"   , "Fps"   , "Asp"   , "Yel"  , "Blu"]
 1873:   Len  = len(names)
 1874:   b3W  = int((barW - VVSZWt * (Len - 1)) / Len)
 1875:   left = VVSZWt
 1876:   for i in range(Len):
 1877:    if i in (0, Len-1) : bg = 'foregroundColor="#00FFFFFF" backgroundColor="%s"' % color[i]
 1878:    else     : bg = 'foregroundColor="%s"'        % color[i]
 1879:    tmp += '<widget name="myPlay%s" position="%d,%d" size="%d,%d" zPosition="1" noWrap="1" %s %s %s />' % (names[i], left, b3Top + 1, b3W, barH, bodyFontStr, alignCenter, bg)
 1880:    if names[i] == "Blu":
 1881:     txtW = 25
 1882:     barH2 = (barH - 8) // 3
 1883:     barTop = b3Top + 2
 1884:     barTL = left + 15
 1885:     barL = barTL + txtW + 5
 1886:     bW  = pLeft - barL - VVSZWt
 1887:     fSz  = int(barH2 * 0.9)
 1888:     namesB = ("SNR", "AGC", "BER")
 1889:     for i1 in range(3):
 1890:      tmp += '<widget name="mySliderTxt%s" position="%d,%d" size="%d,%d" zPosition="4" noWrap="1" font="%s;%d" foregroundColor="#00aaaaaa" backgroundColor="#1100102a" %s />' % (namesB[i1], barTL, barTop, txtW, barH2, VVNhAq, fSz, alignRightCenter)
 1891:      tmp += '<widget name="mySliderFrm%s" position="%d,%d" size="%d,%d" zPosition="4" backgroundColor="#333333" />' % (namesB[i1], barL-1, barTop-1, bW+2, barH2+2)
 1892:      tmp += '<widget name="mySliderBak%s" position="%d,%d" size="%d,%d" zPosition="5" backgroundColor="%s" />' % (namesB[i1], barL, barTop, bW, barH2, VVPTnB)
 1893:      tmp += '<widget name="mySliderPic%s" position="%d,%d" size="%d,%d" zPosition="6" alphatest="blend" />' % (namesB[i1], barL, barTop, bW, barH2)
 1894:      tmp += '<widget name="mySliderCov%s" position="%d,%d" size="%d,%d" zPosition="7" />' % (namesB[i1], barL, barTop, bW, barH2)
 1895:      barTop += barH2 + 4
 1896:    left += b3W + VVSZWt
 1897:   pTop = titleH + 6
 1898:   pW  = width - pLeft - 8
 1899:   pH  = height - pTop - 4
 1900:   tmp += '<eLabel position="%d,%d" size="1,%d" zPosition="1" backgroundColor="#00333333" />' % (pLeft, titleH + 2, height - titleH + 1)
 1901:   tmp += '<widget name="myPlayPic" position="%d,%d" size="%d,%d" zPosition="1" alphatest="blend" />' % (pLeft + 4, pTop, pW, pH)
 1902:   tmp += '<widget name="myPlayTyp" position="%d,%d" size="%d,%d" zPosition="1" backgroundColor="#1100202a" %s %s />' % (pLeft + 4, pTop, pW, pH, alignCenter, bodyFontStr)
 1903:   sz = int(titleH * 0.6)
 1904:   top = int((titleH - sz) / 2.0)
 1905:   gap = 6
 1906:   lft = width - sz - (titleH * 2 + gap * 2)
 1907:   for nm in ( "myPlayCc", "myPlayAud", "myPlayDnld", "myPlayRpt"):
 1908:    tmp += '<widget name="%s" position="%d,%d" size="%d,%d" zPosition="10" alphatest="blend" />' % (nm, lft, top, sz, sz)
 1909:    lft -= sz + gap
 1910:   params = 'zPosition="10" backgroundColor="#11444411"'
 1911:   tmp += '<eLabel %s position="0,0"  size="%d,1" />' % (params, width)
 1912:   tmp += '<eLabel %s position="0,%d" size="%d,1" />' % (params, height - 1, width)
 1913:   tmp += '<eLabel %s position="0,0"  size="1,%d" />' % (params, height)
 1914:   tmp += '<eLabel %s position="%d,0" size="1,%d" />' % (params, width - 1, height -1)
 1915:  elif VVON3k == VVnUU2:
 1916:   w  = int((width - 10) / 4.0)
 1917:   h  = bodyH - 10
 1918:   left = 5
 1919:   top  = bodyTop + 5
 1920:   tmp += '<widget name="myColorF" position="%d,%d" size="%d,%d" zPosition="1" backgroundColor="#00ffffff" />' % (left, top, w, h)
 1921:   for i in range(4):
 1922:    tmp += '<widget name="myColor%d" position="%d,%d" size="%d,%d" zPosition="2" backgroundColor="%s" foregroundColor="#ffffff" %s %s />' % (i, left + 4, top + 4, w - 8, h - 8, VVPTnB, bodyFontStr, alignLeftCenter)
 1923:    left += w
 1924:  elif VVON3k == VVUcno:
 1925:   itemsH  = bodyLineH * 2.0
 1926:   menuH  = int(bodyLineH * 2.5)
 1927:   menuW  = int(ratioW  * 200)
 1928:   menuLeft = int((width - menuW) / 2.0)
 1929:   textH  = bodyH - menuH
 1930:   menuTop  = bodyTop + textH
 1931:   itemsTop = int(menuTop + VVpeQE / 2.0 + (menuH - itemsH) / 2.0)
 1932:   tmp += '<widget name="myLine"  position="0,%d"  size="%d,1"  zPosition="3" backgroundColor="#11444444" />' % (menuTop, width)
 1933:   tmp += '<widget name="myLabel" position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="%s" foregroundColor="#ffffff" %s %s />' % (VVSZWt, bodyTop, bodyW, textH, VVPTnB, alignCenter, bodyFontStr)
 1934:   tmp += '<widget name="myMenu"  position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="%s" foregroundColor="#ffffff" scrollbarMode="showOnDemand" itemHeight="%d" />' % (menuLeft, itemsTop, menuW, itemsH, VVPTnB, bodyLineH)
 1935:  elif VVON3k == VVvJlJ:
 1936:   tmp += '<widget name="myTableH" position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="%s" scrollbarMode="showOnDemand" scrollbarWidth="%d" />' % (VVSZWt, bodyTop, bodyW, 0, VVPTnB, scrollBarW)
 1937:   tmp += '<widget name="myTable"  position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="%s" scrollbarMode="showOnDemand" scrollbarWidth="%d" />' % (VVSZWt, bodyTop, bodyW, bodyH, VVPTnB, scrollBarW)
 1938:  elif VVON3k == VVkFCt:
 1939:   perc1, perc2, tbg1, tbg2, bg1, bg2 = VVUuJZ["perc1"], VVUuJZ["perc2"], VVUuJZ["tbg1"], VVUuJZ["tbg2"], VVUuJZ["bg1"], VVUuJZ["bg2"]
 1940:   lblH = int(titleH * 0.75)
 1941:   lblF = int(lblH * 0.65)
 1942:   mnuF = int(lblH * 0.7)
 1943:   w1 = int((width - VVSZWt * 4) * perc1 / 100.0)
 1944:   w2 = int((width - VVSZWt * 4) * (100 - perc1) / 100.0)
 1945:   wt1 = int(w2 * perc2 / 100.0)
 1946:   wt2 = w2 - wt1
 1947:   bgW = width // 2
 1948:   lft2 = VVSZWt + w1 + VVSZWt * 2
 1949:   mTop = bodyTop + lblH + 3
 1950:   h = bodyH - lblH
 1951:   h = height - VVeFSs - mTop - VVpeQE
 1952:   lblP = 'noWrap="1" font="%s;%d" %s' % (VVNhAq, lblF, alignCenter)
 1953:   tmp += '<widget position="%d,%d" size="%d,%d" name="myTitle1" backgroundColor="%s" %s />' % (VVSZWt, bodyTop, w1, lblH, tbg1, lblP)
 1954:   tmp += '<widget position="%d,%d" size="%d,%d" name="myTitle2" backgroundColor="%s" %s />' % (lft2, bodyTop , wt1-3, lblH, tbg2, lblP)
 1955:   tmp += '<widget position="%d,%d" size="%d,%d" name="myTitle3" backgroundColor="%s" %s />' % (lft2 + wt1 + 2, bodyTop, wt2-2, lblH, tbg2, lblP)
 1956:   tmp += '<widget position="%d,%d" size="%d,%d" name="myFrm1" backgroundColor="%s" />' % (VVSZWt, mTop, w1, h, bg1)
 1957:   tmp += '<widget position="%d,%d" size="%d,%d" name="myFrm2" backgroundColor="%s" />' % (lft2, mTop, w2, h, bg2)
 1958:   gap, gap2 = 8, 16
 1959:   mnuP = 'transparent="1" scrollbarMode="showOnDemand" scrollbarWidth="%d"' % scrollBarW
 1960:   tmp += '<widget position="%d,%d" zPosition="2" size="%d,%d" name="list"   %s />' % (VVSZWt + gap, mTop + gap, w1 - gap2, h - gap2, mnuP)
 1961:   tmp += '<widget position="%d,%d" zPosition="2" size="%d,%d" name="myMenu" %s />' % (lft2 + gap, mTop + gap, w2 - gap2, h - gap2, mnuP)
 1962:  elif VVON3k == VVHfYH:
 1963:   titleFont = int(VVgbF2 * 0.6)
 1964:   boxFont  = int(VVgbF2 * 1.2)
 1965:   boxH  = int(VVgbF2 * 2.0)
 1966:   digitW  = int(VVgbF2 * 1.3)
 1967:   names  = ["year", "month", "day", "gap", "hour", "min", "sec"]
 1968:   boxW  = [  4   ,    2   ,   2  ,   1  ,   2   ,   2  ,   2  ]
 1969:   gap   = 4
 1970:   boxLeft  = int((width - digitW * 15) / 2.0 - gap)
 1971:   btnTitleH = titleFont * 2
 1972:   titleTop = int(bodyTop + (height - VVeFSs - bodyTop - (btnTitleH + boxH + gap)) / 2.0)
 1973:   boxTop  = titleTop + btnTitleH + gap
 1974:   tmp += '<widget name="curTime" position="0,%d" size="%d,%d" zPosition="2" foregroundColor="white" transparent="1" %s %s />' % (titleH + 1, width, titleTop - titleH - 2, bodyFontStr, alignCenter)
 1975:   par = 'zPosition="3" foregroundColor="white" backgroundColor="#11404040" %s' % alignCenter
 1976:   for i in range(0, 7):
 1977:    tmpW = digitW * boxW[i]
 1978:    tmp += '<widget name="%s" position="%d,%d" size="%d,%d" font="%s;%d" %s />' % (names[i]+"Title", boxLeft, titleTop, tmpW - gap, btnTitleH, VVNhAq, titleFont, par)
 1979:    tmp += '<widget name="%s" position="%d,%d" size="%d,%d" font="%s;%d" %s />' % (names[i], boxLeft, boxTop, tmpW - gap, boxH, VVNhAq, boxFont, par)
 1980:    boxLeft += tmpW + boxW[i]
 1981:  elif VVON3k == VVDEl1:
 1982:   titleFont = int(VVgbF2 * 0.6)
 1983:   boxFont  = int(VVgbF2 * 1.2)
 1984:   boxH  = int(VVgbF2 * 2.0)
 1985:   digitW  = int(VVgbF2 * 1.3)
 1986:   names, boxW = ["sign", "hour", "min"], [2, 4, 4]
 1987:   gap   = 6
 1988:   boxLeft  = int((width - digitW * 10) / 2.0 - gap)
 1989:   btnTitleH = titleFont * 2
 1990:   titleTop = int(bodyTop + (height - VVeFSs - bodyTop - (btnTitleH + boxH + gap)) / 2.0)
 1991:   boxTop  = titleTop + btnTitleH + gap
 1992:   par   = 'zPosition="3" foregroundColor="white" backgroundColor="%s" %s' % (VVPTnB, alignCenter)
 1993:   for i in range(0, 3):
 1994:    tmpW = digitW * boxW[i]
 1995:    tmp += '<widget name="%s" position="%d,%d" size="%d,%d" font="%s;%d" %s />' % (names[i]+"Title", boxLeft, titleTop, tmpW - gap, btnTitleH, VVNhAq, titleFont, par)
 1996:    tmp += '<widget name="%s" position="%d,%d" size="%d,%d" font="%s;%d" %s />' % (names[i], boxLeft, boxTop, tmpW - gap, boxH, VVNhAq, boxFont, par)
 1997:    boxLeft += tmpW + boxW[i]
 1998:  elif VVON3k == VVnhJ8:
 1999:   barW = int(ratioW  * 500)
 2000:   infH = int(titleH * 0.8)
 2001:   infTop = height - infH
 2002:   infFont = int(0.5  * infH)
 2003:   bAreaH = int(height - titleH - infH)
 2004:   barH = int((bAreaH - VVpeQE * 4) / 3)
 2005:   barTop = titleH + VVpeQE
 2006:   barL = int(width - barW - titleH / 2)
 2007:   txtW = barL - VVSZWt - 4
 2008:   name = [ "SNR", "AGC", "BER"]
 2009:   tmp += '<widget name="mySNRdB" text="0 dB" position="%d,%d" size="%d,%d" %s %s zPosition="4" transparent="1" foregroundColor="white" />' % (0, 0, width - 20, titleH, bodyFontStr, alignRightCenter)
 2010:   for i in range(3):
 2011:    tmp += '<eLabel position="%d,%d" size="%d,%d" zPosition="5" text="%s" %s %s backgroundColor="%s" foregroundColor="white" />' % (VVSZWt, barTop, txtW, barH, name[i], bodyFontStr, alignLeftCenter, VVPTnB)
 2012:    tmp += '<eLabel position="%d,%d" size="%d,%d" zPosition="4" backgroundColor="#ffffff" />' % (barL-1, barTop-1, barW+2, barH+2)
 2013:    tmp += '<eLabel position="%d,%d" size="%d,%d" zPosition="4" backgroundColor="%s" />' % (barL, barTop, barW, barH, VVPTnB)
 2014:    tmp += '<widget name="mySlider%s" position="%d,%d" size="%d,%d" zPosition="5" alphatest="blend" />' % (name[i], barL, barTop, barW, barH)
 2015:    tmp += '<widget name="mySliderCov%s" position="%d,%d" size="%d,%d" zPosition="6" />' % (name[i], barL, barTop, barW, barH)
 2016:    tmp += '<widget name="my%s" position="%d,%d" size="%d,%d" %s %s zPosition="7" text="0 " foregroundColor="#ffffff" transparent="1" shadowColor="#00000000" shadowOffset="-1,-1" />' % (name[i], barL, barTop, barW, barH, bodyFontStr, alignCenter)
 2017:    barTop += barH + VVpeQE
 2018:   tmp += '<widget name="myTPInfo" position="0,%d" size="%d,%d" zPosition="8" backgroundColor="%s" font="%s;%d" %s />' % (infTop, width, infH, VVOJKe, VVNhAq, infFont, alignCenter)
 2019:   tmp += '<eLabel position="0,%d"  size="%d,1"  zPosition="9" backgroundColor="#22aaaaaa" />' % (infTop -1, width)
 2020:  elif VVON3k == VVsg3D:
 2021:   totBars = VVUuJZ.get("totBars")
 2022:   h1  = int(bodyH / 2.0) if totBars == 2 else bodyH
 2023:   barL = VVSZWt
 2024:   barT = bodyTop
 2025:   barW = bodyW
 2026:   barH = int((height - bodyTop - VVpeQE * 2 ) / 2.0) if totBars == 2 else int(height - bodyTop - VVpeQE)
 2027:   fontH= int(0.7  * barH)
 2028:   for i in range(1, 3):
 2029:    tmp += '<widget name="myProgFr%s" position="%d,%d" size="%d,%d" zPosition="2" backgroundColor="#ffffff" />' % (i, barL-1, barT-1, barW+2, barH+2)
 2030:    tmp += '<widget name="myProgBG%s" position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="%s" />' % (i, barL, barT, barW, barH, VVPTnB)
 2031:    tmp += '<widget name="myProgFG%s" position="%d,%d" size="%d,%d" zPosition="4" backgroundColor="#884422" foregroundColor="#ffffff" />' % (i, barL, barT, barW, barH)
 2032:    tmp += '<widget name="myProgVal%s" position="%d,%d" size="%d,%d" zPosition="5" foregroundColor="#ffffff" transparent="1" shadowColor="#00000000" shadowOffset="-1,-1" font="%s;%d" %s />' % (i, barL, barT, barW, barH, VVNhAq, fontH, alignCenter)
 2033:    barT += h1 + int(VVpeQE / 2.0)
 2034:  elif VVON3k in (VVujxw, VVpLGo):
 2035:   totRows , totCols= VVUuJZ.get("rows"), VVUuJZ.get("cols")
 2036:   picR , lblR  = VVUuJZ.get("picR"), VVUuJZ.get("lblR")
 2037:   w1  , w2  = int(width * VVUuJZ.get("w1R")), int(width * VVUuJZ.get("w2R"))
 2038:   transpBG = VVUuJZ.get("trC")
 2039:   upSBar  = VVUuJZ.get("upSBar", False)
 2040:   bGap  = VVUuJZ.get("bGap", 0)
 2041:   infH = int(height * 0.092)
 2042:   addH = int(infH * (1000 - height) / 1000.0)
 2043:   infH += addH if addH > 0 else 0
 2044:   infT = titleH + 1
 2045:   boxT = infT + infH + VVpeQE + 2
 2046:   boxW = int((width - bGap * (totCols - 1) - (0 if upSBar else VVt3Ak) - VVSZWt * 2)  / totCols)
 2047:   boxH = int((height - bGap  * (totRows - 1)  - VVeFSs - boxT - VVpeQE) / totRows)
 2048:   s = '<widget name="myPiconInf%d" position="%d,%d" size="%d,%d" zPosition="1" foregroundColor="%s" noWrap="1" backgroundColor="%s" font="%s;%d" %s />'
 2049:   h = int(infH * 0.3333)
 2050:   y = infT
 2051:   fg= "#00ffffff"
 2052:   if VVON3k == VVujxw:
 2053:    totInf = 6
 2054:    fntSz, bg = int(h * 0.7), ("#00002828", "#00003333", "#00004444", "#00002233", "#00003344", "#00004455")
 2055:    for i in range(3):
 2056:     tmp += s % (i  , 0   , y, w1, h, fg, bg[i]  , VVNhAq, fntSz, alignLeftCenter)
 2057:     tmp += s % (i+3, w1+1, y, w2, h, fg, bg[i+3], VVNhAq, fntSz, alignLeftCenter)
 2058:     y += h
 2059:   else:
 2060:    totInf = 4
 2061:    h1, h2 = int(infH * 0.58), int(infH * 0.42)
 2062:    tmp += s % (0, 0, y  , w1, h1 , "#0088ff88", "#00333333", VVNhAq, int(h1 * 0.7), alignLeftCenter)
 2063:    tmp += s % (1, 0, y + h1, w1, h2 , "#00aaaaaa", "#002a2a2a", VVNhAq, int(h2 * 0.7), alignLeftCenter)
 2064:    h, fntSz, fg, bg = int(infH * 0.50), int(h2 * 0.60), "#00888888", "#0a111111"
 2065:    tmp += s % (2, w1, y , w2, h, fg, bg, VVNhAq, fntSz, alignCenter)
 2066:    tmp += s % (3, w1, y + h, w2, h, fg, bg, VVNhAq, fntSz, alignCenter)
 2067:   retPar = VVSZWt, boxT, boxW, boxH, infT, infH, totInf, bGap
 2068:   tmp += '<eLabel position="0,%d"  size="%d,1"  zPosition="1" backgroundColor="#00555555" />' % (infT + infH, width)
 2069:   pT = infT + 3
 2070:   pH = infH - 6
 2071:   pW = int(pH * 1.66)
 2072:   pL = width - pW - 12
 2073:   tmp += '<widget name="myPiconF"   position="%d,%d" size="%d,%d" zPosition="2" backgroundColor="#0a555500" />' % (pL    , pT    , pW  , pH)
 2074:   tmp += '<widget name="myPiconBG"  position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="#0a220000" />' % (pL + 1, pT + 1, pW - 2 , pH - 2)
 2075:   tmp += '<widget name="myPiconPic" position="%d,%d" size="%d,%d" zPosition="4" alphatest="blend" />'    % (pL + 2, pT + 2, pW - 4 , pH - 5)
 2076:   tmp += '<widget name="myCursorLbl" position="%d,%d" size="%d,%d" zPosition="5" backgroundColor="#00ffff66" />' % (VVSZWt, boxT + VVpeQE, boxW-2, boxH-2)
 2077:   tmp += '<widget name="myCursorPic" position="%d,%d" size="%d,%d" zPosition="5" alphatest="on" scale="1" />' % (VVSZWt, boxT + VVpeQE, boxW-2, boxH-2)
 2078:   picBgTr = 'transparent="1"' if VVUuJZ.get("picBgTr", 0) else ""
 2079:   lblTr = 'transparent="1"' if VVUuJZ.get("lblTr", 0) else ""
 2080:   lblFR = VVUuJZ.get("lblFR", 0.65)
 2081:   lblFg = VVUuJZ.get("lblFg", "#00ffffff")
 2082:   lblBg = VVUuJZ.get("lblBg", VVPTnB)
 2083:   gapX = VVUuJZ.get("gapX", 4)
 2084:   gapY = VVUuJZ.get("gapY", 4)
 2085:   midGap = VVUuJZ.get("mGap", 0)
 2086:   percBar = VVUuJZ.get("percBar", 0)
 2087:   areaW = boxW - gapX * 2
 2088:   areaH = boxH - gapY * 2 - midGap
 2089:   picT = boxT + gapY
 2090:   picH = int(areaH * picR)
 2091:   lblH = int(areaH * lblR)
 2092:   lblT = boxT + gapY + picH + midGap
 2093:   lblFS= int(lblH * lblFR)
 2094:   transpBG = 'backgroundColor="%s"'% transpBG if transpBG else ""
 2095:   boxT1 = boxT
 2096:   for row in range(totRows):
 2097:    left = VVSZWt + gapX
 2098:    for col in range(totCols):
 2099:     tmp += '<widget name="myPosterBak%d%d" position="%d,%d" size="%d,%d" zPosition="4" alphatest="blend" scale="1" />' % (row, col, left-gapX, boxT1, boxW, boxH)
 2100:     tmp += '<widget name="myPosterRep%d%d" position="%d,%d" size="%d,%d" zPosition="6" %s %s />' % (row, col, left, picT, areaW, picH, transpBG, picBgTr)
 2101:     tmp += '<widget name="myPosterLbl%d%d" position="%d,%d" size="%d,%d" zPosition="7" foregroundColor="%s" backgroundColor="%s" noWrap="1" %s font="%s;%d" %s />' % (row, col, left, lblT, areaW, lblH, lblFg, lblBg, lblTr, VVNhAq, lblFS, alignCenter)
 2102:     tmp += '<widget name="myPosterPic%d%d" position="%d,%d" size="%d,%d" zPosition="13" alphatest="blend" />' % (row, col, left, picT, areaW, picH)
 2103:     if percBar:
 2104:      x, y, w, h =  left, lblT + lblH + 5, areaW, lblH // 3
 2105:      tmp += '<widget name="myPercFr%d%d" position="%d,%d" size="%d,%d" zPosition="10" backgroundColor="#00ffffff" />' % (row, col, x, y, w, h)
 2106:      tmp += '<widget name="myPercBG%d%d" position="%d,%d" size="%d,%d" zPosition="11" backgroundColor="%s" />'   % (row, col, x+1, y+1, w-2, h-2, lblBg)
 2107:      tmp += '<widget name="myPercFG%d%d" position="%d,%d" size="%d,%d" zPosition="12" backgroundColor="#0055aabb" />' % (row, col, x+1, y+1, w-2, h-2)
 2108:     left += boxW + bGap
 2109:    boxT1 += boxH + bGap
 2110:    picT += boxH + bGap
 2111:    lblT += boxH + bGap
 2112:  elif VVON3k == VVrQU9:
 2113:   totRows = 6
 2114:   totCols = 8
 2115:   tstW = int(width - VVSZWt  * 2)
 2116:   tstH = int(height * 0.15)
 2117:   tstT = int(height - VVeFSs - tstH)
 2118:   boxT = titleH + 2
 2119:   boxW = int(width  / totCols)
 2120:   boxH = int((height - VVeFSs - tstH - boxT) / totRows)
 2121:   tmp += '<widget name="myColorPtr" position="%d,%d" size="%d,%d" zPosition="1" backgroundColor="#00aaaa00" />' % (0, boxT, boxW, boxH)
 2122:   gap  = VVpeQE
 2123:   gap1 = int(gap / 2.0)
 2124:   for row in range(totRows):
 2125:    boxL = 0
 2126:    for col in range(totCols):
 2127:     tmp += '<widget name="myColor%d%d" position="%d,%d" size="%d,%d" zPosition="2" backgroundColor="#00000000" />' % (row, col, boxL+gap1, boxT+gap1, boxW-gap, boxH-gap)
 2128:     boxL += boxW
 2129:    boxT += boxH
 2130:   tmp += '<widget name="myColorTst" position="%d,%d" size="%d,%d" zPosition="2" backgroundColor="#00aaaaaa" %s %s />' % (VVSZWt, tstT, tstW, tstH, alignCenter, bodyFontStr)
 2131:  elif VVON3k == VVsVfC:
 2132:   tmp += '<widget name="myPic" position="0,%d" size="%d,%d" zPosition="4" alphatest="blend" />' % (bodyTop+1, bodyW, bodyH-1)
 2133:  else:
 2134:   if   VVON3k == VVf2e8 : align = alignLeftCenter
 2135:   elif VVON3k == VVmSQ6 : align = alignLeftTop
 2136:   else          : align = alignCenter
 2137:   if VVON3k == VV5jiO:
 2138:    iconSize = 60
 2139:    iconLeft = int(ratioH  * 20)
 2140:    iconTop  = int(bodyTop + (height - bodyTop - iconSize) / 2.0)
 2141:    iconW  = iconSize + iconLeft * 2
 2142:    VVSZWt += iconW
 2143:    bodyW  -= iconW
 2144:    tmp += '<widget name="errPic" position="%d,%d" size="%d,%d" zPosition="4" alphatest="blend" />' % (iconLeft, iconTop, iconSize, iconSize)
 2145:   fontName = VVNhAq
 2146:   if VVOde7 and VVON3k == VVmSQ6:
 2147:    fLst = FFNOP7()
 2148:    if   VVUm9t in fLst and CFG.fontPathTerm.getValue(): fontName = VVUm9t
 2149:    elif VV2DFQ in fLst         : fontName = VV2DFQ
 2150:   VVpRUN = 'backgroundColor="%s" foregroundColor="#ffffff" font="%s;%d" %s ' % (VVPTnB, fontName, VVgbF2, align)
 2151:   tmp += '<widget name="myLabel" position="%d,%d" size="%d,%d" zPosition="4" %s />' % (VVSZWt, bodyTop, bodyW, bodyH, VVpRUN)
 2152:  infoW  = int(ratioW  * 500)
 2153:  infoH  = int(ratioH  * 100)
 2154:  infoLeft = int((width - infoW) / 2.0)
 2155:  infoTop  = int((height - infoH) / 2.0)
 2156:  VVwdmN = int(ratioH  * 30)
 2157:  tmp += '<widget name="myInfoFrame" position="%d,%d" size="%d,%d" zPosition="20" backgroundColor="#aaaa00" />' % (infoLeft, infoTop, infoW, infoH)
 2158:  tmp += '<widget name="myInfoBody"  position="%d,%d" size="%d,%d" zPosition="21" backgroundColor="#550000" foregroundColor="#ffff00" font="%s;%d" %s />' % (infoLeft+2, infoTop+2, infoW-4, infoH-4, VVNhAq, VVwdmN, alignCenter)
 2159:  if VV0Ay7 > 0:
 2160:   gap = 6
 2161:   sz = titleH - gap * 2
 2162:   mnuL= width - sz - gap * 2
 2163:   infL= mnuL if VV0Ay7 == 3 else mnuL - sz - gap
 2164:   par = 'size="%d,%d" zPosition="20" alphatest="blend"' % (sz, sz)
 2165:   if VV0Ay7 in (1, 2): tmp += '<widget name="keyMenu" position="%d,%d" %s />' % (mnuL, gap, par)
 2166:   if VV0Ay7 in (2, 3): tmp += '<widget name="keyInfo" position="%d,%d" %s />' % (infL, gap, par)
 2167:   if VVON3k == VVvJlJ:
 2168:    w = int(ratioH  * 200)
 2169:    tmp += '<widget name="myTotSel" position="%d,%d" size="%d,%d" zPosition="20" backgroundColor="#550055" font="%s;%d" %s />' % (infL - gap - w, gap, w, sz, VVNhAq, int(sz * 0.6), alignCenter)
 2170:  if VVeFSs > 0:
 2171:   lineTop = height - VVeFSs
 2172:   topGap = max(3, int(ratioH  * 3))
 2173:   btnTop = lineTop + topGap
 2174:   btnH = height - btnTop - topGap
 2175:   barFont = int(0.7  * btnH)
 2176:   gap  = btnH
 2177:   spaceW = gap * (5)
 2178:   btnW = int((width - spaceW) / 4)
 2179:   left = gap
 2180:   name = [ "keyRed"   , "keyGreen" , "keyYellow", "keyBlue"  ]
 2181:   tmp += '<widget name="myBar"  position="0,%d"  size="%d,%d" zPosition="7" backgroundColor="%s" font="%s;%d" %s />' % (lineTop, width, height - lineTop, VVOJKe, VVNhAq, barFont, alignLeftCenter)
 2182:   tmp += '<widget name="myLine" position="0,%d"  size="%d,1"  zPosition="8" backgroundColor="#22aaaaaa" />' % (lineTop, width)
 2183:   for i in range(4):
 2184:    tmp += '<widget name="%s" position="%d,%d" size="%d,%d" zPosition="9" backgroundColor="%s" font="%s;%d" foregroundColor="white" noWrap="1" %s />' % (name[i], left, btnTop, btnW, btnH, VVq9cv[i], VVNhAq, barFont, alignCenter)
 2185:    left += btnW + gap
 2186:  if VVt3Ak:
 2187:   par = 'position="0,0" size="20,20"'
 2188:   tmp += '<widget name="mySbFrm" zPosition="13" %s />' % par
 2189:   tmp += '<widget name="mySbBak" zPosition="14" %s />' % par
 2190:   tmp += '<widget name="mySbSld" zPosition="15" %s />' % par
 2191:  if VVON3k == VVmSQ6 or VVUuJZ.get("topBtnEW", 0):
 2192:   btnW = int(ratioW  * (85 + VVUuJZ.get("topBtnEW", 0)))
 2193:   btnH = int(titleH * 0.6)
 2194:   btnTop = int(titleH * 0.2)
 2195:   btnLeft = width - (btnW + btnTop) * 4
 2196:   btnFont = int(btnH * 0.65)
 2197:   name = [ "Red", "Green", "Yellow", "Blue" ]
 2198:   for i in range(4):
 2199:    tmp += '<widget name="key%sTop1" position="%d,%d" size="%d,%d" zPosition="10" backgroundColor="#0affffff" />' % (name[i], btnLeft, btnTop, btnW, btnH)
 2200:    tmp += '<widget name="key%sTop"  position="%d,%d" size="%d,%d" zPosition="11" backgroundColor="%s" font="%s;%d" foregroundColor="white" %s />' % (name[i], btnLeft+1, btnTop+1, btnW-2, btnH-2, VVq9cv[i], VVNhAq, btnFont, alignCenter)
 2201:    btnLeft += (btnW + btnTop)
 2202:  if VVdrEC:
 2203:   w, h = VVdrEC
 2204:   w = int(ratioW  * w) if w > 0 else int(width  * 0.2)
 2205:   h = int(ratioH  * h) if h > 0 else int(w * 0.75)
 2206:   x, y = width - w - VVSZWt - scrollBarW * 2, bodyTop
 2207:   tmp += '<widget name="myPicF" position="%d,%d" size="%d,%d" zPosition="7" backgroundColor="#0affffff" />' % (x-1, y-1, w+2, h+2)
 2208:   tmp += '<widget name="myPicB" position="%d,%d" size="%d,%d" zPosition="8" backgroundColor="%s" />'   % (x, y, w, h, VVPTnB)
 2209:   tmp += '<widget name="myPic"  position="%d,%d" size="%d,%d" zPosition="9" alphatest="blend" />'    % (x, y, w, h)
 2210:   retPar = x, y, w, h
 2211:  tmp += '</screen>'
 2212:  VVfOli = {"VVON3k":VVON3k, "width":width, "height":height, "titleH":titleH, "VVSZWt":VVSZWt, "VVpeQE":VVpeQE, "VVOJKe":VVOJKe, "VVPTnB":VVPTnB, "VVgbF2":VVgbF2, "VVeFSs":VVeFSs, "VV0Ay7":VV0Ay7, "bodyLineH":bodyLineH, "scrollBarW":scrollBarW, "VVptue":VVptue, "retPar":retPar, "VVUuJZ":VVUuJZ}
 2213:  return tmp, VVfOli
 2214: class CC6cFV(Screen):
 2215:  def __init__(self, session):
 2216:   self.skin, self.VVfOli = FFiNEe(VVWp3I, 800, 1050, 40, 40, 20, "#1a002244", "#10002233", 33, VVeFSs=40, VV0Ay7=2)
 2217:   self.session  = session
 2218:   self.VVG4nJ = ""
 2219:   self.VVYh0m  = r"0{4}t{2}f?$"
 2220:   self.themsList  = []
 2221:   self.Title   = "%s - %s" % (VVh9hj, VVJ6zn)
 2222:   self.timer   = eTimer()
 2223:   self.chkVerResult = ""
 2224:   self.VVpQCY = True
 2225:   VV3wat = []
 2226:   if VVS9Q2:
 2227:    VV3wat.append(("-- MY TEST --", "myTest" ))
 2228:   VV3wat.append(("File Manager"  , "fMan" ))
 2229:   VV3wat.append(VVAL3j)
 2230:   VV3wat.append(("IPTV"    , "iptv" ))
 2231:   VV3wat.append(("Movies Browser" , "movie" ))
 2232:   VV3wat.append(("Services/Channels", "chan" ))
 2233:   VV3wat.append(("Bouquet Editor" , "bouq" ))
 2234:   VV3wat.append(("PIcons"   , "picon" ))
 2235:   VV3wat.append(("EPG"    , "epg"  ))
 2236:   VV3wat.append(VVAL3j)
 2237:   VV3wat.append(("Terminal"   , "term" ))
 2238:   VV3wat.append(("SoftCam"   , "soft" ))
 2239:   VV3wat.append(("Plugins"   , "plug" ))
 2240:   VV3wat.append(("Backup & Restore" , "bakup" ))
 2241:   VV3wat.append(VVAL3j)
 2242:   VV3wat.append(("Date/Time"  , "date" ))
 2243:   VV3wat.append(("Network"   , "net"  ))
 2244:   FFZMxC(self, title=self.Title, VV3wat=VV3wat)
 2245:   FFRLNq(self["keyRed"] , "Exit")
 2246:   FFRLNq(self["keyGreen"] , "Settings")
 2247:   FFRLNq(self["keyYellow"], "Dev. Info.")
 2248:   FFRLNq(self["keyBlue"] , "Color/Font")
 2249:   FFBep1(self,
 2250:   {
 2251:    "red" : self.close     ,
 2252:    "green" : self.VVvcU7    ,
 2253:    "yellow": self.VV9fkx    ,
 2254:    "blue" : self.VVfK2F   ,
 2255:    "info" : self.VV6Vdq    ,
 2256:    "menu" : self.VV8DSN  ,
 2257:    "text" : BF(self.VVtMoq, "t")  ,
 2258:    "f4" : BF(self.VVtMoq, "f")  ,
 2259:    "0"  : BF(self.VVTDgd, 0) ,
 2260:    "1"  : BF(self.VVeDfm, "fMan") ,
 2261:    "2"  : BF(self.VVeDfm, "iptv") ,
 2262:    "3"  : BF(self.VVeDfm, "movie") ,
 2263:    "4"  : BF(self.VVeDfm, "chan") ,
 2264:    "5"  : BF(self.VVeDfm, "bouq") ,
 2265:    "6"  : BF(self.VVeDfm, "picon") ,
 2266:    "7"  : BF(self.VVeDfm, "epg") ,
 2267:    "8"  : BF(self.VVeDfm, "term") ,
 2268:    "9"  : BF(self.VVeDfm, "soft") ,
 2269:    "last" : BF(self.VVeDfm, "plug") ,
 2270:    "next" : BF(self.VVeDfm, "bakup")
 2271:   })
 2272:   self.onShown.append(self.VV7OzD)
 2273:   self.onClose.append(self.onExit)
 2274:   global VVWe5f, VVBvqf, VVaWs8
 2275:   VVWe5f = VVBvqf = 0
 2276:   VVaWs8 = 1
 2277:  def VVPr1F(self):
 2278:   self.VVeDfm(self["myMenu"].l.getCurrentSelection()[1])
 2279:  def VVeDfm(self, item):
 2280:   if item is not None:
 2281:    for ndx, param in enumerate(self["myMenu"].list):
 2282:     if len(param) > 1 and param[1] == item:
 2283:      self["myMenu"].moveToIndex(ndx)
 2284:      break
 2285:    global VV3knk
 2286:    VV3knk = self["myMenu"].l.getCurrentSelection()[0].strip()
 2287:    if   item == "myTest" : self.VVMtb4()
 2288:    elif item == "fMan"  : self.session.open(CClYaF)
 2289:    elif item == "iptv"  : self.session.open(CCkEI5)
 2290:    elif item == "movie" : CCG2jh.VV7hTj(self)
 2291:    elif item == "chan"  : self.session.open(CCYrUm)
 2292:    elif item == "bouq"  : self.session.open(CCLSIv)
 2293:    elif item == "picon" : self.VVD3q5()
 2294:    elif item == "epg"  : self.session.open(CC5TsO)
 2295:    elif item == "term"  : self.session.open(CCtzVm)
 2296:    elif item == "soft"  : FFimQ3(self, BF(self.session.open, CCid3A))
 2297:    elif item == "plug"  : self.session.open(CCeSkW)
 2298:    elif item == "bakup" : self.session.open(CCxSED)
 2299:    elif item == "date"  : self.session.open(CCbQCK)
 2300:    elif item == "net"  : self.session.open(CCJIaP)
 2301:  def VV7OzD(self):
 2302:   FF2GM8(self)
 2303:   if self.VVpQCY:
 2304:    self.VVpQCY = False
 2305:    FF4IPF(self["myMenu"])
 2306:    FFWgBS(self)
 2307:    FF6W0I(self)
 2308:    self.VVxS6b()
 2309:  def VVxS6b(self):
 2310:   if not hasattr(self["myMenu"].instance, "setTextOffset"):
 2311:    for ndx, item in enumerate(self["myMenu"].list):
 2312:     if len(item) == 2:
 2313:      self["myMenu"].list[ndx] = ("   %s" % item[0], item[1])
 2314:   FFzcnD(self)
 2315:   self.VVsLLY()
 2316:   if (VV5xkJ or VVNA43 or VVS9Q2):
 2317:    FFZ0AC(self["myTitle"], "#ff0000")
 2318:   var = "PLUGIN" + "_VERSION"
 2319:   if var in globals():
 2320:    FF28n1(self, "Welcome", 300)
 2321:   if CFG.checkForUpdateAtStartup.getValue():
 2322:    self["myTitle"].instance.setFont(gFont(VVNhAq, 30))
 2323:    self["myTitle"].setText("  %s      %s" % (VVh9hj, FFjt5L("Checking for updates ...", VVA4XU)))
 2324:    try: self.timer_conn = self.timer.timeout.connect(self.VV1bB4)
 2325:    except: self.timer.callback.append(self.VV1bB4)
 2326:    self.timer.start(500, False)
 2327:    myThread = iThread(name="ajp_chk_ver", target=self.VVjUSC)
 2328:    myThread.start()
 2329:  def VV1bB4(self):
 2330:   if self.chkVerResult:
 2331:    self.timer.stop()
 2332:    if self.chkVerResult == "no":
 2333:     fnt = gFont(VVNhAq, 33)
 2334:     txt = self.Title
 2335:    else:
 2336:     fnt = gFont(VVNhAq, 30)
 2337:     txt = "%s    (v%s available)" % (self.Title, self.chkVerResult)
 2338:    self["myTitle"].instance.setFont(fnt)
 2339:    self["myTitle"].setText("  %s" % txt)
 2340:  def VVjUSC(self):
 2341:   url = CCJaSw.VVYs9i()
 2342:   curVer = VVJ6zn
 2343:   path, err = FFx9uM(url + "version", "ajp_tmp.ver", timeout=2)
 2344:   if err or not FFCyVu(path):
 2345:    self.chkVerResult = "no"
 2346:   else:
 2347:    cVer, wVer, isHigher = CCeSkW.VV2PRQ(curVer, FFYVq0(path))
 2348:    FFwgGB(path)
 2349:    self.chkVerResult = wVer if isHigher else "no"
 2350:  def onExit(self):
 2351:   self.timer.stop()
 2352:   FFIFeD()
 2353:   global VVWe5f, VVBvqf
 2354:   VVWe5f = VVBvqf = 0
 2355:   FFYDZ6("VVaWs8")
 2356:  def VVTDgd(self, digit):
 2357:   self.VVG4nJ += str(digit)
 2358:   ln = len(self.VVG4nJ)
 2359:   global VVWe5f
 2360:   if ln == 4:
 2361:    if self.VVG4nJ == "0" * ln:
 2362:     VVWe5f = 1
 2363:     FFZ0AC(self["myTitle"], "#11805040")
 2364:    else:
 2365:     self.VVG4nJ = "x"
 2366:  def VVtMoq(self, s):
 2367:   self.VVG4nJ += s
 2368:   if iMatch(self.VVYh0m, self.VVG4nJ):
 2369:    global VVBvqf
 2370:    VVBvqf, c = (2, "#ff8000") if self.VVG4nJ.endswith("f") else (1, "#dd5588")
 2371:    FFZ0AC(self["myTitle"], c)
 2372:  def VVD3q5(self):
 2373:   found = False
 2374:   pPath = CCafIt.VVjkKT()
 2375:   if VVmJwX(pPath):
 2376:    for fName, fType in CCafIt.VVq4T1(pPath):
 2377:     if fName:
 2378:      found = True
 2379:      break
 2380:   if found:
 2381:    self.session.open(CCafIt)
 2382:   else:
 2383:    VV3wat = []
 2384:    VV3wat.append(("PIcons Tools" , "CCafIt" ))
 2385:    VV3wat.append(VVAL3j)
 2386:    VV3wat.append(CCafIt.VVdmZZ())
 2387:    VV3wat.append(VVAL3j)
 2388:    VV3wat += CCafIt.VVC3jQ()
 2389:    FFLFTC(self, self.VVWtJl, VV3wat=VV3wat)
 2390:  def VVWtJl(self, item=None):
 2391:   if item:
 2392:    if   item == "CCafIt"   : self.session.open(CCafIt)
 2393:    elif item == "VVZxA1"  : CCafIt.VVZxA1(self)
 2394:    elif item == "VVS8ig"  : CCafIt.VVS8ig(self)
 2395:    elif item == "findPiconBrokenSymLinks" : CCafIt.VVqb9O(self, True)
 2396:    elif item == "FindAllBrokenSymLinks" : CCafIt.VVqb9O(self, False)
 2397:  @FFOAKH()
 2398:  def VV6Vdq(self):
 2399:   fil = VVIp2p + "_changeLog.txt"
 2400:   title = "%s %s  -  %s  (by AMAJamry)" % (VVh9hj, VVJ6zn, VVzOp7)
 2401:   if FFCyVu(fil):
 2402:    txt = "\n%s%s\n" % (FFjt5L("Home Page : ", VVFuwR), FFjt5L(CCJaSw.VVCcoN(), VVJEMb))
 2403:    lines  = FFL19l(fil)
 2404:    for line in lines:
 2405:     line = line.strip()
 2406:     if line and not line.startswith("#"):
 2407:      if line.startswith("[") and line.endswith("]"):
 2408:       line = line.replace("[", "").replace("]", "")
 2409:       line = FFjt5L("\n%s\n%s\n%s" % (SEP, line, SEP), VV1fx4, VVwdUw)
 2410:      elif line.strip().startswith("-"): line = "\n" + line
 2411:      elif line.strip().startswith(".."): line = FFjt5L(line, VVo7S9, VVwdUw)
 2412:      txt += line +"\n"
 2413:    FF4lCP(self, txt.strip(), title=title, VVwdmN=28, width=1600, height=1000, titleBg="#11000020", VVemyB="#0a00000a")
 2414:   else:
 2415:    FFdw58(self, "Change Log file not found:\n\n%s" % fil, title=title)
 2416:  def VV8DSN(self):
 2417:   VV3wat = []
 2418:   VV3wat.append(("Open Custom Menu ", "cMenu"))
 2419:   VV3wat.append(("Custom Menu Help" , "cmHlp"))
 2420:   VV3wat.append(VVAL3j)
 2421:   VV3wat.append(("Movies Resume History", "resum"))
 2422:   VV3wat.append(VVAL3j)
 2423:   VV3wat.append(("%s Optional Dependencies" % VVh9hj, "libr"))
 2424:   VV3wat.append(VVAL3j)
 2425:   VV3wat.append(("General Guide", "ghHlp" ))
 2426:   VV3wat.append(("Keys Help" , "hlp"  ))
 2427:   FFLFTC(self, self.VVRTdI, VV3wat=VV3wat, width=650, title="Options")
 2428:  def VVRTdI(self, item=None):
 2429:   if item:
 2430:    if   item == "cMenu": CCRlkm.VVEYRT(self)
 2431:    elif item == "cmHlp": FFw2rR(self, "_help_cmenu", "Custom Menu Help")
 2432:    elif item == "resum": self.session.open(CC6F0F)
 2433:    elif item == "libr" : self.VVwxzq()
 2434:    elif item == "ghHlp": self.VVLqG9()
 2435:    elif item == "hlp" : FFw2rR(self, "_help_main", "Main Page (Keys Help)")
 2436:  def VVLqG9(self):
 2437:   lst = [tuple(line.split("@")) for line in FFL19l(VVIp2p + "_hlpG") if "@" in line]
 2438:   if lst: FFLFTC(self, None, title="General Guide", VV3wat=sorted(lst), width=1200, height=1000, VVwltY="#11101100", VVkxBG="#11112222", VVOa1G=self.VV3DNo, VVU8mZ=True)
 2439:  def VV3DNo(self, item=None):
 2440:   if item:
 2441:    VV7tND, title, pic, ndx = item
 2442:    self.VVnppw(VV7tND, title, pic)
 2443:  @FFOAKH("Loading ...", par=1)
 2444:  def VVnppw(self, VV7tND, title, pic):
 2445:   url = CCJaSw.VVYs9i()
 2446:   path, err = FFx9uM(url + "help/%s" % pic, "ajp_tmp%s" % os.path.splitext(pic)[1], timeout=2)
 2447:   if err or not FFCyVu(path) : FFdw58(self, "Cannot get help file from server !", title=title)
 2448:   else       : CCf8zb.VVjnMn(self, path, title=title)
 2449:   FFwgGB(path)
 2450:  def VVvcU7(self) : self.session.open(CCJaSw)
 2451:  def VV9fkx(self) : self.session.open(CC674y)
 2452:  def VVfK2F(self):
 2453:   title = "Colors and Fonts"
 2454:   c1, c2, c3, c4, c5 = VVZtfx, VVyFI2, VVFuwR, VVJEMb, VVIH76
 2455:   added = CFG.fontPathAdd.getValue()
 2456:   VV3wat = []
 2457:   VV3wat.append((c1 + "Change Title Colors"   , "title"  ))
 2458:   VV3wat.append((c1 + "Change Menu Area Colors"  , "body"  ))
 2459:   VV3wat.append((c1 + "Change Menu Pointer Colors" , "cursor"  ))
 2460:   VV3wat.append((c1 + "Change Bottom Bar Colors" , "bar"   ))
 2461:   VV3wat.append((c2 + "Reset Colors"    , "resetColor" ))
 2462:   VV3wat.append(VVAL3j)
 2463:   VV3wat.append((c3 + "Change %s Font" % VVh9hj, "mainFont" ))
 2464:   VV3wat.append((c3 + "Change Terminal Font"   , "termFont" ))
 2465:   VV3wat.append(VVAL3j)
 2466:   VV3wat.append(FFsLU5("Add Extra Font to System" , "addFont", not added , c4))
 2467:   VV3wat.append(FFsLU5("Replace Extra Font"  , "rplFont", added  , c4))
 2468:   VV3wat.append(FFsLU5("Remove Extra Font"  , "delFont", added  , c4))
 2469:   VV3wat.append(VVAL3j)
 2470:   VV3wat.append(FFsLU5("Change System Fonts Size" , "fntScl", not CFG.fontPathSys.getValue(), c5))
 2471:   VV3wat.append((c5 + "Change System Font"     , "sysFont" ))
 2472:   FFLFTC(self, BF(self.VVDebU, title), VV3wat=VV3wat, width=600, height=1000, title=title, VVwltY="#11001122", VVkxBG="#11001122")
 2473:  def VVDebU(self, title, item=None):
 2474:   if item:
 2475:    if item in ("title", "body", "cursor", "bar"):
 2476:     tDict = self.VVCMBG()
 2477:     fg = tDict.get("main_%s_fg" % item, "")
 2478:     bg = tDict.get("main_%s_bg" % item, "")
 2479:     self.session.openWithCallback(BF(self.VVh2PD, tDict, item), CC1FS2, defFG=fg, defBG=bg)
 2480:    elif item == "resetColor" : FFRMYv(self, self.VV7Rj8, "Reset to default colors ?", title=title)
 2481:    elif item == "mainFont"  : self.VVWtNV(VVNj6e)
 2482:    elif item == "termFont"  : self.VVWtNV(VVUm9t)
 2483:    elif item == "addFont"  : self.VVWtNV(VVLn2O)
 2484:    elif item == "rplFont"  : self.VVWtNV(VVLn2O)
 2485:    elif item == "delFont"  : FFRMYv(self, self.VVfQgy, "Remove Extra Font and Restart GUI ?", title="Remove Extra Font")
 2486:    elif item == "fntScl"  : self.VVgHDD()
 2487:    elif item == "sysFont"  : self.VVWtNV(VVnvzh, chFontSz=True)
 2488:  def VVfQgy(self):
 2489:   FFjt1c(CFG.fontPathAdd, "")
 2490:   CCp90q.VV6bHp(self)
 2491:  @FFOAKH()
 2492:  def VVwxzq(self):
 2493:   title = "%s Optional Dependencies (for more features)" % VVh9hj
 2494:   VVAkuK = self.VVcB2d()
 2495:   VVwSzI = ("Install"    , BF(self.VVnYkC, title), [])
 2496:   VV4QTJ  = ("Update Sys. Packages", self.VVhnZU , [])
 2497:   header  = ("Library", "State", "Usage" )
 2498:   widths  = (20   , 25  , 55  )
 2499:   VVLIqP = (LEFT  , CENTER , LEFT  )
 2500:   VV6A99 = FFUQ0v(self, None, title=title, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=28, width=1350, VVwSzI=VVwSzI, VV4QTJ=VV4QTJ, VVKDPJ=2)
 2501:  def VVnYkC(self, Title, VV6A99, title, txt, colList):
 2502:   pkg, state, usage = colList
 2503:   cbFnc = BF(self.VV47ii, VV6A99)
 2504:   if pkg == "xz" and "BusyBox" in state:
 2505:    FFbi5l(self, FF5sZa(VVwFAi, pkg), VVoasw=cbFnc, title=Title)
 2506:   elif "Installed" in state:
 2507:    FF1mVE(VV6A99, "Already installed.")
 2508:   else:
 2509:    pkgDict = self.VVX3o7()
 2510:    if   pkg == "requests" : CCwhE4.VVOJRa(self, cbFnc=cbFnc)
 2511:    elif pkg == "Imaging" : CC6u6z.VV181X(self, Title, False, cbFnc=cbFnc)
 2512:    elif pkg == "ar"  : FFbi5l(self, FFvQ9y(), VVoasw=cbFnc, title=Title)
 2513:    elif pkg in pkgDict  : FFbi5l(self, FFMAzK(pkgDict[pkg], pkg, pkg.capitalize()), VVoasw=cbFnc, title=Title)
 2514:  def VVhnZU(self, VV6A99, title, txt, colList):
 2515:   CCeSkW.VV3sSc(self)
 2516:  def VV47ii(self, VV6A99):
 2517:   VVAkuK = self.VVcB2d()
 2518:   VV6A99.VViSLW(VVAkuK[VV6A99.VVGTqU()])
 2519:  def VVcB2d(self):
 2520:   tDict = {}
 2521:   path = VVIp2p + "_sup_lib"
 2522:   if FFCyVu(path):
 2523:    for line in FFL19l(path):
 2524:     lib, _, txt = line.partition("=")
 2525:     tDict[lib] = txt
 2526:   def VVJi7Q(lib, ok):
 2527:    txt = tDict.get(lib, "")
 2528:    if ok: return (lib, "#f#0000ff00#" + "Installed" , txt)
 2529:    else : return (lib, "#f#00ff8000#" + "Not installed", txt)
 2530:   VVAkuK = []
 2531:   VVAkuK.append(VVJi7Q("requests", CCwhE4.VVOJRa(self, install=False)))
 2532:   VVAkuK.append(VVJi7Q("Imaging" , CC6u6z.VV181X(self, "", False, install=False)))
 2533:   VVAkuK.append(VVJi7Q("ar"   , CCeSkW.VVgrug()))
 2534:   for pkg, cmd in self.VVX3o7().items():
 2535:    row = VVJi7Q(pkg, FFayeZ(cmd))
 2536:    if pkg == "xz":
 2537:     pFound, pBBox = FFmCnY(pkg)
 2538:     if pFound and pBBox:
 2539:      c1 = VVYjI5
 2540:      stt = FFjt5L("BusyBox xz (old)", c1)
 2541:      usg = "%s  ...  %s" % (row[2], FFjt5L("xz v5 recommended", c1))
 2542:      row = (pkg, stt, usg)
 2543:    VVAkuK.append(row)
 2544:   VVAkuK.sort(key=lambda x: x[0].lower())
 2545:   return VVAkuK
 2546:  def VVX3o7(self):
 2547:   d = {}
 2548:   for pkg in ("xz", "zip", "p7zip", "unrar", "bzip2", "ffmpeg"):
 2549:    d[pkg] = pkg
 2550:   d["p7zip"] = "7za"
 2551:   return d
 2552:  def VVOaDJ(self):
 2553:   return FF0cqc() + "ajpanel_colors"
 2554:  def VVCMBG(self):
 2555:   tDict = { "main_title_fg" : ""
 2556:     , "main_title_bg" : ""
 2557:     , "main_body_fg" : ""
 2558:     , "main_body_bg" : ""
 2559:     , "main_cursor_fg" : ""
 2560:     , "main_cursor_bg" : ""
 2561:     , "main_bar_fg"  : ""
 2562:     , "main_bar_bg"  : ""
 2563:     }
 2564:   p = self.VVOaDJ()
 2565:   if FFCyVu(p):
 2566:    txt = FFYVq0(p)
 2567:    lst = iFindall(r"(.*[^\s])\s*=\s*(#(?:[A-Fa-f0-9]{8}))", txt, IGNORECASE)
 2568:    for txt, c in lst:
 2569:     tDict[txt] = c
 2570:   return tDict
 2571:  def VVh2PD(self, tDict, item, fg, bg):
 2572:   if fg:
 2573:    self.VV1Psn(item, fg)
 2574:    self.VVb1TK(item, bg)
 2575:    tDict["main_%s_fg" % item] = fg
 2576:    tDict["main_%s_bg" % item] = bg
 2577:    self.VVZ5At(tDict)
 2578:  def VVZ5At(self, tDict):
 2579:    p = self.VVOaDJ()
 2580:    with open(p, "w") as f:
 2581:     for key, val in tDict.items():
 2582:      f.write("%s=%s\n" % (key, val))
 2583:  def VV1Psn(self, item, fg):
 2584:   if   item == "title" : FFGUI5(self["myTitle"], fg)
 2585:   elif item == "body"  :
 2586:    FFGUI5(self["myMenu"], fg)
 2587:    FFGUI5(self["myBody"], fg)
 2588:   elif item == "cursor" : self["myMenu"].instance.setForegroundColorSelected(parseColor(fg))
 2589:   elif item == "bar"  :
 2590:    for item in ("myBar", "keyRed", "keyGreen", "keyYellow", "keyBlue"): FFGUI5(self[item], fg)
 2591:  def VVb1TK(self, item, bg):
 2592:   if   item == "title" : FFZ0AC(self["myTitle"], bg)
 2593:   elif item == "body"  :
 2594:    FFZ0AC(self["myMenu"], bg)
 2595:    FFZ0AC(self["myBody"], bg)
 2596:   elif item == "cursor" : self["myMenu"].instance.setBackgroundColorSelected(parseColor(bg))
 2597:   elif item == "bar"  : FFZ0AC(self["myBar"], bg)
 2598:  def VV7Rj8(self):
 2599:   FFpwZS("rm '%s'" % self.VVOaDJ())
 2600:   self.close()
 2601:  def VVsLLY(self):
 2602:   tDict = self.VVCMBG()
 2603:   for item in ("title", "body", "cursor", "bar"):
 2604:    self.VV3kNF(tDict, item)
 2605:  def VV3kNF(self, tDict, name):
 2606:   fg = tDict.get("main_%s_fg" % name, "")
 2607:   bg = tDict.get("main_%s_bg" % name, "")
 2608:   if fg: self.VV1Psn(name, fg)
 2609:   if bg: self.VVb1TK(name, bg)
 2610:  def VVgHDD(self):
 2611:   cur = CFG.fontAllPerc.getValue()
 2612:   tab = lambda sign, rng:  [("%s%s%s  %s %%" % (" " * 15, VVSGsk if i == cur else "", sign, abs(i)), i) for i in rng]
 2613:   lst = tab("+", [x for x in range(5, 45, 5)])
 2614:   lst.append(VVAL3j)
 2615:   lst.extend(tab("-", [x for x in range(-5,-45, -5)]))
 2616:   if cur != 0:
 2617:    lst.insert(0, VVAL3j)
 2618:    lst.insert(0, ("Reset Size %s" % FFjt5L(" (Requires GUI Restart)", VVIH76), 0))
 2619:   FFLFTC(self, self.VVs6ym, VV3wat=lst, title="Change Size", width=700, height=1050, VVwdmN=28, VVwltY="#22221122", VVkxBG="#22220022")
 2620:  @FFOAKH()
 2621:  def VVs6ym(self, addPerc):
 2622:   if addPerc is None or addPerc == CFG.fontAllPerc.getValue(): return
 2623:   if addPerc == 0:
 2624:    FFRMYv(self, self.VVdRGg, "Restore and Restart ?", title="Restore Original Font Size")
 2625:   else:
 2626:    FFjt1c(CFG.fontAllPerc, addPerc)
 2627:    if CC6cFV.VVVGio():
 2628:     self.hide()
 2629:     self.show()
 2630:    else:
 2631:     FFjADj(self, "Cannot change fonts", 1500)
 2632:  def VVdRGg(self):
 2633:   FFjt1c(CFG.fontAllPerc, 0)
 2634:   CCp90q.VV6bHp(self)
 2635:  @FFOAKH()
 2636:  def VVWtNV(self, which, chFontSz=False):
 2637:   if   which == VVNj6e  : rest, defFnt, title = False, CFG.fontPathMain.getValue(), VVh9hj
 2638:   elif which == VVUm9t : rest, defFnt, title = False, CFG.fontPathTerm.getValue(), "Terminal "
 2639:   elif which == VVLn2O  : rest, defFnt, title = True , CFG.fontPathAdd.getValue() , "System Extra"
 2640:   elif which == VVnvzh  : rest, defFnt, title = True , CFG.fontPathSys.getValue() , "System"
 2641:   CCEBvG.VVpZFB(self, "Change %s Font" % title, defFnt, rest, BF(self.VVorz3, which), chFontSz)
 2642:  def VVorz3(self, which, fntPar=None):
 2643:   if fntPar: path, scale = fntPar
 2644:   else  : return
 2645:   if path == "DEFAULT": path = ""
 2646:   if   which == VVNj6e  : FFjt1c(CFG.fontPathMain, path)
 2647:   elif which == VVUm9t: FFjt1c(CFG.fontPathTerm, path)
 2648:   elif which == VVLn2O  : FFjt1c(CFG.fontPathAdd , path)
 2649:   elif which == VVnvzh:
 2650:    FFjt1c(CFG.fontPathSys , path)
 2651:    FFjt1c(CFG.fontScaleSys, scale if path else 100)
 2652:   err = CC6cFV.VVSfcK(which)
 2653:   if err          : FFdw58(self, err, title=title)
 2654:   elif which == VVNj6e   : self.close()
 2655:   elif which == VVUm9t  : FF1mVE(self, "Terminal font applied", 1500)
 2656:   elif which == VVLn2O and path : FF1mVE(self, "Font Added", 1500)
 2657:   elif which == VVnvzh and path: FF1mVE(self, "System font applied", 1500)
 2658:   elif which == VVnvzh   : FFRMYv(self, BF(CCp90q.VV6bHp, self), "Font changed (will take effect after GUI Restart).\n\nRestart GUI ?", title="Reset font to default")
 2659:  @staticmethod
 2660:  def VVAeob():
 2661:   if CFG.fontPathSys.getValue():
 2662:    CC6cFV.VVSfcK(VVNj6e  )
 2663:    CC6cFV.VVSfcK(VVUm9t)
 2664:    CC6cFV.VVSfcK(VVLn2O  )
 2665:    CC6cFV.VVSfcK(VVnvzh  )
 2666:   elif CFG.fontAllPerc.getValue() != 0:
 2667:    CC6cFV.VVVGio()
 2668:  @staticmethod
 2669:  def VVVGio():
 2670:   perc, tot = CFG.fontAllPerc.getValue(), 0
 2671:   for name, scale, repl, fName, fPath, skinF in FFcFmA():
 2672:    newScale = int(int(scale) + float(scale) * int(perc) / 100.0)
 2673:    if FFXcbU(fPath, name, scale=newScale, isRepl=1 if repl else 0):
 2674:     tot += 1
 2675:   return tot
 2676:  @staticmethod
 2677:  def VVSfcK(name):
 2678:   if   name == VVNj6e : path, repl = CFG.fontPathMain.getValue(), 0
 2679:   elif name == VVUm9t: path, repl = CFG.fontPathTerm.getValue(), 0
 2680:   elif name == VVLn2O  : path, repl = CFG.fontPathAdd.getValue() , 1
 2681:   elif name == VVnvzh : path, repl = CFG.fontPathSys.getValue() , 1
 2682:   if not path:
 2683:    FFNOP7()
 2684:    return ""
 2685:   elif not FFCyVu(path):
 2686:    return "Font file not found"
 2687:   scale = 100
 2688:   nameLst = []
 2689:   if name == VVnvzh:
 2690:    scale = CFG.fontScaleSys.getValue()
 2691:    nameLst = []
 2692:    for nm in FFNOP7():
 2693:     if not nm in (VVNj6e, VVUm9t):
 2694:      nameLst.append(nm)
 2695:   else:
 2696:    nameLst = [name]
 2697:   totDone = 0
 2698:   for fntName in nameLst:
 2699:    if FFXcbU(path, fntName, scale=scale, isRepl=repl):
 2700:     totDone += 1
 2701:   if totDone > 0: FFNOP7()
 2702:   else    : return "Could not add font"
 2703:  def VVMtb4(self):
 2704:   CCqWM2.VVHc02(self.session)
 2705: class CChtNF(Screen):
 2706:  def __init__(self, session, mode=0, dstP="", evName=""):
 2707:   self.skin, self.VVfOli = FFiNEe(VVlrZA, 510, 510, 30, 0, 0, "
 2708:   self.session = session
 2709:   self.mode  = mode
 2710:   self.dstP  = dstP
 2711:   self.evName  = evName or CC5TsO.VVMZqx(self)
 2712:   self.pDir  = "/tmp/ajp_p/"
 2713:   self.cleanName = CCa36K.VVD1PA()
 2714:   self.tbl  = None
 2715:   FFZMxC(self)
 2716:   self.onShown.append(self.VV7OzD)
 2717:  def VV7OzD(self):
 2718:   self.onShown.remove(self.VV7OzD)
 2719:   self.VVobpU()
 2720:  def cancel(self, VV6A99=None, ret=None):
 2721:   if self.tbl: self.tbl.cancel()
 2722:   self.VV1omp()
 2723:   self.close(ret)
 2724:  def VVQ5VQ(self, err, end=False):
 2725:   FFdw58(self, err, self.evName or "Get Poster")
 2726:   if end: self.cancel()
 2727:  def VV1omp(self):
 2728:   FFpwZS("rm -rf '%s'" % self.pDir)
 2729:  @FFOAKH()
 2730:  def VVobpU(self):
 2731:   self.evName = self.cleanName(self.evName)
 2732:   if not self.evName:
 2733:    self.VVQ5VQ("Invalid Event Name", True)
 2734:    return
 2735:   self.VV1omp()
 2736:   if not FFpwZS("mkdir -p '%s'" % self.pDir):
 2737:    self.VVQ5VQ("Cannot create working directory", True)
 2738:    return
 2739:   if self.mode == 0:
 2740:    self.mode = 1
 2741:    lst, err = self.VVwuhm()
 2742:    if not lst:
 2743:     self.mode = 2
 2744:     lst, err = self.VVCYeR()
 2745:     if err:
 2746:      self.VVQ5VQ(err, True)
 2747:      return
 2748:   else:
 2749:    if self.mode == 1: lst, err = self.VVwuhm()
 2750:    else    : lst, err = self.VVCYeR()
 2751:    if err:
 2752:     self.VVQ5VQ(err, True)
 2753:     return
 2754:   if not lst:
 2755:    self.VVQ5VQ("Not found", True)
 2756:    return
 2757:   if self.mode == 1:
 2758:    for ndx, (titl, rel, ov, smlU, page, ratio) in enumerate(lst):
 2759:     ratio1 = CCafIt.VV8e0X(self.evName, self.cleanName(titl))
 2760:     lst[ndx] = (titl, rel, ov, smlU, page, ratio1)
 2761:    lst = sorted(lst, key=lambda x: (x[5], x[1].lower(), x[0].lower()), reverse=True)
 2762:   else:
 2763:    for ndx, (titl, cap, rel, topCr, picU, smlU, ratio) in enumerate(lst):
 2764:     ratio1 = CCafIt.VV8e0X(self.evName, self.cleanName(titl))
 2765:     lst[ndx] = (titl, cap, rel, topCr, picU, smlU, ratio1)
 2766:    lst = sorted(lst, key=lambda x: (x[6], x[2].lower(), x[0].lower()), reverse=True)
 2767:   picDic = self.VVJFKy(lst)
 2768:   VVAkuK = []
 2769:   if self.mode == 1:
 2770:    bg = VVkxBG="#22002233"
 2771:    for ndx, (titl, rel, ov, smlU, page, ratio) in enumerate(lst):
 2772:     VVAkuK.append((str(ndx + 1), "", titl, rel, ov, picDic.get(ndx, ""), page, str(ratio)))
 2773:   else:
 2774:    bg = VVkxBG="
 2775:    for ndx, (titl, cap, rel, topCr, picU, smlU, ratio) in enumerate(lst):
 2776:     if cap and (cap == titl or cap == topCr or cap == "%s (%s)" % (titl, rel)): cap = ""
 2777:     if cap and topCr: ov = "%s ... %s" % (cap, topCr)
 2778:     else   : ov = cap or topCr
 2779:     VVAkuK.append((str(ndx + 1), "", titl, rel, ov, picDic.get(ndx, ""), picU, str(ratio)))
 2780:   VVu8qI = self.cancel
 2781:   VVu1YM  = ("View Poster"    , self.VVeCNN , [])
 2782:   VV2ytr = (""       , self.VVDj4v  , [])
 2783:   if self.dstP: VVScQz = ("Select"  , self.VVpBL3  , [])
 2784:   else  : VVScQz = ("Save Poster" , self.VVUCUp , [])
 2785:   VV4QTJ = ("More Posters"    , self.VVownO , []) if self.mode == 1 else None
 2786:   VVoGCy  = (1, None, 5)
 2787:   header  = ("Num" , "" , "Title" , "Release" , "Overview", "smlP", "picU", "ratio" )
 2788:   widths  = (6  , 3  , 42  , 10  , 39  , 0  , 0  , 0   )
 2789:   VVLIqP = (CENTER , LEFT , LEFT  , CENTER , LEFT  , LEFT , LEFT , LEFT  )
 2790:   self.tbl = FFUQ0v(self, None, title=self.evName, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, width=1800, height=950, VV3cHe=widths, VVwdmN=28, VVu1YM=VVu1YM, VV2ytr=VV2ytr, VVu8qI=VVu8qI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVdrEC=(0, 240), VVoGCy=VVoGCy
 2791:     , VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVoRat="#11ffff00", VVJKqd="#11220000", VVbcr0=bg, VVX9AA="#11400040")
 2792:   self.tbl.VVIOX6(self.VVwjNh)
 2793:  def VVownO(self, VV6A99, title, txt, colList):
 2794:   VV6A99.cancel()
 2795:   self.mode, self.tbl = 2, None
 2796:   self.VVobpU()
 2797:  def VVwjNh(self):
 2798:   if not self.tbl.VVacFr(self.tbl.VV5crm()[5]):
 2799:    self.tbl.VVTOb9()
 2800:  def VVeCNN(self, VV6A99, title, txt, colList):
 2801:   self.VVy7WX(0, colList[6])
 2802:  def VVDj4v(self, VV6A99, title, txt, colList):
 2803:   num, pstr, titl, rel, ov, smlP, picU, ratio = colList
 2804:   txt  = "Title\t: %s\n" % titl
 2805:   if rel: txt += "Release\t: %s\n" % rel
 2806:   if ov : txt += "\n%s\n%s" % (FFjt5L("Overview", VVFuwR), ov)
 2807:   FF4lCP(self, txt, title)
 2808:  def VVpBL3(self, VV6A99, title, txt, colList):
 2809:   self.VVy7WX(3, colList[6])
 2810:  def VVUCUp(self, VV6A99, title, txt, colList):
 2811:   VV3wat = []
 2812:   VV3wat.append(("Set as a Poster for a Local Media", "1"))
 2813:   VV3wat.append(("Save to backup directory"   , "2"))
 2814:   FFLFTC(self, BF(self.VVjQ8l, colList[6]), title="Save Poster", VV3wat=VV3wat)
 2815:  def VVjQ8l(self, picU, item=None):
 2816:   if  item == "1": self.VVy7WX(1, picU)
 2817:   elif item == "2": self.VVy7WX(2, picU)
 2818:  def VVwuhm(self):
 2819:   res, err = CCHRcZ.VVcUJs(("s%=yreuq?hcraes/gro.bdeivomeht.www//:sptth")[::-1] % FFSiPR(self.evName), timeout=5)
 2820:   if err: return [], "Netowrk Error"
 2821:   lst = []
 2822:   d1 = iCompile(r'"lazy".+src="(.+\.jpg)".+srcset="(.+)"\salt="(.+)"')
 2823:   d2 = iCompile(r'href="(.+)"')
 2824:   d3 = iCompile(r'<span class="release_date">.+(\d{4})<')
 2825:   d4 = iCompile(r'<p>(.+)<\/p>')
 2826:   src1 = src2 = titl = page = rel = ov = ""
 2827:   for line in res.text.split("\n"):
 2828:    if "lazy" in line: src1 = src2 = titl = page = rel = ov = ""
 2829:    elif "search_results person hide" in line:  break
 2830:    span = d1.search(line)
 2831:    if span: src1, src2, titl = span.groups()
 2832:    span = d2.search(line)
 2833:    if span: page = "gro.bdeivomeht.www//:sptth"[::-1] + span.group(1)
 2834:    span = d3.search(line)
 2835:    if span: rel = span.group(1)
 2836:    span = d4.search(line)
 2837:    if span: ov = span.group(1)
 2838:    if all((src1, src2, titl, page, rel, ov)):
 2839:     src1, src2, titl, page, rel, ov = [CCDJgl.VVZwxs(str(x.encode().decode())).strip() for x in (src1, src2, titl, page, rel, ov)]
 2840:     pics = [src1]
 2841:     for pic in iFindall(r"(http.+?.jpg)", src2):
 2842:      pic = str(pic.encode().decode())
 2843:      if not pic in pics: pics.append(pic)
 2844:     lst.append((titl, rel, ov, pics[-1] if pics else "", page, 0))
 2845:     src1 = src2 = titl = page = rel = ov = ""
 2846:   return lst, "" if lst else "Not found"
 2847:  def VVCYeR(self):
 2848:   res, err = CCHRcZ.VVcUJs(("ms_rs_vn=_fer&s%=q&tt=s?/dnif/moc.bdmi.www//:sptth")[::-1] % FFSiPR(self.evName), timeout=5)
 2849:   if err: return [], "Netowrk Error"
 2850:   lst, err = self.VVLTOC(res.text)
 2851:   if err: return [], err
 2852:   return lst, ""
 2853:  def VVLTOC(self, txt):
 2854:   x = txt.find("<img alt=")
 2855:   if x == -1: return [], "Tag-1 not found"
 2856:   txt = txt[x:].replace("<img alt=", "\n<img alt=").replace("<svg", "\n<svg").replace("</a>", "</a>\n")
 2857:   lst1 = []
 2858:   for line in [ln for ln in txt.split("\n")]:
 2859:    if line.startswith("<img ") and not "Get the IMDb app" in line:
 2860:     span = iSearch(r'alt="(.+?)"\s+src="(.+?)"\s+srcSet="(.+?)".+\/title\/(.+?)\/', line)
 2861:     if not span: continue
 2862:     nam1, src1, src2, id1 = [CCDJgl.VVZwxs(str(x.encode().decode())) for x in span.groups()]
 2863:     pics = [src1]
 2864:     for pic in iFindall(r"(http.+?.jpg)", src2):
 2865:      pic = str(pic.encode().decode())
 2866:      if not pic in pics: pics.append(pic)
 2867:     lst1.append((nam1, pics, id1))
 2868:   lst2 = []
 2869:   span = iSearch(r'"titleResults":(.+}),"companyResults"', txt)
 2870:   if not span: return [], "Tag-2 not found"
 2871:   try:
 2872:    tDic = jLoads(span.group(1))["results"]
 2873:    for item in tDic:
 2874:     id2  = FFYjVd(item, "id")
 2875:     titl = FFYjVd(item, "titleNameText")
 2876:     rel  = FFYjVd(item, "titleReleaseText")
 2877:     topCr = FFYjVd(item, "topCredits")
 2878:     if not "titlePosterImageModel" in item: continue
 2879:     item = item["titlePosterImageModel"]
 2880:     picU = FFYjVd(item, "url")
 2881:     cap  = FFYjVd(item, "caption")
 2882:     try: topCr = ", ".join([CCDJgl.VVZwxs(str(x.encode())) for x in eval(topCr)])
 2883:     except: pass
 2884:     if not picU: continue
 2885:     titl, cap, rel, picU, id2 = [CCDJgl.VVZwxs(str(x.encode().decode())) for x in (titl, cap, rel, picU, id2)]
 2886:     rel = rel.strip(str(u"\u2013"))
 2887:     lst2.append((titl, cap, rel, topCr, picU, id2))
 2888:   except Exception as e:
 2889:    return [], str(e)
 2890:   l1, l2 = len(lst1), len(lst2)
 2891:   if  not all((l1, l2)) : return [], "Not found"
 2892:   elif not (l1 == l2)  : return [], "Incorrect Lengths (%s/%s)" % (l1, l2)
 2893:   pLst = []
 2894:   for titl, cap, rel, topCr, picU, id2 in lst2:
 2895:    for nam1, pics, id1 in lst1:
 2896:     if id1 == id2:
 2897:      row = (titl, cap, rel, topCr, picU, pics[-1] if pics else "", 0)
 2898:      if not row in pLst: pLst.append(row)
 2899:      break
 2900:    else:
 2901:     return [], "Incorrect IDs (1 & 2)"
 2902:   return pLst, "" if pLst else "No searh result"
 2903:  def VVJFKy(self, lst):
 2904:   def VVZwiy(ndx, smlU):
 2905:    path, err = FFx9uM(smlU, "p%s.jpg" % ndx, timeout=3, VVzHui=True, tmpPath=self.pDir)
 2906:    if path: picDic[ndx] = path
 2907:   picDic, threads = {}, []
 2908:   for ndx, item in enumerate(lst):
 2909:    if self.mode == 1: titl, rel, ov, smlU, page, ratio = item
 2910:    else    : titl, cap, rel, topCr, picU, smlU, ratio = item
 2911:    if smlU:
 2912:     thr = iThread(target=VVZwiy, args=(ndx, smlU))
 2913:     thr.start()
 2914:     threads.append(thr)
 2915:   for thr in threads: thr.join()
 2916:   return picDic
 2917:  def VVy7WX(self, mode, picU):
 2918:   FFimQ3(self.tbl, BF(self.VVYvOY, mode, picU))
 2919:  def VVYvOY(self, mode, picU):
 2920:   if self.mode == 1:
 2921:    picU = self.VVadfn(picU)
 2922:    if not picU: return
 2923:   path, err = FFx9uM(picU, "p.jpg", timeout=2, VVzHui=True, tmpPath=self.pDir)
 2924:   if path:
 2925:    resized, curW, curH, curW, curH = CC6u6z.VVV85P(path, 1200, 1800)
 2926:    if  mode == 0: CCf8zb.VVjnMn(self, path, title=self.evName, cbFnc=self.VVygsO)
 2927:    elif mode == 1: self.session.openWithCallback(BF(self.VVupqU, path), BF(CClYaF, VV1gDA="movies", VV1pbK=CFG.MovieDownloadPath.getValue()))
 2928:    elif mode == 2: self.VV6gua("Save to backup directory", path, FF0cqc() + self.evName + ".jpg")
 2929:    elif mode == 3: self.VV6gua("Save as Local Media Poster", path, self.dstP)
 2930:   else:
 2931:    self.VVQ5VQ("Cannot download poster")
 2932:  def VVygsO(self, path):
 2933:   FFwgGB(path)
 2934:  def VVadfn(self, url):
 2935:   picU = ""
 2936:   res, err = CCHRcZ.VVcUJs(url, timeout=3)
 2937:   if err:
 2938:    self.VVQ5VQ("Cannot get poster")
 2939:   else:
 2940:    for line in res.text.split("\n"):
 2941:     span = iSearch(r'srcset=".+,(.+)\s2x"', line)
 2942:     if span:
 2943:      picU = span.group(1)
 2944:      break
 2945:    else:
 2946:     self.VVQ5VQ("Cannot download poster")
 2947:   return picU
 2948:  def VVupqU(self, path, mPath):
 2949:   if mPath:
 2950:    dstF = "%s%s" % (os.path.splitext(mPath)[0], os.path.splitext(os.path.basename(path))[1])
 2951:    self.VV6gua("Save as Local Media Poster", path, dstF)
 2952:  def VV6gua(self, title, path, dst):
 2953:   if FFCyVu(dst) : FFRMYv(self, BF(self.VVddAM, title, path, dst), "Overwrite existing file ?", title=title)
 2954:   else    : self.VVddAM(title, path, dst)
 2955:  def VVddAM(self, title, path, dst):
 2956:   if FFpwZS("mv -f '%s' '%s'" % (path, dst)):
 2957:    if self.dstP: self.cancel(ret=path)
 2958:    else  : FFipXT(self, "Saved to:\n\n%s" % dst, False)
 2959:   else:
 2960:    self.VVQ5VQ("Cannot save file.")
 2961:    FFwgGB(path)
 2962: class CCMTfv():
 2963:  VVf0Wz = "ajpWebServer"
 2964:  def __init__(self, session):
 2965:   self.session = session
 2966:   tw = skt = srv = None
 2967:   try: from twisted.internet import reactor as tw
 2968:   except: pass
 2969:   try: import SocketServer as skt
 2970:   except:
 2971:    try: import socketserver as skt
 2972:    except: pass
 2973:   try: import SimpleHTTPServer as srv
 2974:   except:
 2975:    try: import http.server as srv
 2976:    except: pass
 2977:   self.VVAfaV, self.VVQf8x, self.VVjlTM = skt, srv, tw
 2978:  def VV0G75(self):
 2979:   if not self.VVAfaV or not self.VVQf8x: return
 2980:   fnc = self.VVN7Qw
 2981:   VVjlTM = self.VVjlTM
 2982:   class CC1yD2(self.VVQf8x.SimpleHTTPRequestHandler):
 2983:    def do_GET(self):
 2984:     self.VVHRFn("")
 2985:    def do_POST(self):
 2986:     length = int(self.headers["Content-Length"])
 2987:     data = str(self.rfile.read(length))
 2988:     self.VVHRFn(data)
 2989:    def VVHRFn(self, data):
 2990:     if   len(self.path) > 100: mode, rCode, rTxt = 1, 414, "URI Too Long"
 2991:     elif not VVjlTM   : mode, rCode, rTxt = 1, 400, "Missing Twisted Module"
 2992:     else      : mode, rCode, rTxt = fnc(self.path, data)
 2993:     if mode == 1:
 2994:      cType = "application/json"
 2995:      dic = {VVh9hj: VVJ6zn, "Request": self.path, "Result" : rTxt}
 2996:      rTxt = jDumps(dic).encode()
 2997:     else:
 2998:      cType = "text/html"
 2999:     self.send_response(rCode)
 3000:     self.send_header("Content-type", cType)
 3001:     self.end_headers()
 3002:     self.wfile.write(rTxt)
 3003:   try:
 3004:    global VV7R9N
 3005:    handler = CC1yD2
 3006:    self.VVAfaV.TCPServer.allow_reuse_address = True
 3007:    VV7R9N = self.VVAfaV.TCPServer(("", CFG.wsPort.getValue()), handler)
 3008:    th = iThread(name=CCMTfv.VVf0Wz, target=VV7R9N.serve_forever)
 3009:    th.setDaemon(True)
 3010:    th.start()
 3011:   except:
 3012:    pass
 3013:  def VVN7Qw(self, uPath, data):
 3014:   uPath = uPath.lower()
 3015:   if  uPath.startswith("/player"): rCode, rTxt = self.VVi03A(data)
 3016:   else       : rCode, rTxt = 400, "Unknown request"
 3017:   mode = 1
 3018:   return mode, rCode, rTxt
 3019:  def VVXiXt(self, fnc):
 3020:   def VVZwiy():
 3021:    if currentThread().getName() == "MainThread": fnc()
 3022:   if self.VVjlTM: self.VVjlTM.callFromThread(VVZwiy)
 3023:  def VVi03A(self, data):
 3024:   try: dic = jLoads(data)
 3025:   except: dic = {}
 3026:   tab = lambda x: FFXarh(str(dic[x]).strip()) if x in dic else ""
 3027:   url = tab("url")
 3028:   ref = tab("ref")
 3029:   name= tab("name")
 3030:   logo= tab("logo")
 3031:   endRef= tab("endRef")
 3032:   if not name and url.startswith("/"): name = os.path.splitext(os.path.basename(url))[0]
 3033:   name = name or "No Name"
 3034:   if ref and not iMatch(r"^((?:[A-Fa-f0-9]+[:]){10})$", ref)   : return 400, "Incorrect ref format"
 3035:   if endRef and not iMatch(r"^((?:[A-Fa-f0-9]+[:]){10}).*", endRef): return 400, "Incorrect endRef format"
 3036:   chUrl = ""
 3037:   if url:
 3038:    ref = ref or "%s:0:1:0:0:0:0:0:0:0:" % CFG.iptvAddToBouquetRefType.getValue()
 3039:    if  url.startswith("http") : url = FFSiPR(url)
 3040:    elif url.startswith("/") : pass
 3041:    else      : return 400, "Incorrect URL"
 3042:    chUrl = "%s%s:%s" % (ref.upper(), url, name)
 3043:   elif ref:
 3044:    chUrl = ref
 3045:   if CCqWM2.VVyLCv:
 3046:    txt = "Channel Changed" if ref else "Player is already shown"
 3047:    fnc = BF(CCqWM2.VVyLCv.VVU96j, chUrl, endRef, logo)
 3048:   else:
 3049:    txt = "Player Started"
 3050:    fnc = BF(CCqWM2.VVHc02, self.session, VVaHNe=chUrl, endRef=endRef, VVAfO9=logo)
 3051:   self.VVXiXt(fnc)
 3052:   return 200, txt
 3053:  def VVeTpx(self, trunOn):
 3054:   err = ""
 3055:   if not all((self.VVAfaV, self.VVQf8x)):
 3056:    err = "Missing Python libraries"
 3057:   else:
 3058:    isOn = CCMTfv.VVy1jd()
 3059:    if trunOn:
 3060:     if isOn : err = "Already running"
 3061:     else : self.VV0G75()
 3062:    else:
 3063:     if isOn : CCMTfv.VVVTz6()
 3064:     else : err = "Already stopped"
 3065:   return err, CCMTfv.VV9cQA()
 3066:  @staticmethod
 3067:  def VVVTz6():
 3068:   if "VV7R9N" in globals():
 3069:    global VV7R9N
 3070:    if hasattr(VV7R9N, "_BaseServer__shutdown_request"):
 3071:     VV7R9N._BaseServer__shutdown_request = True
 3072:    VV7R9N.shutdown()
 3073:    VV7R9N.server_close()
 3074:    FFYDZ6("VV7R9N")
 3075:  @staticmethod
 3076:  def VV9cQA():
 3077:   return "Turned %s" % ("ON" if CCMTfv.VVy1jd() else "OFF")
 3078:  @staticmethod
 3079:  def VVy1jd():
 3080:   thrListUrls = []
 3081:   for thr in iEnumerate():
 3082:    if thr.name == CCMTfv.VVf0Wz:
 3083:     return True
 3084:   else:
 3085:    return False
 3086: class CC3rDi():
 3087:  def __init__(self, session):
 3088:   self.Session = session
 3089:   self.servPtr  = CC3rDi.VVvi2b(self.Session)
 3090:   self.VVPxk5  = ""
 3091:   self.VVZcRP  = ""
 3092:   self.VV57TX  = ""
 3093:   self.VVfaDB  = ""
 3094:   self.VV1wIO   = ""
 3095:   self.prov   = ""
 3096:   self.state   = ""
 3097:   self.isMarker  = False
 3098:   self.info   = self.servPtr and self.servPtr.info()
 3099:   if self.info:
 3100:    self.VV1wIO  = self.info.getName()
 3101:    ref     = FFMzWf(self.info, iServiceInformation.sServiceref)
 3102:    state   = FFMzWf(self.info, iServiceInformation.sDVBState)
 3103:    self.prov  = FFMzWf(self.info, iServiceInformation.sProvider)
 3104:    self.isMarker = FFhPtm(ref)
 3105:    if self.isMarker:
 3106:     self.state = "Marker"
 3107:     self.VVPxk5 = ref.rstrip(":")
 3108:     self.VV1wIO = self.VVfa5Q()
 3109:    else:
 3110:     self.VVfaDB = ref if self.VVZcRP else ""
 3111:     self.state = self.VVOXOJ(state)
 3112:     self.VVPxk5, self.VVZcRP, self.VV57TX, self.VVfaDB = CC3rDi.VVGg6H(ref)
 3113:   self.servRef = CC3rDi.VVrnMj(self.Session)
 3114:   if self.servRef:
 3115:    self.Name  = self.servRef.getName()
 3116:    self.VVu06s = self.servRef.toString()
 3117:    self.VVpJLI = self.servRef.toCompareString()
 3118:    self.refType = str(self.servRef.type)
 3119:    self.Path  = self.servRef.getPath()
 3120:    self.isValid = self.servRef.valid()
 3121:    self.flags  = self.servRef.flags
 3122:    try: self.chNum = self.servRef.getChannelNum()
 3123:    except: self.chNum = 0
 3124:   else:
 3125:    self.Name  = ""
 3126:    self.VVu06s = ""
 3127:    self.VVpJLI = ""
 3128:    self.refType = ""
 3129:    self.Path  = ""
 3130:    self.isValid = False
 3131:    self.flags  = 0
 3132:    self.chNum  = 0
 3133:   span = iSearch(r"^((?:[A-F0-9]+[:]){9}(?:[A-F0-9]+))", self.VVPxk5 or self.VVu06s, IGNORECASE)
 3134:   self.VVXbok = span.group(1).upper().rstrip(":") if span else ""
 3135:   span = iSearch(r"http.+\/((?:[A-Fa-f0-9]+:){10}):", self.VVZcRP)
 3136:   self.VVAQqG = span.group(1).rstrip(":") if span else ""
 3137:   self.isLocal = self.isIptv = self.isFtp = self.isDvb = self.isDvbS = self.isDvbC = self.isDvbT = self.VVDiQp = False
 3138:   typ = ""
 3139:   if   "file?file" in self.VVu06s or ":ftp%3a//" in self.VVu06s : typ, self.isFtp = "FTP", True
 3140:   elif FFHgaY(self.VVu06s) or self.VVAQqG    : typ, self.VVDiQp= "S. Relay", True
 3141:   elif FFUPnc(self.VVu06s)          : typ, self.isIptv = "IPTV", True
 3142:   elif self.Path.startswith("/")         : typ, self.isLocal = "Local Media", True
 3143:   elif not self.Path:
 3144:    self.isDvb = True
 3145:    ns = FFARk6(self.VVu06s)
 3146:    if   ns.startswith("EEEE") : typ, self.isDvbT = "DVB-T", True
 3147:    elif ns.startswith("FFFF") : typ, self.isDvbC = "DVB-C", True
 3148:    else      : typ, self.isDvbS = "DVB-S", True
 3149:   self.streamType = typ
 3150:   span = iSearch(r"(.+)(mode=.+end=)", self.VVZcRP, IGNORECASE)
 3151:   if span:
 3152:    self.VVev7q = span.group(1).rstrip("&?")
 3153:    self.myPhp = span.group(2)
 3154:   else:
 3155:    self.VVev7q = ""
 3156:    self.myPhp = ""
 3157:   self.uniqueId = self.myPhp if self.myPhp else self.Path or self.VVPxk5
 3158:   self.userTxt = self.VVev7q or self.Path or self.VVPxk5
 3159:  def VVfa5Q(self):
 3160:   for r, n, f in CCMvE7.VVqZTI(mode=1):
 3161:    if self.VVPxk5 in r:
 3162:     return n
 3163:   return self.VV1wIO + " (Marker)"
 3164:  def VVOXOJ(self, s):
 3165:   if   not s :s=""
 3166:   elif s=="0" :s="*No free tuner"
 3167:   elif s=="1" :s="*Tune Failed"
 3168:   elif s=="2" :s="*Timeout reading PAT"
 3169:   elif s=="3" :s="*SID not found in PAT"
 3170:   elif s=="4" :s="*Timeout reading PMT"
 3171:   elif s=="5" :s="New program info"
 3172:   elif s=="6" :s="Tuned"
 3173:   elif s=="7" :s="Pre-Start"
 3174:   elif s=="8" :s="SOF"
 3175:   elif s=="9" :s="EOF"
 3176:   elif s=="10":s="*Check tuner configuration"
 3177:   elif s=="11":s="HBBTV Info"
 3178:   elif s=="12":s="*Stopped"
 3179:   elif s=="13":s="Channel Allocated"
 3180:   return s
 3181:  @staticmethod
 3182:  def VVrnMj(session):
 3183:   return session.nav.getCurrentlyPlayingServiceReference()
 3184:  @staticmethod
 3185:  def VVvi2b(session):
 3186:   return session.nav.getCurrentService()
 3187:  @staticmethod
 3188:  def VVGg6H(ref):
 3189:   if ref.endswith(("%3a", "%3A")): ref = ref[:-3]
 3190:   span = iSearch(r"((?:[A-Fa-f0-9]+[:]){10})(.+\/\/.+)", ref)
 3191:   if span:
 3192:    VVPxk5 = span.group(1).upper().rstrip(":")
 3193:    VV57TX = span.group(2)
 3194:    return VVPxk5, FFXarh(VV57TX), VV57TX, VVPxk5 + ":" + VV57TX
 3195:   else:
 3196:    VVPxk5 = ref
 3197:   return VVPxk5.rstrip(":"), "", "", ""
 3198: class CCKg9B():
 3199:  def __init__(self, SELF, tableObj, colNum=0):
 3200:   self.SELF  = SELF
 3201:   self.tableObj = tableObj
 3202:   self.colNum  = colNum
 3203:   self.VVj2Pf = -1
 3204:   self.SERVICE = 0
 3205:   self.STRING  = 1
 3206:   self.MULTI  = 2
 3207:   s = str(type(self.tableObj.l))
 3208:   if   "'enigma.eListboxServiceContent'" in s  : self.mode = self.SERVICE
 3209:   elif "'enigma.eListboxPythonStringContent'" in s: self.mode = self.STRING
 3210:   elif "'enigma.eListboxPythonMultiContent'" in s : self.mode = self.MULTI
 3211:   else           : return
 3212:   from Tools.NumericalTextInput import NumericalTextInput
 3213:   self.numericalTextInput = NumericalTextInput(nextFunc=self.VVcBWk)
 3214:   self.numericalTextInput.setUseableChars('1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ')
 3215:   FFBep1(SELF, {str(i):BF(self.VVvXnM, i) for i in range(10)})
 3216:  def VVvXnM(self, key):
 3217:   self.VVj2Pf = self.numericalTextInput.getKey(key)
 3218:   for group in ("1", "2ABC", "3DEF", "4GHI", "5JKL", "6MNO", "7PQRS", "8TUV", "9WXYZ", "0"):
 3219:    if self.VVj2Pf in group:
 3220:     if VVwdUw:
 3221:      txt = " ".join(group)
 3222:      txt = txt.replace(self.VVj2Pf, VVwdUw + self.VVj2Pf + VVA4XU)
 3223:      txt = VVA4XU + txt
 3224:     else:
 3225:      sep = "    "
 3226:      txt = sep + sep.join(group) + sep
 3227:      txt = txt.replace(sep + self.VVj2Pf + sep, "   [%s]   " % self.VVj2Pf)
 3228:     FF28n1(self.SELF, txt)
 3229:  def VVcBWk(self):
 3230:   FF28n1(self.SELF)
 3231:   try:
 3232:    if not self.tableObj:
 3233:     return
 3234:    if self.mode == self.SERVICE:
 3235:     try: self.tableObj.moveToChar(self.VVj2Pf)
 3236:     except: self.tableObj.moveToChar(self.VVj2Pf.encode())
 3237:    elif self.tableObj.list:
 3238:     for ndx in range(len(self.tableObj.list)):
 3239:      item = self.tableObj.list[ndx]
 3240:      if self.mode == self.STRING : item = item[self.colNum]
 3241:      else      : item = item[self.colNum + 1][7]
 3242:      item = FFzBfi(item).strip().encode().decode()
 3243:      if item.upper()[:1] == self.VVj2Pf:
 3244:       self.tableObj.moveToIndex(ndx)
 3245:       break
 3246:   except:
 3247:    pass
 3248: class CCZCVj(Screen):
 3249:  def __init__(self, session, isMove, VVGape, srcDir, dstDir):
 3250:   self.skin, self.VVfOli = FFiNEe(VVmSQ6, 1600, 1000, 50, 40, 20, "#11003040", "#11001122", 30)
 3251:   self.session  = session
 3252:   self.isMove   = isMove
 3253:   self.VVGape   = VVGape
 3254:   self.srcDir   = FFoWxR(srcDir)
 3255:   self.dstDir   = FFoWxR(dstDir)
 3256:   self.isMoveFast  = isMove and CClYaF.VVuTcL(self.srcDir) == CClYaF.VVuTcL(self.dstDir)
 3257:   self.files   = []
 3258:   self.dirs   = []
 3259:   self.others   = []
 3260:   self.action   = "move" if isMove else "copy"
 3261:   self.Title   = self.action.capitalize()
 3262:   self.resText  = ""
 3263:   self.totPaths  = 0
 3264:   self.totFiles  = 0
 3265:   self.totDirs  = 0
 3266:   self.curItem  = ""
 3267:   self.curErr   = ""
 3268:   FFZMxC(self, addScrollLabel=True, title=self.Title)
 3269:   FFBep1(self, { "ok": self.VVfXzC, "cancel": self.VVfXzC })
 3270:   self.onShown.append(self.VV7OzD)
 3271:  def VV7OzD(self):
 3272:   self.onShown.remove(self.VV7OzD)
 3273:   self["myLabel"].VV5kEH()
 3274:   err = ""
 3275:   itemExists = False
 3276:   if self.srcDir == self.dstDir:
 3277:    self.VVQ5VQ("Cannot %s to same directory" % self.action)
 3278:   else:
 3279:    itself = "Cannot %s a directory to itself" % self.action
 3280:    for name in self.VVGape:
 3281:     err = ""
 3282:     path = os.path.join(self.srcDir, name)
 3283:     if path == self.dstDir:
 3284:      err = itself
 3285:     elif os.path.islink(FFVc4H(path)):
 3286:      self.totPaths += 1
 3287:     elif os.path.ismount(path):
 3288:      err = "Cannot include mount"
 3289:     elif os.path.isdir(path):
 3290:      self.totPaths += 1
 3291:      if FFoWxR(path) == self.dstDir:
 3292:       err = itself
 3293:      else:
 3294:       totDir, totFile, totLink = FFK6he(path)
 3295:       self.totPaths += totDir + totFile + totLink
 3296:     else:
 3297:      self.totPaths += 1
 3298:     if err:
 3299:      self.VVQ5VQ("%s\n\n%s" % (err, path))
 3300:      return
 3301:     elif FFCyVu(os.path.join(self.dstDir, FFxtW5(path))):
 3302:      itemExists = True
 3303:   if itemExists: FFRMYv(self, self.VVuXXc, "Overwrite items in destination ?", callBack_No=self.close, title=self.Title)
 3304:   else   : self.VVuXXc()
 3305:  def VVfXzC(self):
 3306:   self.close()
 3307:  def VVDiQh(self, txt):
 3308:   self["myLabel"].appendText(str(txt))
 3309:  def VVQ5VQ(self, txt):
 3310:   FFdw58(self, txt, title=self.Title)
 3311:   self.VVfXzC()
 3312:  def VVuXXc(self):
 3313:   totBars = 1 if self.isMoveFast else 2
 3314:   CCh3tv.VV7Nf4(self, VVLL7M=self.Title, VVIZBP=CCh3tv.VVgJkc, titleBg="#22220022", bodyBg="#22220022", totBars=totBars
 3315:       , VVixvy  = self.VVK8ea
 3316:       , VVbYwR = self.VV3Kl4 )
 3317:  def VVK8ea(self, VVXyP6):
 3318:   VVXyP6.VVq8NF(self.totPaths)
 3319:   for name in self.VVGape:
 3320:    srcPath = os.path.join(self.srcDir, name)
 3321:    dstPath = os.path.join(self.dstDir, name)
 3322:    self.curItem = srcPath
 3323:    if not VVXyP6 or VVXyP6.isCancelled: return
 3324:    if os.path.islink(FFVc4H(srcPath)):
 3325:     self.totFiles += self.VVwlwh(srcPath, dstPath, VVXyP6)
 3326:    elif os.path.isdir(srcPath):
 3327:     for Dir, subdirs, files in os.walk(srcPath):
 3328:      if not VVXyP6 or VVXyP6.isCancelled: return
 3329:      if not subdirs and not files:
 3330:       VVXyP6.VVxtQs(1)
 3331:       dstDir = os.path.join(self.dstDir, Dir[len(self.srcDir):].lstrip("/"))
 3332:       try:
 3333:        if not VVmJwX(dstDir): os.makedirs(dstDir)
 3334:        self.totDirs += 1
 3335:       except Exception as e:
 3336:        self.curErr = str(e)
 3337:        VVXyP6.VVlmol()
 3338:        return
 3339:      else:
 3340:       VVXyP6.VVxtQs(1)
 3341:       dstDir = os.path.join(self.dstDir, Dir[len(self.srcDir):].lstrip("/"))
 3342:       try:
 3343:        if not VVmJwX(dstDir): os.makedirs(dstDir)
 3344:        self.totDirs += 1
 3345:       except Exception as e:
 3346:        self.curErr = str(e)
 3347:        VVXyP6.VVlmol()
 3348:        return
 3349:       for name in files:
 3350:        if not VVXyP6 or VVXyP6.isCancelled: return
 3351:        self.totFiles += self.VVwlwh(os.path.join(Dir, name), os.path.join(dstDir, name), VVXyP6)
 3352:     if self.isMove: FFOzbr(srcPath)
 3353:    else:
 3354:     self.totFiles += self.VVwlwh(srcPath, dstPath, VVXyP6)
 3355:  def VVwlwh(self, srcPath, dstPath, VVXyP6):
 3356:   title = "../" + os.path.join(FFxtW5(FFx9pN(srcPath, True)), os.path.basename(srcPath))
 3357:   VVXyP6.VVaks5(title)
 3358:   self.curItem = srcPath
 3359:   size = FFXhoc(srcPath)
 3360:   if size == -1:
 3361:    size = 0
 3362:   VVXyP6.VVV3RA(0)
 3363:   VVXyP6.VVUIH1(size)
 3364:   VVXyP6.VVxtQs(1)
 3365:   if os.path.islink(FFVc4H(srcPath)):
 3366:    FFOzbr(dstPath)
 3367:    try:
 3368:     os.symlink(os.readlink(srcPath), dstPath)
 3369:    except:
 3370:     self.curErr = "Cannot copy SymLink"
 3371:     VVXyP6.VVlmol()
 3372:     return 0
 3373:   elif self.isMoveFast:
 3374:    if not FFpwZS("mv -f '%s' '%s'" % (srcPath, dstPath)):
 3375:     VVXyP6.VVlmol()
 3376:     return 0
 3377:   else:
 3378:    try:
 3379:     with open(srcPath, "rb") as srcF:
 3380:      with open(dstPath, "wb") as dstF:
 3381:       while True:
 3382:        if not VVXyP6 or VVXyP6.isCancelled:
 3383:         FFwgGB(dstPath)
 3384:         return 0
 3385:        try:
 3386:         data = srcF.read(1024)
 3387:         if not data:
 3388:          break
 3389:         dstF.write(data)
 3390:         VVXyP6.VVg2Dw(len(data))
 3391:        except Exception as e:
 3392:         self.curErr = str(e)
 3393:         FFwgGB(dstPath)
 3394:         VVXyP6.VVlmol()
 3395:         return 0
 3396:       VVXyP6.VVaks5(FFjt5L(title, VVSGsk))
 3397:    except Exception as e:
 3398:     self.curErr = str(e)
 3399:     return 0
 3400:   try: iCopymode(srcPath, dstPath)
 3401:   except: pass
 3402:   if self.isMove: FFOzbr(srcPath)
 3403:   return 1
 3404:  def VV3Kl4(self, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
 3405:   txt  = "Total\t: %s\n" % self.totPaths
 3406:   txt += "Processed\t: %s\n\n" % (FFjt5L(threadCounter, VVSGsk if threadCounter == self.totPaths else VVz22H))
 3407:   txt += "%s Files\t: %s\n" % ("Moved" if self.isMove else "Copied", self.totFiles)
 3408:   txt += "%s Dirs\t: %s\n" % ("Moved" if self.isMove else "Copied", self.totDirs)
 3409:   if not VVRI6P or self.curErr or threadErr or threadCounter != self.totPaths:
 3410:    txt += FFjt5L("\n\nLast Processed:\n", VVz22H)
 3411:    txt += "%s\n" % self.curItem
 3412:    if self.curErr:
 3413:     txt += FFjt5L("\nLast Error:\n", VVz22H)
 3414:     txt += "%s\n" % self.curErr
 3415:   self.VVDiQh(txt)
 3416:   self["myLabel"].VVfu0l()
 3417: class CCwklK():
 3418:  def __init__(self):
 3419:   self.nmUselessWords  = CCwklK.VVO6rU()
 3420:   self.nmComp2yearsPatt = iCompile(r".*\d{4}.+\d{4}")
 3421:   self.nmSkip2yearsPatt = iCompile(r"(.*\d{4}.+)\d{4}\s*(.*)")
 3422:   self.nmSkip1yearsPatt = iCompile(r" \d{4}")
 3423:   self.nmSkipWordsPatt = CCwklK.VVu30K()
 3424:   try:
 3425:    from difflib import get_close_matches as iClosest
 3426:    self.iClosest = iClosest
 3427:   except:
 3428:    self.iClosest = None
 3429:  def VVUziJ(self, textToFind, pathLst, maxRes=0, cutoff=0.3):
 3430:   if   not pathLst  : return [] , ""
 3431:   elif not self.iClosest : return [], 'Missing "difflib" library'
 3432:   if maxRes == 0:
 3433:    maxRes = len(pathLst)
 3434:   refLst = []
 3435:   for ndx, path in enumerate(pathLst):
 3436:    fName = os.path.splitext(os.path.basename(path))[0]
 3437:    fName = iSub(r"([^A-Za-z0-9])", " ", fName).strip()
 3438:    words = []
 3439:    for word in fName.split():
 3440:     if not word.lower() in self.nmUselessWords and not iMatch(self.nmSkipWordsPatt, word):
 3441:      words.append(word)
 3442:    txt = " ".join(words)
 3443:    if iMatch(self.nmComp2yearsPatt, txt): txt = iSub(self.nmSkip2yearsPatt, r"\1\2", txt).rstrip();
 3444:    else         : txt = iSub(self.nmSkip1yearsPatt, "", txt)
 3445:    if txt:
 3446:     refLst.append("%d,%s" % (ndx, txt))
 3447:   bestLst = self.iClosest(textToFind, refLst, n=maxRes, cutoff=cutoff)
 3448:   lst = []
 3449:   if bestLst:
 3450:    for item in bestLst:
 3451:     ndx, fName = item.split(",", 1)
 3452:     lst.append(pathLst[int(ndx)])
 3453:   return lst, ""
 3454:  def VVQebZ(self, SELF, cbFnc, textToFind, pathLst, maxRes=0, cutoff=0.3):
 3455:   if  not pathLst  : cbFnc([] , "")
 3456:   elif not self.iClosest : cbFnc([], 'Missing "difflib" library')
 3457:   else:
 3458:    CCh3tv.VV7Nf4(self, VVLL7M="Searching ...", titleBg="#22220022", bodyBg="#22220022", VVIZBP=CCh3tv.VVgJkc
 3459:        , VVixvy  = BF(self.VVGnmo, textToFind, pathLst, maxRes, cutoff, cbFnc)
 3460:        , VVbYwR = BF(self.VVcnr1, SELF, textToFind, pathLst, maxRes, cutoff, cbFnc))
 3461:  def VVGnmo(self, textToFind, pathLst, maxRes, cutoff, cbFnc, VVXyP6):
 3462:   VVXyP6.VVq8NF(len(pathLst))
 3463:   VVXyP6.VVNc18 = []
 3464:   if maxRes == 0:
 3465:    maxRes = len(pathLst)
 3466:   for ndx, path in enumerate(pathLst):
 3467:    if not VVXyP6 or VVXyP6.isCancelled:
 3468:     return
 3469:    VVXyP6.VVxtQs(1)
 3470:    fName = os.path.splitext(os.path.basename(path))[0]
 3471:    fName = iSub(r"([^A-Za-z0-9])", " ", fName).strip()
 3472:    words = []
 3473:    for word in fName.split():
 3474:     if not word.lower() in self.nmUselessWords and not iMatch(self.nmSkipWordsPatt, word):
 3475:      words.append(word)
 3476:    txt = " ".join(words)
 3477:    if iMatch(self.nmComp2yearsPatt, txt): txt = iSub(self.nmSkip2yearsPatt, r"\1\2", txt).rstrip();
 3478:    else         : txt = iSub(self.nmSkip1yearsPatt, "", txt)
 3479:    if txt and VVXyP6 and not VVXyP6.isCancelled:
 3480:     VVXyP6.VVNc18.append("%d,%s" % (ndx, txt))
 3481:  @FFOAKH("Filtering ...", par=1)
 3482:  def VVcnr1(self, SELF, textToFind, pathLst, maxRes, cutoff, cbFnc, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
 3483:   bestLst = self.iClosest(textToFind, VVNc18, n=maxRes, cutoff=cutoff)
 3484:   lst = []
 3485:   if bestLst:
 3486:    for item in bestLst:
 3487:     ndx, fName = item.split(",", 1)
 3488:     lst.append(pathLst[int(ndx)])
 3489:   cbFnc(lst, "")
 3490:  @staticmethod
 3491:  def VVO6rU():
 3492:   return ('4k','8k','aac5','am','ar','arabic','avc','blueray','bluray','brrip','ddp5','dts','en','english','evo','hd','hdr','hdrip','hevc','mora','multi','multisub','mx','netflix','nf','remux','srt','sub','utf8','web','webrip','xvid','yify','yts')
 3493:  @staticmethod
 3494:  def VVu30K():
 3495:   return iCompile(r"\d{3,4}p"
 3496:       r"|[A-Za-z]\d{3}"
 3497:       r"|\d{1,3}bit[s]?"
 3498:       r"|25r|25rat|25rate"
 3499:       r"|[A-Za-z]{2}\d"
 3500:       , IGNORECASE)
 3501: class CCJIaP(Screen):
 3502:  def __init__(self, session):
 3503:   self.skin, self.VVfOli = FFiNEe(VVWp3I, 800, 950, 40, 50, 30, "#22300030", "#0a202020", 33)
 3504:   self.session  = session
 3505:   self.netEntryFile = FF0cqc() + "ajpanel_network"
 3506:   c1, c2 = VVFuwR, VVJEMb
 3507:   VV3wat = []
 3508:   VV3wat.append((c1 + "Network Storage (FTP)"   , "dev" ))
 3509:   VV3wat.append(VVAL3j)
 3510:   VV3wat.append(("Network Scanner (ping)"    , "ping"))
 3511:   VV3wat.append(("Port Scanner (scan for famous ports)" , "port"))
 3512:   VV3wat.append(VVAL3j)
 3513:   VV3wat.append((c2 + "Check Internet Connection"  , "intr"))
 3514:   FFZMxC(self, title="Network Tools", VV3wat=VV3wat)
 3515:   self.onShown.append(self.VV7OzD)
 3516:  def VV7OzD(self):
 3517:   self.onShown.remove(self.VV7OzD)
 3518:   FF4IPF(self["myMenu"])
 3519:   FF2GM8(self)
 3520:  def VVPr1F(self):
 3521:   item = FFTmHZ(self)
 3522:   if   item == "dev" : self.VVk1PK()
 3523:   elif item == "ping" : self.VVD9YS()
 3524:   elif item == "port" : CCuqoc.VVxG6z(self, self.VVmOM9, title="Select host to scan")
 3525:   elif item == "intr" : self.session.open(CCoFdR)
 3526:  @FFOAKH("Reading Devices ...")
 3527:  def VVk1PK(self, canCencel=False):
 3528:   title = "Network Devices"
 3529:   VVAkuK = self.VVW9Fl()
 3530:   if VVAkuK:
 3531:    bg = "#0a223333"
 3532:    VVAkuK.sort(key=lambda x: x[0].lower())
 3533:    VVu8qI = BF(self.VVgHxg, canCencel)
 3534:    VVu1YM  = ("Start FTP"   , self.VV8wVH    , [])
 3535:    VVScQz = ("Entry Options"  , self.VVkDjp  , [])
 3536:    VV4QTJ = ("Scan for Devices" , self.VV91lj , [])
 3537:    header  = ("Num" , "IP-Address" , "Username", "Password", "Default Path", "Remarks" )
 3538:    widths  = (7  , 25   , 19  , 19  , 0.01   , 30  )
 3539:    VVLIqP = (CENTER , LEFT   , LEFT  , LEFT  , LEFT   , LEFT  )
 3540:    VV6A99 = FFUQ0v(self, None, title=title, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, width=1500, height=900, VV3cHe=widths, VVwdmN=28, VVu1YM=VVu1YM, VVu8qI=VVu8qI, VVScQz=VVScQz, VV4QTJ=VV4QTJ
 3541:        , VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVoRat="#11ffff00", VVJKqd="#11220000", VVbcr0="#00333333", VVX9AA="#11400040")
 3542:    ndx = CFG.lastNetworkDevice.getValue()
 3543:    if isinstance(ndx, int):
 3544:     VV6A99.VVrqBw(ndx)
 3545:   else:
 3546:    FFRMYv(self, BF(self.VVEzoy, canCencel=canCencel), "No devices found !\n\nScan network ?", callBack_No=BF(self.VVgHxg, canCencel), title=title)
 3547:  def VVkDjp(self, VV6A99, title, txt, colList):
 3548:   VV3wat = []
 3549:   VV3wat.append(("Change Username"   , "user"))
 3550:   VV3wat.append(("Change Password"   , "pass"))
 3551:   VV3wat.append(("Change Remarks"   , "rem"))
 3552:   VV3wat.append(VVAL3j)
 3553:   VV3wat.append(("Remove Selected Server" , "del"))
 3554:   FFLFTC(self, BF(self.VVIjs1, VV6A99), VV3wat=VV3wat, title="Entry Options")
 3555:  def VVIjs1(self, VV6A99, item=None):
 3556:   if item:
 3557:    if   item == "user" : self.VVVyBx("u", VV6A99)
 3558:    elif item == "pass" : self.VVVyBx("p", VV6A99)
 3559:    elif item == "rem" : self.VVVyBx("r", VV6A99)
 3560:    elif item == "del" : FFRMYv(self, BF(self.VVPhuf, VV6A99), "Continue ?", title="Delete Entry")
 3561:  def VVgHxg(self, canCencel, VV6A99=None):
 3562:   if VV6A99: VV6A99.cancel()
 3563:   if canCencel : self.close()
 3564:  def VV8wVH(self, VV6A99, title, txt, colList):
 3565:   num, ip, u, p, path, rem = colList
 3566:   entry = (ip, u, p, path, rem)
 3567:   FFjt1c(CFG.lastNetworkDevice, VV6A99.VVGTqU())
 3568:   self.session.openWithCallback(BF(self.VVeh0L, entry, VV6A99), CCJve5, entry)
 3569:  def VVeh0L(self, entry, VV6A99, newPath=None):
 3570:   if newPath:
 3571:    ip, u, p, path, rem = entry
 3572:    if path != newPath:
 3573:     self.VVgBlN("d", newPath, ip, u, p, path, rem)
 3574:     self.VVRrjo(VV6A99)
 3575:  @FFOAKH("Scanning Network ...", clearMsg=False, par=1)
 3576:  def VV91lj(self, VV6A99, title, txt, colList):
 3577:   self.VVEzoy(mainTableInst=VV6A99)
 3578:  @FFOAKH("Scanning ...")
 3579:  def VVEzoy(self, canCencel=False, mainTableInst=None):
 3580:   title = "Network Devices"
 3581:   ftpLst, err = CCuqoc.VVp3V6(CCuqoc.VVhT2I)
 3582:   if err:
 3583:    FFdw58(self, err, title=title)
 3584:    return
 3585:   telLst, err = CCuqoc.VVp3V6(CCuqoc.VVtfD0)
 3586:   if err:
 3587:    FFdw58(self, err, title=title)
 3588:    return
 3589:   tLst = list(set(ftpLst + telLst))
 3590:   lst = []
 3591:   for item in tLst:
 3592:    typ = []
 3593:    if item in ftpLst: typ.append("FTP")
 3594:    if item in telLst: typ.append("Telnet")
 3595:    lst.append((item[0], item[1], " / ".join(typ)))
 3596:   ftpLst = telLst = tLst = None
 3597:   if mainTableInst:
 3598:    mainTableInst.VVrmMb()
 3599:   if lst:
 3600:    def VVD3N9(p1, p2): return FFa9eD(p1[0], p2[0])
 3601:    lst.sort(key=FFgEff(VVD3N9))
 3602:    bg = "#0a202020"
 3603:    VVu8qI = BF(self.VVgHxg, canCencel)
 3604:    VVu1YM  = ("Add to Devices" , BF(self.VVpyCP, mainTableInst, canCencel), [])
 3605:    header  = ("IP-Address" , "MAC-Address" , "Open Ports" )
 3606:    widths  = (40   , 34   , 26   )
 3607:    VVLIqP = (LEFT   , CENTER  , CENTER  )
 3608:    FFUQ0v(self, None, title=title, header=header, VVGape=lst, VVLIqP=VVLIqP, VV3cHe=widths, width=1200, VVwdmN=30, VVu1YM=VVu1YM, VVu8qI=VVu8qI, VVKDPJ=2
 3609:      , VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#0a225555", VVX9AA="#11403040")
 3610:   else:
 3611:    FFdw58(self, "No devices found !", title=title)
 3612:  @FFOAKH("Scanning ...")
 3613:  def VVD9YS(self):
 3614:   title = 'Hosts that responded to "ping"'
 3615:   lst, err = CCuqoc.VVp3V6(-1)
 3616:   if err:
 3617:    FFdw58(self, err, title=title)
 3618:   elif lst:
 3619:    def VVD3N9(p1, p2): return FFa9eD(p1[0], p2[0])
 3620:    lst.sort(key=FFgEff(VVD3N9))
 3621:    bg = "#0a202020"
 3622:    header  = ("IP-Address" , "MAC-Address" )
 3623:    widths  = (50   , 50   )
 3624:    VVLIqP = (LEFT   , LEFT   )
 3625:    FFUQ0v(self, None, title=title, header=header, VVGape=lst, VVLIqP=VVLIqP, VV3cHe=widths, width=1000, height=700, VVwdmN=30
 3626:      , VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#0a225555", VVX9AA="#11403040")
 3627:   else:
 3628:    FFdw58(self, "Network scanning failed !", title=title)
 3629:  @FFOAKH("Scanning")
 3630:  def VVmOM9(self, ip=None):
 3631:   if not ip: return
 3632:   dct = {20: "FTP Data Transfer", 21: "FTP Control", 22: "SSH", 23: "Telnet", 25: "SMTP (eMail)", 80: "HTTP", 443: "HTTPS"}
 3633:   txt  = "IP:\n   %s\n\n" % ip
 3634:   txt += "Ping Result:\n   %s\n\n" % ("OK" if CCuqoc.VVZsjD(ip) else "Failed")
 3635:   txt += "Available Ports:\n"
 3636:   ports = ""
 3637:   for port, subj in dct.items():
 3638:    ok = CCuqoc.VV7fvo(ip, port, timeout=0.5)
 3639:    if ok:
 3640:     ports += "   %d : %s\n" % (port, subj)
 3641:   FF4lCP(self, txt + (ports or "   None"), title="Scanned ports : %s" % str(list(dct)).strip("[]"))
 3642:  def VVW9Fl(self):
 3643:   tLst = []
 3644:   if FFCyVu(self.netEntryFile):
 3645:    txt = FFYVq0(self.netEntryFile)
 3646:    data = iFindall(r"host\s*=(.+),\s*user\s*=(.+),\s*pass\s*=(.*),\s*path\s*=(.*),\s*rem\s*=(.*)", txt, IGNORECASE)
 3647:    for ip, u, p, path, rem in data:
 3648:     ip, u, p, path, rem = ip.strip(), u.strip(), p.strip(), path.strip() or "/", rem.strip()
 3649:     tLst.append((ip, u, p, path, rem))
 3650:   def VVD3N9(p1, p2): return FFa9eD(p1[0], p2[0])
 3651:   tLst.sort(key=FFgEff(VVD3N9))
 3652:   lst = []
 3653:   for num1, item in enumerate(tLst, start=1):
 3654:    ip, u, p, path, rem = item
 3655:    lst.append((str(num1), ip, u, p, path, rem))
 3656:   return lst
 3657:  def VVpyCP(self, mainTableInst, canCencel, VV6A99, title, txt, colList):
 3658:   ip, mac, typ = VV6A99.VVMADj(VV6A99.VVGTqU())
 3659:   if "Own" in ip:
 3660:    FF28n1(VV6A99, "Cannot add your device", 1500)
 3661:   else:
 3662:    gw = "Gateway"
 3663:    if gw in ip : ip, u, p, path, rem = ip.split()[0].strip(), "admin", "123456", "/", gw
 3664:    else  : ip, u, p, path, rem = ip, "root", "dreambox", "/", "No-name"
 3665:    for entry in self.VVW9Fl():
 3666:     num1, ip1, u1, p1, path1, rem1 = entry
 3667:     if (ip, u, p, path, rem) == (ip1, u1, p1, path1, rem1):
 3668:      break
 3669:    else:
 3670:     if FFCyVu(self.netEntryFile):
 3671:      FFJvhj(self.netEntryFile)
 3672:     with open(self.netEntryFile, "a") as f:
 3673:      f.write(self.VV6PMw(ip, u, p, path, rem))
 3674:    if mainTableInst: self.VVRrjo(mainTableInst, [ip, u, p, path, rem])
 3675:    else   : self.VVk1PK(canCencel)
 3676:    VV6A99.cancel()
 3677:  def VV6PMw(self, ip, u, p, path, rem):
 3678:   return "host=%s,user=%s,pass=%s,path=%s,rem=%s\n" % (ip, u, p, path, rem)
 3679:  @FFOAKH("Deleting ...", par=1)
 3680:  def VVPhuf(self, VV6A99):
 3681:   num, ip, u, p, path, rem = VV6A99.VVMADj(VV6A99.VVGTqU())
 3682:   lst = self.VVW9Fl()
 3683:   tot = 0
 3684:   with open(self.netEntryFile, "w") as f:
 3685:    for item in lst:
 3686:     num1, ip1, u1, p1, path1, rem1 = item
 3687:     if not (ip1, u1, p1, path1, rem1) == (ip, u, p, path, rem):
 3688:      f.write(self.VV6PMw(ip1, u1, p1, path1, rem1))
 3689:      tot += 1
 3690:   if tot:
 3691:    self.VVRrjo(VV6A99)
 3692:   else:
 3693:    VV6A99.cancel()
 3694:  def VVVyBx(self, col, VV6A99):
 3695:   num, ip, u, p, path, rem = VV6A99.VVMADj(VV6A99.VVGTqU())
 3696:   if   col == "u": orig, subj = u  , "User"
 3697:   elif col == "p": orig, subj = p  , "Password"
 3698:   elif col == "r": orig, subj = rem, "Remarks"
 3699:   FF4z45(self, BF(self.VVdh5B, col, orig, VV6A99, num, ip, u, p, path, rem), defaultText=orig, title="Change %s" % subj, message="Enter %s:" % subj)
 3700:  def VVdh5B(self, col, orig, VV6A99, num, ip, u, p, path, rem, newTxt):
 3701:   if not newTxt == None:
 3702:    newTxt = newTxt.strip()
 3703:    if orig == newTxt:
 3704:     FF28n1(VV6A99, "No change", 1500)
 3705:    elif not newTxt and col == "u":
 3706:     FF28n1(VV6A99, "No user !", 2000)
 3707:    else:
 3708:     self.VVgBlN(col, newTxt, ip, u, p, path, rem)
 3709:     self.VVRrjo(VV6A99)
 3710:  def VVgBlN(self, col, newTxt, ip, u, p, path, rem):
 3711:   lst = self.VVW9Fl()
 3712:   oldItem = (ip, u, p, path, rem)
 3713:   with open(self.netEntryFile, "w") as f:
 3714:    for item in lst:
 3715:     num1, ip1, u1, p1, path1, rem1 = item
 3716:     if (ip1, u1, p1, path1, rem1) == oldItem:
 3717:      if   col == "u": u1  = newTxt
 3718:      elif col == "p": p1  = newTxt
 3719:      elif col == "d": path1 = newTxt
 3720:      elif col == "r": rem1 = newTxt
 3721:     f.write(self.VV6PMw(ip1, u1, p1, path1, rem1))
 3722:  def VVRrjo(self, VV6A99, newEntry=None):
 3723:   VVAkuK = self.VVW9Fl()
 3724:   if VVAkuK : VV6A99.VVMqQ9(VVAkuK, VVDpzd=BF(self.VVNFyd, newEntry))
 3725:   else  : VV6A99.cancel()
 3726:  def VVNFyd(self, newEntry, VV6A99, title, txt, colList):
 3727:   if newEntry:
 3728:    for ndx, row in enumerate(VV6A99.VVrrm9()):
 3729:     if row[1:] == newEntry:
 3730:      VV6A99.VVrqBw(ndx)
 3731:  def VVgHxg(self, canCencel, VV6A99=None):
 3732:   if VV6A99: VV6A99.cancel()
 3733:   if canCencel : self.close()
 3734: class CCuqoc():
 3735:  VVhT2I = 21
 3736:  VVtfD0 = 23
 3737:  def __init__(self):
 3738:   self.VVQsoo()
 3739:  def VVQsoo(self):
 3740:   self.ftp  = None
 3741:   self.ftpIp  = ""
 3742:   self.ftpUser = ""
 3743:   self.ftpPass = ""
 3744:   self.ftpSys  = ""
 3745:  def VVEGGE(self, ip, User, Pass, timeout=5):
 3746:   myIp = CCuqoc.VVEZHZ()
 3747:   if ip != myIp:
 3748:    if CCuqoc.VV7fvo(ip, CCuqoc.VVhT2I):
 3749:     self.VVQsoo()
 3750:     err = ""
 3751:     try:
 3752:      from ftplib import FTP
 3753:      self.ftp  = FTP(ip, user=User, passwd=Pass, timeout=timeout)
 3754:      self.ftp.set_pasv(False)
 3755:      self.ftpIp  = ip
 3756:      self.ftpUser = User
 3757:      self.ftpPass = Pass
 3758:     except Exception as e:
 3759:      err = str(e)
 3760:    else:
 3761:     err = "Connection timed out !\n\n%s" % ip
 3762:   else:
 3763:    err = "Cannot FTP to your Device-IP:\n\n%s" % ip
 3764:   return err
 3765:  def VVNcyD(self):
 3766:   try: return self.ftp.sendcmd("SYST")
 3767:   except: return ""
 3768:  def VVwQa6(self):
 3769:   try: return self.ftp.sendcmd("NOOP")
 3770:   except: return ""
 3771:  def VVBAfQ(self, timeout=3):
 3772:   t1 = iTime()
 3773:   while True:
 3774:    state = self.VVwQa6()
 3775:    if not state or state == "200 OK" or iTime() - t1 >= timeout:
 3776:     break
 3777:  def VVaqgE(self):
 3778:   try: return self.ftp.sendcmd("STAT")
 3779:   except: return ""
 3780:  def VVQyPa(self, Dir, isLong=False):
 3781:   files, err = [], ""
 3782:   if self.ftp and self.VVejFu(Dir):
 3783:    try:
 3784:     if isLong: self.ftp.dir(files.append)
 3785:     else  : self.ftp.nlst()
 3786:    except Exception as e:
 3787:     err = str(e)
 3788:   else:
 3789:    err = "No FTP Connection !"
 3790:   return files, err
 3791:  def VVPc1T(self):
 3792:   try: return self.ftp.pwd()
 3793:   except: return ""
 3794:  def VVqA3B(self, path):
 3795:   try:
 3796:    size = self.ftp.sendcmd("SIZE %s" % path)
 3797:    return "f"
 3798:   except:
 3799:    VVXgOC = self.VVPc1T()
 3800:    if self.VVejFu(path) : typ = "d"
 3801:    else      : typ = "b"
 3802:    self.VVejFu(VVXgOC)
 3803:    return typ
 3804:  def VVNt99(self, path):
 3805:   try: return self.ftp.size(path)
 3806:   except: return -1
 3807:  def VVejFu(self, path):
 3808:   try:
 3809:    self.ftp.cwd(path)
 3810:    return True
 3811:   except:
 3812:    return False
 3813:  def VVxL8X(self, path):
 3814:   try:
 3815:    self.ftp.mkd(path)
 3816:    return True
 3817:   except:
 3818:    return False
 3819:  def VV8IY8(self, path, flag):
 3820:   try:
 3821:    if flag == "d" : self.ftp.rmd(path)
 3822:    else   : self.ftp.delete(path)
 3823:    return True
 3824:   except:
 3825:    return False
 3826:  def VVmIS9(self, fromN, toN):
 3827:   try:
 3828:    self.ftp.rename(fromN, toN)
 3829:    return True
 3830:   except:
 3831:    return False
 3832:  def VVWKNk(self, remFile, locFile="", maxSz=10000000):
 3833:   sz = self.VVNt99(remFile)
 3834:   if   sz == -1 : return "", sz, "Cannot read file size."
 3835:   elif sz > maxSz : return "", sz, "File too big."
 3836:   else   : err= ""
 3837:   locFile = locFile or "/tmp/%s" % os.path.basename(remFile)
 3838:   try:
 3839:    self.ftp.retrbinary("RETR %s" % remFile, open(locFile, "wb").write)
 3840:    if FFCyVu(locFile) : return locFile, sz, ""
 3841:    else     : return "", sz, "Download Failed."
 3842:   except Exception as e:
 3843:    FFwgGB(locFile)
 3844:    return "", sz, str(e)
 3845:  def VVmRZd(self):
 3846:   if self.ftp:
 3847:    try: self.ftp.quit()
 3848:    except: pass
 3849:   self.VVQsoo()
 3850:  @staticmethod
 3851:  def VVMOOa():
 3852:   from uuid import getnode
 3853:   return ':'.join(iFindall('..', '%012x' % getnode())).upper()
 3854:  @staticmethod
 3855:  def VVEZHZ():
 3856:   from socket import socket, setdefaulttimeout, AF_INET, SOCK_DGRAM
 3857:   try:
 3858:    setdefaulttimeout(1)
 3859:    s = socket(AF_INET, SOCK_DGRAM)
 3860:    s.connect(("1.1.1.1", 80))
 3861:    ip = s.getsockname()[0]
 3862:    s.close()
 3863:    return ip
 3864:   except:
 3865:    return ""
 3866:  @staticmethod
 3867:  def VVStKU():
 3868:   myIp = CCuqoc.VVEZHZ()
 3869:   if myIp.count(".") == 3:
 3870:    parts = myIp.split('.')
 3871:    return ".".join(parts[:3]) + "."
 3872:   return ""
 3873:  @staticmethod
 3874:  def VV6JG2():
 3875:   span = iSearch(r"((?:\d+.){3}\.\d+)", FFTKR0("ip route | grep default"), IGNORECASE)
 3876:   return span.group(1) if span else ""
 3877:  @staticmethod
 3878:  def VV6V4z(port=-1):
 3879:   lst = []
 3880:   def VVZwiy(ip):
 3881:    if port > -1: ok = CCuqoc.VV7fvo(ip, port)
 3882:    else  : ok = CCuqoc.VVZsjD(ip)
 3883:    if ok:
 3884:     lst.append(ip)
 3885:   try:
 3886:    baseIp = CCuqoc.VVStKU()
 3887:    thLst  = []
 3888:    for num in range(1, 255):
 3889:     ip = "%s%d" % (baseIp, num)
 3890:     th = iThread(name="ajp_scanIp%d" % num, target=BF(VVZwiy, ip))
 3891:     th.start()
 3892:     thLst.append(th)
 3893:    for th in thLst: th.join()
 3894:    return lst, ""
 3895:   except Exception as e:
 3896:    err = str(e)
 3897:    return [], err + '\n\nMax Threads = %d\nCheck your system "Max User Processes" with "ulimit -u"' % len(thLst) if "can't start new thread" in err else ""
 3898:  @staticmethod
 3899:  def VVp3V6(port):
 3900:   myIp = CCuqoc.VVEZHZ()
 3901:   myGw = CCuqoc.VV6JG2()
 3902:   tDict = { myIp: CCuqoc.VVMOOa() }
 3903:   devLst, err = CCuqoc.VV6V4z(port)
 3904:   if err:
 3905:    return [], err
 3906:   else:
 3907:    for ip in devLst:
 3908:     span = iSearch(r"((?:\d+.){3}\.\d+).+\s+((?:[a-f\d]{2}:){5}[a-f\d]{2})", FFQ45w("arp -n %s" % ip), IGNORECASE)
 3909:     if span    : tDict[ip] = span.group(2).upper()
 3910:     elif not ip == myIp : tDict[ip] = ""
 3911:    lst = []
 3912:    for key, val in tDict.items():
 3913:     if   key == myIp: txt = " %s Own" % VVFuwR
 3914:     elif key == myGw: txt = " %s Gateway" % VVFuwR
 3915:     else   : txt = ""
 3916:     lst.append((key + txt, val))
 3917:    return lst, ""
 3918:  @staticmethod
 3919:  def VVZsjD(ip):
 3920:   return FFpwZS("ping -W1 -q -c1 %s" % ip)
 3921:  @staticmethod
 3922:  def VV7fvo(host, port, timeout=1.0):
 3923:   from socket import socket, setdefaulttimeout, AF_INET, SOCK_STREAM
 3924:   setdefaulttimeout(timeout)
 3925:   try:
 3926:    socket(AF_INET, SOCK_STREAM).connect((host, port))
 3927:    return True
 3928:   except:
 3929:    return False
 3930:  @staticmethod
 3931:  def VVSuvZ(ip="1.1.1.1", timeout=1):
 3932:   if CCuqoc.VV7fvo(ip, 53, timeout):
 3933:    return True
 3934:   if CCuqoc.VVZsjD(ip):
 3935:    return True
 3936:   return FFpwZS("wget -q -T %d -t 1 --spider %s" % (timeout, ip))
 3937:  @staticmethod
 3938:  def VVxG6z(SELF, okFnc, title):
 3939:   baseIp = CCuqoc.VVStKU()
 3940:   lst = []
 3941:   for num in range(1, 255):
 3942:    item = "%s%d" % (baseIp, num)
 3943:    lst.append((item, item))
 3944:   FFLFTC(SELF, okFnc, VV3wat=lst, width=600, title=title, VVwltY="#222222", VVkxBG="#222222")
 3945: class CCJve5(Screen, CCuqoc):
 3946:  def __init__(self, session, entry):
 3947:   self.skin, self.VVfOli = FFiNEe(VVWp3I, 1400, 920, 40, 50, 30, "#11333344", "#08303030", 30, VVeFSs=40, VV0Ay7=2)
 3948:   self.session  = session
 3949:   self.ftpEntry  = entry
 3950:   self.VVwdmN  = self.VVfOli["VVgbF2"]
 3951:   self.VV8c7y  = self.VVfOli["bodyLineH"]
 3952:   self.VVVljT  = self.VVfOli["width"]
 3953:   self.VVXgOC   = "/"
 3954:   self.list   = []
 3955:   self.png_fil  = CCHmnm.VVKUQG("fil")
 3956:   self.png_dir  = CCHmnm.VVKUQG("dir")
 3957:   self.png_dirup  = CCHmnm.VVKUQG("dirup")
 3958:   self.png_slwfil  = CCHmnm.VVKUQG("slwfil")
 3959:   self.png_slbfil  = CCHmnm.VVKUQG("slbfil")
 3960:   self.png_slwdir  = CCHmnm.VVKUQG("slwdir")
 3961:   self.serverOrigData = None
 3962:   self.Title   = "FTP (%s)" % entry[0]
 3963:   CCuqoc.__init__(self)
 3964:   VV3wat = [("Item-%d" % x,) for x in range(50)]
 3965:   FFZMxC(self, title=self.Title, VV3wat=VV3wat)
 3966:   FFRLNq(self["keyRed"] , "Exit")
 3967:   self["myMenu"] = MenuList(VV3wat, True, eListboxPythonMultiContent)
 3968:   self["myMenu"].l.setFont(0, gFont(VVNhAq, self.VVwdmN))
 3969:   self["myMenu"].l.setItemHeight(self.VV8c7y)
 3970:   FFHlAU(self,
 3971:   {
 3972:    "red" : BF(self.VVfXzC, True) ,
 3973:    "ok" : self.VVPr1F    ,
 3974:    "cancel": self.VVfXzC    ,
 3975:    "menu" : self.VVghcE   ,
 3976:    "info" : self.VVASMR  ,
 3977:    "pageUp": self.VVn7lV    ,
 3978:    "chanUp": self.VVn7lV
 3979:   })
 3980:   self.onShown.append(self.VV7OzD)
 3981:   self.onClose.append(self.onExit)
 3982:   self["myMenu"].onSelectionChanged.append(self.VVkvel)
 3983:  def VV7OzD(self):
 3984:   self.onShown.remove(self.VV7OzD)
 3985:   FF4IPF(self["myMenu"])
 3986:   FF2GM8(self)
 3987:   FFWgBS(self)
 3988:   FF6W0I(self)
 3989:   FFZ0AC(self["keyBlue"], "#11333333")
 3990:   self.VVsSrI()
 3991:  @FFOAKH("Connecting ...")
 3992:  def VVsSrI(self):
 3993:   ip, u, p, path, rem = self.ftpEntry
 3994:   err = self.VVEGGE(ip, u, p)
 3995:   if err:
 3996:    FFdw58(self, err, title=self.Title)
 3997:    FFRLNq(self["keyBlue"] , "")
 3998:    self.close()
 3999:   elif self.ftp:
 4000:    FFRLNq(self["keyBlue"], self.ftpIp)
 4001:    if not self.VVejFu(path):
 4002:     path = "/"
 4003:    self.VV35Mp(path)
 4004:    self.serverOrigData = (ip, u, p, path, rem)
 4005:  def onExit(self):
 4006:   self["myMenu"].onSelectionChanged = []
 4007:   if self.VVwQa6():
 4008:    self.VVmRZd()
 4009:  def VVPr1F(self):
 4010:   if self.VVaECA():
 4011:    sel = self["myMenu"].l.getCurrentSelection()
 4012:    if sel:
 4013:     name, target, targetState, flag, sortSeq = sel[0]
 4014:     if   flag == "d" or targetState == "d" : self.VV35Mp(os.path.join(self.VVXgOC, name))
 4015:     elif flag == "x"      : self.VVn7lV()
 4016:     else         : self.VVC1uy(os.path.join(self.VVXgOC, name))
 4017:  def VVfXzC(self, force=False):
 4018:   if force or CFG.FileManagerExit.getValue() == "e": self.close(self.VVXgOC)
 4019:   else            : self.VVn7lV()
 4020:  def VVaECA(self):
 4021:   if self.VVwQa6():
 4022:    return True
 4023:   else:
 4024:    FFdw58(self, "FTP Server is now diconnected !", title=self.Title)
 4025:    return False
 4026:  def VVC1uy(self, path):
 4027:   cat = CCHmnm.VVMyky(path)
 4028:   if cat in ("pic"):
 4029:    self.VVTKHt(path)
 4030:   elif cat in ("mov", "mus"):
 4031:    if CCkEI5.VVUDPe("5002"):
 4032:     url = "ftp%%3a//%s%%3a%s@%s%s" % (self.ftpUser, self.ftpPass, self.ftpIp, path)
 4033:     rType = "5002"
 4034:    else:
 4035:     rType = CFG.iptvAddToBouquetRefType.getValue()
 4036:     url = "http%%3a//%s/file?file=%s" % (self.ftpIp, path)
 4037:    FFimQ3(self, BF(CClYaF.VVTWR0, self, url, rType=rType), title="Playing Media ...")
 4038:  @FFOAKH()
 4039:  def VVTKHt(self, path):
 4040:   locFile, size, err = self.VVWKNk(path)
 4041:   if err: FFdw58(self, err, title="View Picture File")
 4042:   else  : CCf8zb.VVjnMn(self, locFile, fakePath="ftp:/%s" % path, cbFnc=BF(FFwgGB))
 4043:  def VVkvel(self):
 4044:   sel = self["myMenu"].l.getCurrentSelection()
 4045:   if sel: title = "  %s  " % os.path.join(self.VVXgOC, "" if sel[0][0] == CCHmnm.VVXivL else sel[0][0])
 4046:   else  : title=  VVYjI5 + "  No Files Found !"
 4047:   self["myTitle"].setText(title)
 4048:  def VVn7lV(self):
 4049:   if self.VVaECA():
 4050:    lastPart = FFxtW5(self.VVXgOC)
 4051:    parentDir = os.path.abspath(os.path.join(self.VVXgOC, os.pardir))
 4052:    self.VV35Mp(parentDir, lastPart, "d")
 4053:  @FFOAKH()
 4054:  def VV35Mp(self, Dir, moveTo="", moveToType=""):
 4055:   files, err = self.VVQyPa(Dir, isLong=True)
 4056:   self.VVXgOC = self.VVPc1T() or "/"
 4057:   self.VVjqEq(files)
 4058:   if moveTo:
 4059:    for ndx, item in enumerate(self.list):
 4060:     name, target, targetState, flag, sortSeq = item[0]
 4061:     if moveTo == name:
 4062:      if not moveToType or moveToType == flag:
 4063:       self["myMenu"].moveToIndex(ndx)
 4064:       break
 4065:   else:
 4066:    self["myMenu"].moveToIndex(0)
 4067:  def VVjqEq(self, files):
 4068:   self.list = []
 4069:   if self.VVXgOC != "/":
 4070:    self.list.append(self.VVcZ51(CCHmnm.VVXivL, CCHmnm.VVXivL, "", "", "x"))
 4071:   for item in files:
 4072:    linkTo = ""
 4073:    isDir = isFile = isLink = False
 4074:    item = item.strip()
 4075:    if   item.startswith("l")     : flag = "l"
 4076:    elif item.startswith("d") or "<DIR>" in item: flag = "d"
 4077:    else          : flag = "f"
 4078:    gaps = 3 if item[:1].isdigit() else 8
 4079:    name = item.split(None, gaps)[gaps]
 4080:    linkSep = " -> "
 4081:    origName = name
 4082:    target = targetState = ""
 4083:    if linkSep in name:
 4084:     flag = "l"
 4085:     name, _, target = name.partition(linkSep)
 4086:     if not target.startswith("/"):
 4087:      target = "/" + target
 4088:     targetState = self.VVqA3B(target)
 4089:     color = VVYjI5 if targetState == "b" else VVSGsk
 4090:     origName = name + VV1fx4 + linkSep + color + " "+ target
 4091:    self.list.append(self.VVcZ51(origName, name, target, targetState, flag))
 4092:   self.list.sort(key=lambda x: (x[0][4], x[0][0]))
 4093:   self["myMenu"].l.setList(self.list)
 4094:  def VVcZ51(self, origName, name, target, targetState, flag):
 4095:   if flag == "f":
 4096:    png = self.png_fil
 4097:    ext = os.path.splitext(name)[1]
 4098:    if ext:
 4099:     cat = CCHmnm.VVMyky(name)
 4100:     if cat: png = LoadPixmap("%s%s.png" % (VVIp2p, cat))
 4101:   elif flag == "d": png = self.png_dir
 4102:   elif flag == "l":
 4103:    if   targetState == "f" : png = self.png_slwfil
 4104:    elif targetState == "d" : png = self.png_slwdir
 4105:    elif targetState == "b" : png = self.png_slbfil
 4106:    else      : png = self.png_slwfil
 4107:   elif flag == "x": png = self.png_dirup
 4108:   else   : png = self.png_fil
 4109:   if   origName == CCHmnm.VVXivL: sortSeq = 0
 4110:   elif flag == "d" or targetState == "d"  : sortSeq = 1
 4111:   else          : sortSeq = 2
 4112:   tableRow = [ (name, target, targetState, flag, sortSeq) ]
 4113:   tableRow.append((eListboxPythonMultiContent.TYPE_TEXT, self.VV8c7y + 10, 0, self.VVVljT, self.VV8c7y, 0, LEFT | RT_VALIGN_CENTER, origName))
 4114:   tableRow.append(CCnES5.VVmxDV(0, 2, self.VV8c7y-4, self.VV8c7y-4, png))
 4115:   return tableRow
 4116:  def VVghcE(self):
 4117:   sel = self["myMenu"].l.getCurrentSelection()
 4118:   if sel : name, target, targetState, flag, sortSeq = sel[0]
 4119:   else : name = target = targetState = flag = ""
 4120:   isTop  = name == CCHmnm.VVXivL
 4121:   isDir  = flag == "d" or targetState == "d"
 4122:   isFile = flag == "f" or targetState == "f"
 4123:   def VVb94q(titl, ref, chk, color=""):
 4124:    if chk: return VV3wat.append((color + titl, ref))
 4125:    else  : return VV3wat.append((titl, ))
 4126:   VV3wat = []
 4127:   VVb94q("Properties", "VVASMR", not isTop)
 4128:   c = VVFuwR
 4129:   VV3wat.append(VVAL3j)
 4130:   VVb94q("Download Selected File ..."    , "VVQGeJ", isFile, c)
 4131:   VVb94q("Upload a Local File to Remote Server ...", "VVqeGJ" , True  , c)
 4132:   VV3wat.append(VVAL3j)
 4133:   VVb94q("Create new directory", "VV5THc", True)
 4134:   VVb94q("Rename", "VVlFvn", not isTop)
 4135:   VVb94q("DELETE", "VVgcbK", not isTop, VVz22H)
 4136:   VV3wat.append(VVAL3j)
 4137:   VVb94q("FTP Server Information", "VVJIrN", True)
 4138:   VV3wat.append(VVAL3j)
 4139:   VVb94q("Refresh File List", "refresh", True)
 4140:   FFLFTC(self, self.VV5Qsx, VV3wat=VV3wat, title="Options")
 4141:  def VV5Qsx(self, item=None):
 4142:   if item:
 4143:    if   item == "VVASMR"     : self.VVASMR()
 4144:    elif item == "VVQGeJ"   : self.VVQGeJ()
 4145:    elif item == "VVqeGJ"   : self.VVqeGJ()
 4146:    elif item == "VV5THc"   : self.VV5THc()
 4147:    elif item == "VVlFvn"   : self.VVlFvn()
 4148:    elif item == "VVgcbK"   : self.VVgcbK()
 4149:    elif item == "VVJIrN"    : self.VVJIrN()
 4150:    elif item == "refresh" and self.VVaECA(): self.VV35Mp(self.VVXgOC)
 4151:  def VVASMR(self):
 4152:   if self.VVaECA():
 4153:    sel = self["myMenu"].l.getCurrentSelection()
 4154:    if sel:
 4155:     name, target, targetState, flag, sortSeq = sel[0]
 4156:     path = os.path.join(self.VVXgOC, name)
 4157:     txt = "%s:\n%s\n\n" % (FFjt5L("Path", VVFuwR), path)
 4158:     typ = {"d": "Directory", "f": "File", "l": "SymLink", "x": ""}.get(flag, "")
 4159:     if typ: txt += "Type\t: %s%s\n" % (typ, " (Broken)" if targetState == "b" else "")
 4160:     if target: txt += "Target\t: %s\n" % target
 4161:     sz = self.VVNt99(path)
 4162:     if sz > -1: txt += "Size\t: %s" % CClYaF.VV99gM(sz)
 4163:    else:
 4164:     txt = "Nothing selected"
 4165:    FF4lCP(self, txt, title="Properties")
 4166:  def VVJIrN(self):
 4167:   if self.VVaECA():
 4168:    Sys  = self.VVNcyD() or " -"
 4169:    txt = "%s\n  %s\n\n" % (FFjt5L("System:", VVFuwR), Sys[4:] if Sys.startswith("215 ") else Sys)
 4170:    Stat = self.VVaqgE() or " -"
 4171:    txt += "%s\n" % (FFjt5L("Status:", VVFuwR))
 4172:    for line in Stat.splitlines():
 4173:     txt += "  %s\n" % (line[4:] if line.startswith("211-") or line.startswith("211 ") else line)
 4174:    FF4lCP(self, txt, title="FTP Server Information")
 4175:  def VV5THc(self, name=""):
 4176:   if self.VVaECA():
 4177:    title = "Add New Directory"
 4178:    FF4z45(self, BF(self.VV3kJe, title), defaultText=name, title=title, message="Enter Directory name")
 4179:  def VV3kJe(self, title, name):
 4180:   if name and name.strip():
 4181:    if self.VVxL8X(name) : self.VV35Mp(self.VVXgOC, name, "d")
 4182:    else     : FFdw58(self, "Failed to create : %s" % name, title)
 4183:  def VVlFvn(self):
 4184:   if self.VVaECA():
 4185:    sel = self["myMenu"].l.getCurrentSelection()
 4186:    if sel:
 4187:     title = "Rename"
 4188:     name, target, targetState, flag, sortSeq = sel[0]
 4189:     FF4z45(self, BF(self.VVuz7i, title, name, flag), defaultText=name, title=title, message="Enter new name")
 4190:  def VVuz7i(self, title, name, flag, newName):
 4191:   if newName and newName.strip():
 4192:    if self.VVmIS9(name, newName.strip()) : self.VV35Mp(self.VVXgOC, newName, flag)
 4193:    else          : FFdw58(self, "Failed to rename to : %s" % newName, title)
 4194:  def VVgcbK(self):
 4195:   if self.VVaECA():
 4196:    sel = self["myMenu"].l.getCurrentSelection()
 4197:    if sel:
 4198:     name, target, targetState, flag, sortSeq = sel[0]
 4199:     FFRMYv(self, BF(self.VV3hnb, name, flag), "Delete ?\n\n%s" % name, title="Delete")
 4200:  @FFOAKH("Deleting ...")
 4201:  def VV3hnb(self, name, flag):
 4202:   if self.VV8IY8(name, flag) : self.VV35Mp(self.VVXgOC)
 4203:   else         : FFdw58(self, "Failed to delete:\n\n%s" % name, "Delete")
 4204:  def VVQGeJ(self):
 4205:   if self.VVaECA():
 4206:    sel = self["myMenu"].l.getCurrentSelection()
 4207:    if sel:
 4208:     title = "Download File"
 4209:     name, target, targetState, flag, sortSeq = sel[0]
 4210:     remFile = os.path.join(self.VVXgOC, name)
 4211:     size = self.VVNt99(remFile)
 4212:     if size == -1:
 4213:      FFdw58(self, "Cannot get file size for:\n\n%s" % remFile, title=title)
 4214:     else:
 4215:      Dir = CFG.lastFtpLocalPath.getValue() if VVmJwX(CFG.lastFtpLocalPath.getValue()) else FF0cqc()
 4216:      self.session.openWithCallback(BF(self.VVs8BP, title, remFile, name, size), BF(CClYaF, mode=CClYaF.VV9N82, VVqlNR="Download here", VV1pbK=Dir, width=1200, height=840, pickTitleBG="#11002222", pickBodyBG="#11003333", VVoCB2="#11005566"))
 4217:  def VVs8BP(self, title, remFile, name, size, locPath):
 4218:   if locPath:
 4219:    FFjt1c(CFG.lastFtpLocalPath, locPath)
 4220:    locFile = os.path.join(locPath, name)
 4221:    CCh3tv.VV7Nf4(self, VVLL7M="Downloading ...", titleBg="#22220022", bodyBg="#22220022"
 4222:        , VVixvy  = BF(self.VVOIoL, remFile, size, locFile)
 4223:        , VVbYwR = BF(self.VVZPV3, remFile, size, locFile))
 4224:  def VVOIoL(self, remFile, size, locFile, VVXyP6):
 4225:   VVXyP6.VVq8NF(size)
 4226:   VVXyP6.VVNc18 = ""
 4227:   with open(locFile, "wb") as locFileObj:
 4228:    try:
 4229:     def VVxggW(data):
 4230:      if not VVXyP6 or VVXyP6.isCancelled:
 4231:       return
 4232:      locFileObj.write(data)
 4233:      VVXyP6.VVxtQs(len(data))
 4234:     self.ftp.retrbinary("RETR %s" % remFile, VVxggW)
 4235:    except Exception as e:
 4236:     VVXyP6.VVNc18 = str(e)
 4237:  def VVZPV3(self, remFile, size, locFile, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
 4238:   title = "File Download"
 4239:   delF = False
 4240:   if VVNc18:
 4241:    FFdw58(self, "%s\n\nftp:/%s" % (VVNc18, remFile), title="Download Error")
 4242:    delF = True
 4243:   elif not VVRI6P:
 4244:    FFdw58(self, "Download cancelled for:\n\nftp:/%s" % remFile, title=title)
 4245:    delF = True
 4246:   else:
 4247:    if size == FFXhoc(locFile):
 4248:     txt = "Successfully downloaded to:\n\n%s" % locFile
 4249:     FFipXT(self, txt, title=title)
 4250:    else:
 4251:     FFdw58(self, "Incorrect downloaded file size for:\n\nftp:/%s" % remFile, title=title)
 4252:     delF = True
 4253:   if delF:
 4254:    FFwgGB(locFile)
 4255:  def VVqeGJ(self):
 4256:   if self.VVaECA():
 4257:    Dir = CFG.lastFtpLocalPath.getValue() if VVmJwX(CFG.lastFtpLocalPath.getValue()) else FF0cqc()
 4258:    self.session.openWithCallback(self.VVS7dC, BF(CClYaF, VVqlNR="Upload selected file", VV1pbK=Dir, VV1gDA="all", width=1200, height=850, pickTitleBG="#11001122", pickBodyBG="#11330033", VVoCB2="#11662200"))
 4259:  def VVS7dC(self, locFile):
 4260:   if locFile:
 4261:    title = "Upload File to Remote Server"
 4262:    FFjt1c(CFG.lastFtpLocalPath, os.path.dirname(locFile))
 4263:    size = FFXhoc(locFile)
 4264:    if size == -1:
 4265:     FFdw58(self, "Cannot get file size for:\n\n%s" % locFile, title=title)
 4266:    else:
 4267:     remFile = os.path.join(self.VVXgOC, os.path.basename(locFile))
 4268:     CCh3tv.VV7Nf4(self, VVLL7M="Uploading ...", titleBg="#22220022", bodyBg="#22220022"
 4269:         , VVixvy  = BF(self.VV9WLi, locFile, size, remFile)
 4270:         , VVbYwR = BF(self.VVY5Vb, locFile, size, remFile))
 4271:  def VV9WLi(self, locFile, size, remFile, VVXyP6):
 4272:   VVXyP6.VVq8NF(size)
 4273:   VVXyP6.VVNc18 = ""
 4274:   with open(locFile, "rb") as locFileObj:
 4275:    try:
 4276:     def VVd7e8(data):
 4277:      if not VVXyP6 or VVXyP6.isCancelled:
 4278:       VVXyP6.VVNc18 = "Upload cancelled"
 4279:       locFileObj.close()
 4280:       return
 4281:      VVXyP6.VVxtQs(len(data))
 4282:     self.ftp.storbinary("STOR %s" % remFile, locFileObj, callback=VVd7e8)
 4283:    except Exception as e:
 4284:     VVXyP6.VVNc18 = VVXyP6.VVNc18 or str(e)
 4285:  def VVY5Vb(self, locFile, size, remFile, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
 4286:   title = "File Upload"
 4287:   err = ""
 4288:   if VVRI6P:
 4289:    if size == FFXhoc(locFile) : FFipXT(self, "Successfully uploaded to:\n\n%s" % remFile, title=title)
 4290:    else       : err = "Incorrect uploaded file size for:\n\nftp:/%s" % remFile
 4291:   elif VVNc18 : err = "%s\n\n%s" % (VVNc18, locFile)
 4292:   else    : err = "Incomplete file transfer:\n\n%s" % locFile
 4293:   if err:
 4294:    FFdw58(self, err, title=title)
 4295:    self.VVBAfQ()
 4296:    self.VV8IY8(remFile, "")
 4297:   self.VV35Mp(self.VVXgOC)
 4298: class CC6u6z():
 4299:  VVjbK6  = "all"
 4300:  VVOdU6 = "vid"
 4301:  VV9Iya  = "osd"
 4302:  VVQjxm = "dreamboxctl"
 4303:  VVklE8  = "grab"
 4304:  @staticmethod
 4305:  def VVTqPs(session, k, dm):
 4306:   if CC6u6z.VVgrEx(session) or CFG.screenshotFType.getValue() == "off":
 4307:    return
 4308:   title = "%s Screenshot" % VVh9hj
 4309:   err = ""
 4310:   if   not FFayeZ(CC6u6z.VVklE8)   : err = "g"
 4311:   elif dm and not FFayeZ(CC6u6z.VVQjxm): err = "gd"
 4312:   if err:
 4313:    FFzcnp(session, "Missing %s-command !" % err, title=title)
 4314:    return
 4315:   winShown = session.current_dialog.shown
 4316:   if k == CC6u6z.VVOdU6 and winShown: session.current_dialog.hide()
 4317:   FFIElK(BF(CC6u6z.VVWcGy, title, session, k, winShown, dm))
 4318:  @staticmethod
 4319:  def VVWcGy(title, session, k, winShown, dm):
 4320:   fTitle = skinName = ""
 4321:   x = y = w = h = 0
 4322:   if k == CC6u6z.VV9Iya:
 4323:    if not winShown:
 4324:     FFzcnp(session, "No Window to capture !", title=title)
 4325:     return
 4326:    if not CC6u6z.VV181X(session, title, True):
 4327:     return
 4328:    valid, origTitle, clnTitle, skinName, x, y, w, h = CC6u6z.VV7K5o(session)
 4329:    fTitle = "%s_(%s)" % (clnTitle, skinName)
 4330:    if not valid:
 4331:     FFzcnp(session, "Cannot get Window Dimensions !", title=title)
 4332:     return
 4333:   if not fTitle:
 4334:    s = CC3rDi(session)
 4335:    fTitle = FFOu5Y(s.VV1wIO.strip(), "-") or s.VVXbok.replace(":", "_")
 4336:   ext = CFG.screenshotFType.getValue()
 4337:   path = "%sscreenshot_%s_%s.%s" % (FFCq6F(), fTitle, FFjTQe(), ext)
 4338:   fnc = BF(CC6u6z.VVjh1O, path, title, session, k, winShown, x, y, w, h)
 4339:   if dm:
 4340:    CCaTk8().VVtIZD("%s screenshot -f '%s'" % (CC6u6z.VVQjxm, path), fnc)
 4341:   else:
 4342:    FF7ymp("%s -q -s %s > '%s'" % (CC6u6z.VVklE8, {"jpg":"-j 100", "png":"-p"}.get(ext, ""), path))
 4343:    fnc()
 4344:  @staticmethod
 4345:  def VVjh1O(path, title, session, k, winShown, x, y, w, h, *args):
 4346:   if k == CC6u6z.VVOdU6 and winShown:
 4347:    session.current_dialog.show()
 4348:   elif k == CC6u6z.VV9Iya:
 4349:    ok = CC6u6z.VVOO8R(path, x, y, w, h)
 4350:    if not ok:
 4351:     FFwgGB(path)
 4352:     FFzcnp(session, "Error while cropping image file !", title=title)
 4353:     return
 4354:   if FFCyVu(path) : session.open(CCf8zb, VVPq2Z=path, title=path, menuFnc=CC6u6z.VVZSn1)
 4355:   else    : FFzcnp(session, "Error while capturing screen !", title=title)
 4356:  @staticmethod
 4357:  def VVZSn1(pvObj):
 4358:   def VVsXF6():
 4359:    FFwgGB(pvObj.VVPq2Z)
 4360:    pvObj.close()
 4361:   FFRMYv(pvObj, VVsXF6, "Delete Screenshot File ?\n\n%s" % pvObj.VVPq2Z, title="Screen Shot")
 4362:  @staticmethod
 4363:  def VV181X(SELF, title, VV1rS5, install=True, cbFnc=None):
 4364:   try:
 4365:    from PIL import Image
 4366:    return True
 4367:   except:
 4368:    if install:
 4369:     FFRMYv(SELF, BF(CC6u6z.VVG5xJ, SELF, VV1rS5, cbFnc=cbFnc), "Imaging Library is required.\n\nInstall ?", title=title, VV1rS5=VV1rS5)
 4370:    return False
 4371:  @staticmethod
 4372:  def VVG5xJ(SELF, VV1rS5, cbFnc=None):
 4373:   if pyVersion[0] >= 3: name = "python3-pillow"
 4374:   else    : name = "python-imaging"
 4375:   if VV1rS5: fnc = BF(FF7yGJ, VVoasw=cbFnc)
 4376:   else    : fnc = BF(FFbi5l , VVoasw=cbFnc)
 4377:   fnc(SELF, FF5sZa(VVwFAi, name), VV62hm=True, title="Installing Imaging Library")
 4378:  @staticmethod
 4379:  def VV7K5o(session):
 4380:   valid = False
 4381:   origTitle = clnTitle = skinName = ""
 4382:   x = y = w = h = 0
 4383:   obj = session.current_dialog
 4384:   if obj:
 4385:    skinName = obj.skinName
 4386:    if isinstance(skinName, list) : skinName = "-".join(skinName)
 4387:    else       : skinName = str(skinName)
 4388:    inst = obj.instance
 4389:    if inst:
 4390:     origTitle = inst.getTitle()
 4391:     pos, size = inst.position(), inst.size()
 4392:     x, y, w, h = pos.x(), pos.y(), size.width(), size.height()
 4393:     valid = w != 0 and h !=0
 4394:     clnTitle = FFOu5Y(origTitle.strip(), r"-")
 4395:     clnTitle = FFMYNg(clnTitle, "-")
 4396:   return valid, origTitle, clnTitle, skinName, x, y, w, h
 4397:  @staticmethod
 4398:  def VVgrEx(session):
 4399:   valid, origTitle, clnTitle, skinName, x, y, w, h = CC6u6z.VV7K5o(session)
 4400:   return skinName.lower() in ("hotkeysetup", "buttonsetup", "spaQButton")
 4401:  @staticmethod
 4402:  def VVOO8R(path, x, y, w, h, scaleToScreen=True):
 4403:   try:
 4404:    from PIL import Image
 4405:    im = Image.open(path)
 4406:    x1 = w + x
 4407:    y1 = h + y
 4408:    if scaleToScreen:
 4409:     scrW, scrH = FFrPd1()
 4410:     w, h = im.size
 4411:     if w != scrW or h != scrH:
 4412:      x  = FFjFSv(x , 0, scrW, 0, w)
 4413:      y  = FFjFSv(y , 0, scrH, 0, h)
 4414:      x1 = FFjFSv(x1, 0, scrW, 0, w)
 4415:      y1 = FFjFSv(y1, 0, scrH, 0, h)
 4416:    im = im.crop((x, y, x1, y1))
 4417:    im.save(path)
 4418:    return True
 4419:   except:
 4420:    return False
 4421:  @staticmethod
 4422:  def VV5h28(path):
 4423:   size = FFXhoc(path)
 4424:   sizeTxt = CClYaF.VV99gM(size) if size > -1 else ""
 4425:   try:
 4426:    from PIL import Image
 4427:    im = Image.open(path)
 4428:    form = im.format
 4429:    mode = im.mode
 4430:    resTxt = "%d x %d" % im.size
 4431:   except:
 4432:    resTxt = form = mode = ""
 4433:   return size, sizeTxt, resTxt, form, mode
 4434:  @staticmethod
 4435:  def VVZLHD(path):
 4436:   try:
 4437:    from PIL import Image
 4438:    im = Image.open(path)
 4439:    w, h = im.size
 4440:    return w, h, ""
 4441:   except IOError as e:
 4442:    return -1, -1, "Error: %s" % str(e)
 4443:   except:
 4444:    pass
 4445:   res = FFTKR0("ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=X:p=0 '%s' 2> /dev/null" % path)
 4446:   if "X" in res:
 4447:    w, h = res.split("X")
 4448:    if w.isdigit() and h.isdigit():
 4449:     w, h, = int(w), int(h)
 4450:     if w > 0 and h > 0:
 4451:      return w, h, ""
 4452:   return -1, -1, res or "Error"
 4453:  @staticmethod
 4454:  def VVV85P(path, maxW, maxH, toRgb=True):
 4455:   curW, curH, err = CC6u6z.VVZLHD(path)
 4456:   if err or (curW <= maxW and curH <= maxH): return False, curW, curH, curW, curH
 4457:   w, h = min(curW, maxW), min(curH, maxH)
 4458:   try:
 4459:    from PIL import Image
 4460:    im = Image.open(path)
 4461:    im = im.resize((w, h))
 4462:    if toRgb and im.mode == "CMYK": im = im.convert("RGB")
 4463:    im.save(path)
 4464:    return True, curW, curH, w, h
 4465:   except:
 4466:    if FFayeZ("ffmpeg") and FFpwZS("ffmpeg -y -i '%s' -vf scale=%s:%s '%s'" % (path, w, h, path)):
 4467:     return True , curW, curH, w, h
 4468:    else:
 4469:     return False, curW, curH, curW, curH
 4470:  @staticmethod
 4471:  def VVQuYE(pixMap, path, toPng=False):
 4472:   if not FFCyVu(path):
 4473:    return ""
 4474:   sz = pixMap.instance.size()
 4475:   w, h = sz.width(), sz.height()
 4476:   fil, ext = os.path.splitext(path)
 4477:   tFile = "%s_ajp_%sx%s%s" % (fil, w, h, ".png" if toPng else ext)
 4478:   if FFCyVu(tFile):
 4479:    return tFile
 4480:   else:
 4481:    try:
 4482:     from PIL import Image
 4483:     im = Image.open(path)
 4484:     im = im.resize((w, h))
 4485:     im.save(tFile)
 4486:     return tFile
 4487:    except:
 4488:     if FFayeZ("ffmpeg") and FFpwZS("ffmpeg -y -i '%s' -vf scale=%s:%s '%s'" % (path, w, h, tFile)):
 4489:      return tFile
 4490:     else:
 4491:      return ""
 4492:  @staticmethod
 4493:  def VVZKCF(path, headers=""):
 4494:   tab1 = lambda x, y: "%s\t: %s\n" % (x, y) if y else ""
 4495:   tab2 = lambda Dic, nm, k: tab1(nm, FFYjVd(Dic, k))
 4496:   mExt, mCat, mTitle = CC6u6z.VVQvWl(path)
 4497:   if not mExt:
 4498:    return ""
 4499:   txt  = "\n" + FFGEAF(("%s Metadata" % mTitle).strip(), VVFuwR )
 4500:   try:
 4501:    res = FFQ45w("ffprobe -loglevel 0 %s -of json -show_format -show_streams -show_chapters '%s'" % (headers, path))
 4502:    d = jLoads(res)
 4503:    d1 = d["format"]
 4504:    dur = FFYjVd(d1, "duration")
 4505:    if FFajKn(dur):
 4506:     dur = "%s\t( %s sec )" % (FFFHEC(float(dur)), dur.rstrip("0").rstrip("."))
 4507:    sz = FFYjVd(d1, "size")
 4508:    if sz.isdigit():
 4509:     sz = "%s\t( %s )" % (sz, CClYaF.VV99gM(int(sz), mode=4))
 4510:    txt += tab1("Duration"  , dur   )
 4511:    txt += tab1("File Size"  , sz   )
 4512:    txt += tab2(d1, "Bit Rate" , "bit_rate" )
 4513:    txt += tab2(d1, "Format" , "format_name" )
 4514:    txt += tab2(d1, "Streams" , "nb_streams" )
 4515:    txt += tab1("Chapters"  , len(d["chapters"]))
 4516:    if "tags" in d1:
 4517:     d1 = d1["tags"]
 4518:     tm = FFYjVd(d1, "creation_time")
 4519:     span = iSearch(r"(.+)T(.+)\.", tm)
 4520:     txt += tab2(d1, "Encoder" , "encoder")
 4521:     txt += tab1("Created", "  ".join(span.groups()) if span else tm)
 4522:    for d1 in d["streams"]:
 4523:     ind = FFYjVd(d1, "index"  )
 4524:     typ = FFYjVd(d1, "codec_type" )
 4525:     frmR= FFYjVd(d1, "r_frame_rate")
 4526:     frmR= frmR if frmR != "0/0" else ""
 4527:     w = FFYjVd(d1, "width" )
 4528:     h = FFYjVd(d1, "height" )
 4529:     dim = " x ".join((w, h)) if w and h else ""
 4530:     txt += "\n"
 4531:     txt += FFjt5L(tab1("Stream - %s" % ind, typ.title()), VVZtfx)
 4532:     txt += tab2(d1, "Codec"   , "codec_name"  )
 4533:     txt += tab1("Dimensions"  , dim    )
 4534:     txt += tab2(d1, "Aspect Ratio" , "display_aspect_ratio")
 4535:     txt += tab2(d1, "Pixel Format"  , "pix_fmt"   )
 4536:     txt += tab1("Frame Rate"  , frmR    )
 4537:     txt += tab2(d1, "Sample Rate" , "sample_rate"  )
 4538:     txt += tab2(d1, "Frames"  , "nb_frames"  )
 4539:     txt += tab2(d1, "Channels"  , "channels"  )
 4540:     txt += tab2(d1, "Ch. Layout"  , "channel_layout" ).title()
 4541:     if "tags" in d1:
 4542:      txt += tab2(d1["tags"], "Title"  , "title" )
 4543:      txt += tab2(d1["tags"], "Language"  , "language").title()
 4544:    return txt
 4545:   except:
 4546:    return ""
 4547:  @staticmethod
 4548:  def VVFs8l(path, headers=""):
 4549:   lst = []
 4550:   try:
 4551:    res = FFQ45w("ffprobe -loglevel 0 %s -of json -show_chapters '%s'" % (headers, path))
 4552:    for item in jLoads(res)["chapters"]:
 4553:     try:
 4554:      tm = float(FFYjVd(item, "start_time"))
 4555:      if tm > 0:
 4556:       tmTxt = FFFHEC(tm)
 4557:       pts = int(tm * 90000)
 4558:       name = ""
 4559:       if "tags" in item:
 4560:        name = FFYjVd(item["tags"], "title")
 4561:       lst.append(("%s   %s" % (tmTxt, name), pts))
 4562:     except:
 4563:      pass
 4564:   except:
 4565:    pass
 4566:   return lst
 4567:  @staticmethod
 4568:  def VVmdd5(VVZcRP, VV1wIO):
 4569:   path = headers = ""
 4570:   if FFUl6q(VVZcRP):
 4571:    url = VVZcRP.replace(":" + VV1wIO, "")
 4572:    if "chCode=" in url:
 4573:     if "j.php" in url:
 4574:      pass
 4575:     else:
 4576:      path = iSub(r"[&?]mode=.+end=", r"", url, flags=IGNORECASE)
 4577:      p, err = CC96QG.VV9eVr(VVZcRP)
 4578:      head = p.portal_latestResponse["headers"] if p else ""
 4579:      auth = "Authorization"
 4580:      if head and auth in head:
 4581:       headers  = '-headers "%s: %s"' % (auth, head[auth])
 4582:       headers += " -headers $'Cookie: mac=%s; stb_lang=en\r\n'" % p.VVvRlC
 4583:    else:
 4584:     path = url
 4585:   return path, headers
 4586:  @staticmethod
 4587:  def VVQvWl(path):
 4588:   ext = os.path.splitext(path)[1]
 4589:   mExt = mCat = mName = ""
 4590:   for cat, lst in CCHmnm.VViatp().items():
 4591:    if cat in ("mov", "pic", "mus"):
 4592:     if ext in lst:
 4593:      mExt, mCat = ext, cat
 4594:      break
 4595:     else:
 4596:      for x in lst:
 4597:       if "." + x in path:
 4598:        mExt, mCat = x, cat
 4599:        break
 4600:   return mExt, mCat, {"mov": "Video", "pic": "Picture", "mus": "Audio"}.get(mCat, "")
 4601:  @staticmethod
 4602:  def VVtAiS():
 4603:   try:
 4604:    import pickle, zlib
 4605:    with open("%sMisc/inf.png" % FF0cqc(), 'rb') as f:
 4606:     return pickle.loads(zlib.decompress(f.read().split(bytearray.fromhex("6082"))[1]))
 4607:   except:
 4608:    return None
 4609:  @staticmethod
 4610:  def VVZxjK(i):
 4611:   try: return FFqmPQ(CC6u6z.VVtAiS()[i][1:-1])
 4612:   except: return None
 4613: class CCEBvG(Screen):
 4614:  def __init__(self, session, title, fontsList, defFnt, withRestart, chFontSz, regF):
 4615:   self.skin, self.VVfOli = FFiNEe(VVWp3I, 1400, 1000, 40, 40, 30, "#0a001100", "#10110000", 30, VVeFSs=220, VVUuJZ={"topBtnEW":25})
 4616:   self.session = session
 4617:   self.fontsList = fontsList
 4618:   self.defFnt  = defFnt
 4619:   self.chFontSz = chFontSz
 4620:   self.regF  = regF
 4621:   self.defScale = CFG.fontScaleSys.getValue()
 4622:   txt = FFjt5L(" (Requires GUI Restart)", VVIH76) if withRestart else ""
 4623:   VV3wat = []
 4624:   for path in self.fontsList:
 4625:    VV3wat.append((os.path.splitext(os.path.basename(path))[0], path))
 4626:   VV3wat.sort(key=lambda x: x[0].lower())
 4627:   VV3wat.insert(0, VVAL3j)
 4628:   VV3wat.insert(0, ("Reset to Default%s" % txt, "DEFAULT"))
 4629:   self.VVBGsZ = 0
 4630:   if self.defFnt:
 4631:    for ndx, item in enumerate(VV3wat):
 4632:     if len(item) == 2 and item[1] == self.defFnt:
 4633:      VV3wat[ndx] = (VVSGsk + item[0] + "  (Current font)", item[1])
 4634:      self.VVBGsZ = ndx
 4635:      break
 4636:   else:
 4637:    VV3wat[self.VVBGsZ] = (VVSGsk + VV3wat[self.VVBGsZ][0], VV3wat[self.VVBGsZ][1])
 4638:   FFZMxC(self, VV3wat=VV3wat, title=title)
 4639:   self["keyRedTop"] = Label("%s%%" % self.defScale)
 4640:   self["keyGreenTop"] = Label("Current")
 4641:   self["keyYellowTop"]= Label("Font -")
 4642:   self["keyBlueTop"] = Label("Font +")
 4643:   for s in ("Red", "Green", "Yellow", "Blue"):
 4644:    self["key%sTop1" % s] = Label()
 4645:    if not chFontSz and s != "Green":
 4646:     self["key%sTop" % s].hide()
 4647:     self["key%sTop1" % s].hide()
 4648:   FFBep1(self,
 4649:   {
 4650:    "red" : BF(self.VVTpvn,  0),
 4651:    "green" : self.VVsl6c   ,
 4652:    "yellow": BF(self.VVTpvn, -5),
 4653:    "blue" : BF(self.VVTpvn,  5),
 4654:    "cancel": self.cancel
 4655:   })
 4656:   self.onShown.append(self.VV7OzD)
 4657:  def VV7OzD(self):
 4658:   self.onShown.remove(self.VV7OzD)
 4659:   FF4IPF(self["myMenu"])
 4660:   FFWgBS(self, isTopBar=True)
 4661:   FF2GM8(self)
 4662:   self["myBar"].setText(self.VVE1ob())
 4663:   self["myBar"].instance.setHAlign(1)
 4664:   self["myMenu"].onSelectionChanged.append(self.VVcmBw)
 4665:   self.VVcmBw()
 4666:  def VVPr1F(self):
 4667:   self["myMenu"].onSelectionChanged = []
 4668:   self.close((self["myMenu"].l.getCurrentSelection()[1], self.defScale))
 4669:  def cancel(self):
 4670:   self["myMenu"].onSelectionChanged = []
 4671:   self.close("")
 4672:  def VVsl6c(self):
 4673:   self["myMenu"].moveToIndex(self.VVBGsZ)
 4674:  def VVTpvn(self, val):
 4675:   if not self.chFontSz:
 4676:    return
 4677:   ok = False
 4678:   if  val == 0       : self.defScale, ok = 100, True
 4679:   elif val < 0 and self.defScale == 70 : FF28n1(self, "Minimum Scale = 70%", 500)
 4680:   elif val > 0 and self.defScale == 140: FF28n1(self, "Maximum Scale = 140%", 500)
 4681:   else         : self.defScale, ok = self.defScale + val, True
 4682:   if ok : self.VVcmBw()
 4683:  def VVcmBw(self):
 4684:   path = self["myMenu"].l.getCurrentSelection()[1]
 4685:   if FFCyVu(path):
 4686:    fnt = "AJP_Sample"
 4687:    FFXcbU(path, fnt, scale=self.defScale, isRepl=1, save=False)
 4688:   elif FFCyVu(self.regF):
 4689:    fnt = "AJP_Sample"
 4690:    FFXcbU(self.regF, fnt, scale=self.defScale, isRepl=1, save=False)
 4691:   else:
 4692:    fnt = VV8nt5
 4693:   try:
 4694:    inst = self["myMenu"].instance
 4695:    inst.setFont(gFont(fnt, self.VVfOli["VVgbF2"]))
 4696:    inst.invalidate()
 4697:   except:
 4698:    try:
 4699:     l = self["myMenu"].l
 4700:     l.setFont(gFont(fnt, self.VVfOli["VVgbF2"]))
 4701:     l.invalidate()
 4702:    except:
 4703:     pass
 4704:   self["myBar"].instance.setFont(gFont(fnt, int(self.VVfOli["VVgbF2"] * 1.3)))
 4705:   self["myBar"].instance.invalidate()
 4706:   if self.chFontSz:
 4707:    self["keyRedTop"].setText("%s%%" % self.defScale)
 4708:    FFGUI5(self["keyRedTop"], "#00aaffaa" if self.defScale == 100 else "#00ffeebb")
 4709:  def VVE1ob(self):
 4710:   txt = ""
 4711:   for i in range(65, 91): txt += chr(i)
 4712:   txt += "\n"
 4713:   for i in range(97, 123): txt += chr(i)
 4714:   txt += "  "
 4715:   for i in range(48, 58): txt += chr(i)
 4716:   txt += "\n"
 4717:   txt += u"\u0623\u0628\u062c\u062f \u0647\u0648\u0632 \u062d\u0637\u064a \u0643\u0644\u0645\u0646 \u0633\u0639\u0641\u0635 \u0642\u0631\u0634\u062a \u062b\u062e\u0630 \u0636\u0638\u063a  \u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669"
 4718:   return str(txt)
 4719:  @staticmethod
 4720:  def VV9FYu():
 4721:   lst, regF = set(), ""
 4722:   for name, scale, repl, fName, fPath, skinF in FFcFmA():
 4723:    lst.add(fPath)
 4724:    if name == "Regular": regF = fPath
 4725:   for fil in FFkzic(resolveFilename(SCOPE_FONTS), "*.[tToO][tT][fF]"): lst.add(fil)
 4726:   return sorted(list(lst)), regF
 4727:  @staticmethod
 4728:  def VVpZFB(SELF, title, defFnt, rest, VVbYwR, chFontSz):
 4729:   fLst, regF = CCEBvG.VV9FYu()
 4730:   defFnt = defFnt or regF
 4731:   if fLst : SELF.session.openWithCallback(VVbYwR, CCEBvG, title, fLst, defFnt, rest, chFontSz, regF)
 4732:   else : FFdw58(SELF, "No fonts found.", title=title)
 4733: class CC3yRP(Screen):
 4734:  def __init__(self, session, path, VV3wat, title):
 4735:   self.skin, self.VVfOli = FFiNEe(VVWp3I, 1700, 1000, 40, 40, 30, "#11001122", "#11002233", 30, VVrz9u=50)
 4736:   self.session = session
 4737:   self.path  = path
 4738:   FFZMxC(self, VV3wat=VV3wat, title=title)
 4739:   self["myLabelFrm"] = Label()
 4740:   self["myLabelTit"] = Label("Result Sample")
 4741:   self["myLabelTxt"] = Label()
 4742:   FFHlAU(self,
 4743:   {
 4744:    "ok"  : self.VVPr1F   ,
 4745:    "cancel" : self.cancel   ,
 4746:    "pageUp" : self.VVeXFp,
 4747:    "chanUp" : self.VVeXFp,
 4748:    "pageDown" : self.VVQ0fH ,
 4749:    "chanDown" : self.VVQ0fH ,
 4750:   })
 4751:   self.onShown.append(self.VV7OzD)
 4752:  def VV7OzD(self):
 4753:   self.onShown.remove(self.VV7OzD)
 4754:   FF4IPF(self["myMenu"])
 4755:   FF2GM8(self)
 4756:   FFZ0AC(self["myLabelFrm"], "#11110000")
 4757:   FFZ0AC(self["myLabelTit"], "#11663322")
 4758:   FFZ0AC(self["myLabelTxt"], "#11110000")
 4759:   self["myMenu"].onSelectionChanged.append(self.VVE83j)
 4760:   self.VVE83j()
 4761:  def VVE83j(self):
 4762:   if FFCyVu(self.path): txt = FFYVq0(self.path, maxSize=1000, encLst=[self["myMenu"].l.getCurrentSelection()[1]])
 4763:   else     : txt = "Review error !"
 4764:   self["myLabelTxt"].setText(txt.strip())
 4765:  def VVPr1F(self):
 4766:   self["myMenu"].onSelectionChanged = []
 4767:   self.close(self["myMenu"].l.getCurrentSelection()[1])
 4768:  def cancel(self):
 4769:   self["myMenu"].onSelectionChanged = []
 4770:   self.close("")
 4771:  def VVeXFp(self) : self["myMenu"].moveToIndex(0)
 4772:  def VVQ0fH(self) : self["myMenu"].moveToIndex(len(self["myMenu"].list) - 1)
 4773: class CC7ocD():
 4774:  @staticmethod
 4775:  def VVmFe6():
 4776:   return [None, "utf-8"] + ["iso-8859-%d" % i for i in range(1,17)] + ["windows-125%d" % i for i in range(1,9)]
 4777:  @staticmethod
 4778:  def VVOFk8(SELF):
 4779:   import sys, locale
 4780:   lst = []
 4781:   c1 = "#f#00ffbbff#"
 4782:   c2 = "#f#00ffffaa#"
 4783:   lst.append(("Language Code"     , locale.getdefaultlocale()[0]  ))
 4784:   lst.append(("Default Locale Encoding"  , locale.getdefaultlocale()[1]  ))
 4785:   lst.append((c1 + "Preferred Encoding"  , c1 + locale.getpreferredencoding(False)))
 4786:   lst.append((c2 + "System Default Encoding" , c2 + sys.getdefaultencoding()  ))
 4787:   lst.append((c2 + "Filesystem Encoding"  , c2 + sys.getfilesystemencoding() ))
 4788:   c = "#f#11aaffff#"
 4789:   for item in locale.setlocale(locale.LC_ALL).split(";"):
 4790:    parts = item.split("=")
 4791:    if len(parts) == 2:
 4792:     lst.append((c + parts[0], c +
 4793:     parts[1]))
 4794:   FFUQ0v(SELF, None, VVGape=lst, VVwdmN=30, VVKDPJ=1)
 4795:  @staticmethod
 4796:  def VV51oT(path, SELF=None):
 4797:   for enc in CC7ocD.VVmFe6():
 4798:    try:
 4799:     with ioOpen(path, "r", encoding=enc) as f:
 4800:      for line in f:
 4801:       pass
 4802:     return enc
 4803:    except:
 4804:     pass
 4805:   if SELF:
 4806:    FFdw58(SELF, "Cannot detect file encoding for:\n\n%s" % path)
 4807:   return -1
 4808:  @staticmethod
 4809:  def VVm9FZ(path):
 4810:   for enc in CC7ocD.VVmFe6():
 4811:    try:
 4812:     c = 0
 4813:     with ioOpen(path, "r", encoding=enc) as f:
 4814:      for line in f:
 4815:       c += 1
 4816:     return enc, c
 4817:    except:
 4818:     pass
 4819:   return -1, 0
 4820:  @staticmethod
 4821:  def VVRTBW(path, enc):
 4822:   try:
 4823:    with ioOpen(path, "r", encoding=enc) as f:
 4824:     for line in f:
 4825:      pass
 4826:    return True
 4827:   except:
 4828:    return False
 4829:  @staticmethod
 4830:  def VV9PZW(SELF, path, cbFnc, curEnc=VV9iuh, title="Select Encoding"):
 4831:   lst = CC7ocD.VVZyMn(SELF, path, "")
 4832:   if lst:
 4833:    SELF.session.openWithCallback(cbFnc, CC3yRP, path, lst, title)
 4834:  @staticmethod
 4835:  def VViA40(SELF, cbFnc, curEnc=VV9iuh, title="Select Encoding"):
 4836:   lst = CC7ocD.VVZyMn(SELF, "", "")
 4837:   if lst:
 4838:    FFLFTC(SELF, cbFnc, title=title, VV3wat=lst, width=1000, height=1000, VVwltY="
 4839:  @staticmethod
 4840:  def VVZyMn(SELF, path, curEnc):
 4841:   lst = CC7ocD.VV5QBn(path)
 4842:   if lst:
 4843:    VV3wat = []
 4844:    for name, enc in lst:
 4845:     txt = "%s (%s)" % (name, enc)
 4846:     if   enc == curEnc   : c = VVSGsk
 4847:     elif enc == VV9iuh: c = VV1fx4
 4848:     else      : c = ""
 4849:     VV3wat.append((c + txt, enc))
 4850:    return VV3wat
 4851:   else:
 4852:    FFjADj(SELF, "No proper encoding", 2000)
 4853:  @staticmethod
 4854:  def VV5QBn(path=""):
 4855:   encLst = []
 4856:   cPath = VVIp2p + "_sup_codecs"
 4857:   if FFCyVu(cPath):
 4858:    lines = FFL19l(cPath)
 4859:    for line in lines:
 4860:     parts = line.split("\t")
 4861:     if len(parts) == 2:
 4862:      encLst.append((parts))
 4863:   if not encLst:
 4864:    tmp = list(CC7ocD.VVmFe6())
 4865:    tmp.pop(0)
 4866:    encLst = [("General", ",".join(tmp))]
 4867:   lst = []
 4868:   for item in encLst:
 4869:    for enc in (item[1].split(",")):
 4870:     if path:
 4871:      try:
 4872:       with ioOpen(path, "r", encoding=enc) as f:
 4873:        for line in f:
 4874:         pass
 4875:       lst.append((item[0], enc))
 4876:      except:
 4877:       pass
 4878:     else:
 4879:      lst.append((item[0], enc))
 4880:   return lst
 4881: class CC674y(Screen):
 4882:  def __init__(self, session):
 4883:   self.skin, self.VVfOli = FFiNEe(VVWp3I, 900, 950, 50, 40, 30, "#22003300", "#22001100", 30)
 4884:   self.session  = session
 4885:   VV3wat = []
 4886:   VV3wat.append(("Settings File"   , "SettingsFile" ))
 4887:   VV3wat.append(VVAL3j)
 4888:   VV3wat.append(("Box Info"     , "VVetBc"  ))
 4889:   VV3wat.append(("Tuners Info"    , "VVtK13" ))
 4890:   VV3wat.append(("Python Version"   , "VVUKRb" ))
 4891:   VV3wat.append(("Stream Relay Patch"  , "VVluJ6" ))
 4892:   VV3wat.append(VVAL3j)
 4893:   VV3wat.append(("Screen Size"    , "ScreenSize"  ))
 4894:   VV3wat.append(("Language/Locale"   , "Locale"   ))
 4895:   VV3wat.append(("Processor"    , "Processor"  ))
 4896:   VV3wat.append(("Operating System"   , "VViKIV" ))
 4897:   VV3wat.append(("Drivers (Kernel Object)"     , "VVOcsB"))
 4898:   VV3wat.append(("Drivers (Loadable Kernel Modules - LKM)" , "VV1ECU" ))
 4899:   VV3wat.append(("Drivers (Built-in Kernel Modules)"  , "VVHkKI" ))
 4900:   VV3wat.append(VVAL3j)
 4901:   VV3wat.append(("System Users"    , "SystemUsers"   ))
 4902:   VV3wat.append(("Logged-in Users"   , "LoggedInUsers"  ))
 4903:   VV3wat.append(("Uptime"     , "Uptime"    ))
 4904:   VV3wat.append(VVAL3j)
 4905:   VV3wat.append(("Host Name"    , "HostName"   ))
 4906:   VV3wat.append(("MAC Address"    , "MACAddress"   ))
 4907:   VV3wat.append(("Network Configuration" , "NetworkConfiguration"))
 4908:   VV3wat.append(("Network Status"   , "NetworkStatus"  ))
 4909:   VV3wat.append(VVAL3j)
 4910:   VV3wat.append(("Disk Usage"    , "VVu1Uy"   ))
 4911:   VV3wat.append(("Mount Points"    , "VVTdXJ"  ))
 4912:   VV3wat.append(("File System Table (FSTAB)", "VVGciC"  ))
 4913:   VV3wat.append(("USB Devices"    , "USB_Devices"   ))
 4914:   VV3wat.append(("Block-Devices List"  , "blockDevices"  ))
 4915:   VV3wat.append(("Directory Size"   , "DirectorySize"  ))
 4916:   VV3wat.append(("Memory"     , "Memory"    ))
 4917:   VV3wat.append(VVAL3j)
 4918:   VV3wat.append(("Running Processes"  , "RunningProcesses" ))
 4919:   VV3wat.append(("Processes with open files", "ProcessesOpenFiles" ))
 4920:   VV3wat.append(VVAL3j)
 4921:   VV3wat.append(("Bootloader Second-stage (old DreamBox only)" , "DreamBoxBootloader"))
 4922:   FFZMxC(self, VV3wat=VV3wat, title="Device Information")
 4923:   self.onShown.append(self.VV7OzD)
 4924:  def VV7OzD(self):
 4925:   self.onShown.remove(self.VV7OzD)
 4926:   FF4IPF(self["myMenu"])
 4927:   FF2GM8(self)
 4928:  def VVPr1F(self):
 4929:   item = FFTmHZ(self)
 4930:   if item is not None:
 4931:    if   item == "SettingsFile"   : self.session.open(CCUImU)
 4932:    elif item == "VVetBc"   : self.VVetBc()
 4933:    elif item == "VVtK13"  : self.VVtK13()
 4934:    elif item == "VVUKRb"  : self.VVUKRb()
 4935:    elif item == "VVluJ6"  : self.VVluJ6()
 4936:    elif item == "ScreenSize"   : FF4lCP(self, "Width\t: %s\nHeight\t: %s" % (FFrPd1()[0], FFrPd1()[1]))
 4937:    elif item == "Locale"    : CC7ocD.VVOFk8(self)
 4938:    elif item == "Processor"   : self.VVyUAC()
 4939:    elif item == "VViKIV"  : self.VViKIV()
 4940:    elif item == "VVOcsB"  : self.VVOcsB()
 4941:    elif item == "VV1ECU"  : self.VV1ECU()
 4942:    elif item == "VVHkKI"  : self.VVHkKI()
 4943:    elif item == "SystemUsers"   : FFZQVC(self, "id")
 4944:    elif item == "LoggedInUsers"  : FFZQVC(self, "who -a")
 4945:    elif item == "Uptime"    : FFZQVC(self, "uptime")
 4946:    elif item == "HostName"    : FFZQVC(self, "hostname")
 4947:    elif item == "MACAddress"   : self.VVxHe9()
 4948:    elif item == "NetworkConfiguration" : FFZQVC(self, "ifconfig %s %s" % (FFSPDv("HWaddr", VVcPtB), FFSPDv("addr:", VV1fx4)))
 4949:    elif item == "NetworkStatus"  : FFZQVC(self, "netstat -tulpn", VVwdmN=24)
 4950:    elif item == "VVu1Uy"   : self.VVu1Uy()
 4951:    elif item == "VVTdXJ"  : self.VVTdXJ()
 4952:    elif item == "VVGciC"  : self.VVGciC()
 4953:    elif item == "USB_Devices"   : FFZQVC(self, "lsusb")
 4954:    elif item == "blockDevices"   : FFZQVC(self, "blkid")
 4955:    elif item == "DirectorySize"  : FFZQVC(self, "du -shc /* 2> /dev/null | sed '/total/i-----\t-------------' | sed 's/total/TOTAL/g'")
 4956:    elif item == "Memory"    : FFZQVC(self, "cat /proc/meminfo | sed 's/ //g' | sed 's/:/\t: /g' | sed '/MemAvailable/a%s'" % ("-" * 25), consFont=False)
 4957:    elif item == "RunningProcesses"  : FFZQVC(self, "ps")
 4958:    elif item == "ProcessesOpenFiles" : FFZQVC(self, "lsof")
 4959:    elif item == "DreamBoxBootloader"  : self.VVft8B()
 4960:    else        : self.close()
 4961:  def VVxHe9(self):
 4962:   res = FFQ45w("ip link")
 4963:   list = iFindall(r"[0-9]+:\s+(.+):\s+.+\n.+\s+(.+)brd", res, IGNORECASE)
 4964:   if list:
 4965:    txt = ""
 4966:    for item in list:
 4967:     brd = item[0].upper()
 4968:     mac = item[1].upper()
 4969:     if not brd == "LO":
 4970:      txt += "%s\t: %s\n" % (item[0].upper(), item[1].upper())
 4971:    FF4lCP(self, txt)
 4972:   else:
 4973:    FFZQVC(self, "ip link")
 4974:  @FFOAKH()
 4975:  def VVu1Uy(self):
 4976:   VVAkuK, cols = [], 0
 4977:   for cmd, cols in (("df -aTh", 7), ("df -ah", 6)):
 4978:    txt = FFQ45w(cmd)
 4979:    if not "invalid option" in txt:
 4980:     for line in txt.split("\n"):
 4981:      parts = line.split()
 4982:      if len(parts) >= cols and not "Mounted on" in line:
 4983:       VVAkuK.append(parts[:cols])
 4984:     break
 4985:   if VVAkuK:
 4986:    if cols == 7:
 4987:     header  = ("Filesystem" , "Type", "Size", "Used", "Available" , "Use %", "Mounted on" )
 4988:     widths  = (25   , 12 , 10 , 9  , 10   , 9  , 25   )
 4989:     VVLIqP = (LEFT   , CENTER, CENTER, CENTER, CENTER  , CENTER, LEFT   )
 4990:    else:
 4991:     header  = ("Filesystem" , "Size", "Used", "Available" , "Use %", "Mounted on" )
 4992:     widths  = (30   , 11 , 11 , 11   , 11 , 26   )
 4993:     VVLIqP = (LEFT   , CENTER, CENTER, CENTER  , CENTER, LEFT   )
 4994:    VVAkuK.sort(key=lambda x: x[0].lower())
 4995:    FFUQ0v(self, None, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, width=1700, height=1000, VVpCEu=True, VV3cHe=widths, VVwdmN=28)
 4996:   else:
 4997:    FFdw58(self, "Cannot get data !")
 4998:  def VVTdXJ(self):
 4999:   lines = FF3xOt("mount")
 5000:   VVAkuK = []
 5001:   for line in lines:
 5002:    span = iSearch(r"(.+)\son\s(.+)\stype\s(.+)\s\((.+)\)", line, IGNORECASE)
 5003:    if span:
 5004:     VVAkuK.append(span.groups())
 5005:   if VVAkuK:
 5006:    VVAkuK.sort(key=lambda x: x[0].lower())
 5007:    header  = ("Device/FS" , "Mount Point" , "VFS Type", "Mount Options")
 5008:    widths  = (20   , 25   , 13  , 42 )
 5009:    VVLIqP = (LEFT   , LEFT   , CENTER , LEFT )
 5010:    FFUQ0v(self, None, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVpCEu=True)
 5011:   else:
 5012:    FFdw58(self, "Cannot process data.")
 5013:  def VVGciC(self):
 5014:   lst =  []
 5015:   for line in FFL19l("/etc/fstab"):
 5016:    s1 = line.strip().split()
 5017:    if len(s1) == 6:
 5018:     lst.append(s1)
 5019:   if lst:
 5020:    bg = "#11000600"
 5021:    lst.sort(key=lambda x: x[0].lower())
 5022:    header  = ("Device" , "Mount Point" , "FS Type" , "Options" , "Backup" , "FS Check")
 5023:    widths  = (24  , 24   , 10  , 24  , 9   , 9   )
 5024:    VVLIqP = (LEFT  , LEFT   , CENTER , LEFT  , CENTER , CENTER )
 5025:    FFUQ0v(self, None, header=header, VVGape=lst, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVpCEu=True, VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#00004455", VVbcr0="#0a282828")
 5026:   else:
 5027:    FFdw58(self, "Cannot read FSTAB !\n\n( or no data )")
 5028:  @FFOAKH()
 5029:  def VVHkKI(self):
 5030:   def VVZwiy(p1, bg=""):
 5031:    tLst =  []
 5032:    for line in FF3xOt("find '%s' -maxdepth 1 -type f | sort" % p1):
 5033:     vals = FFL19l(os.path.join(p1, line))
 5034:     if vals:
 5035:      tLst.append((bg + FFxtW5(line).strip().capitalize(), vals[0].strip()))
 5036:    return sorted(tLst, key=lambda x: x[0].lower())
 5037:   lst =  []
 5038:   for line in FF3xOt("cat /lib/modules/$(uname -r)/modules.builtin"):
 5039:    if line.startswith("kernel"):
 5040:     driv = os.path.splitext(os.path.basename(line))[0]
 5041:     p1 = "/sys/module/%s/" % driv
 5042:     p2 = os.path.join(p1, "parameters/")
 5043:     tot1 = len([f for f in os.listdir(p1) if FFL19l(p1 + f)]) if VVmJwX(p1) else 0
 5044:     tot2 = len([f for f in os.listdir(p2) if FFL19l(p2 + f)]) if VVmJwX(p2) else 0
 5045:     lst.append((driv, line, "Yes" if tot1 + tot2 > 0 else ""))
 5046:   if lst:
 5047:    bg = "
 5048:    lst.sort(key=lambda x: x[0].lower())
 5049:    VV2ytr = ("", self.VVdw3L, [])
 5050:    header  = ("Driver" , "Name", "Info")
 5051:    widths  = (36   , 57 , 7  )
 5052:    VVLIqP = (LEFT  , LEFT, CENTER )
 5053:    FFUQ0v(self, None, header=header, VVGape=lst, VVLIqP=VVLIqP, VV3cHe=widths, VVpCEu=True, VVwdmN=28, VV2ytr=VV2ytr, VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#00004455", VVbcr0="#0a282828")
 5054:   else:
 5055:    FFdw58(self, "Cannot read Builtin Drivers List !")
 5056:  @FFOAKH()
 5057:  def VVOcsB(self):
 5058:   lst = []
 5059:   for line in FF3xOt("find /lib/modules/ -iname *.ko"):
 5060:    lst.append((os.path.splitext(os.path.basename(line))[0], line))
 5061:   if lst : FFUQ0v(self, None, header=("Driver", "Path"), VVGape=sorted(lst, key=lambda x: x[0].lower()), VV3cHe=(20, 80), VVpCEu=True, VVwdmN=26)
 5062:   else : FFdw58(self, "No list found !")
 5063:  @FFOAKH()
 5064:  def VV1ECU(self):
 5065:   lst =  []
 5066:   for line in FF3xOt("lsmod"):
 5067:    s1 = line.split()
 5068:    Len = len(s1)
 5069:    if Len >= 3 and s1[1] != "Size":
 5070:     if   Len == 3: lst.append(s1)
 5071:     else   : lst.append(s1[:2] + [" ".join(s1[2:])])
 5072:   if lst:
 5073:    bg = "#11000600"
 5074:    lst.sort(key=lambda x: x[0].lower())
 5075:    VV2ytr = ("", self.VVdw3L, [])
 5076:    header  = ("Module" , "Size", "Used By" )
 5077:    widths  = (30  , 15 , 55  )
 5078:    VVLIqP = (LEFT  , CENTER, LEFT  )
 5079:    FFUQ0v(self, None, header=header, VVGape=lst, VVLIqP=VVLIqP, VV3cHe=widths, VVpCEu=True, VVwdmN=28, VV2ytr=VV2ytr, VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#00004455", VVbcr0="#0a282828")
 5080:   else:
 5081:    FFdw58(self, "Cannot get drivers Info !")
 5082:  @FFOAKH(par=1)
 5083:  def VVdw3L(self, VV6A99, title, txt, colList):
 5084:   driv = colList[0]
 5085:   lst1, lst3 = [], []
 5086:   for line in FF3xOt("modinfo %s" % driv):
 5087:    if ":" in line:
 5088:     subj, _, val = line.partition(":")
 5089:     subj, val = subj.strip().capitalize(), val.strip()
 5090:     if not val.startswith("ERROR"):
 5091:      tLst = lst1 if subj in ("Filename", "Version", "Author", "Description", "License", "Srcversion", "Depends", "Vermagic") else lst3
 5092:      tLst.append((subj, val))
 5093:   def VVZwiy(p1, bg=""):
 5094:    tLst =  []
 5095:    for line in FF3xOt("find '%s' -maxdepth 1 -type f | sort" % p1):
 5096:     vals = FFL19l(os.path.join(p1, line))
 5097:     if vals:
 5098:      tLst.append((bg + FFxtW5(line).strip().capitalize(), vals[0].strip()))
 5099:    return sorted(tLst, key=lambda x: x[0].lower())
 5100:   path = "/sys/module/%s" % driv
 5101:   lst2 = [("#b#0a220000#" + a, b) for (a,b) in VVZwiy(path) if (a,b) not in lst1]
 5102:   lst4 = VVZwiy(os.path.join(path, "parameters"), "#b#0a221133#")
 5103:   lst1 = [("#b#11000a0f#" + a,b) for a,b in lst1]
 5104:   lst3 = [("#b#0a003344#" + a,b) for a,b in lst3]
 5105:   VVGape = lst1 + lst2 + lst3 + lst4
 5106:   bg, title = "#11001122", "Driver : %s" % driv
 5107:   if VVGape: FFUQ0v(self, None, title=title, VVGape=VVGape, VV3cHe=(40, 60), VVKDPJ=1, VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#00883300", VVbcr0="#0a444444")
 5108:   else  : FFdw58(self, "No Driver Info !", title=title)
 5109:  def VVyUAC(self):
 5110:   cmd  = "RES=$(uname -m | awk '{print toupper($0)}');"
 5111:   cmd += "if [ -z \"$RES\" ] ; then RES=$(uname -a | awk '{print toupper($12)}'); fi;"
 5112:   cmd += "if [ -z \"$RES\" ] ; then echo 'Could not read Info.!'; else echo $RES; fi"
 5113:   FFZQVC(self, cmd)
 5114:  def VViKIV(self):
 5115:   FFZQVC(self, "uname -a")
 5116:  def VVft8B(self):
 5117:   cmd = FFoY7E(VVZDGE, "| grep secondstage")
 5118:   if cmd : FFZQVC(self, 'output=$(%s); if [ -z "$output" ] ; then echo "Not found for this receiver."; else echo $output; fi' % cmd)
 5119:   else : FFfone(self)
 5120:  def VVetBc(self):
 5121:   c1, c2, c3 = "#b#11000a0f#", "#b#0a220000#", "#b#0a003344#"
 5122:   VVGape = []
 5123:   VVGape.append((c1 + "Box Type"  , self.VVOq0L("boxtype").upper() ))
 5124:   VVGape.append((c1 + "Board Version" , self.VVOq0L("board_revision") ))
 5125:   VVGape.append((c1 + "Chipset"  , self.VVOq0L("chipset")   ))
 5126:   VVGape.append((c1 + "S/N"   , self.VVOq0L("sn")    ))
 5127:   VVGape.append((c1 + "Version"  , self.VVOq0L("version")   ))
 5128:   VVvZXX   = []
 5129:   VVSBVq = ""
 5130:   try:
 5131:    from Components.SystemInfo import SystemInfo
 5132:    keysList = list(SystemInfo)
 5133:    if keysList:
 5134:     for key in keysList:
 5135:      if key == "canMultiBoot":
 5136:       VVSBVq = SystemInfo[key]
 5137:      else:
 5138:       VVvZXX.append((c3 + str(key), str(SystemInfo[key])))
 5139:   except:
 5140:    pass
 5141:   if VVSBVq:
 5142:    VVbnnF = self.VVUG40(VVSBVq, c2)
 5143:    if VVbnnF:
 5144:     VVbnnF.sort(key=lambda x: x[0].lower())
 5145:     VVGape += VVbnnF
 5146:   if VVvZXX:
 5147:    VVvZXX.sort(key=lambda x: x[0].lower())
 5148:    VVGape += VVvZXX
 5149:   if VVGape:
 5150:    header  = ("Subject" , "Value")
 5151:    widths  = (40    , 60)
 5152:    FFUQ0v(self, None, header=header, VVGape=VVGape, VV3cHe=widths, VVwdmN=28, VVKDPJ=1, VVoRat="#00ffff00", VVJKqd="#0a884400")
 5153:   else:
 5154:    FF4lCP(self, "Could not read info!")
 5155:  def VVOq0L(self, fileName):
 5156:   fileName = "/proc/stb/info/" + fileName
 5157:   if FFCyVu(fileName):
 5158:    try:
 5159:     txt = FFL19l(fileName)[0]
 5160:     if txt:
 5161:      return txt
 5162:    except:
 5163:     pass
 5164:   return "-"
 5165:  def VVUG40(self, mbDict, bg):
 5166:   try:
 5167:    mbList = list(mbDict)
 5168:    VVGape = []
 5169:    for key in mbList:
 5170:     bootDict = mbDict[key]
 5171:     device  = bootDict.get("device"  , "")
 5172:     rootsubdir = bootDict.get("rootsubdir" , "")
 5173:     startupfile = bootDict.get("startupfile", "")
 5174:     subject  = "Multiboot-" + str(key)
 5175:     value  = ""
 5176:     if startupfile : subject += " ... "      + startupfile
 5177:     if rootsubdir : value  += "Root-Sub-Dir = %s  ...  " % rootsubdir
 5178:     if device  : value  += "Device = "     + device
 5179:     if not value:
 5180:      value  = str(bootDict)
 5181:     VVGape.append((bg + subject, value))
 5182:   except:
 5183:    pass
 5184:   return VVGape
 5185:  def VVtK13(self):
 5186:   title = "Tuners"
 5187:   c1 = "#f#00ffff88#"
 5188:   sName = [c1 + "Slot Name"]
 5189:   Type = [c1 + "Type"]
 5190:   Descr = [c1 + "Description"]
 5191:   conn = [c1 + "Connectable to"]
 5192:   fId  = [c1 + "Frontend ID"]
 5193:   sId  = [c1 + "Slot ID"]
 5194:   mType = [c1 + "Multi-Type"]
 5195:   mStream = [c1 + "Multi-Stream"]
 5196:   FCB  = [c1 + "FCB"]
 5197:   bScan = [c1 + "Supports Blind-Scan"]
 5198:   tot = 0
 5199:   for ndx, slot in enumerate(nimmanager.nim_slots):
 5200:    if slot.frontend_id is not None:
 5201:     tot += 1
 5202:     sName.append(slot.getSlotName())
 5203:     Type.append(slot.getType())
 5204:     Descr.append(slot.getFriendlyFullDescription())
 5205:     conn.append(" , ".join(slot.connectableTo()))
 5206:     fId.append(str(slot.frontend_id))
 5207:     sId.append(slot.getSlotID())
 5208:     mType.append("Yes" if slot.isMultiType() else "No")
 5209:     try:  mStream.append("Yes" if slot.isMultistream() else "No")
 5210:     except:  mStream.append("?")
 5211:     try:  FCB.append("Yes" if slot.isFBCTuner() else "No")
 5212:     except:  FCB.append("?")
 5213:     try:  bScan.append("Yes" if slot.supportsBlindScan() else "No")
 5214:     except:  bScan.append("?")
 5215:   if tot:
 5216:    VVAkuK = []
 5217:    VVAkuK.append(sName)
 5218:    VVAkuK.append(Type)
 5219:    VVAkuK.append(Descr)
 5220:    VVAkuK.append(conn)
 5221:    VVAkuK.append(fId)
 5222:    VVAkuK.append(sId)
 5223:    VVAkuK.append(mType)
 5224:    VVAkuK.append(mStream)
 5225:    VVAkuK.append(FCB)
 5226:    VVAkuK.append(bScan)
 5227:    FFUQ0v(self, None, title="%s (Total = %s)" % (title, tot), VVGape=VVAkuK, width=1700, height=1000, VVKDPJ=1)
 5228:   else:
 5229:    FFdw58(self, "No Tuner Info.", title=title)
 5230:  def VVUKRb(self):
 5231:   major   = pyVersion[0]
 5232:   minor   = pyVersion[1]
 5233:   micro   = pyVersion[2]
 5234:   releaselevel = pyVersion[3]
 5235:   serial   = pyVersion[4]
 5236:   txt = "Version\t: %d.%d.%d\n" % (major, minor, micro)
 5237:   txt += "Release\t: %s\n"  % releaselevel
 5238:   txt += "Serial\t: %d\n"   % serial
 5239:   FF4lCP(self, txt)
 5240:  def VVluJ6(self):
 5241:   if CCYrUm.VVWp6i():
 5242:    tab = lambda x, y: "%s\t: %s\n" % (x, y)
 5243:    txt = tab("Stream Relay", "Supported")
 5244:    host, port = CCYrUm.VVbfMb()
 5245:    txt += tab("Hosts List", host or "?")
 5246:    txt += tab("Port", port or "?")
 5247:    txt += tab("Total Services", len(CCYrUm.VVtXqQ()))
 5248:    FF4lCP(self, txt, width=900)
 5249:   else:
 5250:    FFdw58(self, "Patch not found.")
 5251:  @staticmethod
 5252:  def VVSwko():
 5253:   def VVJi7Q(v, ndx):
 5254:    lst = v.split(";")[ndx].split(",")
 5255:    return {lst[i]: lst[i + 1] for i in range(0, len(lst), 2)}
 5256:   v = "openbox,OpenBox,openpli,OpenPLI,openvision,OpenVision;areadeltasat,ArEaDeltaSat,cobralibero,Cobralibero,opentr,OpenTR,peter,PeterPan,Gemini,Gemini;italysat,ItalySat,oozoon,OoZooN,openatv,openATV,openeight,OpenEight,openmips,OpenMips,opennfr,OpenNFR,openplus,OpenPlus,openspa,OpenSPA,pure2,Pure2,rudream,ruDream,teamblue,teamBlue,titannit,OpenAFF_Titan"
 5257:   v = {"/etc/issue": VVJi7Q(v,0), "/etc/issue.net": VVJi7Q(v,1), "/etc/image-version": VVJi7Q(v,2)}
 5258:   for p1, d in v.items():
 5259:    img = CC674y.VVyFLu(p1, d)
 5260:    if img: return img
 5261:   v = "Blackhole,Blackhole,DE,Dream-Elite,EGAMI,Egami,LT,LT,MediaSat,MediaSat,OPENDROID,OpenDroid,Bp/geminimain,GP3;Domica,Domica,DreamElite,Dream-Elite,GP4,GP4,SatLodge,Satlodge,Satdreamgr,SatdreamGr,TSimage,OpenTS_Ts,newnigma2,newnigma2;DemonisatManager,DDD-Demoni,VTIPanel,VTI,ViX,OpenVIX;AddOnManager,Merlin3,DreamOSatcamManager,DreamOSat CamManager,ExtraAddonss,OpenESI,HDF-Toolbox,OpenHDF,HDMUCenter,HDMU,LDteam,OpenLD,NssPanel,NonSoloSat,PKT,PKT,PowerboardCenter,PBNigma-VX,TDW,TDW"
 5262:   p = "/usr/lib/enigma2/python/"
 5263:   v = {p: VVJi7Q(v,0), p + "Plugins/": VVJi7Q(v,1), VVhDOZ: VVJi7Q(v,2), VVUytA: VVJi7Q(v,3)}
 5264:   for p1, d in v.items():
 5265:    img = CC674y.VVdVCf(p1, d)
 5266:    if img: return img
 5267:   return "OpenBlackhole" if iGlob("%sScreens/BpBlue.p*" % p) else ""
 5268:  @staticmethod
 5269:  def VVyFLu(path, d):
 5270:   if FFCyVu(path):
 5271:    txt = FFYVq0(path).lower()
 5272:    for key, val in d.items():
 5273:     if key.lower() in txt: return val
 5274:   return ""
 5275:  @staticmethod
 5276:  def VVdVCf(path, d):
 5277:   for key, val in d.items():
 5278:    if VVmJwX(path + key): return val
 5279:   return ""
 5280:  @staticmethod
 5281:  def VV1LWx():
 5282:   return VVmJwX(VVhDOZ + "VTIPanel")
 5283: class CCUImU(Screen):
 5284:  def __init__(self, session):
 5285:   self.skin, self.VVfOli = FFiNEe(VVWp3I, 700, 630, 50, 40, 30, "#22003300", "#22001100", 32)
 5286:   self.session  = session
 5287:   VV3wat = []
 5288:   VV3wat.append(("Settings (All)"   , "all" ))
 5289:   VV3wat.append(("Settings (Hot Keys)"  , "hk" ))
 5290:   VV3wat.append(("Settings (Tuner/DiSEqC)" , "tun" ))
 5291:   VV3wat.append(("Settings (Plugins)"  , "plug"))
 5292:   VV3wat.append(("Settings (Usage)"   , "usg" ))
 5293:   VV3wat.append(("Settings (Time Zone)"  , "tz" ))
 5294:   VV3wat.append(("Settings (Skin)"   , "sk" ))
 5295:   FFZMxC(self, VV3wat=VV3wat)
 5296:   self.onShown.append(self.VV7OzD)
 5297:  def VV7OzD(self):
 5298:   self.onShown.remove(self.VV7OzD)
 5299:   FF4IPF(self["myMenu"])
 5300:   FF2GM8(self)
 5301:  def VVPr1F(self):
 5302:   item = FFTmHZ(self)
 5303:   if item is not None:
 5304:    if   item == "all" : g = ""
 5305:    elif item == "hk" : g = ("config.misc.ButtonSetup." if CCxSED.VVdBQ3() else "config.misc.hotkey.")
 5306:    elif item == "tun" : g = "config.Nims."
 5307:    elif item == "plug" : g = ".plugins."
 5308:    elif item == "usg" : g = ".usage."
 5309:    elif item == "tz" : g = ".timezone."
 5310:    elif item == "sk" : g = ".skin."
 5311:    title = self["myMenu"].l.getCurrentSelection()[0]
 5312:    lst = []
 5313:    for line in FF3xOt("cat %s%s" % (VVfBVj, (" | grep %s" % g) if g else "")):
 5314:     k, _, v = line.partition("=")
 5315:     k, v = k.strip(), v.strip() or "-"
 5316:     if not g or g in line:
 5317:      lst.append((k.strip() or "-", v.strip() or "-"))
 5318:    if lst : FFUQ0v(self, None, title=title, header=("Key", "Value"), VVGape=lst, VVwdmN=28, VVpCEu=True)
 5319:    else : FFdw58(self, "No settings changes found.", title=title)
 5320: class CCid3A(Screen):
 5321:  def __init__(self, session):
 5322:   self.skin, self.VVfOli = FFiNEe(VVWp3I, 950, 800, 50, 40, 30, "#22003300", "#22001100", 30)
 5323:   self.VVtkkP, VV4gQd, VVmNNN, camCommand = CCid3A.VVYmCL()
 5324:   self.session  = session
 5325:   self.VV4gQd  = VV4gQd
 5326:   self.camInfo_cmd = camCommand + " -V 2> /dev/null"
 5327:   camName = "SoftCam"
 5328:   nC = oC = c = ""
 5329:   if VV4gQd:
 5330:    c = VVJEMb if VVmNNN else VVZtfx
 5331:    if   "oscam" in VV4gQd : camName, oC = "OSCam", c
 5332:    elif "ncam"  in VV4gQd : camName, nC = "NCam" , c
 5333:   VV3wat = []
 5334:   VV3wat.append(("OSCam Files" , "OSCamFiles" ))
 5335:   VV3wat.append(("NCam Files" , "NCamFiles" ))
 5336:   VV3wat.append(("CCcam Files" , "CCcamFiles" ))
 5337:   VV3wat.append(VVAL3j)
 5338:   VV3wat.append((VVFuwR + 'Convert "/etc/CCcam.cfg" to OSCam/NCam Readers', "VVAyqf"))
 5339:   VV3wat.append(VVAL3j)
 5340:   VV3wat.append((oC + "OSCam Readers" , "OSCamReaders"))
 5341:   VV3wat.append((nC + "NCam Readers" , "NSCamReaders"))
 5342:   VV3wat.append(VVAL3j)
 5343:   camCmd = os.path.basename(camCommand)
 5344:   txt = "%s Settings%s" % (camName, "" if camCmd in ("oscam", "ncam") else " ( %s )" % camCmd)
 5345:   VV3wat.append(FFsLU5(txt, "camInfo", VV4gQd, c))
 5346:   VV3wat.append(VVAL3j)
 5347:   camLst = ((c + camName + " Live Status" , "camLiveStatus" )
 5348:     , (c + camName + " Live Log" , "camLiveLog"  ))
 5349:   if VV4gQd:
 5350:    for item in camLst: VV3wat.append(item)
 5351:   else:
 5352:    for item in camLst: VV3wat.append((item[0], ))
 5353:   FFZMxC(self, title="SoftCam Tools", VV3wat=CCid3A.VV2wVK(VV3wat, 5))
 5354:   self.onShown.append(self.VV7OzD)
 5355:  def VV7OzD(self):
 5356:   self.onShown.remove(self.VV7OzD)
 5357:   FF4IPF(self["myMenu"])
 5358:   FF2GM8(self)
 5359:  def VVPr1F(self):
 5360:   item = FFTmHZ(self)
 5361:   if item is not None:
 5362:    if   item == "OSCamFiles"  : self.session.open(CC3v50, "oscam")
 5363:    elif item == "NCamFiles"  : self.session.open(CC3v50, "ncam")
 5364:    elif item == "CCcamFiles"  : self.session.open(CC3v50, "cccam")
 5365:    elif item == "VVAyqf" : self.VVAyqf()
 5366:    elif item == "VVgo8Z" : self.VVgo8Z()
 5367:    elif item == "OSCamReaders"  : self.VVL8Lp("os")
 5368:    elif item == "NSCamReaders"  : self.VVL8Lp("n")
 5369:    elif item == "camInfo"   : self.VVm7sR(self.camInfo_cmd)
 5370:    elif item == "camLiveStatus" : CCid3A.VVgHEe(self.session, True)
 5371:    elif item == "camLiveLog"  : CCid3A.VVgHEe(self.session, False)
 5372:    else       : self.close()
 5373:  def VVm7sR(self, cmd):
 5374:   lines = FF3xOt(cmd)
 5375:   VVAkuK = []
 5376:   for line in lines:
 5377:    line = line.strip()
 5378:    if ":" in line:
 5379:     parts = line.split(":")
 5380:     key  = parts[0].strip()
 5381:     val  = parts[1].strip()
 5382:     VVAkuK.append((key, val))
 5383:    elif line:
 5384:     VVAkuK.append((line, ""))
 5385:   if VVAkuK:
 5386:    header   = ("Parameter" , "Value" )
 5387:    widths   = (50    , 50  )
 5388:    FFUQ0v(self, None, header=header, VVGape=VVAkuK, VV3cHe=widths, VVwdmN=28, VVpCEu=True)
 5389:   else:
 5390:    FFZQVC(self, cmd)
 5391:  def VVAyqf(self):
 5392:   path = CCid3A.VVWxDt()
 5393:   outFile = "%scccam_to_reader_%s.txt" % (FF0cqc(), FFjTQe())
 5394:   if FFCyVu(path):
 5395:    lines = FFL19l(path)
 5396:    lst = []
 5397:    for line in lines:
 5398:     line = line.strip()
 5399:     if line.startswith("C:"):
 5400:      while "  " in line: line = line.replace("  ", " ")
 5401:      parts = line.split(" ")
 5402:      if len(parts) == 5:
 5403:       CTxt, host, port, User, Pass = parts
 5404:       lst.append((host, port, User, Pass))
 5405:    newLine = []
 5406:    if lst:
 5407:     VVJi7Q = lambda txt, val: "%s= %s\n" % (txt.ljust(30), str(val))
 5408:     with open(outFile, "w") as f:
 5409:      for ndx, item in enumerate(lst, start=1):
 5410:       host, port, User, Pass = item
 5411:       f.write("[reader]\n")
 5412:       f.write(VVJi7Q("label"    , "CCcam-Line-%d" % ndx))
 5413:       f.write(VVJi7Q("description"  , "CCcam-Line-%d" % ndx))
 5414:       f.write(VVJi7Q("protocol"   , "cccam"))
 5415:       f.write(VVJi7Q("device"    , "%s,%s" % (host, port)))
 5416:       f.write(VVJi7Q("user"    , User))
 5417:       f.write(VVJi7Q("password"   , Pass))
 5418:       f.write(VVJi7Q("fallback"   , "1"))
 5419:       f.write(VVJi7Q("group"    , "64"))
 5420:       f.write(VVJi7Q("cccversion"   , "2.3.2"))
 5421:       f.write(VVJi7Q("audisabled"   , "1"))
 5422:       f.write(VVJi7Q("ccckeepalive"  , "1"))
 5423:       f.write("\n")
 5424:     tot = len(lst)
 5425:     FFipXT(self, "Output = %d Reader%s in:\n\n%s" % (tot, FFcacr(tot), outFile))
 5426:    else:
 5427:     FF28n1(self, "No valid CCcam lines", 1500)
 5428:   else:
 5429:    FF28n1(self, "%s not found" % path, 1500)
 5430:  def VVgo8Z(self):
 5431:   CCh3tv.VV7Nf4(self, VVixvy=self.VVs6qu, VVbYwR=self.VVOgyS)
 5432:  def VVs6qu(self, VVXyP6):
 5433:   ttl = "Processing ..."
 5434:   VVXyP6.VVNc18 = ("", "Not found")
 5435:   dic = CC6u6z.VVtAiS()
 5436:   if dic : VVXyP6.VVq8NF(len(dic[1]) + 4)
 5437:   else : return
 5438:   lst1 = []
 5439:   uErr = []
 5440:   uNoLn = []
 5441:   for uNum, u in enumerate(dic[1], start=1):
 5442:    u = FFqmPQ(u[1:-1])
 5443:    if not VVXyP6 or VVXyP6.isCancelled: return
 5444:    VVXyP6.VVaks5(u.partition("/")[0] if VVBvqf else ttl)
 5445:    VVXyP6.VVxtQs(1)
 5446:    res, err = CCHRcZ.VVcUJs("https://%s" % u, timeout=4)
 5447:    if res:
 5448:     span = iSearch(r"(C: \S+ \d+ \S+ [^\s<]+)", res.text, IGNORECASE)
 5449:     if span : lst1.append(str(span.group(1)).strip().replace("c:", "C:"))
 5450:     else : uNoLn.append(u)
 5451:    elif err:
 5452:     uErr.append(u)
 5453:   lst2 = []
 5454:   u = FFqmPQ(dic[2][1:-1])
 5455:   if not VVXyP6 or VVXyP6.isCancelled: return
 5456:   VVXyP6.VVaks5((u + " (P1)") if VVBvqf else ttl)
 5457:   VVXyP6.VVxtQs(1)
 5458:   res, err = CCHRcZ.VVcUJs("https://%s" % u, timeout=2)
 5459:   if res:
 5460:    span = iSearch(r'<a href="(.+)">%s<\/a>' % FFQqEJ("RnJlZSBDQ2NhbSBzZXJ2ZXJz"), res.text, IGNORECASE)
 5461:    if span:
 5462:     if not VVXyP6 or VVXyP6.isCancelled: return
 5463:     VVXyP6.VVaks5((u + " (P2)") if VVBvqf else ttl)
 5464:     VVXyP6.VVxtQs(1)
 5465:     res, err = CCHRcZ.VVcUJs(span.group(1), timeout=2)
 5466:     if res:
 5467:      lst2 = iFindall(r"(C:\s+.+)#", res.text) or []
 5468:      lst2 = list(map(str.strip, list(map(str, lst2))))
 5469:      lst2.sort()
 5470:     elif err: uErr.append(u)
 5471:   elif err: uErr.append(u)
 5472:   if not lst2: uNoLn.append(u)
 5473:   lst3 = []
 5474:   u = FFqmPQ(dic[3][1:-1])
 5475:   if not VVXyP6 or VVXyP6.isCancelled: return
 5476:   VVXyP6.VVaks5(u  if VVBvqf else ttl)
 5477:   VVXyP6.VVxtQs(1)
 5478:   res, err = CCHRcZ.VVcUJs("https://%s" % u, timeout=2)
 5479:   if res:
 5480:    lst3 = iFindall(r"(C:\s+.+)<\/a>", res.text) or []
 5481:    lst3 = list(map(str.strip, list(map(str, lst3))))
 5482:    lst3.sort()
 5483:   elif err: uErr.append(u)
 5484:   if not lst3: uNoLn.append(u)
 5485:   if not lst1 and not lst2 and not lst3:
 5486:    VVXyP6.VVNc18 = ("", "No lines found")
 5487:    return
 5488:   sep1 = "#" + " %s %s %s" % ("=" * 15, FFwjLg(), "=" * 15)
 5489:   sep2 = "#" + " " + "-" * 51
 5490:   lst = ["", sep1]
 5491:   lst.extend(lst1)
 5492:   if lst1 and lst2: lst.append(sep2)
 5493:   lst.extend(lst2)
 5494:   if lst1 or lst2: lst.append(sep2)
 5495:   lst.extend(lst3)
 5496:   totL = len(lst1) + len(lst2) + len(lst3)
 5497:   def VVONcs(p):
 5498:    patt = r"^#\s={10,}\s.+\s={10,}"
 5499:    fLines, totR  = [], 0
 5500:    oldLines = FFL19l(p)
 5501:    Max = len(oldLines) - 1
 5502:    for ndx, ln in enumerate(oldLines):
 5503:     ln = str(ln).strip()
 5504:     if ndx < Max:
 5505:      nextL = oldLines[ndx + 1].strip()
 5506:      if   iMatch(patt, ln) and (iMatch(patt, nextL) or not nextL or nextL.startswith("#")) : continue
 5507:      elif (ln == sep2) and (not nextL or nextL == sep2 or iMatch(patt, nextL))    : continue
 5508:     if not ln or ln.startswith("#"):
 5509:      fLines.append(ln)
 5510:     else:
 5511:      Code = ln.partition("#")[0].strip()
 5512:      if not Code in lst : fLines.append(ln)
 5513:      elif Code   : totR += 1
 5514:    return fLines, totR
 5515:   def VV9EHD(p, lines):
 5516:    fTxt = "\n".join(lines).strip()
 5517:    while "\n\n\n" in fTxt: fTxt = fTxt.replace("\n\n\n", "\n\n")
 5518:    with open(p, "w") as f: f.write("%s\n" % fTxt)
 5519:   f1 = CCid3A.VVWxDt()
 5520:   fLines, totR1 = VVONcs(f1)
 5521:   fLines.extend(lst)
 5522:   VV9EHD(f1, fLines)
 5523:   f2 = CCid3A.VVv8H6()
 5524:   totR2 = 0
 5525:   if FFCyVu(f2):
 5526:    fLines, totR2 = VVONcs(f2)
 5527:    fLines.extend(lst)
 5528:    VV9EHD(f2, fLines)
 5529:   c1 = VVFuwR
 5530:   ttl = lambda x: "%s:\n" % FFjt5L(x, c1)
 5531:   txt1  = ttl("Updated Files")
 5532:   txt1 += "  %s%s\n" % (f1, ("   (Replaced : %s)" % totR1) if totR1 else "")
 5533:   if FFCyVu(f2): txt1 += "  %s%s\n" % (f2, ("   (Replaced : %s)" % totR2) if totR2 else "")
 5534:   if VVBvqf:
 5535:    txt = txt1
 5536:    if uErr:
 5537:     txt += "\n" + ttl("With Errors")
 5538:     txt += "  %s\n" % "\n  ".join(uErr)
 5539:    if uNoLn:
 5540:     txt += "\n" + ttl("With no Lines")
 5541:     txt += "  %s\n" % "\n  ".join(uNoLn)
 5542:    txt += "\n%s" % FFGEAF("Added Lines (%s)" % totL, VVJEMb)
 5543:    txt += "\n".join(lst)
 5544:   else:
 5545:    txt  = ttl("Added Lines")
 5546:    txt += "  %s\n\n" % totL
 5547:    txt += txt1
 5548:   VVXyP6.VVNc18 = (txt, "")
 5549:  def VVOgyS(self, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
 5550:   if VVRI6P:
 5551:    txt, err = VVNc18
 5552:    if err  : FFdw58(self, err)
 5553:    elif not txt: FFdw58(self, "Not found")
 5554:    else:
 5555:     FF4lCP(self, txt)
 5556:     CCid3A.VVaomc(self.session)
 5557:  @FFOAKH()
 5558:  def VVL8Lp(self, VVX2Ni):
 5559:   VVAkuK = CCid3A.VVj372(self, VVX2Ni)
 5560:   if VVAkuK:
 5561:    VVAkuK.sort(key=lambda x: int(x[0]))
 5562:    if self.VV4gQd and self.VV4gQd.startswith(VVX2Ni):
 5563:     VVwWmA = ("Delete Reader" , BF(self.VV2zpk, VVX2Ni) , [])
 5564:     VVwSzI = ("Toggle State"  , self.VV6saL, [VVX2Ni]     , "Changing State ...")
 5565:     VVpCEu = False
 5566:    else:
 5567:     VVwWmA = VVwSzI = None
 5568:     VVpCEu = True
 5569:    bg = "#22000011"
 5570:    header   = ("No." , "State" , "Label" , "Description" , "Host", "Port", "Protocol", "User", "Password")
 5571:    widths   = (4  , 5    , 28    , 16   , 14 , 6   , 9   , 9  , 9   )
 5572:    VVLIqP  = (CENTER , CENTER , LEFT   , LEFT   , LEFT , CENTER, LEFT  , LEFT , LEFT  )
 5573:    FFUQ0v(self, None, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, width=1800, height=1000, VVwdmN=24, VVpCEu=VVpCEu, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVHPI7=True
 5574:      , VVwltY="#22002030", VVkxBG=bg, VVemyB=bg, VVJKqd="#00664411", VVbcr0="#00444444", VVX9AA="#08442211")
 5575:  def VVqc5j(self, VV6A99, VVX2Ni):
 5576:   VVAkuK = CCid3A.VVj372(self, VVX2Ni)
 5577:   if VVAkuK : VV6A99.VVMqQ9(VVAkuK)
 5578:   else  : VV6A99.cancel()
 5579:  def VVj372(self, VVX2Ni):
 5580:   rFile = "%s%scam.server" % (self.VVtkkP, VVX2Ni)
 5581:   if FFCyVu(rFile):
 5582:    lst = CCid3A.VValww(rFile)
 5583:    if not lst: FFdw58(self, "No readers found !")
 5584:    return lst
 5585:   else:
 5586:    FF8Wsn(self, rFile)
 5587:    return []
 5588:  def VV2zpk(self, VVX2Ni, VV6A99, title, txt, colList):
 5589:   num, stt, lbl, dscr, hst, prt, prot, usr, pas = colList
 5590:   FFRMYv(self, BF(CCid3A.VVQGgp, VV6A99, lbl, cbFnc=BF(self.VVqc5j, VV6A99, VVX2Ni)), "%s\n\nDelete ?" % lbl, title="Delete Reader")
 5591:  def VV6saL(self, VV6A99, VVX2Ni):
 5592:   confFile = "%s%scam.conf" % (self.VVtkkP, VVX2Ni)
 5593:   readerState = VV6A99.VVeE40(1)
 5594:   readerLabel = VV6A99.VVeE40(2)
 5595:   if "off" in readerState.lower() : newState = "enable"
 5596:   else       : newState = "disable"
 5597:   urlAction = "&label=%s&action=%s" % (FFSiPR(readerLabel), newState)
 5598:   uReq = CCid3A.VVJssd(self, VVX2Ni, confFile, "readerlist", urlAction)
 5599:   if uReq:
 5600:    try:
 5601:     page = iUrlopen(uReq, timeout=4)
 5602:    except Exception as e:
 5603:     VV6A99.VVrmMb()
 5604:     FFdw58(self, "Cannot connect to SoftCAM !\n\nError = %s" % str(e))
 5605:     return
 5606:    self.VVqc5j(VV6A99, VVX2Ni)
 5607:   else:
 5608:    VV6A99.VVrmMb()
 5609:  @staticmethod
 5610:  def VVJssd(SELF, VVX2Ni, confFile, urlPart, urlAction, typ="html"):
 5611:   if FFCyVu(confFile):
 5612:    lines = FFL19l(confFile)
 5613:    user = "root"
 5614:    pwd  = port = ""
 5615:    if lines:
 5616:     webif = False
 5617:     for line in lines:
 5618:      line = line.strip().lower()
 5619:      if "[webif]" in line:
 5620:       webif = True
 5621:      if webif and "=" in line:
 5622:       if   line.startswith("httpuser"): user = line.split("=")[1].strip()
 5623:       elif line.startswith("httppwd") : pwd = line.split("=")[1].strip()
 5624:       elif line.startswith("httpport"): port = line.split("=")[1].strip()
 5625:    if not webif:
 5626:     FFdw58(SELF, "Cannot connect to SoftCAM Web Interface !")
 5627:     return None
 5628:    elif not port:
 5629:     FFdw58(SELF, "SoftCAM Web Port not found in file:\n\n%s" % confFile)
 5630:     return None
 5631:   else:
 5632:    FF8Wsn(SELF, confFile)
 5633:    return None
 5634:   if not iRequest:
 5635:    FFdw58(SELF, "Module not found\n\nurllib/urllib2")
 5636:    return None
 5637:   try:
 5638:    url = "http://127.0.0.1:%s/%scamapi.%s?part=%s%s" % (port, VVX2Ni, typ, urlPart, urlAction)
 5639:    acceccManager = HTTPPasswordMgrWithDefaultRealm()
 5640:    acceccManager.add_password(None, url, user, pwd)
 5641:    handlers= HTTPDigestAuthHandler(acceccManager)
 5642:    opener = build_opener(HTTPHandler, handlers)
 5643:    install_opener(opener)
 5644:    return iRequest(url)
 5645:   except Exception as e:
 5646:    FFdw58(SELF, "Error while preparing URL Request !\n\n %s" % str(e))
 5647:    return None
 5648:  @staticmethod
 5649:  def VVYmCL():
 5650:   VVtkkP = "/etc/tuxbox/config/"
 5651:   VV4gQd = None
 5652:   VVmNNN  = None
 5653:   camCommand = FFTKR0(r"lsof | grep 'oscam\|ncam' | tail -1 | awk '{print $2}'")
 5654:   if camCommand:
 5655:    camCmd = os.path.basename(camCommand).lower()
 5656:    if   camCmd.startswith("oscam") : VV4gQd = "oscam"
 5657:    elif camCmd.startswith("ncam") : VV4gQd = "ncam"
 5658:   if VV4gQd:
 5659:    tStr = os.path.basename(camCommand).lower()
 5660:    for path in iGlob("/etc/init.d/softcam.*"):
 5661:     _, _, camName = os.path.basename(path).lower().partition(".")
 5662:     if camName == tStr:
 5663:      fTxt = FFYVq0(path)
 5664:      span = iSearch(r"-config-dir\s(\/etc\/tuxbox.*?)\s", fTxt, IGNORECASE)
 5665:      if span:
 5666:       VVtkkP = FFoWxR(span.group(1))
 5667:       var = "$CAMNAME"
 5668:       if var in VVtkkP:
 5669:        span = iSearch(r'CAMNAME="(.+)"', fTxt, IGNORECASE)
 5670:        if span:
 5671:         VVtkkP = VVtkkP.replace(var, span.group(1))
 5672:       break
 5673:    else:
 5674:     path = FFTKR0(camCommand + " -V 2> /dev/null | grep -i configdir | awk '{print $2}'")
 5675:     path = FFoWxR(path)
 5676:     if VVmJwX(path):
 5677:      VVtkkP = path
 5678:    tFile = FFoWxR(VVtkkP) + VV4gQd + ".conf"
 5679:    tFile = FFTKR0("FILE='%s'; [ -f $FILE ] && cat $FILE | grep -i LOGFILE | awk '{print $3}'" % tFile)
 5680:    if FFCyVu(tFile):
 5681:     VVmNNN = tFile
 5682:   return VVtkkP, VV4gQd, VVmNNN, camCommand
 5683:  @staticmethod
 5684:  def VVw1zi(SELF=None):
 5685:   VVtkkP, VV4gQd, VVmNNN, camCommand = CCid3A.VVYmCL()
 5686:   VVX2Ni = confFile = ""
 5687:   if VV4gQd:
 5688:    VVX2Ni = "os" if "oscam" in VV4gQd else "n"
 5689:    confFile = "%s%scam.conf" % (VVtkkP, VVX2Ni)
 5690:   elif SELF:
 5691:    FFdw58(SELF, message="No active OSCam/NCam")
 5692:   return VVtkkP, VV4gQd, VVmNNN, camCommand, VVX2Ni, confFile
 5693:  @staticmethod
 5694:  def VV6ows(SELF, part, act, typ="html"):
 5695:   VVtkkP, VV4gQd, VVmNNN, camCommand, VVX2Ni, confFile = CCid3A.VVw1zi(SELF)
 5696:   return CCid3A.VVJssd(SELF, VVX2Ni, confFile, part, act, typ=typ) if VV4gQd else None
 5697:  @staticmethod
 5698:  def VV27G2():
 5699:   VVtkkP, VV4gQd, VVmNNN, camCommand, VVX2Ni, confFile = CCid3A.VVw1zi()
 5700:   return "%s%scam.server" % (VVtkkP, VVX2Ni) if VV4gQd else ""
 5701:  @staticmethod
 5702:  def VVv8H6():
 5703:   VVtkkP, VV4gQd, VVmNNN, camCommand, VVX2Ni, confFile = CCid3A.VVw1zi()
 5704:   return ("%sCCcam.cfg" % VVtkkP) if VVtkkP else ""
 5705:  @staticmethod
 5706:  def VVWxDt():
 5707:   return "/etc/CCcam.cfg"
 5708:  @staticmethod
 5709:  def VVFzc8():
 5710:   return (CCid3A.VVWxDt(), CCid3A.VVv8H6())
 5711:  @staticmethod
 5712:  def VValww(rFile):
 5713:   lst  = []
 5714:   tag  = "[reader]"
 5715:   lines = FFL19l(rFile)
 5716:   tagFound= False
 5717:   enable = label = description = url = port = protocol = User = password = ""
 5718:   onStr = "
 5719:   offStr = "OFF"
 5720:   for ndx, line in enumerate(lines):
 5721:    if tag in line.lower() or ndx >= len(lines) - 1:
 5722:     if enable or label or description or url or port or protocol or User or password:
 5723:      if enable == "": enable = onStr
 5724:      lst.append((str(len(lst) + 1), enable, label, description, url, port, protocol, User, password))
 5725:     enable = label = description = url = port = protocol = User = password = ""
 5726:    elif "=" in line:
 5727:     key, _, val = line.partition("=")
 5728:     key, val = key.strip().lower(), val.strip()
 5729:     if   key == "label"   : label   = val
 5730:     elif key == "description" : description = val
 5731:     elif key == "protocol"  : protocol  = val
 5732:     elif key == "user"   : User   = val
 5733:     elif key == "password"  : password  = val
 5734:     elif key == "enable"  : enable = offStr if val == "0" else onStr
 5735:     elif key == "device"  :
 5736:      url, _, port = val.partition(",")
 5737:      url, port = url.strip(), port.strip()
 5738:   return lst
 5739:  @staticmethod
 5740:  @FFOAKH("Deleting ...")
 5741:  def VVQGgp(SELF, lbl, delCC=True, cbFnc=None):
 5742:   if delCC: CCid3A.VV9mPr(lbl)
 5743:   uReq = CCid3A.VV6ows(SELF, "readerlist", "&label=%s&action=delete" % FFSiPR(lbl), typ="json")
 5744:   if uReq:
 5745:    try:
 5746:     res = iUrlopen(uReq, timeout=4)
 5747:     if cbFnc: cbFnc()
 5748:    except:
 5749:     FFjADj(SELF, "Cannot access SoftCam", 2000)
 5750:  @staticmethod
 5751:  def VV9mPr(dLbl):
 5752:   relatedReaders = []
 5753:   rFile = CCid3A.VV27G2()
 5754:   rLst = [(hst, prt, usr, pas) for num, stt, lbl, dscr, hst, prt, prot, usr, pas in CCid3A.VValww(rFile) if lbl==dLbl]
 5755:   for f in CCid3A.VVFzc8():
 5756:    c, lines = 0, []
 5757:    for ln in FFL19l(f):
 5758:     span = iSearch(r"^(?:C|N):\s+(\S+)\s+(\d+)\s+(\S+)\s+(\S+)", ln.strip())
 5759:     if span and span.groups() in rLst:
 5760:      ln = "
 5761:      c += 1
 5762:     lines.append(ln)
 5763:    if c > 0:
 5764:     with open(f, "w") as f:
 5765:      f.write("%s\n" % "\n".join(lines))
 5766:  @staticmethod
 5767:  def VVaomc(session):
 5768:   cmd, name = CCid3A.VVAAze()
 5769:   if cmd:
 5770:    def VVZwiy(*args): CCYrUm.VV0iSP(session)
 5771:    CCaTk8().VVtIZD("%s restart" % cmd, VVZwiy)
 5772:  @staticmethod
 5773:  def VVAAze():
 5774:   try:
 5775:    c = os.path.realpath("/etc/init.d/softcam")
 5776:    if not c.endswith(".None"): return c, os.path.split(c)[1].partition(".")[2]
 5777:   except:
 5778:    pass
 5779:   return "", ""
 5780:  @staticmethod
 5781:  def VVgHEe(session, VVpLzn):
 5782:   VVtkkP, VV4gQd, VVmNNN, camCommand = CCid3A.VVYmCL()
 5783:   if VV4gQd: session.open(CC6dXO, VVtkkP=VVtkkP, VV4gQd=VV4gQd, VVmNNN=VVmNNN, VVpLzn=VVpLzn)
 5784:   else  : FFzcnp(session, message="No active OSCam/NCam", title="Live Log")
 5785:  @staticmethod
 5786:  def VVAilv(SELF):
 5787:   if iElem:
 5788:    return True
 5789:   else:
 5790:    FFdw58(SELF, "Module not found:\n\nxml.etree")
 5791:    return False
 5792:  @staticmethod
 5793:  def VV2wVK(lst, i):
 5794:   t = CC6u6z.VVZxjK(900)
 5795:   if t and VVBvqf: lst.insert(i, (VVFuwR + t, "VVgo8Z"))
 5796:   return lst
 5797: class CC3v50(Screen):
 5798:  def __init__(self, session, VVqTGx):
 5799:   self.skin, self.VVfOli = FFiNEe(VVWp3I, 700, 650, 50, 40, 30, "#22003300", "#22001100", 30)
 5800:   self.session  = session
 5801:   self.VVtkkP, VV4gQd, VVmNNN, camCommand = CCid3A.VVYmCL()
 5802:   if   VVqTGx == "ncam" : self.prefix = "n"
 5803:   elif VVqTGx == "oscam" : self.prefix = "os"
 5804:   else     : self.prefix = ""
 5805:   VV3wat = []
 5806:   if self.prefix == "":
 5807:    VV3wat.append(("CCcam.cfg"         , "c_CCcam_cfg"  ))
 5808:    VV3wat.append(("ecm.info"          , "c_ecm_info"  ))
 5809:   else:
 5810:    VV3wat.append(("AutoRoll.Key"         , "x_AutoRoll_Key" ))
 5811:    VV3wat.append(("constant.cw"         , "x_constant_cw" ))
 5812:    VV3wat.append((self.prefix + "cam.ccache"      , "x_cam_ccache" ))
 5813:    VV3wat.append((self.prefix + "cam.conf"      , "x_cam_conf"  ))
 5814:    VV3wat.append((self.prefix + "cam.dvbapi"      , "x_cam_dvbapi" ))
 5815:    VV3wat.append((self.prefix + "cam.provid"      , "x_cam_provid" ))
 5816:    VV3wat.append((self.prefix + "cam.server"      , "x_cam_server" ))
 5817:    VV3wat.append((self.prefix + "cam.services"     , "x_cam_services" ))
 5818:    VV3wat.append((self.prefix + "cam.srvid2"      , "x_cam_srvid2" ))
 5819:    VV3wat.append((self.prefix + "cam.user"      , "x_cam_user"  ))
 5820:    VV3wat.append(VVAL3j)
 5821:    VV3wat.append(("SoftCam.Key / SoftCam.key"     , "x_SoftCam_Key" ))
 5822:    VV3wat.append(("CCcam.cfg"         , "x_CCcam_cfg"  ))
 5823:    VV3wat.append(VVAL3j)
 5824:    VV3wat.append((self.prefix + "cam.log (last 100 lines)"  , "x_cam_log"  ))
 5825:    VV3wat.append((self.prefix + "cam.log-prev (last 100 lines)" , "x_cam_log_prev" ))
 5826:    VV3wat.append((self.prefix + "cam.pid"      , "x_cam_pid"  ))
 5827:   FFZMxC(self, VV3wat=VV3wat)
 5828:   self.onShown.append(self.VV7OzD)
 5829:  def VV7OzD(self):
 5830:   self.onShown.remove(self.VV7OzD)
 5831:   FF4IPF(self["myMenu"])
 5832:   FF2GM8(self)
 5833:  def VVPr1F(self):
 5834:   item = FFTmHZ(self)
 5835:   pathTmp = "/tmp/"
 5836:   if item is not None:
 5837:    if   item == "c_CCcam_cfg"  : FFaOUK(self, "/var/etc/CCcam.cfg")
 5838:    elif item == "c_ecm_info"  : FFaOUK(self, "/tmp/ecm.info")
 5839:    elif item == "x_AutoRoll_Key" : FFaOUK(self, self.VVtkkP + "AutoRoll.Key")
 5840:    elif item == "x_constant_cw" : FFaOUK(self, self.VVtkkP + "constant.cw")
 5841:    elif item == "x_cam_ccache"  : self.VVaJjM("cam.ccache")
 5842:    elif item == "x_cam_conf"  : self.VVaJjM("cam.conf")
 5843:    elif item == "x_cam_dvbapi"  : self.VVaJjM("cam.dvbapi")
 5844:    elif item == "x_cam_provid"  : self.VVaJjM("cam.provid")
 5845:    elif item == "x_cam_server"  : self.VVaJjM("cam.server")
 5846:    elif item == "x_cam_services" : self.VVaJjM("cam.services")
 5847:    elif item == "x_cam_srvid2"  : self.VVaJjM("cam.srvid2")
 5848:    elif item == "x_cam_user"  : self.VVaJjM("cam.user")
 5849:    elif item == "x_SEP"   : pass
 5850:    elif item == "x_SoftCam_Key" : self.VVEmlc()
 5851:    elif item == "x_CCcam_cfg"  : FFaOUK(self, self.VVtkkP + "CCcam.cfg")
 5852:    elif item == "x_SEP"   : pass
 5853:    elif item == "x_cam_log"  : FFaOUK(self, pathTmp + self.prefix + "cam.log")
 5854:    elif item == "x_cam_log_prev" : FFaOUK(self, pathTmp + self.prefix + "cam.log-prev")
 5855:    elif item == "x_cam_pid"  : FFaOUK(self, pathTmp + self.prefix + "cam.pid")
 5856:    else       : self.close()
 5857:  def VVaJjM(self, fileName):
 5858:   FFaOUK(self, self.VVtkkP + self.prefix + fileName)
 5859:  def VVEmlc(self):
 5860:   path = self.VVtkkP + "SoftCam.Key"
 5861:   if FFCyVu(path) : FFaOUK(self, path)
 5862:   else    : FFaOUK(self, path.replace(".Key", ".key"))
 5863: class CC6dXO(Screen):
 5864:  def __init__(self, session, VVtkkP="", VV4gQd="", VVmNNN="", VVpLzn=False):
 5865:   self.skin, self.VVfOli = FFiNEe(VVmSQ6, 1700, 950, 50, 30, 20, "
 5866:   self.session   = session
 5867:   self.VVmNNN   = VVmNNN
 5868:   self.VVpLzn   = VVpLzn
 5869:   self.timer    = eTimer()
 5870:   self.VV3o4m  = False
 5871:   self.Title    = "Live Log"
 5872:   self.elementTree  = None
 5873:   self.VVCbxX   = None
 5874:   self.VVNiEs  = False
 5875:   self.user    = "root"
 5876:   self.pwd    = ""
 5877:   self.port    = ""
 5878:   self.VV6A99  = None
 5879:   self.period    = 3000
 5880:   if "oscam" in VV4gQd : titleTxt, self.VVX2Ni = "OSCam", "os"
 5881:   else     : titleTxt, self.VVX2Ni = "NCam" , "n"
 5882:   self.confFile   = "%s%scam.conf" % (VVtkkP, self.VVX2Ni)
 5883:   if self.VVpLzn: self.Title = "  %s Status" % titleTxt
 5884:   else   : self.Title = "  %s Live Log" % titleTxt
 5885:   FFZMxC(self, self.Title, addScrollLabel=True)
 5886:   FFRLNq(self["keyRed"], "Stop")
 5887:   FFBep1(self, {"red": self.VVKNev})
 5888:   self.onShown.append(self.VV7OzD)
 5889:   self.onClose.append(self.onExit)
 5890:  def VV7OzD(self):
 5891:   self.onShown.remove(self.VV7OzD)
 5892:   self["myLabel"].VV5kEH(VV7u0U=False)
 5893:   FFWgBS(self)
 5894:   self["myBar"].instance.setHAlign(1)
 5895:   self.VVKNev()
 5896:  def onExit(self):
 5897:   self.timer.stop()
 5898:  def VVTZ90(self):
 5899:   try: self.timer_conn = self.timer.timeout.connect(self.VV0HkJ)
 5900:   except: self.timer.callback.append(self.VV0HkJ)
 5901:   self.timer.start(self.period, False)
 5902:   self.VV3o4m = True
 5903:   self.VV5jvY(True)
 5904:  def VVOZOa(self):
 5905:   self.timer.stop()
 5906:   self.VV3o4m = False
 5907:   try:
 5908:    self.timer.callback.remove(self.VV0HkJ)
 5909:   except:
 5910:    pass
 5911:   self.VV5jvY(False)
 5912:  def VV5jvY(self, isOn):
 5913:   if isOn : title, redTxt, barTxt, txt = " (Running)" , "Stop" , "Waiting for update ..." , "Started"
 5914:   else : title, redTxt, barTxt, txt = ""   , "Start", ""      , "Stopped"
 5915:   if self.VV6A99:
 5916:    self.VV6A99.VV0ZtI(self.Title + title)
 5917:    self.VV6A99["keyRed"].setText(redTxt)
 5918:    FF28n1(self.VV6A99, txt, 800)
 5919:   else:
 5920:    self["myTitle"].setText(self.Title + title)
 5921:    self["keyRed"].setText(redTxt)
 5922:    FF28n1(self, txt, 1000)
 5923:  def VVKNev(self):
 5924:   if self.VV3o4m:
 5925:    self.VVOZOa()
 5926:   else:
 5927:    self.VVTZ90()
 5928:    uReq = CCid3A.VVJssd(self, self.VVX2Ni, self.confFile, "status", "")
 5929:    if uReq and CCid3A.VVAilv(self):
 5930:     self.VVCbxX, self.elementTree = uReq, iElem
 5931:     if self.VVNiEs:
 5932:      self.VVNiEs = False
 5933:      self["myLabel"].setText("Reading from SoftCAM Interface ...")
 5934:     FFIElK(self.VV7wNh)
 5935:    else:
 5936:     self.close()
 5937:  def VV0HkJ(self):
 5938:   if self.VV3o4m:
 5939:    self.VV6Qml()
 5940:  def VV7wNh(self):
 5941:   self.VV6Qml()
 5942:  def VV6Qml(self):
 5943:   try:
 5944:    page = iUrlopen(self.VVCbxX, timeout=1).read()
 5945:    err = ""
 5946:   except iURLError as e:
 5947:    err = FFWVTk(e)
 5948:   except Exception as e:
 5949:    err = str(e)
 5950:   if err:
 5951:    self["myLabel"].setText(FFjt5L("Cannot read from SoftCAM Interface !\n\nError = %s\n\nPlease activate Softcam." % err, VVz22H))
 5952:    self.VVNiEs = True
 5953:    self.VVOZOa()
 5954:    return
 5955:   camTxt = page.decode("UTF-8")
 5956:   lines = list(map(str, camTxt.splitlines()))
 5957:   if self.VVpLzn: ok = self.VVim5j(lines)
 5958:   else   : ok = self.VVEBkn(lines)
 5959:   txt = "Last Update : %s" % FFIPdt()
 5960:   if self.VV6A99: self.VV6A99["myBar"].setText(txt)
 5961:   else     : self["myBar"].setText(txt)
 5962:   if not ok:
 5963:    FFdw58(self, "No date from SoftCam.")
 5964:    self.VVOZOa()
 5965:    if self.VV6A99: self.VV6A99.cancel()
 5966:    self.close()
 5967:  def VVim5j(self, lines):
 5968:   xmlTxt = '<?xml version="1.0" encoding="UTF-8"?>\n'
 5969:   tags = ("<status", "<client", "<request", "<times", "<connection", "</client", "</status")
 5970:   for line in lines:
 5971:    line = line.strip()
 5972:    if line.startswith(tags):
 5973:     xmlTxt += line
 5974:   parseError = False
 5975:   try:
 5976:    root = self.elementTree.fromstring(xmlTxt)
 5977:   except Exception as e:
 5978:    parseError = FFjt5L("Error while parsing data elements !\n\nError = %s" % str(e), VVYjI5)
 5979:    self.VVNiEs = True
 5980:    self.VVOZOa()
 5981:   txt = ""
 5982:   if not parseError is False:
 5983:    txt = parseError
 5984:    self["myLabel"].setText(txt, VV47Xm=VVYAtm)
 5985:   else:
 5986:    VVAkuK = []
 5987:    for client in root.findall("client"):
 5988:     name  = client.get("name", "-")
 5989:     desc  = client.get("desc", "-")
 5990:     protocol = client.get("protocol", "-")
 5991:     conn  = client.find("connection")
 5992:     if not conn is None:
 5993:      ip  = conn.get("ip", "-")
 5994:      port = conn.get("port", "-")
 5995:      status = conn.text
 5996:     else:
 5997:      ip = port = status = "-"
 5998:     stCode, fg = self.VV87ey(status)
 5999:     VVAkuK.append((name, ip, port, protocol, desc, "%s%s" % (fg, status)))
 6000:    if VVAkuK:
 6001:     VVAkuK.sort(key=lambda x: x[0].lower())
 6002:     if self.VV6A99:
 6003:      self.VV6A99.VVMqQ9(VVAkuK, VV5YRVMsg=False)
 6004:     else:
 6005:      bg = "#22000011"
 6006:      title = self.Title.strip() + " (Running)" if self.VV3o4m else ""
 6007:      VVu8qI = self.VVltJU
 6008:      VVCOpO = (""  , self.VVchAN , [])
 6009:      VVwWmA  = ("Stop"  , self.VVr2sK , [])
 6010:      VV4QTJ = ("Options" , self.VVG1TP, [])
 6011:      header = ("Label" , "Host", "Port", "Protocol", "Description" , "State" )
 6012:      widths = (32  ,  15 , 8  , 17  , 16   , 12  )
 6013:      align = (LEFT  ,  LEFT , CENTER, CENTER , LEFT   , CENTER )
 6014:      self.VV6A99 = FFUQ0v(self, None, title=title, header=header, VVGape=VVAkuK, VVLIqP=align, VV3cHe=widths, VVwdmN=24, width=1700, height=950, VVu8qI=VVu8qI, VVCOpO=VVCOpO, VVwWmA=VVwWmA, VV4QTJ=VV4QTJ
 6015:             , VVwltY="#22002030", VVkxBG=bg, VVemyB=bg, VVJKqd="#00664411", VVbcr0="#00444444", VVX9AA="#08442211")
 6016:     return True
 6017:    else:
 6018:     return False
 6019:  def VVltJU(self, VV6A99):
 6020:   VV6A99.cancel()
 6021:   self.close()
 6022:  def VVchAN(self, VV6A99, title, txt, colList):
 6023:   VV6A99["myBar"].instance.setHAlign(1)
 6024:  def VVr2sK(self, VV6A99, title, txt, colList):
 6025:   self.VVKNev()
 6026:  def VV87ey(self, st):
 6027:   st = st.upper()
 6028:   if   st in ["OK", "CONNECTED", "CARDOK"] or st.startswith(("ON")) : c = 0
 6029:   elif any(x in st for x in ("ERROR", "UNDEF", "UNKNOWN", "OFFLINE")) : c = 1
 6030:   elif st == "OFF"             : c = 2
 6031:   else                : c = 3
 6032:   return c, {0:"#f#0055ff55#", 1:"#f#00ff8000#", 2:"#f#00aa88ff#"}.get(c, "")
 6033:  def VVG1TP(self, VV6A99, title, txt, colList):
 6034:   delLst, lblLst = [], []
 6035:   for lbl, hst, prt, Prot, Dsc, stt in VV6A99.VVrrm9():
 6036:    if not Prot in ("http", "server", "dvbapi"): lblLst.append(lbl)
 6037:    stCode, fg = self.VV87ey(stt)
 6038:    if stCode == 1: delLst.append(lbl)
 6039:   tmp = {x: lblLst.count(x) for x in lblLst}
 6040:   duplLst = []
 6041:   for lbl, cnt in tmp.items():
 6042:    if cnt > 1: duplLst.extend([lbl] * (cnt - 1))
 6043:   curLbl, hst, prt, curProt, Dsc, stt = colList
 6044:   c1, c2 = VVyFI2 , VVZtfx
 6045:   VV3wat = []
 6046:   VV3wat.append(("Delete Selected Reader", "delCur"))
 6047:   VV3wat.append(VVAL3j)
 6048:   VV3wat.append(FFsLU5("Delete Inactive Readers" , "badRdr", delLst))
 6049:   VV3wat.append(FFsLU5("Delete Duplicate Readers" , "dupRdr", duplLst))
 6050:   if VVBvqf:
 6051:    VV3wat.append(VVAL3j)
 6052:    VV3wat.append(FFsLU5("Delete Inactive Lines (from CCcam.cfg Files)" , "badCc", delLst))
 6053:   FFLFTC(self, BF(self.VVDoj8, VV6A99, duplLst, delLst, curLbl, curProt), VV3wat=VV3wat, width=1000, title="Options", VVU8mZ=True)
 6054:  def VVDoj8(self, VV6A99, duplLst, delLst, curLbl, curProt, item=None):
 6055:   if item:
 6056:    title, ref, ndx = item
 6057:    if   ref == "delCur": self.VVALnL(VV6A99, delLst, curLbl, curProt)
 6058:    elif ref == "badRdr": self.VV0UE1(VV6A99, title, delLst, True)
 6059:    elif ref == "dupRdr": self.VV0UE1(VV6A99, title, duplLst, False)
 6060:    elif ref == "badCc" : self.VVIvec(delLst, title)
 6061:  def VVIvec(self, delLst, title=""):
 6062:   def VVZwiy(fil):
 6063:    lines = []
 6064:    c = 0
 6065:    for ln in FFL19l(fil):
 6066:     span = iSearch(r"^(?:C|N):\s+(\S+)\s+(\d+)\s+(\S+)", ln)
 6067:     if span and "_".join(span.groups()) in delLst:
 6068:      c += 1
 6069:      continue
 6070:     else:
 6071:      lines.append(ln)
 6072:    if c > 0:
 6073:     with open(fil, "w") as f:
 6074:      f.write("%s\n" % "\n".join(lines))
 6075:    return c
 6076:   txt = ""
 6077:   for f in CCid3A.VVFzc8():
 6078:    if FFCyVu(f):
 6079:     tot = VVZwiy(f)
 6080:     if tot: txt += "File\t: %s\nDeleted\t: %s\n\n" % (f, tot)
 6081:   if title:
 6082:    if txt:
 6083:     FF4lCP(self, txt, title)
 6084:     CCid3A.VVaomc(self.session)
 6085:    else:
 6086:     FFipXT(self, "No related lines in CCcam.cfg files.", title)
 6087:  def VV0UE1(self, VV6A99, title, delLst, delC):
 6088:   if delC: self.VVIvec(delLst)
 6089:   CCh3tv.VV7Nf4(self, VVixvy=BF(self.VVKM5K, delLst), VVbYwR=BF(self.VV6SFd, title))
 6090:  def VVKM5K(self, delLst, VVXyP6):
 6091:   totDel = totErr = 0
 6092:   VVXyP6.VVq8NF(len(delLst))
 6093:   VVXyP6.VVNc18 = (totDel, totErr)
 6094:   for lbl in delLst:
 6095:    if not VVXyP6 or VVXyP6.isCancelled: return
 6096:    VVXyP6.VVaks5(lbl)
 6097:    VVXyP6.VVxtQs(1)
 6098:    page = None
 6099:    uReq = CCid3A.VVJssd(self, self.VVX2Ni, self.confFile, "readerlist", "&label=%s&action=delete" % FFSiPR(lbl), typ="json")
 6100:    if uReq:
 6101:     try: page = iUrlopen(uReq, timeout=4)
 6102:     except: pass
 6103:    if page : totDel += 1
 6104:    else : totErr += 1
 6105:    if not VVXyP6 or VVXyP6.isCancelled: return
 6106:    VVXyP6.VVNc18 = (totDel, totErr)
 6107:  def VV6SFd(self, title, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
 6108:   totDel, totErr = VVNc18
 6109:   txt = "Deleted : %s" % totDel
 6110:   if totErr: txt += "\n\nFailed : %s" % totErr
 6111:   if totDel: self.VV6Qml()
 6112:   FFipXT(self, txt, title)
 6113:  def VVALnL(self, VV6A99, delLst, curLbl, curProt):
 6114:   fnc = BF(CCid3A.VVQGgp, VV6A99, curLbl, cbFnc=self.VV6Qml)
 6115:   if curProt in ("http", "server", "dvbapi") : FF28n1(VV6A99, "Cannot delete protocol=%s" % curProt, 2000)
 6116:   elif curLbl in delLst      : fnc()
 6117:   else          : FFRMYv(self, fnc, "%s\n\nDelete ?" % curLbl, title="Delete Active Reader")
 6118:  def VVEBkn(self, lines):
 6119:   txt = ""
 6120:   for line in lines:
 6121:    line = line.strip()
 6122:    span = iSearch(r"^[0-9]{4}[-\/][0-9]{2}[-\/][0-9]{2}\s+", line, IGNORECASE)
 6123:    if span:
 6124:     line = "\n" + VVIH76 + line[:19] + VVA4XU + line[19:]
 6125:     for preTxt in (" connecting to ", " from server ", " by ", "reader ", "server ", "(reader) "):
 6126:      if preTxt in line:
 6127:       if preTxt == " by " and " by WebIf" in line:
 6128:        line = line.replace("WebIf", VV9nWG + "WebIf" + VVA4XU)
 6129:       else:
 6130:        t1, t2, t3 = line.partition(preTxt)
 6131:        if t2:
 6132:         h1, h2, h3 = t3.partition(" ")
 6133:         line = t1 + t2 + VVGCYL + h1 + h2 + VVA4XU + h3
 6134:     span = iSearch(r"(.+:\s*)(found\s*)(\(\d+\s*ms\))(.+)", line, IGNORECASE)
 6135:     if span:
 6136:      line = "\n" + span.group(1) + VVSGsk + span.group(2) + VVFuwR + span.group(3) + VVA4XU + span.group(4)
 6137:     line = self.VVcAvB(line, VVFuwR, ("(webif)", ))
 6138:     line = self.VVcAvB(line, VVFuwR, ("(anticasc)", "(anticasc)", "(cache)", "(cccam)", "(chk)", "(client)", "(config)", "(dvbapi)", "(ecm)", "(emm)", "(emmcache)", "(emu)", "(main)", "(net)", "(newcamd)", "(reader)", "(stat)"))
 6139:     line = self.VVcAvB(line, VVSGsk, ("OSCam", "NCam", "log switched"))
 6140:     line = self.VVcAvB(line, VVyFI2, (": not found", "failed", "rejected group", "usr/pwd invalid", "timeout", "no matching reader", "disconnected"))
 6141:     ndx = line.find(") - ")
 6142:     if ndx > -1:
 6143:      line = line[:ndx + 3] + VV1fx4 + line[ndx + 3:] + VVA4XU
 6144:     txt += line + "\n"
 6145:   self["myLabel"].setText(txt, VV47Xm=VVYAtm)
 6146:   return bool(txt.strip())
 6147:  def VVcAvB(self, line, color, lst):
 6148:   for txt in lst:
 6149:    if txt in line:
 6150:     t1, t2, t3 = line.partition(txt)
 6151:     if t2:
 6152:      return t1 + color + t2 + VVA4XU + t3
 6153:   return line
 6154: class CCxSED(Screen):
 6155:  def __init__(self, session):
 6156:   self.skin, self.VVfOli = FFiNEe(VVWp3I, 750, 1000, 50, 60, 30, "#10104060", "#10001A1F", 30)
 6157:   self.session  = session
 6158:   VV3wat = []
 6159:   VV3wat.append(("Backup Channels"    , "VVWyWy"   ))
 6160:   VV3wat.append(("Restore Channels"    , "VVgcOH"  ))
 6161:   VV3wat.append(VVAL3j)
 6162:   VV3wat.append(("Backup SoftCAM Files"   , "VVmuRi" ))
 6163:   VV3wat.append(("Restore SoftCAM Files"  , "VVrIlm" ))
 6164:   VV3wat.append(VVAL3j)
 6165:   VV3wat.append(("Backup Tuner Settings"  , "bkupTuner"    ))
 6166:   VV3wat.append(("Restore Tuner Settings"  , "restTuner"    ))
 6167:   VV3wat.append(VVAL3j)
 6168:   VV3wat.append(("Backup HotKeys Settings"  , "bkupHKeys"    ))
 6169:   VV3wat.append(("Restore HotKeys Settings"  , "restHKeys"    ))
 6170:   VV3wat.append(VVAL3j)
 6171:   VV3wat.append(("Backup Enigma2 Settings File" , "VV31XB"   ))
 6172:   VV3wat.append(("Restore Enigma2 Settings File", "VV2kBT"  ))
 6173:   VV3wat.append(VVAL3j)
 6174:   VV3wat.append(("Backup Network Settings"  , "VVWN2f"   ))
 6175:   VV3wat.append(("Restore Network Settings"  , "VVf1ql"   ))
 6176:   if VVBvqf:
 6177:    VV3wat.append(VVAL3j)
 6178:    VV3wat.append(("Backup FHD-Glass17 Skin" , "bkupFhdg17"    ))
 6179:    VV3wat.append(("Restore FHD-Glass17 Skin" , "restFhdg17"    ))
 6180:   for i in range(0, len(VV3wat), 3):
 6181:    VV3wat[i] = (VVJEMb + VV3wat[i][0], VV3wat[i][1])
 6182:   if VVBvqf:
 6183:    c1, c2, c3, c4, c5 =VVz22H, VVSGsk, VVJEMb , VVGCYL, VVFuwR
 6184:    VV3wat.append(VVAL3j)
 6185:    VV3wat.append((c1 + "Fix Data (%s)" % VVPAan , "VVZ7sM"   ))
 6186:    VV3wat.append((c2 + "1- Create IPK"    , "VVAQWI1"  ))
 6187:    VV3wat.append((c2 + "2- Create DEB"    , "VVAQWI2"  ))
 6188:    VV3wat.append((c3 + "3- Create IPK (No Restart)" , "VVAQWI3"  ))
 6189:    VV3wat.append((c3 + "4- Create DEB (No Restart)" , "VVAQWI4"  ))
 6190:    VV3wat.append((c3 + "5- Create IPK (No Depend)" , "VVAQWI5"  ))
 6191:    VV3wat.append((c3 + "6- Create DEB (No Depend)" , "VVAQWI6"  ))
 6192:    VV3wat.append(VVAL3j)
 6193:    VV3wat.append((c4 + "Decode Crash Report"   , "VVE342" ))
 6194:    VV3wat.append((c4 + "Show Windows Stats"   , "VVUwoK" ))
 6195:    VV3wat.append((c5 + "%s Simple Portal" % ("Disable" if CFG.simplePortal.getValue() else "Enable") , "VVjFUg" ))
 6196:   FFZMxC(self, title="Backup & Restore", VV3wat=VV3wat)
 6197:   self.onShown.append(self.VV7OzD)
 6198:  def VV7OzD(self):
 6199:   self.onShown.remove(self.VV7OzD)
 6200:   FF4IPF(self["myMenu"])
 6201:   FF2GM8(self)
 6202:  def VVPr1F(self):
 6203:   item = FFTmHZ(self)
 6204:   if item is not None:
 6205:    if   item == "VVWyWy"  : self.VVWyWy()
 6206:    elif item == "VVgcOH"  : self.VV7nlV("channels_backup*.tar.gz", self.VVgcOH, isChan=True)
 6207:    elif item == "VVmuRi" : self.VVmuRi()
 6208:    elif item == "VVrIlm": self.VV7nlV("softcam_backup*.tar.gz", self.VVrIlm)
 6209:    elif item == "bkupTuner"   : self.VV5ISt("tuner_backup", ["config.Nims."])
 6210:    elif item == "restTuner"   : self.VV7nlV("tuner_backup*.backup", BF(self.VVJVKe, "tuner"), isTuner=True)
 6211:    elif item == "bkupHKeys"   : self.VV5ISt("hotkey_backup", ["config.misc.hotkey.", "config.misc.ButtonSetup."])
 6212:    elif item == "restHKeys"   : self.VV7nlV("hotkey_backup*.backup", BF(self.VVJVKe, "hotk"))
 6213:    elif item == "VV31XB"  : self.VV31XB()
 6214:    elif item == "VV2kBT"  : self.VV7nlV("settings_backup*.tar.gz", self.VV2kBT)
 6215:    elif item == "VVWN2f"  : self.VVWN2f()
 6216:    elif item == "VVf1ql"  : self.VV7nlV("network_backup*.tar.gz", self.VVf1ql)
 6217:    elif item == "bkupFhdg17"   : self.VV5ISt("fhdg17_skin_backup", ["config.plugins.setupGlass17."])
 6218:    elif item == "restFhdg17"   : self.VV7nlV("fhdg17_skin_backup*.backup", BF(self.VVJVKe, "fhdg17"))
 6219:    elif item == "VVZ7sM"   : FFRMYv(self, BF(FF2JFr, self.session, BF(CCxSED.VVZ7sM, self)), "Erase previous obf ?")
 6220:    elif item.startswith("VVAQWI") : self.VVAQWI(int(item[-1]))
 6221:    elif item == "VVE342" : self.VVE342()
 6222:    elif item == "VVUwoK"  : CCxSED.VVUwoK(self)
 6223:    elif item == "VVjFUg" : self.VVjFUg()
 6224:  def VVjFUg(self):
 6225:   FFjt1c(CFG.simplePortal, not CFG.simplePortal.getValue())
 6226:   self.close()
 6227:  @staticmethod
 6228:  def VVA6y8(SELF):
 6229:   OBF_Path = VV231J + "OBF/"
 6230:   if FFCyVu(OBF_Path + "obf.py"):
 6231:    from sys import path as iPath
 6232:    iPath.append(OBF_Path)
 6233:    try: from imp import reload
 6234:    except: from importlib import reload
 6235:    try: from .OBF import obf
 6236:    except: import obf
 6237:    reload(obf)
 6238:    return obf
 6239:   else:
 6240:    FF8Wsn(SELF, OBF_Path)
 6241:    return None
 6242:  @staticmethod
 6243:  def VVUwoK(SELF):
 6244:   obf = CCxSED.VVA6y8(SELF)
 6245:   if obf:
 6246:    txt, title = obf.windowsStats()
 6247:    FF4lCP(SELF, txt, title=title, VVRhqH="WinStat")
 6248:  @staticmethod
 6249:  def VVZ7sM(SELF):
 6250:   obf = CCxSED.VVA6y8(SELF)
 6251:   if obf:
 6252:    txt, err = obf.fixCode(VV231J, VVJ6zn, VVPAan)
 6253:    if err : FFdw58(SELF, err)
 6254:    else : FF4lCP(SELF, txt, height=1050)
 6255:  def VVAQWI(self, mode):
 6256:   OBF_Path = VV231J + "OBF/"
 6257:   files = iGlob("%s*main_final.py" % OBF_Path)
 6258:   if not files:
 6259:    FFdw58(self, "Final File .py not found in:\n\n%s" % OBF_Path)
 6260:    return
 6261:   FFpwZS("rm -f %s__pycache__/" % VV231J)
 6262:   self.session.open(CCxz86, path=VV231J, VVyCS0=mode in (2, 4, 6), VVKTL7=mode in (3, 4), VVc8YP=mode not in (5, 6))
 6263:  def VVE342(self):
 6264:   path = "/tmp/OBF/"
 6265:   if not VVmJwX(path):
 6266:    FFdw58(self, "Path not found:\n%s" % path)
 6267:    return
 6268:   files = iGlob("%s*.log" % path)
 6269:   if not files:
 6270:    FFdw58(self, "No log files in:\n\n%s" % path)
 6271:    return
 6272:   codF, err = self.VVwsxh("%s*.list" % path)
 6273:   if err:
 6274:    FF8Wsn(self, path + "*.list")
 6275:    return
 6276:   srcF, err = self.VVwsxh("%s*main_final.py" % path)
 6277:   if err:
 6278:    FF8Wsn(self, path + "*.final.py")
 6279:    return
 6280:   VVGape = []
 6281:   for f in files:
 6282:    f = os.path.basename(f)
 6283:    VVGape.append((f, f))
 6284:   FFLFTC(self, BF(self.VVnARS, path, codF, srcF), VV3wat=VVGape)
 6285:  def VVnARS(self, path, codF, srcF, item=None):
 6286:   if item:
 6287:    logF = path + item
 6288:    if not FFCyVu(logF) : FF8Wsn(self, logF)
 6289:    else     : self.VVVXq5(logF, codF, srcF)
 6290:  @FFOAKH()
 6291:  def VVVXq5(self, logF, codF, srcF):
 6292:   lst  = []
 6293:   lines = FFL19l(codF)
 6294:   for line in lines:
 6295:    line = line.split(":")[1]
 6296:    parts = line.split("->")
 6297:    lst.append((parts[1].strip(), parts[0].strip()))
 6298:   if not lst:
 6299:    FFdw58(self, "No codes in : %s" % codF)
 6300:    return
 6301:   newLogF = logF.replace(".log", ".NEW.log")
 6302:   totLog  = self.VVCoa9(lst, logF, newLogF)
 6303:   if totLog == 0:
 6304:    FFdw58(self, "No match found in this version for:\n\n%s" % os.path.basename(logF))
 6305:    return
 6306:   newSrcF = srcF.replace(".py" , ".DBG.py")
 6307:   totSrc  = self.VVCoa9(lst, srcF, newSrcF)
 6308:   txt = "Found\t: %s\nIn\t: %s\n\nFound\t: %s\nIn\t: %s\n\nNew Files\t:\n" % (totLog, logF, totSrc, srcF)
 6309:   if not totLog and not totSrc:
 6310:    txt += "None"
 6311:   else:
 6312:    if totLog: txt += "    %s\n" % newLogF
 6313:    if totSrc: txt += "    %s\n" % newSrcF
 6314:   FF4lCP(self, txt)
 6315:  def VVwsxh(self, patt):
 6316:   tFiles = iGlob(patt)
 6317:   if not tFiles:
 6318:    return "", "*.list"
 6319:   f = tFiles[0]
 6320:   if not FFCyVu(f):
 6321:    return "", "Not found:\n\n"
 6322:   return f, ""
 6323:  def VVCoa9(self, lst, f1, f2):
 6324:   txt = FFYVq0(f1)
 6325:   tot = 0
 6326:   for item in lst:
 6327:    if item[0] in txt:
 6328:     tot += 1
 6329:    txt = txt.replace(item[0], item[1])
 6330:   if tot > 0:
 6331:    with open(f2, "w") as f:
 6332:     f.write(txt)
 6333:   return tot
 6334:  def VVWyWy(self):
 6335:   path1 = VVQe79
 6336:   path2 = "/etc/tuxbox/"
 6337:   VVGape = []
 6338:   VVGape.append("%s%s" % (path1, "*.tv"))
 6339:   VVGape.append("%s%s" % (path1, "*.radio"))
 6340:   VVGape.append("%s%s" % (path1, "*list"))
 6341:   VVGape.append("%s%s" % (path1, "*list_*"))
 6342:   VVGape.append("%s%s" % (path1, "lamedb*"))
 6343:   VVGape.append("%s%s" % (path2, "*.xml"))
 6344:   CCxSED.VVU6pR(self, VVGape, self.VVt2Ml("channels_backup"), addTimeStamp=True)
 6345:  def VVmuRi(self):
 6346:   VVGape = []
 6347:   VVGape.append("/etc/tuxbox/config/")
 6348:   VVGape.append("/etc/tuxbox/scce/")
 6349:   VVGape.append("/etc/CCcam.*")
 6350:   VVGape.append("/usr/keys/")
 6351:   VVGape.append("/usr/scam/")
 6352:   VVGape.append("/etc/tuxbox/*cam*")
 6353:   VVGape.append("/etc/tuxbox/*Cam*")
 6354:   VVGape.append("/usr/local/etc/oscam*.*")
 6355:   VVGape.append("/usr/local/etc/ncam*.*")
 6356:   VVGape.append("/etc/oscam*.*")
 6357:   VVGape.append("/etc/ncam*.*")
 6358:   VVGape.append("/etc/uniqid")
 6359:   CCxSED.VVU6pR(self, VVGape, self.VVt2Ml("softcam_backup"), addTimeStamp=True)
 6360:  def VVWN2f(self):
 6361:   VVGape = []
 6362:   VVGape.append("/etc/hostname")
 6363:   VVGape.append("/etc/default_gw")
 6364:   VVGape.append("/etc/resolv.conf")
 6365:   VVGape.append("/etc/wpa_supplicant*.conf")
 6366:   VVGape.append("/etc/network/interfaces")
 6367:   VVGape.append("%snameserversdns.conf" % VVQe79)
 6368:   CCxSED.VVU6pR(self, VVGape, self.VVt2Ml("network_backup"), addTimeStamp=True)
 6369:  def VV31XB(self):
 6370:   CCxSED.VVU6pR(self, [VVfBVj], self.VVt2Ml("settings_backup"), addTimeStamp=True)
 6371:  def VV2kBT(self, path=None):
 6372:   if path:
 6373:    ques = "Overwrite %s File (and restart) ?" % VVfBVj
 6374:    img = CC674y.VVSwko()
 6375:    if img:
 6376:     if not img.lower() in path.lower():
 6377:      ques = "This file is not labeled with your image name (%s)\n\n%s" % (FFjt5L(img, VV1fx4), ques)
 6378:    FFRMYv(self, BF(self.VVUymq, path), ques)
 6379:  def VVUymq(self, path):
 6380:   path = FF0cqc() + path
 6381:   pathInTar = VVfBVj.lstrip("/")
 6382:   res = FFTKR0("tar -tf '%s' '%s'" % (path, pathInTar))
 6383:   if not res == pathInTar:
 6384:    FFdw58(self, "Cannot read settings file from:\n\n%s" % path)
 6385:    return
 6386:   if not FFpwZS("cp -rf '%s' '%s.bak'" % (VVfBVj, VVfBVj)):
 6387:    FFdw58(self, "Cannot backup the file:\n\n%s" % VVfBVj)
 6388:    return
 6389:   if not FFpwZS("tar -C / -xf '%s' '%s'" % (path, pathInTar)):
 6390:    FFdw58(self, "Cannot read settings file from:\n\n%s" % path)
 6391:    return
 6392:   if FFpwZS("tar -C / -xzf '%s%s'" % (FF0cqc(), path)):
 6393:    FFdw58(self, "Cannot restore the file:\n\n%s" % VVfBVj)
 6394:    return
 6395:   FF28Zd(self, "echo 'Applying new settings ...'")
 6396:  def VVt2Ml(self, fName):
 6397:   img = CC674y.VVSwko()
 6398:   if img: fName = "%s_%s" % (fName, img)
 6399:   return fName
 6400:  def VVgcOH(self, fileName=None):
 6401:   if fileName:
 6402:    FFRMYv(self, BF(self.VVymb6, fileName), "Overwrite current channels ?")
 6403:  @FFOAKH("Restoring ...")
 6404:  def VVymb6(self, fileName):
 6405:   path = FF0cqc() + fileName
 6406:   if FFCyVu(path):
 6407:    if CClYaF.VVJ1XA(path):
 6408:     VVkMso , VVEuxL = CCYrUm.VVBN5t()
 6409:     VVOVzS, VVb8I6 = CCYrUm.VVmPK0()
 6410:     cmd  = FFb2oQ("cd %s" % VVQe79)
 6411:     cmd += FFb2oQ("rm -f *.tv *.radio *.del lamedb* whitelist blacklist satellites.xml %s %s" % (VVEuxL, VVb8I6))
 6412:     cmd += "tar -C / -xzf '%s'" % path
 6413:     ok = FFpwZS(cmd)
 6414:     FFfpyJ()
 6415:     if ok: FFipXT(self, "Channels Restored.")
 6416:     else : FFdw58(self, "Error while restoring:\n\n%s" % fileName)
 6417:    else:
 6418:     FFdw58(self, "Invalid tar file:\n\n%s" % path)
 6419:   else:
 6420:    FF8Wsn(self, path)
 6421:  def VVrIlm(self, fileName=None):
 6422:   if fileName:
 6423:    FFRMYv(self, BF(self.VVvxOt, fileName), "Overwrite SoftCAM files ?")
 6424:  def VVvxOt(self, fileName):
 6425:   fileName = FF0cqc() + fileName
 6426:   txt = FFQ45w("tar -C / -xzf '%s'" % fileName)
 6427:   if txt : FF4lCP(self, "Error while restoring SoftCam files from:\n\n%s\n\n%s\n\nError:\n\n%s" % (fileName, SEP, txt), isErr=True)
 6428:   else : FFipXT(self, "SoftCam Files Restored.\n\n( You may need to restart your SoftCAM )")
 6429:  def VVf1ql(self, fileName=None):
 6430:   if fileName:
 6431:    FFRMYv(self, BF(self.VVeo9P, fileName), "Overwrite Network Settings (and REBOOT) ?")
 6432:  def VVeo9P(self, fileName):
 6433:   fileName = FF0cqc() + fileName
 6434:   if FFCyVu(fileName):
 6435:    cmd = "tar -C / -xzvf '%s';" % fileName
 6436:    cmd += "echo ''; echo 'REBOOTING ...';"
 6437:    cmd += "sleep 3; reboot"
 6438:    FFbi5l(self,  cmd)
 6439:   else:
 6440:    FF8Wsn(self, fileName)
 6441:  def VV7nlV(self, pattern, callBackFunction, isTuner=False, isChan=False):
 6442:   title = FFGNZA()
 6443:   if VVmJwX(FF0cqc()):
 6444:    myFiles = FFkzic(FF0cqc(), pattern)
 6445:    if len(myFiles) > 0:
 6446:     myFiles.sort(key=os.path.getmtime, reverse=True)
 6447:     VVGape = []
 6448:     for myFile in myFiles:
 6449:      fileName = os.path.basename(myFile)
 6450:      VVGape.append((fileName, fileName))
 6451:     if len(myFiles) > 1:
 6452:      title = title + " (Sorted by time)"
 6453:     if   isTuner  : VVwJOl = ("Sat. List", self.VVg19U)
 6454:     elif isChan and iTar: VVwJOl = ("Bouquets Importer", CC9xd9.VVhvea)
 6455:     else    : VVwJOl = None
 6456:     VVaTeF = ("Rename ", self.VV6KMC)
 6457:     VVJbOd = self.VVog33
 6458:     FFLFTC(self, callBackFunction, title=title, width=1200, VV3wat=VVGape, VVJbOd=VVJbOd, VVwJOl=VVwJOl, VVaTeF=VVaTeF, VVtboQ=FF0cqc())
 6459:    else:
 6460:     FFdw58(self, "No files found in:\n\n%s" % FF0cqc(), title)
 6461:   else:
 6462:    FFdw58(self, "Path not found:\n\n%s" % FF0cqc(), title)
 6463:  def VVog33(self, VV7tND, txt, ref, ndx):
 6464:   ttl = lambda x, y: "%s:\n%s\n\n" % (FFjt5L(x, VVFuwR), y)
 6465:   txt  = ttl("File", txt)
 6466:   txt += ttl("Path", FF0cqc())
 6467:   txt += ttl("Note", FFjt5L("%s can restore this file on any image." % VVh9hj, VVJEMb))
 6468:   FF4lCP(self, txt)
 6469:  def VV6KMC(self, VV7tND, fName):
 6470:   left = name = right = ""
 6471:   for prefix in ("channels_backup_", "softcam_backup_", "settings_backup_", "network_backup_"):
 6472:    ext = ".tar.gz"
 6473:    if fName.startswith(prefix) and fName.endswith(ext):
 6474:     left, name, right, = prefix, fName[len(prefix):-len(ext)], ext
 6475:     break
 6476:   if not name:
 6477:    for prefix in ("tuner_backup_", "hotkey_backup_", "fhdg17_skin_backup_"):
 6478:     ext = ".backup"
 6479:     if fName.startswith(prefix) and fName.endswith(ext):
 6480:      left, name, right, = prefix, fName[len(prefix):-len(ext)], ext
 6481:      break
 6482:   if not name:
 6483:    name = fName
 6484:   FF4z45(self, BF(self.VVLWkQ, VV7tND, fName, left, name, right), defaultText=name, title="Rename: %s .. %s" % (left, right), message="New name:")
 6485:  def VVLWkQ(self, VV7tND, fName, left, name, right, nName):
 6486:   if nName is not None:
 6487:    if not nName: left = left.rstrip("_")
 6488:    nName = left + nName + right
 6489:    bPath = FF0cqc()
 6490:    if   fName == nName    : FF28n1(VV7tND, "No change", 800)
 6491:    elif FFCyVu(bPath + nName) : FFdw58(self, "Name already exists:\n\n%s" % nName)
 6492:    else       : FFRMYv(self, BF(self.VVlISN, VV7tND, bPath, fName, nName), "Rename to:\n\n%s" % nName, title=fName)
 6493:  def VVlISN(self, VV7tND, bPath, fName, nName):
 6494:   fPath = bPath + fName
 6495:   nPath = bPath + nName
 6496:   try:
 6497:    stat = os.stat(fPath)
 6498:    os.rename(fPath, nPath)
 6499:    os.utime(nPath, (stat.st_atime, stat.st_mtime))
 6500:    VV7tND.VVKjBW((nName, nName))
 6501:    FF1mVE(VV7tND, "Renamed", 800)
 6502:   except Exception as e:
 6503:    FFdw58(self, str(e), title="Rename")
 6504:  def VV5ISt(self, filePrefix, grepLst):
 6505:   if not FFCyVu(VVfBVj):
 6506:    FFdw58(self, "Cannot read settings file")
 6507:    return
 6508:   grep = r"\|".join(grepLst)
 6509:   lines = FF3xOt("cat '%s' | grep '%s'" % (VVfBVj, grep))
 6510:   if not lines:
 6511:    FFdw58(self, "No settings found")
 6512:   for line in lines:
 6513:    if not any(x in line for x in grepLst):
 6514:     FFdw58(self, "\n".join(lines))
 6515:     return
 6516:   else:
 6517:    path = "%s%s%s_%s.backup" % (FF0cqc(), filePrefix, self.VVt2Ml(""), FFjTQe())
 6518:    try:
 6519:     with open(path, "w") as f:
 6520:      f.write("%s\n" % "\n".join(lines))
 6521:     FFipXT(self, "Result File:\n\n%s" % path)
 6522:    except Exception as e:
 6523:     FFdw58(self, str(e))
 6524:  def VVJVKe(self, mode, path=None):
 6525:   if not path:
 6526:    return
 6527:   path = FF0cqc() + path
 6528:   if not FFCyVu(path):
 6529:    FF8Wsn(self, path)
 6530:    return
 6531:   elif not FFCyVu(VVfBVj):
 6532:    FF8Wsn(self, VVfBVj)
 6533:    return
 6534:   if   mode == "tuner" : subj, grepLst = "Tuner"  , [".Nims."]
 6535:   elif mode == "hotk"  : subj, grepLst = "Hotkeys" , [".hotkey.", ".ButtonSetup."]
 6536:   elif mode == "fhdg17": subj, grepLst = "FHDG17-Skin", [".setupGlass17."]
 6537:   lines = FFL19l(path)
 6538:   lst1 = []
 6539:   for line in lines:
 6540:    if line.strip() and not line in lst1 and any(x in line for x in grepLst):
 6541:     lst1.append(line)
 6542:   if not lst1:
 6543:    FFdw58(self, "Nothing to restore from:\n\n%s" % path)
 6544:    return
 6545:   lst2 = []
 6546:   if mode == "tuner":
 6547:    atvL = ("dvbs.", "dvbc.", "dvbt.", "atsc.")
 6548:    for line in lst1:
 6549:     span = iSearch(r"(\w+\.Nims\.\d+\.)(.+)", line)
 6550:     if span:
 6551:      if span.group(2).startswith(atvL): line = span.group(1) + span.group(2)[5:]
 6552:      else        : line = span.group(1) + "dvbs." + span.group(2)
 6553:      if not line in lst2:
 6554:       lst2.append(line)
 6555:    lst = lst1 + lst2
 6556:    if nimmanager.nim_slots:
 6557:     if "dvbs" in config.Nims[0].dict() : lst = [x for x in lst if any("." + y in x for y in atvL)]
 6558:     else        : lst = [x for x in lst if not any("." + y in x for y in atvL)]
 6559:   elif mode == "hotk":
 6560:    pli, atv = ".hotkey.", ".ButtonSetup."
 6561:    for line in lst1:
 6562:     if   atv in line: line = line.replace(atv, pli)
 6563:     elif pli in line: line = line.replace(pli, atv)
 6564:     if not line in lst2:
 6565:      lst2.append(line)
 6566:    lst = lst1 + lst2
 6567:    if CCxSED.VVdBQ3() : lst = [x for x in lst if atv in x]
 6568:    else          : lst = [x for x in lst if atv not in x]
 6569:   FFRMYv(self, BF(self.VVMVEU, lst, grepLst), "Overwrite %s settings (and restart) ?" % subj)
 6570:  def VVMVEU(self, lines, grepLst):
 6571:   tFile = "/tmp/ajp_tmp"
 6572:   try:
 6573:    with open(tFile, "w") as f:
 6574:     for line in FFL19l(VVfBVj):
 6575:      if line.strip() and not any(x in line for x in grepLst):
 6576:       f.write("%s\n" % line)
 6577:     for ndx, line in enumerate(lines):
 6578:      f.write("%s%s" % (line, "" if ndx == len(lines) - 1 else "\n"))
 6579:   except Exception as e:
 6580:    FFdw58(self, str(e))
 6581:    return
 6582:   cmd  = "echo 'Applying new settings ...';"
 6583:   cmd += "mv -f '%s' '%s'" % (tFile, VVfBVj)
 6584:   FF28Zd(self, cmd)
 6585:  @staticmethod
 6586:  def VVdBQ3():
 6587:   from sys import modules
 6588:   return "Screens.ButtonSetup" in modules
 6589:  def VVg19U(self, selectionObj, path):
 6590:   if not path:
 6591:    return
 6592:   path = FF0cqc() + path
 6593:   if not FFCyVu(path):
 6594:    FF8Wsn(self, path)
 6595:    return
 6596:   txt = FFYVq0(path)
 6597:   satList = []
 6598:   lst = iFindall(r".+[.](diseqc.?)[=](\d+)", txt, IGNORECASE)
 6599:   for sat in lst:
 6600:    diseqc = sat[0].upper()
 6601:    satNum = sat[1]
 6602:    satList.append((diseqc.replace("DISEQC", "DiSEqC-"), satNum))
 6603:   lst = iFindall(r".+[.]sat[.](\d+)[.](lnb[=].+)", txt, IGNORECASE)
 6604:   for sat in lst:
 6605:    satNum = sat[0]
 6606:    lnb  = sat[1].upper()
 6607:    satList.append((lnb.replace("LNB=", "LNB-"), satNum))
 6608:   if satList:
 6609:    satList = list(set(satList))
 6610:    satList.sort(key=lambda x: x[0])
 6611:    txt = ""
 6612:    for item in satList:
 6613:     txt += "%s\t%s\n" % (item[0], FFycBE(item[1]))
 6614:    FF4lCP(self, txt, title="Satellites List")
 6615:   else:
 6616:    FFdw58(self, "Incorrect Tuner Backup file !\n\n(or missing info.)", title="  Satellites List")
 6617:  @staticmethod
 6618:  def VVU6pR(SELF, pathList, tarFileName, addTimeStamp=True):
 6619:   VVGape = []
 6620:   t = ""
 6621:   for path in pathList:
 6622:    if os.path.isfile(path):
 6623:     if FFCyVu(path):
 6624:      VVGape.append(path)
 6625:    elif os.path.isdir(path):
 6626:     if os.listdir(path):
 6627:      VVGape.append(path)
 6628:    else:
 6629:     VVuPkC  = os.path.dirname(path)
 6630:     fileName = os.path.basename(path)
 6631:     fileName = fileName.replace("*", ".*")
 6632:     if CCxSED.VVfwDD(VVuPkC, fileName):
 6633:      VVGape.append(path)
 6634:   if not VVGape:
 6635:    FFdw58(SELF, "Files not found!")
 6636:   elif not VVmJwX(FF0cqc()):
 6637:    FFdw58(SELF, "Path not found!\n\n%s" % FF0cqc())
 6638:   else:
 6639:    tarFileName = "%s%s" % (FF0cqc(), tarFileName)
 6640:    if addTimeStamp:
 6641:     tarFileName = "%s_%s" % (tarFileName, FFjTQe())
 6642:    tarFileName += ".tar.gz"
 6643:    filesLine = ""
 6644:    for f in VVGape:
 6645:     filesLine += "%s " % f
 6646:    failed = "Process failed !"
 6647:    cmd  = "echo 'Collecting files ...';"
 6648:    cmd += "tar -czf '%s' %s 2> /dev/null;" % (tarFileName, filesLine)
 6649:    cmd += "if [ -f '%s' ]; then "   % tarFileName
 6650:    cmd += " chmod 644 '%s';"    % tarFileName
 6651:    cmd += " echo -e '\nDONE\n';"
 6652:    cmd += " echo -e '\nResult File:\n%s\n' %s;" % (tarFileName, FFSPDv(tarFileName, VVSGsk))
 6653:    cmd += " echo '';"
 6654:    cmd += "else"
 6655:    cmd += " echo -e '\n%s\n' %s;"   % (failed, FFSPDv(failed, VVSGsk))
 6656:    cmd += "fi;"
 6657:    FFiOUV(SELF, cmd, VVgoZo=True)
 6658:  @staticmethod
 6659:  def VVfwDD(Dir, patt):
 6660:   lst = []
 6661:   if Dir:
 6662:    exp = iCompile(patt)
 6663:    for root, dirs, files in os.walk(Dir):
 6664:     for f in files:
 6665:      if exp.match(f) is not None:
 6666:       lst.append((root, f))
 6667:   return lst
 6668: class CC9xd9():
 6669:  def __init__(self, SELF):
 6670:   self.SELF   = SELF
 6671:   self.Title   = "Bouquets Importer"
 6672:   self.fileName  = ""
 6673:   self.filePath  = ""
 6674:   self.instance  = None
 6675:   self.isZip   = False
 6676:   self.cbFnc   = None
 6677:  @staticmethod
 6678:  def VVhvea(SELF, fName):
 6679:   bi = CC9xd9(SELF)
 6680:   bi.instance = bi
 6681:   bi.VVJgMK(fName)
 6682:  @staticmethod
 6683:  def VVtXW3(SELF, cbFnc=None):
 6684:   bi = CC9xd9(SELF)
 6685:   bi.instance = bi
 6686:   bi.cbFnc = cbFnc
 6687:   bi.VVjjw4()
 6688:  def VVJgMK(self, fName):
 6689:   self.fileName = fName
 6690:   self.filePath = FF0cqc() + fName
 6691:   self.isZip   = fName.endswith(".zip")
 6692:   if FFCyVu(self.filePath): self.VVFgaQ()
 6693:   else      : self.VVRCp0(self.filePath)
 6694:  def VVQ5VQ(self, txt) : FFdw58(self.SELF, txt, title=self.Title)
 6695:  def VVwb7n(self, txt)  : FF28n1(self, txt, 1500)
 6696:  def VVRCp0(self, path) : FF8Wsn(self.SELF, path, title=self.Title)
 6697:  def VVjjw4(self):
 6698:   if VVmJwX(FF0cqc()):
 6699:    lst = FFkzic(FF0cqc(), "channels_backup*.tar.gz")
 6700:    if iZip: lst.extend(self.VVEGpI())
 6701:    if len(lst) > 0:
 6702:     VV3wat = []
 6703:     for item in lst:
 6704:      item = os.path.basename(item)
 6705:      txt = FFjt5L(item, VVFuwR) if item.endswith(".zip") else item
 6706:      VV3wat.append((txt, item))
 6707:     VV3wat.sort(key=lambda x: x[1].lower())
 6708:     FFLFTC(self.SELF, self.VVk9Z6, VVyRCy=3, title=self.Title, width=1200, VV3wat=VV3wat, VVtboQ=FF0cqc(), VVwltY="#22111111", VVkxBG="#22111111")
 6709:    else:
 6710:     self.VVQ5VQ("No valid backup files found in:\n\n%s" % FF0cqc())
 6711:   else:
 6712:    self.VVQ5VQ("Backup Directory not found:\n\n%s" % FF0cqc())
 6713:  def VVk9Z6(self, fName=None):
 6714:   if fName:
 6715:    self.VVJgMK(fName)
 6716:   else:
 6717:    if self.instance: del self.instance
 6718:  def VVEGpI(self):
 6719:   files = FFkzic(FF0cqc(), "*.zip")
 6720:   lst = []
 6721:   try:
 6722:    for path in files:
 6723:     bakFile = os.path.basename(path)
 6724:     with iZip.ZipFile(path) as zipF:
 6725:      dbFound = bFound = False
 6726:      for zipInfo in zipF.infolist():
 6727:       fName = os.path.basename(zipInfo.filename)
 6728:       if fName == "lamedb" : dbFound = True
 6729:       if fName.endswith(".tv"): bFound = True
 6730:       if dbFound and bFound:
 6731:        lst.append(bakFile)
 6732:        break
 6733:   except:
 6734:    pass
 6735:   return lst
 6736:  def VVnQfA(self, lines):
 6737:   lst = []
 6738:   for line in lines:
 6739:    span = iSearch(r".+(userbouquet\..+\.(tv|radio))", line, IGNORECASE)
 6740:    if span:
 6741:     lst.append(span.group(1))
 6742:   return lst
 6743:  def VVFgaQ(self):
 6744:   CCh3tv.VV7Nf4(self.SELF, VVLL7M="Reading Bouquets ...", titleBg="
 6745:       , VVixvy  = self.VVQPt7
 6746:       , VVbYwR = self.VV6Jtz)
 6747:  def VVQPt7(self, VVXyP6):
 6748:   lines, err = CC9xd9.VVbsHS(self.filePath, "bouquets.tv")
 6749:   if err:
 6750:    self.VVQ5VQ(err)
 6751:    return
 6752:   bTvSortLst  = self.VVnQfA(lines)
 6753:   lines, err = CC9xd9.VVbsHS(self.filePath, "bouquets.radio")
 6754:   if err:
 6755:    self.VVQ5VQ(err)
 6756:    return
 6757:   bRadSortLst = self.VVnQfA(lines)
 6758:   if not VVXyP6 or VVXyP6.isCancelled:
 6759:    return
 6760:   self.VVAkuK = []
 6761:   self.subBouquets = {}
 6762:   if self.filePath.endswith(".zip"):
 6763:    with iZip.ZipFile(self.filePath) as zipF:
 6764:     zInfLst = zipF.infolist()
 6765:     VVXyP6.VVq8NF(len(zInfLst))
 6766:     for zipInfo in zInfLst:
 6767:      fName = os.path.basename(zipInfo.filename)
 6768:      if not VVXyP6 or VVXyP6.isCancelled: return
 6769:      VVXyP6.VVaks5(fName)
 6770:      VVXyP6.VVxtQs(1)
 6771:      span = iSearch(r"userbouquet\..+\.(tv|radio)$", fName, IGNORECASE)
 6772:      if span:
 6773:       mode = span.group(1)
 6774:       with zipF.open(zipInfo.filename) as f:
 6775:        row, bnbLst, err = self.VVsM21(f, mode, len(self.VVAkuK), zipInfo.filename, "-", False)
 6776:        if err:
 6777:         return
 6778:        tName = os.path.basename(row[11])
 6779:        parenB = row[1]
 6780:        if   tName in bTvSortLst : row[0] = str(bTvSortLst.index(tName))
 6781:        elif tName in bRadSortLst: row[0] = str(1000000 + bRadSortLst.index(tName))
 6782:        self.VVAkuK.append(row)
 6783:        lst = []
 6784:        for fPath in bnbLst:
 6785:         for zipInfo in zipF.infolist():
 6786:          if fPath == os.path.basename(zipInfo.filename):
 6787:           with zipF.open(zipInfo.filename) as f:
 6788:            row, bnbLst, err = self.VVsM21(f, mode, len(self.VVAkuK), zipInfo.filename, parenB, True)
 6789:            if err:
 6790:             return
 6791:            lst.append(row)
 6792:        if lst:
 6793:         self.subBouquets[tName] = lst
 6794:   else:
 6795:    with iTar.open(self.filePath) as tar:
 6796:     members = tar.getmembers()
 6797:     VVXyP6.VVq8NF(len(members))
 6798:     for mem in members:
 6799:      fName = os.path.basename(mem.name)
 6800:      if not VVXyP6 or VVXyP6.isCancelled: return
 6801:      VVXyP6.VVaks5(fName)
 6802:      VVXyP6.VVxtQs(1)
 6803:      span = iSearch(r"userbouquet\..+\.(tv|radio)$", fName, IGNORECASE)
 6804:      if span:
 6805:       mode = span.group(1)
 6806:       f = tar.extractfile(mem)
 6807:       row, bnbLst, err = self.VVsM21(f, mode, len(self.VVAkuK), mem.name, "-", False)
 6808:       if err:
 6809:        return
 6810:       tName = os.path.basename(row[11])
 6811:       parenB = row[1]
 6812:       if   tName in bTvSortLst : row[0] = str(bTvSortLst.index(tName))
 6813:       elif tName in bRadSortLst: row[0] = str(1000000 + bRadSortLst.index(tName))
 6814:       self.VVAkuK.append(row)
 6815:       lst = []
 6816:       for fPath in bnbLst:
 6817:        for mem in tar.getmembers():
 6818:         if fPath == os.path.basename(mem.name):
 6819:          f = tar.extractfile(mem.name)
 6820:          row, bnbLst, err = self.VVsM21(f, mode, len(self.VVAkuK), mem.name, parenB, True)
 6821:          if err:
 6822:           return
 6823:          lst.append(row)
 6824:       if lst:
 6825:        self.subBouquets[tName] = lst
 6826:  def VV6Jtz(self, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
 6827:   if self.VVAkuK:
 6828:    self.VVAkuK.sort(key=lambda x: int(x[0]))
 6829:    for ndx, item in enumerate(self.VVAkuK): self.VVAkuK[ndx][0] = str(ndx + 1)
 6830:    for key, lst in self.subBouquets.items():
 6831:     for ndx, row in enumerate(self.VVAkuK):
 6832:      if key == os.path.basename(row[11]):
 6833:       self.VVAkuK = self.VVAkuK[:ndx+1] + lst + self.VVAkuK[ndx+1:]
 6834:       break
 6835:    for ndx, item in enumerate(self.VVAkuK): self.VVAkuK[ndx][0] = str(ndx + 1)
 6836:    VVemyB = "
 6837:    VVlJfJ = self.VVlmMg
 6838:    VVu1YM  = ("Show Services"  , self.VVQnzP  , [])
 6839:    VV2ytr = (""     , self.VVEE0O, [])
 6840:    VVwSzI = ("Import to System" , self.VV3Jty  , [])
 6841:    VVScQz = ("Multi-Select"  , self.VVWIaF, [])
 6842:    header   = ("Num" , "Bouquet Name", "Parent Bouquet" , "Mode", "Items" , "DVB" , "IPTV", "S.Relay" , "Local" , "Marker" , "Bouquet" , "File")
 6843:    widths   = (7  ,  36   , 0.01    , 7  , 7   , 7  , 7  , 7   , 7   , 7   , 8   ,  0.01 )
 6844:    VVLIqP  = (CENTER ,  LEFT   , LEFT    , CENTER, CENTER , CENTER, CENTER, CENTER , CENTER , CENTER , CENTER ,  LEFT )
 6845:    tbl = FFUQ0v(self.SELF, None, title=self.Title, header=header, VVGape=self.VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=24, height=1000, VVu1YM=VVu1YM, VV2ytr=VV2ytr, VVlJfJ=VVlJfJ, VVwSzI=VVwSzI, VVScQz=VVScQz, VVMfsO=1, VVSLOq=CFG.lastFindServers, VVwltY=VVemyB, VVkxBG=VVemyB, VVemyB=VVemyB, VVJKqd="#00004455", VVbcr0="#0a282828")
 6846:    tbl.VVIOX6(BF(self.VVlmMg, tbl))
 6847:   else:
 6848:    self.VVQ5VQ("No valid bouquets in:\n\n%s" % os.path.basename(self.filePath))
 6849:  def VV3Jty(self, VV6A99, title, txt, colList):
 6850:   if VV6A99["keyGreen"].getVisible():
 6851:    cnt = 0
 6852:    if VV6A99.VVXWPu:
 6853:     rows = VV6A99.VVbF9W()
 6854:     for ndx, totBnb in enumerate(VV6A99.VVf3uT(10)):
 6855:      if VV6A99.VVvlf4(ndx) and totBnb.isdigit() and int(totBnb) > 0:
 6856:       VV6A99.VVTQDs(ndx, mode=0, movDn=False)
 6857:       cnt += 1
 6858:    if cnt == 0:
 6859:     if VV6A99.VVXWPu:
 6860:      tot = VV6A99.VVc5NH()
 6861:      ques = "Import %s Bouquet%s" % (FFjt5L(tot, VVSGsk), FFcacr(tot))
 6862:     else:
 6863:      bName = VV6A99.VV5crm()[1]
 6864:      ques = "Import Bouquet ?\n\n%s" % bName
 6865:     FFRMYv(self.SELF, BF(self.VVEzy6, VV6A99, self.filePath), ques, title=self.Title)
 6866:    else:
 6867:     FFjADj(VV6A99, "Fixed Selections : %s" % cnt, 2000)
 6868:  def VVlmMg(self, VV6A99):
 6869:   VV6A99["keyGreen"].hide()
 6870:   if VV6A99.VVXWPu:
 6871:    if VV6A99.VVc5NH() > 0:
 6872:     VV6A99["keyGreen"].show()
 6873:   else:
 6874:    totBnb = VV6A99.VV5crm()[10]
 6875:    if not (totBnb.isdigit() and int(totBnb) > 0):
 6876:     VV6A99["keyGreen"].show()
 6877:  def VVEE0O(self, VV6A99, title, txt, colList):
 6878:   totBnb = VV6A99.VV5crm()[10]
 6879:   if totBnb.isdigit() and int(totBnb) > 0:
 6880:    c1, c2 = VVz22H, VVFuwR
 6881:    txt += "\n%sNote:\n" % c1
 6882:    txt += "%s- This bouquet includes %s%s%s Sub-Bouquet%s.\n" % (c2, c1, totBnb, c2, FFcacr(int(totBnb)))
 6883:    txt += "- Its-Sub-Bouquets will follow it in the list (in yellow) if exist in the backup file."
 6884:   FF4lCP(self.SELF, txt, title=title)
 6885:  def VVWIaF(self, VV6A99, title, txt, colList):
 6886:   CCzSCo(self.SELF, VV6A99, addSep=False, setsOk=True).VV9VR2(None, None, width=700)
 6887:  def VVQnzP(self, VV6A99, title, txt, colList):
 6888:   if FFCyVu(self.filePath):
 6889:    num, bName, parentB, bMode, totItem, totDVB, totIptv, totSRelay, totLoc, totMrk, totBnb, fName = VV6A99.VV5crm()
 6890:    CCh3tv.VV7Nf4(self.SELF, VVLL7M= "Reading Services ...", titleBg="#22003344", bodyBg="#22001122"
 6891:        , VVixvy  = BF(self.VVX7RM, bName, fName)
 6892:        , VVbYwR = BF(self.VVTuhA, VV6A99, bName))
 6893:   else:
 6894:    FF28n1(VV6A99, "Cannot open file !", 1500)
 6895:  def VVX7RM(self, bName, fName, VVXyP6):
 6896:   lines, err = CC9xd9.VVbsHS(self.filePath, "lamedb")
 6897:   if err:
 6898:    self.VVQ5VQ(err)
 6899:    return
 6900:   dbServLst = CCYrUm.VVBshb(lines, mode=10)
 6901:   lines, err = CC9xd9.VVbsHS(self.filePath, os.path.basename(fName))
 6902:   if err:
 6903:    self.VVQ5VQ(err)
 6904:    return
 6905:   if not VVXyP6 or VVXyP6.isCancelled: return
 6906:   patt = iCompile(r"1:64:(?:[a-f0-9]+:){8}:(.+)"
 6907:       r'|.+1:7:.+FROM BOUQUET\s+"(.+)"'
 6908:       r"|(?:[a-f0-9]+:){10}http.+:(.+)"
 6909:       r"|(?:[a-f0-9]+:){10}(\/.+)"
 6910:       r'|.+1:7:.+FROM BOUQUET\s+"(.+)"'
 6911:       r"|((?:[a-f0-9]+:){10})(?:$|:.+)"
 6912:       , IGNORECASE)
 6913:   VVXyP6.VVq8NF(len(lines))
 6914:   VVAkuK = []
 6915:   bnbFound = False
 6916:   for line in lines:
 6917:    if not VVXyP6 or VVXyP6.isCancelled: return
 6918:    VVXyP6.VVxtQs(1)
 6919:    iSleep(0.0005)
 6920:    if line.startswith("
 6921:     span = patt.search(line)
 6922:     if span:
 6923:      g1, g2, g3, g4, g5, g6 = span.groups()
 6924:      if   g1: VVAkuK.append((g1.strip(), "Marker"))
 6925:      elif g2: VVAkuK.append((g2 or "-", "Sub-Bouquet"))
 6926:      elif g3: VVAkuK.append((g3.strip() or "-", "Stream Relay" if FFHgaY(line) else "IPTV"))
 6927:      elif g4: VVAkuK.append((os.path.basename(g4.strip() or "-"), "Local Media"))
 6928:      elif g5: VVAkuK.append((g5 or "-", "Sub-Bouquet"))
 6929:      elif g6:
 6930:       dbCode = CCYrUm.VVlPsR(g6)
 6931:       for dbCode1, name, prov in dbServLst:
 6932:        if dbCode1.upper() in dbCode:
 6933:         VVAkuK.append((name.strip() or "-", FFec0y(g6, False)))
 6934:         break
 6935:      if any((g2, g5)):
 6936:       bnbFound = True
 6937:      if not VVXyP6 or VVXyP6.isCancelled: return
 6938:      if VVAkuK:
 6939:       VVXyP6.VVaks5(VVAkuK[len(VVAkuK) - 1][0])
 6940:   if bnbFound:
 6941:    if not VVXyP6 or VVXyP6.isCancelled: return
 6942:    VVXyP6.VVq8NF(len(VVAkuK))
 6943:    VVXyP6.VV78Id(0)
 6944:    for ndx, item in enumerate(VVAkuK):
 6945:     name, descr = item
 6946:     if not VVXyP6 or VVXyP6.isCancelled: return
 6947:     VVXyP6.VVaks5(name)
 6948:     VVXyP6.VVxtQs(1)
 6949:     if iMatch(r".+\.tv", name, IGNORECASE):
 6950:      lines, err = CC9xd9.VVbsHS(self.filePath, os.path.basename(name))
 6951:      if lines and not err:
 6952:       span = iSearch(r"
 6953:       if span:
 6954:        bName = span.group(1).strip()
 6955:        if bName:
 6956:         VVAkuK[ndx] = (bName, descr)
 6957:   if not VVXyP6 or VVXyP6.isCancelled:
 6958:    return
 6959:   VVXyP6.VVNc18 = VVAkuK
 6960:  def VVTuhA(self, VV6A99, bName, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
 6961:   if VVNc18:
 6962:    VVemyB = "#11001122"
 6963:    bName = iSub(r"\s{4,}" ," .. " , bName)
 6964:    header  = ("Service", "Type")
 6965:    widths  = (80  , 20 )
 6966:    VVLIqP = (LEFT  , CENTER)
 6967:    FFUQ0v(self.SELF, None, title="Services in : %s" % bName, header=header, VVGape=VVNc18, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVwltY=VVemyB, VVkxBG=VVemyB, VVemyB=VVemyB, VVJKqd="#11550033", VVSLOq=CFG.lastFindServers)
 6968:   elif not VVRI6P:
 6969:    pass
 6970:   else:
 6971:    FF28n1(VV6A99, "No valid services !", 1500)
 6972:  def VVsM21(self, f, mode, sequence, fPath, parentB, isSubB):
 6973:   bName = ""
 6974:   totItem = totDVB = totMrk = totBnb = totIptv = totSRelay = totLoc = 0
 6975:   bnbLst = []
 6976:   for line in f:
 6977:    try:
 6978:     line = str(line.decode()).strip()
 6979:    except:
 6980:     self.VVQ5VQ("Encoding Error in the archived file:\n\n%s" % fPath)
 6981:     return [], [], "File Encoding Error"
 6982:    if line.startswith("#SERVICE "):
 6983:     totItem +=1
 6984:     if   iMatch(r".+1:64:(?:[A-Fa-f0-9]+:){8}:.+", line)    : totMrk += 1
 6985:     elif FFHgaY(line)           : totSRelay += 1
 6986:     elif iMatch(r".+(?:[A-Fa-f0-9]+:){10}http.+:.+", line, IGNORECASE) : totIptv += 1
 6987:     elif iMatch(r".+(?:[A-Fa-f0-9]+:){10}\/.+", line)     : totLoc += 1
 6988:     elif iMatch(r".+(?:[A-Fa-f0-9]+:){10}(?:$|:.+)", line)    : totDVB += 1
 6989:     else:
 6990:      span = iSearch(r'.+1:7:.+FROM BOUQUET\s+"(.+)".+', line, IGNORECASE)
 6991:      if span:
 6992:       totBnb += 1
 6993:       bnbLst.append(span.group(1))
 6994:    elif line.startswith("
 6995:     bName = line[6:]
 6996:   chColor = lambda x: str(x) if x else "#f#00666666#" + str(x)
 6997:   bMode = "TV" if mode == "tv" else "Radio"
 6998:   if   totBnb : fg, totBnb  = "#f#00ff5522#" , str(totBnb)
 6999:   elif isSubB : fg, totBnb  = "#f#00ffffbb#" , "Sub-B."
 7000:   else  : fg, totBnb = ""    , chColor(totBnb)
 7001:   row = [str(2000001 + sequence), fg + bName, parentB, fg + bMode, "
 7002:   return row, bnbLst, ""
 7003:  def VVEzy6(self, VV6A99, archPath):
 7004:   title = "Import Bouquets"
 7005:   tvBouquetFile  = VVQe79 + "bouquets.tv"
 7006:   radBouquetFile = VVQe79 + "bouquets.radio"
 7007:   for f in (tvBouquetFile, radBouquetFile):
 7008:    if not FFCyVu(f):
 7009:     FF8Wsn(self.SELF, f, title=title)
 7010:     return
 7011:   isMulti = VV6A99.VVXWPu
 7012:   if isMulti : rows = VV6A99.VVbF9W()
 7013:   else  : rows = [VV6A99.VV5crm()]
 7014:   CCh3tv.VV7Nf4(self.SELF, VVLL7M=title, titleBg="#22003344", bodyBg="#22001122", totBars=2
 7015:       , VVixvy  = BF(self.VVlZ6h, VV6A99, rows, archPath, tvBouquetFile, radBouquetFile, title)
 7016:       , VVbYwR = BF(self.VV0n7h, title) )
 7017:  def VVlZ6h(self, VV6A99, rows, archPath, tvBouquetFile, radBouquetFile, title, VVXyP6):
 7018:   totTP = totServ = totTv = totRad = totMissTP = totMissServ = totMissSRelay = totAllServ = 0
 7019:   totBouq = len(rows)
 7020:   VVXyP6.VVq8NF(totBouq)
 7021:   VVXyP6.VVUIH1(totBouq)
 7022:   VVXyP6.VVNc18 = (totBouq, totAllServ, totTP, totServ, totTv, totRad, totMissTP, totMissServ, totMissSRelay)
 7023:   bList = []
 7024:   totAllServ = 0
 7025:   if FFCyVu(archPath):
 7026:    for num, bName, parentB, bMode, totItem, totDVB, totIptv, totSRelay, totLoc, totMrk, totBnb, fName in rows:
 7027:     if not VVXyP6 or VVXyP6.isCancelled:
 7028:      return
 7029:     VVXyP6.VVaks5(bName)
 7030:     VVXyP6.VVxtQs(1)
 7031:     totAllServ += int(totItem)
 7032:     newFile = os.path.basename(fName)
 7033:     span = iSearch(r".+\.(.+)\.(tv|radio)", newFile, IGNORECASE)
 7034:     if span : fNamePart, fNameExt = span.group(1), span.group(2)
 7035:     else : fNamePart, fNameExt = "bouquet", "tv"
 7036:     newFile = "userbouquet.%s.%s" % (fNamePart, fNameExt)
 7037:     bPath = VVQe79 + newFile
 7038:     num  = 0
 7039:     while FFCyVu(bPath):
 7040:      num += 1
 7041:      newFile = "userbouquet.%s_%d.%s" % (fNamePart, num, fNameExt)
 7042:      bPath = VVQe79 + newFile
 7043:     CC9xd9.VV9cx5(archPath, fName, VVQe79, newFile)
 7044:     if FFCyVu(bPath):
 7045:      bList.append(newFile)
 7046:   if not VVXyP6 or VVXyP6.isCancelled:
 7047:    return
 7048:   if bList:
 7049:    FFJvhj(tvBouquetFile)
 7050:    FFJvhj(radBouquetFile)
 7051:    for bFile in bList:
 7052:     if bFile.endswith("tv") : mainBFile, totTv = tvBouquetFile , totTv  + 1
 7053:     else     : mainBFile, totRad = radBouquetFile, totRad + 1
 7054:     with open(mainBFile, "a") as f:
 7055:      f.write('#SERVICE 1:7:1:0:0:0:0:0:0:0:FROM BOUQUET "%s" ORDER BY bouquet\n' % bFile)
 7056:    if not VVXyP6 or VVXyP6.isCancelled:
 7057:     return
 7058:    VVXyP6.VVNc18 = (totBouq, totAllServ, totTP, totServ, totTv, totRad, totMissTP, totMissServ, totMissSRelay)
 7059:    totTP, totServ, totMissTP, totMissServ, totMissSRelay = self.VVUNqO(archPath, bList, VVXyP6)
 7060:    VVXyP6.VVNc18 = (totBouq, totAllServ, totTP, totServ, totTv, totRad, totMissTP, totMissServ, totMissSRelay)
 7061:  def VV0n7h(self, title, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
 7062:   FFfpyJ()
 7063:   totBouq, totAllServ, totTP, totServ, totTv, totRad, totMissTP, totMissServ, totMissSRelay = VVNc18
 7064:   c1, c2 = VVFuwR, VVz22H
 7065:   txt  = FFjt5L("Added:\n", VVFuwR)
 7066:   txt += "Bouquets\t: %d     (%d TV , %d Radio)\n" % (totBouq, totTv, totRad)
 7067:   txt += "Services\t: %d\n" % totAllServ
 7068:   if totTP or totServ:
 7069:    txt += "\n"
 7070:    txt += FFjt5L("Imported to lamedab:\n", VVFuwR)
 7071:    if totTP : txt += "Transponders\t: %d\n" % totTP
 7072:    if totServ : txt += "Services\t: %d\n"  % totServ
 7073:   if any((totMissTP, totMissServ, totMissSRelay)):
 7074:    txt += "\n"
 7075:    txt += FFjt5L("Missing from archived lamedb:\n", VVz22H)
 7076:    if totMissTP : txt += "Transponders\t: %d\n" % totMissTP
 7077:    if totMissServ : txt += "Services\t: %d"  % totMissServ
 7078:    if totMissSRelay : txt += "Stream Relay\t: %d" % totMissSRelay
 7079:   FF4lCP(self.SELF, txt, title=title, width=1000)
 7080:   if self.cbFnc:
 7081:    self.cbFnc()
 7082:  def VVUNqO(self, archPath, bList, VVXyP6):
 7083:   VVkMso, err = CCYrUm.VVQwcg(self.SELF, VV49Lf=False)
 7084:   if err:
 7085:    return 0, 0, 0, 0
 7086:   dbServIDs = CCYrUm.VVaZcW(VVkMso, mode=11)
 7087:   if not dbServIDs:
 7088:    return 0, 0, 0, 0
 7089:   newDbServIDs = set()
 7090:   newDbTpIDs  = set()
 7091:   newStreamRelayChNames = set()
 7092:   for bFile in bList:
 7093:    if not VVXyP6 or VVXyP6.isCancelled:
 7094:     return
 7095:    VVXyP6.VVaks5(bFile)
 7096:    VVXyP6.VVg2Dw(1)
 7097:    lines = FFL19l(VVQe79 + bFile)
 7098:    for line in lines:
 7099:     span = iSearch(r"((?:[A-Fa-f0-9]+:){10}$)", line, IGNORECASE)
 7100:     if span:
 7101:      VVPxk5 = span.group(1)
 7102:      dbCode = CCYrUm.VVlPsR(VVPxk5)
 7103:      if not dbCode in dbServIDs:
 7104:       newDbServIDs.add(dbCode)
 7105:       newDbTpIDs.add(CCYrUm.VVIoyj(VVPxk5))
 7106:     else:
 7107:      span = iSearch(r"(?:[A-Fa-f0-9]+:){10}https?(?::|%3a)\/\/(?:(?:127|0)\.\d+\.\d+\.\d+|localhost)(?::|%3a)\d+\/(.+)\/pid(\d+):", line, IGNORECASE)
 7108:      if span:
 7109:       newStreamRelayChNames.add(" PID ".join(span.groups()))
 7110:   dbServIDs = None
 7111:   if not VVXyP6 or VVXyP6.isCancelled:
 7112:    return
 7113:   VVXyP6.VVaks5("Updating lamedb (Stage-1) ...")
 7114:   tFile = ""
 7115:   if any((newDbServIDs, newDbTpIDs, newStreamRelayChNames)) and FFCyVu(archPath):
 7116:    dbName = "lamedb"
 7117:    tFile = "/tmp/%s.tmp" % dbName
 7118:    fName = CC9xd9.VVcVZU(archPath, dbName)
 7119:    CC9xd9.VV9cx5(archPath, fName, "/tmp/", dbName + ".tmp")
 7120:   newTPLines = set()
 7121:   newServLines= set()
 7122:   dbTpData = CCYrUm.VVaZcW(VVkMso, mode=0)
 7123:   dbServData = CCYrUm.VVaZcW(VVkMso, mode=10)
 7124:   if newDbTpIDs:
 7125:    for item in CCYrUm.VVaZcW(tFile, mode=0):
 7126:     if item[0].upper() in newDbTpIDs and not item in dbTpData:
 7127:      newTPLines.add(item)
 7128:   if newDbServIDs:
 7129:    for item in CCYrUm.VVaZcW(tFile, mode=10):
 7130:     if item[0].upper() in newDbServIDs and not item in dbServData:
 7131:      newServLines.add(item)
 7132:   totMissSRelay = len(newStreamRelayChNames)
 7133:   if newStreamRelayChNames:
 7134:    for item in CCYrUm.VVaZcW(tFile, mode=14):
 7135:     for VV1wIO in newStreamRelayChNames:
 7136:      if VV1wIO.lower() == item[1].lower():
 7137:       totMissSRelay = 0
 7138:       if not item in dbServData:
 7139:        newServLines.add(item)
 7140:        tp = CCYrUm.VVwhja(item[0])
 7141:        if not tp in dbTpData:
 7142:         newTPLines.add(tp)
 7143:   if not VVXyP6 or VVXyP6.isCancelled:
 7144:    return
 7145:   VVXyP6.VVaks5("Updating lamedb (Stage-2) ...")
 7146:   totMissTP = 0
 7147:   totMissServ = 0
 7148:   lst = CCYrUm.VVaZcW(tFile, mode=1)
 7149:   for dbCode in newDbTpIDs:
 7150:    if not lst or not dbCode in lst:
 7151:     totMissTP += 1
 7152:   lst = CCYrUm.VVaZcW(tFile, mode=11)
 7153:   for dbCode in newDbServIDs:
 7154:    if not lst or not dbCode in lst:
 7155:     totMissServ += 1
 7156:   if not VVXyP6 or VVXyP6.isCancelled:
 7157:    return
 7158:   VVXyP6.VVaks5("Updating lamedb (Stage-3) ...")
 7159:   FFwgGB(tFile)
 7160:   totServ = totTP = 0
 7161:   if newTPLines or newServLines:
 7162:    isServ = isTP = False
 7163:    tmpDbFile = VVkMso + ".tmp"
 7164:    lines   = FFL19l(VVkMso)
 7165:    with open(tmpDbFile, "w") as f:
 7166:     for line in lines:
 7167:      sLine = line.strip()
 7168:      if   sLine == "transponders": isTP, isServ = True, False
 7169:      elif sLine == "services" : isTP, isServ = False, True
 7170:      elif sLine == "end":
 7171:       if isTP:
 7172:        for item in (newTPLines):
 7173:         totTP += 1
 7174:         for L in item:
 7175:          f.write(L + "\n")
 7176:       elif isServ:
 7177:        for item in (newServLines):
 7178:         totServ += 1
 7179:         for L in item:
 7180:          f.write(L + "\n")
 7181:      f.write(line + "\n")
 7182:    FFpwZS("mv -f '%s' '%s'" % (tmpDbFile, VVkMso))
 7183:   return totTP, totServ, totMissTP, totMissServ, totMissSRelay
 7184:  @staticmethod
 7185:  def VVcVZU(path, fName):
 7186:   if path.endswith(".zip"):
 7187:    with iZip.ZipFile(path) as zipF:
 7188:     for zipInfo in zipF.infolist():
 7189:      if os.path.basename(zipInfo.filename) == fName:
 7190:       return zipInfo.filename
 7191:   else:
 7192:    with iTar.open(path) as tar:
 7193:     for mem in tar.getmembers():
 7194:      if os.path.basename(mem.name) == fName:
 7195:       return mem.name
 7196:   return ""
 7197:  @staticmethod
 7198:  def VV9cx5(path, fName, newPath, newFile):
 7199:   if path.endswith(".zip"):
 7200:    with iZip.ZipFile(path) as zipF:
 7201:     zipInfo = zipF.getinfo(fName)
 7202:     zipInfo.filename = newFile
 7203:     zipF.extract(zipInfo, newPath)
 7204:   else:
 7205:    with iTar.open(path) as tar:
 7206:     mem = tar.getmember(fName)
 7207:     mem.name = newFile
 7208:     tar.extract(mem, path=newPath)
 7209:  @staticmethod
 7210:  def VVbsHS(path, subFile):
 7211:   lines = []
 7212:   try:
 7213:    if path.endswith(".zip"):
 7214:     with iZip.ZipFile(path) as zipF:
 7215:      for zipInfo in zipF.infolist():
 7216:       fName = os.path.basename(zipInfo.filename)
 7217:       if fName == subFile:
 7218:        with zipF.open(zipInfo.filename) as f:
 7219:         lines = f.read().decode().splitlines()
 7220:        break
 7221:      else:
 7222:       return [], "Archived file not found:\n\n%s" % subFile
 7223:    else:
 7224:     with iTar.open(path) as tar:
 7225:      for mem in tar.getmembers():
 7226:       fName = os.path.basename(mem.name)
 7227:       if fName == subFile:
 7228:        f = tar.extractfile(mem)
 7229:        lines = f.read().decode().splitlines()
 7230:        break
 7231:      else:
 7232:       return [], "Archived file not found:\n\n%s" % subFile
 7233:    return [str(x.strip()) for x in lines], ""
 7234:   except:
 7235:    return [], "Error while reading the archived file:\n\n%s" % subFile
 7236: class CCEzue():
 7237:  def __init__(self):
 7238:   self.VVcHUa   = "Package Creator"
 7239:   self.VVrVbw   = "ajpanel_package_"
 7240:   self.VVvHW8  = FF0cqc()
 7241:   self.VVwdtN   = ""
 7242:   self.VVNvsj   = ""
 7243:   self.VVHCVG   = ""
 7244:   self.VVkzdr   = None
 7245:   self.VVIHf1   = None
 7246:   self.VVs3Gr = ""
 7247:   self.VVEvFg  = ""
 7248:   self.VVJorQ = ""
 7249:   self.VVQBGg = ""
 7250:   self.VVuB9m = ""
 7251:   self.VVj1mD = ""
 7252:   self.VVhQ0X()
 7253:  def VVhQ0X(self):
 7254:   self.projPkg   = ""
 7255:   self.projVer   = ""
 7256:   self.projArch   = ""
 7257:   self.VVHCVGsSize  = 0
 7258:   self.projTotalDirs  = 0
 7259:   self.projTotalFiles  = 0
 7260:   self.projAct_postInst = 0
 7261:   self.projAct_postRm  = 0
 7262:  @FFOAKH()
 7263:  def VV37Fz(self):
 7264:   FFHQjU()
 7265:   self.VVvHW8 = FFoUor()
 7266:   lst = FFkES0(self.VVvHW8)
 7267:   VV3wat = []
 7268:   if lst:
 7269:    for path in lst:
 7270:     if path.startswith(self.VVrVbw):
 7271:      prName = os.path.basename(path)
 7272:      VV3wat.append((prName, prName))
 7273:   if VV3wat:
 7274:    VV3wat.sort(key=lambda x: x[1].lower())
 7275:    VVOa1G = self.VVBAJe
 7276:    VVwJOl = ("Add new project", self.VVtfY4)
 7277:    VVB4pu= ("Delete Project" , self.VVLvWJ)
 7278:    self.VVkzdr = FFLFTC(self, None, VV3wat=VV3wat, width=1100, VVOa1G=VVOa1G, VVwJOl=VVwJOl, VVB4pu=VVB4pu, VVyRCy=5, VVwltY="#22111133", VVkxBG="#22111133")
 7279:   else:
 7280:    FFRMYv(self, self.VVGrGJ, "No projects found !\n\n Create new project ?", title=self.VVcHUa)
 7281:  def VVGrGJ(self)    : FFimQ3(self, BF(self.VVQTlD))
 7282:  def VVtfY4(self, VV7tND, item) : FFimQ3(self.VVkzdr, BF(self.VVQTlD))
 7283:  def VVQTlD(self):
 7284:   err, _ = self.VVWetn(0)
 7285:   if err:
 7286:    self.VVwTG2(err)
 7287:   else:
 7288:    c = 0
 7289:    while True:
 7290:     c += 1
 7291:     name = "project_%d" % (c)
 7292:     if not VVmJwX("%s%s%s" % (self.VVvHW8, self.VVrVbw, name)):
 7293:      break
 7294:    self.VVmNbG(name)
 7295:  def VVmNbG(self, name, cbFnc=None):
 7296:   FF4z45(self, cbFnc or self.VVaqC7, defaultText=name, title="New Project Name", message="Enter project name")
 7297:  def VVaqC7(self, name):
 7298:   if name and name.strip():
 7299:    path = "%s%s%s" % (self.VVvHW8, self.VVrVbw, name)
 7300:    if VVmJwX(path):
 7301:     FFRMYv(self, BF(self.VVmNbG, name), "Project directory already exists !\n\n Change name ?", title=self.VVcHUa)
 7302:    else:
 7303:     err = FFENxa(path)
 7304:     if err:
 7305:      self.VVwTG2("Cannot create project directory !\n\n %s" % err)
 7306:     else:
 7307:      item = os.path.basename(path)
 7308:      if self.VVkzdr: self.VVkzdr.VV5HD3((item, item), isSort=True)
 7309:      else   : self.VV37Fz()
 7310:  def VVLvWJ(self, VV7tND, path):
 7311:   if path:
 7312:    path = self.VVvHW8 + path
 7313:    if VVmJwX(path):
 7314:     totDir, totFile, totLink = FFK6he(path)
 7315:     FFRMYv(self, BF(self.VVbRTn, path), "Project directory contains %d items.\n\n%s\n\nDelete ?" %(totDir + totFile + totLink, path), title=self.VVcHUa)
 7316:  def VVbRTn(self, path):
 7317:   if FFpwZS("rm -rf '%s'" % path):
 7318:    self.VVkzdr.VV478W()
 7319:  def VVBAJe(self, item=None):
 7320:   if item:
 7321:    VV7tND, txt, Dir, ndx = item
 7322:    self.VVhQ0X()
 7323:    self.VVwdtN = os.path.basename(Dir)[len(self.VVrVbw):]
 7324:    self.VVNvsj = "%s%s/" % (self.VVvHW8, Dir)
 7325:    self.VVHCVG = "%s%s.cfg"  % (self.VVNvsj, self.VVwdtN)
 7326:    self.VVs3Gr = self.VVNvsj + "control"
 7327:    self.VVEvFg  = self.VVNvsj + "prerm"
 7328:    self.VVJorQ = self.VVNvsj + "postrm"
 7329:    self.VVQBGg = self.VVNvsj + "preinst"
 7330:    self.VVuB9m = self.VVNvsj + "postinst"
 7331:    if not FFCyVu(self.VVs3Gr):
 7332:     err, lst = self.VVWetn(2)
 7333:     if err:
 7334:      self.VVwTG2(err)
 7335:      return
 7336:     pkg = FFWEt2(self.VVwdtN, r"_").lower()
 7337:     with open(self.VVs3Gr, "w") as f:
 7338:      for line in lst:
 7339:       f.write("%s\n" % (line[1].replace("xx1", pkg).replace("xx2", self.VVwdtN)))
 7340:    if not FFCyVu(self.VVHCVG):
 7341:     with open(self.VVHCVG, "w") as f:
 7342:      sep = "#" * 80
 7343:      f.write("%s\n" % sep)
 7344:      f.write("%s Project\t: %s\n" % ("#", self.VVwdtN))
 7345:      f.write("%s Started\t: %s\n" % ("#", FFIPdt()))
 7346:      f.write("%s\n" % sep)
 7347:    if FFCyVu(self.VVHCVG): self.VVEB1h(VV7tND)
 7348:    else      : self.VVwTG2("Cannot create project file:\n\n%s" % self.VVHCVG)
 7349:  def VVEB1h(self, VV7tND=None, jmpDict=None):
 7350:   FFimQ3(VV7tND or self.VVIHf1 or self, BF(self.VV1Ovp, jmpDict))
 7351:  def VV1Ovp(self, jmpDict):
 7352:   self.VVhQ0X()
 7353:   pkgRows, ctrlRows, actnRows, fileRows, unknRows = [], [], [], [], []
 7354:   tLst = []
 7355:   if FFCyVu(self.VVs3Gr):
 7356:    for lineNdx, line in enumerate(FFL19l(self.VVs3Gr)):
 7357:     line = line.strip()
 7358:     if ":" in line:
 7359:      subj, val, rem = self.VVEhxm(line)
 7360:      if   subj in tLst: rem = FFjt5L("Duplicate Field", VVz22H)
 7361:      elif val == ""  : rem = FFjt5L("No Value", VVz22H)
 7362:      tLst.append(subj)
 7363:      pkgRows.append((str(lineNdx), "Control", subj, val, "", rem, ""))
 7364:   if not pkgRows:
 7365:    self.VVwTG2('Invalid "control" file:\n\n%s' % self.VVs3Gr)
 7366:    return
 7367:   for path in (self.VVQBGg, self.VVuB9m, self.VVEvFg, self.VVJorQ):
 7368:    size = val = ""
 7369:    if FFCyVu(path):
 7370:     val = path
 7371:     sz = FFXhoc(path)
 7372:     if sz > -1: size = CClYaF.VV99gM(sz, mode=4)
 7373:     else   : size = FFjt5L("Size error", VVz22H)
 7374:    ctrlRows.append(("", "Script", os.path.basename(path), val, size, "", ""))
 7375:   lines = list(map(str.strip, FFL19l(self.VVHCVG)))
 7376:   pathsLst = []
 7377:   for line in lines:
 7378:    if line.startswith("/"):
 7379:     pathsLst.append(line)
 7380:   pathsAnalysis = CCts4c.VVm09O(pathsLst)
 7381:   for lineNdx, line in enumerate(lines):
 7382:    lineNdx = str(lineNdx)
 7383:    if line and not line.startswith("
 7384:     validF = size = rem = ""
 7385:     if line.startswith("/"):
 7386:      path, fName, typ, size, rem, validF = self.VVF6iU(line, fileRows, pathsAnalysis)
 7387:      fileRows.append((lineNdx, "Resource", typ or "Unknown", path, size, rem, validF))
 7388:     else:
 7389:      Title, val = self.VV2ukf(line)
 7390:      if Title: actnRows.append((lineNdx, "Action", Title, val, size, rem, validF))
 7391:      else : unknRows.append((lineNdx, "?", "-", line, size, FFjt5L("Unknown value", VVz22H), validF))
 7392:   for ndx, row in enumerate(actnRows):
 7393:    lineNdx, Section, Title, Value, Size, Remarks, ValidF = row
 7394:    rem = ""
 7395:    if   FFCyVu(self.VVuB9m) and Title == "postinst" : rem = "Ignored (if custom postinst)"
 7396:    elif FFCyVu(self.VVJorQ  ) and Title == "postrm" : rem = "Ignored (if custom postrm)"
 7397:    if rem:
 7398:     actnRows[ndx] = (lineNdx, Section, Title, Value, Size, FFjt5L(rem, VVz22H), ValidF)
 7399:   actnRows.sort(key=lambda x: x[2].lower())
 7400:   fileRows.sort(key=lambda x: (x[2].lower(), x[3].lower()))
 7401:   unknRows.sort(key=lambda x: x[3].lower())
 7402:   VVAkuK = pkgRows
 7403:   VVAkuK.extend(actnRows)
 7404:   VVAkuK.extend(ctrlRows)
 7405:   VVAkuK.extend(fileRows)
 7406:   VVAkuK.extend(unknRows)
 7407:   cDict = {"Control":"", "Action":"0c302636", "Script":"0a28281a", "Resource":"1100385a", "?":"11550000"}
 7408:   for ndx, row in enumerate(VVAkuK):
 7409:    lineNdx, Section, Title, Value, Size, Remarks, ValidF = row
 7410:    color = cDict.get(Section, "")
 7411:    if color:
 7412:     if ValidF: Remarks = "%s%s" % (FFjt5L("Valid", VVSGsk), " ... " + Remarks if Remarks else "")
 7413:     VVAkuK[ndx] = (lineNdx, "
 7414:   if self.VVIHf1:
 7415:    self.VVIHf1.VVMqQ9(VVAkuK, VVDpzd=BF(self.VVagnj, jmpDict) if jmpDict else None, isSort=False)
 7416:   else:
 7417:    bg = "#15000000"
 7418:    title = "%s : %s" % (self.VVcHUa, self.VVwdtN)
 7419:    VV2ytr = (""     , self.VVA984   , [])
 7420:    VVdHJK = (""     , self.VVV9gg   , [])
 7421:    VVwWmA = ("Create Package"  , self.VV1QUT , [])
 7422:    VVScQz = ("Post Install Action", self.VVKEHB, [])
 7423:    VV4QTJ = ("Edit File"   , self.VVc4kr  , [])
 7424:    header  = ("lineNdx", "Section" , "Title" , "Value / Path", "Size", "Remarks" , "ValidF")
 7425:    widths  = (0  , 9   , 11  , 48   , 10 , 22  , 0   )
 7426:    VVLIqP = (CENTER , CENTER , LEFT  , LEFT   , CENTER, LEFT  , CENTER )
 7427:    self.VVIHf1 = FFUQ0v(self, None, title=title, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, width=1850, height=1040, VVwdmN=26, VV2ytr=VV2ytr, VVdHJK=VVdHJK, VVwWmA=VVwWmA, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVMfsO=2
 7428:          , VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#00664411", VVbcr0="#00444444", VVX9AA="#08442211")
 7429:    self.VVIHf1.VVIOX6(self.VVp6TV)
 7430:  def VVagnj(self, jmpDict, VV6A99, title, txt, colList):
 7431:   self.VVIHf1.VVPkdw(jmpDict)
 7432:  def VVp6TV(self):
 7433:   lineNdx, Section, Title, Value, Size, Remarks, ValidF = self.VVIHf1.VV5crm()
 7434:   if Section == "Control":
 7435:    txt = '"control" File'
 7436:   elif Section == "Script" :
 7437:    txt = "Script File"
 7438:    if Value.startswith("/") and FFCyVu(Value):
 7439:     txt = "Script File"
 7440:    else:
 7441:     self.VVIHf1["keyBlue"].hide()
 7442:     return
 7443:   else:
 7444:    txt = "Project File"
 7445:   self.VVIHf1["keyBlue"].show()
 7446:   self.VVIHf1["keyBlue"].setText("Edit %s" % txt)
 7447:  def VVEhxm(self, line):
 7448:   def VVZwiy(patt, val, Len):
 7449:    if len(val) < Len   : return FFjt5L("Length error" , VVz22H)
 7450:    elif not iMatch(patt, val) : return FFjt5L("Invalid format" , VVz22H)
 7451:    else      : return ""
 7452:   subj, _, val = line.partition(":")
 7453:   val, rem = val.strip(), ""
 7454:   if   not self.projPkg  and subj == "Package"  : self.projPkg, rem = val, VVZwiy(r"^[a-z]+[a-z0-9+-_.]+$", val, 2)
 7455:   elif not self.projVer  and subj == "Version"  : self.projVer, rem = val, VVZwiy(r"^[a-zA-Z0-9_+-.~]*$" , val, 1)
 7456:   elif not self.projArch and subj == "Architecture": self.projArch = val
 7457:   return subj, val, rem
 7458:  def VVF6iU(self, path, fileRows, pathsAnalysis):
 7459:   cleanLst, dirLst, filLst, errLst, mntLst, rmDirLst, totDuplDir, totDuplFil = pathsAnalysis
 7460:   rem = note = validF = targetType = ""
 7461:   size = "-"
 7462:   isCtrl = False
 7463:   fName = os.path.basename(path)
 7464:   typ = FFTWKU(path)
 7465:   path = FFVc4H(path)
 7466:   c1 = VVz22H
 7467:   if   typ == "Mount"     : rem = "Not allowed"
 7468:   elif not typ      : rem = "Cannot be accessed"
 7469:   elif FFoWxR(path) in rmDirLst: rem = "Ignored (child exists)"
 7470:   else:
 7471:    for item in fileRows:
 7472:     if item[3].strip() == path:
 7473:      rem = "Duplicate"
 7474:      break
 7475:   if rem:
 7476:    rem = FFjt5L(rem, c1)
 7477:    return path, fName, typ, size, rem, validF
 7478:   sz = -1
 7479:   skipSz = False
 7480:   if typ == "Directory":
 7481:    sz = FF4oMa(path)
 7482:   elif typ == "SymLink":
 7483:    targetPath = os.path.realpath(path)
 7484:    targetType = FFTWKU(targetPath)
 7485:    if  targetType == "Mount"  : skipSz, rem = True, FFjt5L("Not allowed", c1)
 7486:    elif targetType == "Directory" : sz = FF4oMa(targetPath)
 7487:    elif targetType == "File"  : sz = FFXhoc(targetPath)
 7488:    else       : sz, rem = FFXhoc(path), FFjt5L("Invalid", c1)
 7489:    note = "%s%s%s" % (note, " ... " if note else "", "Linked to : %s" % targetPath)
 7490:   elif typ == "File":
 7491:    sz = FFXhoc(path)
 7492:   if not skipSz:
 7493:    if sz > -1:
 7494:     validF = "" if rem else "1"
 7495:     if validF:
 7496:      if "Directory" in (typ, targetType) : self.projTotalDirs  += 1
 7497:      if "File" in (typ, targetType)  : self.projTotalFiles += 1
 7498:      self.VVHCVGsSize += sz
 7499:     size = CClYaF.VV99gM(sz, mode=4)
 7500:    else:
 7501:     size = FFjt5L("Size error", c1)
 7502:   rem = "%s%s%s" % (rem, " ... " if rem else "", note)
 7503:   return path, fName, typ, size, rem, validF
 7504:  def VV2ukf(self, line):
 7505:   Title = val = ""
 7506:   actDict = {"restart":1, "reboot":2 }
 7507:   span = iSearch(r"postinst\s*=\s*(.+)", line, IGNORECASE)
 7508:   if span:
 7509:    act = span.group(1).lower()
 7510:    self.projAct_postInst = actDict.get(act, 0)
 7511:    Title, val = "postinst", "%s after the package is installed" % act.capitalize()
 7512:   else:
 7513:    span = iSearch(r"postrm\s*=\s*(.+)", line, IGNORECASE)
 7514:    if span:
 7515:     act = span.group(1).lower()
 7516:     self.projAct_postRm = actDict.get(act, 0)
 7517:     Title, val = "postrm", "%s after the package is removed" % act.capitalize()
 7518:   return Title, val
 7519:  def VVc4kr(self, VV6A99, title, txt, colList):
 7520:   lineNdx, Section, Title, Value, Size, Remarks, ValidF = colList
 7521:   if   Section == "Control": path, lineNdx = self.VVs3Gr, int(lineNdx)
 7522:   elif Section == "Script" : path, lineNdx = Value, 0
 7523:   else      : path, lineNdx = self.VVHCVG, int(lineNdx)
 7524:   if FFCyVu(path) : CCyMCP(self, path, VVbYwR=self.VVsV9F, VVPhQC=lineNdx)
 7525:   else    : FF8Wsn(self, path)
 7526:  def VVsV9F(self, fileChanged):
 7527:   if fileChanged:
 7528:    self.VVEB1h()
 7529:  def VVwTG2(self, txt):
 7530:   FFdw58(self, txt, title=self.VVcHUa)
 7531:  def VVA984(self, VV6A99, title, txt, colList):
 7532:   tab = lambda x, y: "%s\t: %s\n" % (x, y)
 7533:   c = VVFuwR
 7534:   s  = FFGEAF("Current Row", c)
 7535:   s += title + "\n"
 7536:   s += txt + "\n"
 7537:   s += FFGEAF("Project", c)
 7538:   s += tab("File Name", self.VVHCVG)
 7539:   s += tab("Valid Dirs", self.projTotalDirs)
 7540:   s += tab("Valid Files", self.projTotalFiles)
 7541:   s += tab("Total Size", CClYaF.VV99gM(self.VVHCVGsSize))
 7542:   FF4lCP(self, s, title="Project Info", width=1600)
 7543:  def VVV9gg(self, VV6A99, title, txt, colList):
 7544:   c1, c2, c3, c4, c5 = VVJEMb, VVZtfx, VVFuwR, VVz22H, VVSGsk
 7545:   allRes, invRes, unkRes = self.VV0sEJ()
 7546:   totAll = len(allRes)
 7547:   totInv = len(invRes)
 7548:   totAllTxt = ("(Total=%d)" % totAll) if allRes else ""
 7549:   totInvTxt = ("(Total=%d)" % totInv) if invRes else ""
 7550:   lineNdx, Section, Title, Value, Size, Remarks, ValidF = colList
 7551:   canDel = False
 7552:   if Section != "Script" and Title not in ("Package", "Version", "Description", "Maintainer", "Architecture"):
 7553:    canDel = True
 7554:   canAddPkg, depTitle = False, ""
 7555:   if Section == "Control" and Title in ("Breaks", "Built-Using", "Conflicts", "Depends", "Enhances", "Pre-Depends", "Provides", "Recommends", "Replaces", "Suggests"):
 7556:    canAddPkg, depTitle = True , VVA4XU + '\tFor : "%s"' % Title
 7557:   VV3wat = []
 7558:   VV3wat.append((c1 + "Add Resource Files/Dirs"       , "addFiles"))
 7559:   VV3wat.append((c1 + "Import Files/Dirs List from an Installed Package", "pkgFiles"))
 7560:   VV3wat.append(VVAL3j)
 7561:   VV3wat.append((c3 + "Import Control File (control/preinst/prerm/postinst/postrm)" , "ctrlFMan" ))
 7562:   VV3wat.append((c3 + "Import Control Data from an Installed Package"    , "ctrlImprt" ))
 7563:   VV3wat.append((c3 + "Add Control Field"           , "ctrlField" ))
 7564:   VV3wat.append(VVAL3j)
 7565:   VV3wat.append(FFsLU5("Add Binary Package%s"  % depTitle  , "addDep" , canAddPkg, c2 ))
 7566:   VV3wat.append(FFsLU5("Remove Binary Package%s" % depTitle  , "delDep" , canAddPkg, c2 ))
 7567:   VV3wat.append(VVAL3j)
 7568:   VV3wat.append(("Change Package Name"  , "pkgNam" ))
 7569:   VV3wat.append(VVAL3j)
 7570:   VV3wat.append(FFsLU5("Delete All Resources %s"  % totAllTxt , "delAllRes" , totAll > 0, c4))
 7571:   VV3wat.append(FFsLU5("Delete Invalid Resources %s" % totInvTxt , "delInval" , totInv > 0, c4))
 7572:   VV3wat.append(FFsLU5("Delete Current Row"      , "delRow"  , canDel , c4))
 7573:   VV3wat.append(VVAL3j)
 7574:   VV3wat.append(FFsLU5('Undo Last "control" File Changes'   , "ctrlUndo" , FFCyVu(self.VVs3Gr + ".bak"), c5))
 7575:   VV3wat.append(FFsLU5("Undo Last Project File Changes"   , "projUndo" , FFCyVu(self.VVHCVG + ".bak")  , c5))
 7576:   FFLFTC(self, BF(self.VVml7A, Title), VV3wat=VV3wat, width=1050, height=1000, title="Options", VVwltY="#11001122", VVkxBG="#11001122", VVU8mZ=True)
 7577:  def VVml7A(self, fldTitle, item=None):
 7578:   if item:
 7579:    ques, item, ndx = item
 7580:    ques = FFzBfi(ques)
 7581:    if   item == "addFiles" : self.VV4RT4()
 7582:    elif item == "pkgFiles" : self.VVcm7J(self.VVIHf1, "Import Files/Dirs", self.VVusXB)
 7583:    elif item == "ctrlFMan" : self.VVuApU()
 7584:    elif item == "ctrlImprt": self.VVcm7J(self.VVIHf1, "Import 'control' data", self.VVuDfE)
 7585:    elif item == "ctrlField": self.VVC6AO()
 7586:    elif item == "addDep" : self.VV9kEP(self.VVIHf1, fldTitle)
 7587:    elif item == "delDep" : self.VVpbtA(fldTitle)
 7588:    elif item == "pkgNam" : self.VVlbnM()
 7589:    elif item == "delAllRes": self.VVLpXB(ques, 1)
 7590:    elif item == "delInval" : self.VVLpXB(ques, 2)
 7591:    elif item == "delRow" : self.VVJIGU()
 7592:    elif item == "ctrlUndo" : self.VV22s9(self.VVs3Gr)
 7593:    elif item == "projUndo" : self.VV22s9(self.VVHCVG)
 7594:  def VV4RT4(self):
 7595:   Dir = CFG.lastPkgProjDir.getValue()
 7596:   self.session.openWithCallback(self.VVA4iB, BF(CClYaF, mode=CClYaF.VVR977, VV1pbK=Dir, VVIC7J=True))
 7597:  def VVA4iB(self, path):
 7598:   if path:
 7599:    if isinstance(path, list):
 7600:     lines = "\n".join(path)
 7601:     path = path[0]
 7602:    else:
 7603:     lines = path
 7604:    FFjt1c(CFG.lastPkgProjDir, FFx9pN(path, True))
 7605:    self.VVLKxu(lines, 2)
 7606:  @FFOAKH(par=1)
 7607:  def VVusXB(self, VV6A99, title, txt, colList):
 7608:   pkg = colList[0]
 7609:   lst = FF3xOt(r"%s | grep -E '^\/'" % (FF5sZa(VVjZ1L, pkg)))
 7610:   if lst : FFRMYv(self, BF(self.VVTJmT, VV6A99, lst), "Add %s Files/Dirs to project ?" % len(lst), title="Import Control Fields")
 7611:   else : self.VVwTG2("No files/dirs found in package:\n\n%s" % pkg)
 7612:  def VVTJmT(self, VV6A99, lst):
 7613:   VV6A99.cancel()
 7614:   self.VVLKxu("\n".join(lst), 2)
 7615:  def VVuApU(self):
 7616:   Dir = FFx9pN(CFG.lastPkgProjDir.getValue(), False)
 7617:   self.session.openWithCallback(self.VVmcFt, BF(CClYaF, VV1gDA="pkgCtrl", VV1pbK=Dir))
 7618:  def VVmcFt(self, path):
 7619:   if path:
 7620:    FFjt1c(CFG.lastPkgProjDir, path)
 7621:    fName = os.path.basename(path)
 7622:    FFj2hO(self.VVs3Gr)
 7623:    if FFpwZS("cp -f '%s' '%s'" % (path, self.VVNvsj + fName)):
 7624:     self.VVEB1h()
 7625:     self.VVIHf1.VVPkdw({1:"Script", 2:fName})
 7626:  def VV22s9(self, File):
 7627:   if FFpwZS("mv -f '%s.bak' '%s'" % (File, File)):
 7628:    self.VVEB1h()
 7629:   else:
 7630:    self.VVwTG2("Process Failed !")
 7631:  @FFOAKH(par=1)
 7632:  def VVuDfE(self, VV6A99, title, txt, colList):
 7633:   pkg = colList[0]
 7634:   lines = []
 7635:   for line in FF3xOt(FF5sZa(VVaS8u, pkg)):
 7636:    span = iSearch(r"^([A-Z].+):\s*.+", line)
 7637:    if span and span.group(1) in ("Package", "Version", "Depends", "Section", "Architecture", "Maintainer", "Source", "Description"):
 7638:     lines.append(line)
 7639:   if lines: FFRMYv(self, BF(self.VVoueF, VV6A99, lines), "Replace current fields ?", title="Import Control Fields")
 7640:   else : self.VVwTG2("Cannot import from this package:\n\n%s" % pkg)
 7641:  def VVoueF(self, VV6A99, lines):
 7642:   VV6A99.cancel()
 7643:   FFj2hO(self.VVs3Gr)
 7644:   with open(self.VVs3Gr, "w") as f:
 7645:    for line in lines:
 7646:     f.write(line.strip() + "\n")
 7647:   self.VVEB1h(jmpDict={1:"Control", 2:"Package"})
 7648:  def VV0sEJ(self):
 7649:   allRes, invRes, unkRes = [], [], []
 7650:   for ndx, row in enumerate(self.VVIHf1.VVrrm9()):
 7651:    lineNdx, Section, Title, Value, Size, Remarks, ValidF = row
 7652:    if lineNdx.isdigit():
 7653:     if Section == "Resource":
 7654:      allRes.append(int(lineNdx))
 7655:      if not ValidF: invRes.append(int(lineNdx))
 7656:     if Section == "?": unkRes.append(int(lineNdx))
 7657:   allRes.extend(unkRes)
 7658:   invRes.extend(unkRes)
 7659:   return sorted(allRes), sorted(invRes), sorted(unkRes)
 7660:  def VVLpXB(self, ques, mode):
 7661:   allRes, invRes, unkRes = self.VV0sEJ()
 7662:   if   mode == 1: lst = allRes
 7663:   elif mode == 2: lst = invRes
 7664:   if lst : FFRMYv(self, BF(self.VV0On5, lst), "%s ?" % ques, title=self.VVcHUa)
 7665:   else : FF28n1(self.VVIHf1, "Nothing to delete", 2000)
 7666:  def VV0On5(self, ndxLst):
 7667:   if FFCyVu(self.VVHCVG):
 7668:    lines = FFL19l(self.VVHCVG)
 7669:    FFj2hO(self.VVHCVG)
 7670:    with open(self.VVHCVG, "w") as f:
 7671:     for ndx, line in enumerate(lines):
 7672:      if not ndx in ndxLst:
 7673:       f.write("%s\n" % line)
 7674:    self.VVEB1h()
 7675:   else:
 7676:    FF8Wsn(self, self.VVHCVG, title=self.VVcHUa)
 7677:  def VVJIGU(self):
 7678:   lineNdx, Section, Title, Value, Size, Remarks, ValidF = self.VVIHf1.VV5crm()
 7679:   if    Section == "Control" : file = self.VVs3Gr
 7680:   else      : file = self.VVHCVG
 7681:   if Section == "Control" : FFj2hO(self.VVs3Gr)
 7682:   else     : FFj2hO(self.VVHCVG)
 7683:   lineNum = int(self.VVIHf1.VV5crm()[0]) + 1
 7684:   FFpwZS("sed -i .bak -e '%dd' '%s'" % (lineNum, file))
 7685:   self.VVEB1h()
 7686:  def VVLKxu(self, line, jmp):
 7687:   if FFCyVu(self.VVHCVG):
 7688:    FFj2hO(self.VVHCVG)
 7689:    FFJvhj(self.VVHCVG)
 7690:    with open(self.VVHCVG, "a") as f:
 7691:     f.write("%s\n" % line)
 7692:    if   jmp == 1: jmpDict = {1:"Action" , 2:line.split("=")[0]}
 7693:    elif jmp == 2: jmpDict = {1:"Resource" , 3:line.strip().rstrip("/")}
 7694:    else   : jmpDict = None
 7695:    self.VVEB1h(jmpDict=jmpDict)
 7696:   else:
 7697:    FF8Wsn(self, self.VVHCVG, title=self.VVcHUa)
 7698:  def VVKEHB(self, VV6A99, title, txt, colList):
 7699:   VV3wat = []
 7700:   VV3wat.append(FFsLU5("No-Action after installation" , "instNon", self.projAct_postInst != 0))
 7701:   VV3wat.append(FFsLU5("Restart after installation" , "instRes", self.projAct_postInst != 1))
 7702:   VV3wat.append(FFsLU5("Reboot after installation"  , "instReb", self.projAct_postInst != 2))
 7703:   VV3wat.append(VVAL3j)
 7704:   VV3wat.append(FFsLU5("No-Action after removal" , "rmNon", self.projAct_postRm != 0))
 7705:   VV3wat.append(FFsLU5("Restart after removal" , "rmRes", self.projAct_postRm != 1))
 7706:   VV3wat.append(FFsLU5("Reboot after removal"  , "rmReb", self.projAct_postRm != 2))
 7707:   FFLFTC(self, self.VVYw4S, VV3wat=VV3wat, title="Action (after the package is installed/removed)")
 7708:  def VVYw4S(self, item=None):
 7709:   if item:
 7710:    if   item == "instNon" : self.VVmBmf("postinst", 0)
 7711:    elif item == "instRes" : self.VVmBmf("postinst", 1)
 7712:    elif item == "instReb" : self.VVmBmf("postinst", 2)
 7713:    elif item == "rmNon" : self.VVmBmf("postrm", 0)
 7714:    elif item == "rmRes" : self.VVmBmf("postrm", 1)
 7715:    elif item == "rmReb" : self.VVmBmf("postrm", 2)
 7716:  def VVmBmf(self, subj, val):
 7717:   if FFCyVu(self.VVHCVG):
 7718:    lines = FFL19l(self.VVHCVG)
 7719:    FFj2hO(self.VVHCVG)
 7720:   else:
 7721:    lines = []
 7722:   inFile = False
 7723:   with open(self.VVHCVG, "w") as f:
 7724:    for ndx, line in enumerate(lines):
 7725:     line = line.strip()
 7726:     if not iMatch(r"%s\s*=.+" % subj, line, IGNORECASE) : f.write(line + "\n")
 7727:     else            : inFile = True
 7728:   if val > 0: self.VVLKxu("%s=%s" % (subj, {1:"restart", 2:"reboot"}.get(val, "")), 1)
 7729:   elif inFile: self.VVEB1h()
 7730:  def VVlbnM(self):
 7731:   pkg = FFWEt2(self.VVwdtN, r"_").lower()
 7732:   VV3wat = []
 7733:   VV3wat.append((pkg, pkg))
 7734:   VV3wat.append(VVAL3j)
 7735:   for s in ("extensions", "systemplugins", "", "skins", "picons", "softcams", "", "drivers", "security", "settings"):
 7736:    if s:
 7737:     name = "enigma2-plugin-%s-%s" % (s, pkg)
 7738:     c = VVFuwR if name == self.projPkg else ""
 7739:     VV3wat.append((c + name, name))
 7740:    else:
 7741:     VV3wat.append(VVAL3j)
 7742:   FFLFTC(self, self.VVfrko, VV3wat=VV3wat, title="Package Name")
 7743:  def VVfrko(self, item=None):
 7744:   if item:
 7745:    self.VVALN2("Package", item)
 7746:  @FFOAKH(par=1)
 7747:  def VV9kEP(self, VVIHf1, fldTitle):
 7748:   lst = set()
 7749:   for path in CCeSkW.VVrmJV():
 7750:    if FFCyVu(path):
 7751:     with open(path, "r") as f:
 7752:      for line in f:
 7753:       if line.startswith(("Package")):
 7754:        lst.add(line.split(":", 1)[1].strip())
 7755:   if lst:
 7756:    VV3wat = []
 7757:    for item in lst: VV3wat.append((item, item))
 7758:    VV3wat.sort(key=lambda x: x[0].lower())
 7759:    VV7tND = FFLFTC(self, BF(self.VVaSIb, fldTitle), VV3wat=VV3wat, width=1100, title="Add Binary Package")
 7760:    if self.VVj1mD:
 7761:     VV7tND.VVyQ6Y(self.VVj1mD)
 7762:   else:
 7763:    self.VVwTG2("Cannot read dependencies list !")
 7764:  def VVaSIb(self, fldTitle, item=None):
 7765:   if item:
 7766:    lst = []
 7767:    self.VVj1mD = item
 7768:    if FFCyVu(self.VVs3Gr):
 7769:     for line in FFL19l(self.VVs3Gr):
 7770:      line = line.strip()
 7771:      if line.startswith("%s:" % fldTitle):
 7772:       pkgs = line[len(fldTitle) + 1:].strip()
 7773:       if pkgs:
 7774:        lst = list(map(str.strip, pkgs.split(",")))
 7775:       break
 7776:    if not item in lst:
 7777:     lst.append(item)
 7778:     self.VVALN2("%s" % fldTitle, ", ".join(lst))
 7779:    else:
 7780:     FF28n1(self.VVIHf1, "Already added", 1500)
 7781:  def VVpbtA(self, fldTitle):
 7782:   lst = []
 7783:   lineNdx, Section, Title, Value, Size, Remarks, ValidF = self.VVIHf1.VV5crm()
 7784:   lst = list(map(str.strip, Value.split(",")))
 7785:   if lst:
 7786:    VV3wat = []
 7787:    for item in lst: VV3wat.append((item, item))
 7788:    FFLFTC(self, BF(self.VVGDdK, fldTitle, lst), VV3wat=VV3wat, title="Remove Dependency")
 7789:   else:
 7790:    self.VVwTG2("No dependencies to remove !")
 7791:  def VVGDdK(self, fldTitle, lst, item=None):
 7792:   if item:
 7793:    for ndx, dep in enumerate(lst):
 7794:     if dep == item:
 7795:      del lst[ndx]
 7796:      break
 7797:    if lst:
 7798:     self.VVALN2(fldTitle, ", ".join(lst))
 7799:    else:
 7800:     FFj2hO(self.VVs3Gr)
 7801:     FFpwZS("sed -i '/%s:*/d' '%s'" % (fldTitle, self.VVs3Gr))
 7802:     self.VVEB1h(jmpDict={1:"Control", 2:fldTitle})
 7803:  def VVALN2(self, subj, val):
 7804:   lines = FFL19l(self.VVs3Gr) if FFCyVu(self.VVs3Gr) else []
 7805:   inFile = False
 7806:   FFj2hO(self.VVs3Gr)
 7807:   with open(self.VVs3Gr, "w") as f:
 7808:    for ndx, line in enumerate(lines):
 7809:     line = line.strip()
 7810:     if line.startswith(subj + ":"):
 7811:      line = "%s: %s" % (subj, val)
 7812:      inFile = True
 7813:     f.write(line + "\n")
 7814:    if not inFile:
 7815:     f.write("%s: %s\n" % (subj, val))
 7816:   self.VVEB1h(jmpDict={1:"Control", 2:subj})
 7817:  def VVC6AO(self):
 7818:   err, lst = self.VVWetn(3, onlyName=True)
 7819:   if err:
 7820:    self.VVwTG2(err)
 7821:   else:
 7822:    curFields = []
 7823:    for ndx, row in enumerate(self.VVIHf1.VVrrm9()):
 7824:     lineNdx, Section, Title, Value, Size, Remarks, ValidF = row
 7825:     if Section == "Control":
 7826:      curFields.append(Title)
 7827:    lst.sort(key=lambda x: x[0].lower())
 7828:    VV3wat = []
 7829:    for item in lst:
 7830:     if not item[0] in curFields:
 7831:      VV3wat.append((item[0], item[1]))
 7832:    if VV3wat : FFLFTC(self, self.VVzUQ0, VV3wat=VV3wat, title="Control Fields", VVU8mZ=True)
 7833:    else  : self.VVwTG2("All fields are added.")
 7834:  def VVzUQ0(self, item=None):
 7835:   if item:
 7836:    if FFCyVu(self.VVs3Gr):
 7837:     txt, line, ndx = item
 7838:     FFj2hO(self.VVs3Gr)
 7839:     FFJvhj(self.VVs3Gr)
 7840:     with open(self.VVs3Gr, "a") as f:
 7841:      f.write("%s\n" % line)
 7842:     self.VVEB1h(jmpDict={1:"Control", 2:txt})
 7843:    else:
 7844:     FF8Wsn(self, self.VVs3Gr, title=self.VVcHUa)
 7845:  def VVWetn(self, mode, excl="", onlyName=False):
 7846:   path = "%sajpanel_pkg" % VVIp2p
 7847:   if not FFCyVu(path) : return "Missing 'control' Template File !", []
 7848:   elif mode == 0   : return "", []
 7849:   reqLst1, optLst1 , optLst2 = [], [], []
 7850:   for line in FFL19l(path):
 7851:    line = line.strip()
 7852:    if line and not line.startswith("
 7853:     span = iSearch(r"(.{3})(\d):(.+):\s*(.*)", line)
 7854:     if span:
 7855:      typ, seq, name, val = span.group(1), span.group(2), span.group(3), span.group(4)
 7856:      if not excl or excl.startswith("%s:", fld):
 7857:       item = ((name, "%s: %s" %(name, val)))
 7858:       if   typ == "REQ" and seq == "1": reqLst1.append(item)
 7859:       elif typ == "OPT" and seq == "1": optLst1.append(item)
 7860:       elif typ == "OPT" and seq == "2": optLst2.append(item)
 7861:   if   mode == 1: lst = reqLst1
 7862:   elif mode == 2: lst = reqLst1 + optLst1
 7863:   else    : lst = reqLst1 + optLst1 + optLst2
 7864:   return "", lst
 7865:  def VV1QUT(self, VV6A99, title, txt, colList):
 7866:   for ndx, row in enumerate(self.VVIHf1.VVrrm9()):
 7867:    lineNdx, Section, Title, Value, Size, Remarks, ValidF = row
 7868:    if Section == "Control" and Remarks:
 7869:     self.VVIHf1.VVrqBw(ndx)
 7870:     FF28n1(self.VVIHf1, "Check %s\n( %s )" % (Title, FFzBfi(Remarks)), 1500)
 7871:     return
 7872:   VV3wat = []
 7873:   VV3wat.append(("Create .ipk", "ipk"))
 7874:   VV3wat.append(("Create .deb", "deb"))
 7875:   VV3wat.append(VVAL3j)
 7876:   VV3wat.append(("Create .tar.gz  (ignore control files)", "tar"))
 7877:   FFLFTC(self, self.VV41ZX, VV3wat=VV3wat, width=700, title=self.VVcHUa)
 7878:  def VV41ZX(self, typ=None):
 7879:   if typ:
 7880:    fnc = BF(self.VVyMDW, self.VVIHf1, typ)
 7881:    if self.projTotalDirs + self.projTotalFiles > 0:
 7882:     fnc()
 7883:    elif typ == "tar":
 7884:     self.VVwTG2("No Dirs/Files found !\n\nYou need to add at least 1 directory or 1 file to the project !")
 7885:     return
 7886:    else:
 7887:     FFRMYv(self, fnc, "No directories/files included in this package.\n\nContinue ?", title=self.VVcHUa)
 7888:  @FFOAKH(par=1)
 7889:  def VVyMDW(self, VVIHf1, typ):
 7890:   if   not self.projPkg : err = "Package"
 7891:   elif not self.projVer : err = "Version"
 7892:   elif not self.projArch : err = "Architecture"
 7893:   else     : err = ""
 7894:   if err:
 7895:    self.VVwTG2('Parameter "%s" not found !' % err)
 7896:    return
 7897:   pyTxt = ""
 7898:   if typ == "tar":
 7899:    tName, ext, arch = self.VVwdtN, "tar.gz" , ""
 7900:   else:
 7901:    tName, ext, arch = self.projPkg , typ  , "_" + self.projArch
 7902:    if   "py2" in self.VVwdtN.lower() : pyTxt = "_py2"
 7903:    elif "py3" in self.VVwdtN.lower() : pyTxt = "_py3"
 7904:   outFile = "%s%s_%s%s%s.%s" % (FFoUor(), tName, self.projVer, arch, pyTxt, ext)
 7905:   projDir = "/tmp/__%s/" % VVh9hj
 7906:   FFpwZS("rm -rf '%s'"  % projDir)
 7907:   if not typ == "tar":
 7908:    if not FFpwZS("mkdir -p '%s'" % projDir):
 7909:     self.VVwTG2("Cannot create tmp files:\n\n%s" % projDir)
 7910:     return
 7911:   ctrlLst = []
 7912:   resFiles = []
 7913:   for ndx, row in enumerate(self.VVIHf1.VVrrm9()):
 7914:    lineNdx, Section, Title, Value, Size, Remarks, ValidF = row
 7915:    if   Section == "Control": ctrlLst.append("%s: %s" % (Title, Value))
 7916:    elif ValidF     : resFiles.append(Value)
 7917:   if typ == "tar":
 7918:    CCts4c.VVyKy5(self, pType=typ, pName=self.VVwdtN, outFile=outFile, resFiles=resFiles)
 7919:    return
 7920:   cFile = "%scontrol" % projDir
 7921:   try:
 7922:    with open(cFile, "w") as f:
 7923:     for line in ctrlLst:
 7924:      f.write("%s\n" % line)
 7925:   except:
 7926:    self.VVwTG2("Cannot create 'control' file:\n\n%s" % cFile)
 7927:    return
 7928:   fName = ("prerm"     ,"preinst"      ,"postrm"     , "postinst"     )
 7929:   srcF  = (self.VVEvFg  , self.VVQBGg   , self.VVJorQ  , self.VVuB9m  )
 7930:   line  = ("Removing package : xx ...", "Installing Package : xx ..." , "Package removed (xx)." , "Installation completed (xx)" )
 7931:   act   = (0       , 0        , self.projAct_postRm  , self.projAct_postInst   )
 7932:   def VVZwiy(act):
 7933:    if   act == 1: return "echo 'RESTARTING GUI ...'\n%s\n" % CCp90q.VV0los()
 7934:    elif act == 2: return "echo 'REBOOTING DEVICE ...'\nsleep 3; reboot\n"
 7935:    else   : return "echo 'You may need to Restart GUI.'\n"
 7936:   cntrlFiles = [cFile]
 7937:   for fName, srcF, line, act in zip(fName, srcF, line, act):
 7938:    dstF = os.path.join(projDir, fName)
 7939:    cntrlFiles.append(dstF)
 7940:    if FFCyVu(srcF):
 7941:     FFpwZS("cp -f '%s' '%s'" % (srcF, dstF))
 7942:    else:
 7943:     with open(dstF, "w") as f:
 7944:      f.write("#!/bin/bash\n")
 7945:      f.write("echo '%s'\n" % line.replace("xx", self.projPkg))
 7946:      f.write(VVZwiy(act) if srcF in (self.VVuB9m, self.VVJorQ) else "")
 7947:      f.write("exit 0\n")
 7948:   CCts4c.VVyKy5(self, pType=typ, pName=self.VVwdtN, outFile=outFile, cntrlFiles=cntrlFiles, resFiles=resFiles, cbFnc=BF(self.VVfP9s, projDir))
 7949:  def VVfP9s(self, projDir):
 7950:   FFpwZS("rm -rf '%s'"  % projDir)
 7951: class CCxz86(Screen):
 7952:  def __init__(self, session, path, VVyCS0, VVKTL7=False, VVc8YP=False):
 7953:   self.skin, self.VVfOli = FFiNEe(VVlrZA, 510, 510, 30, 0, 0, "#ff000000", "#ff000000", 30, VVU4ws=False)
 7954:   self.session    = session
 7955:   self.Path     = FFoWxR(path)
 7956:   self.VVuolg   = path
 7957:   self.VV6hPq   = ""
 7958:   self.VVZI3n   = ""
 7959:   self.VVyCS0    = VVyCS0
 7960:   self.VVKTL7   = VVKTL7
 7961:   self.VVc8YP   = VVc8YP
 7962:   self.VVHfwN    = ""
 7963:   self.VVcMkC  = ""
 7964:   self.VVXMAG    = False
 7965:   self.VVpnvE  = False
 7966:   self.origPackageName  = ""
 7967:   self.VVdTT5   = 0
 7968:   self.VVW8yV  = "enigma2-plugin-extensions-"
 7969:   self.VVy1b0  = "enigma2-plugin-systemplugins-"
 7970:   self.VVmbMf = "enigma2-"
 7971:   self.VVvd6z  = 0
 7972:   self.VVUbo0  = 1
 7973:   self.VVcz78  = 2
 7974:   self.tbl     = None
 7975:   self.allOk     = False
 7976:   self.grnBtn     = True
 7977:   if VVmJwX(self.Path + "DEBIAN") or VVyCS0 : self.VVtdm0 = "DEBIAN"
 7978:   else           : self.VVtdm0 = "CONTROL"
 7979:   self.controlPath = self.Path + self.VVtdm0
 7980:   self.controlFile = self.controlPath + "/control"
 7981:   self.preinstFile = self.controlPath + "/preinst"
 7982:   self.postinstFile = self.controlPath + "/postinst"
 7983:   self.prermFile  = self.controlPath + "/prerm"
 7984:   self.postrmFile  = self.controlPath + "/postrm"
 7985:   self.newControlPath = ""
 7986:   if VVyCS0 : self.packageExt = ".deb"
 7987:   else  : self.packageExt = ".ipk"
 7988:   self.Title = "Create Package (%s)" % self.packageExt
 7989:   FFZMxC(self)
 7990:   self.onShown.append(self.VV7OzD)
 7991:  def VV7OzD(self):
 7992:   self.onShown.remove(self.VV7OzD)
 7993:   self.VVlHAi()
 7994:  @FFOAKH()
 7995:  def VVlHAi(self):
 7996:   self.VVTNjW(True)
 7997:   self.VVYJMU(True)
 7998:  def VVqL2C(self, state):
 7999:   if self.tbl:
 8000:    if self.grnBtn : self.tbl["keyGreen"].show()
 8001:    else   : self.tbl["keyGreen"].hide()
 8002:  def VVYJMU(self, VVpQCY=False):
 8003:   cLst, pkgName, ok = self.VVFIaW(self.controlFile)
 8004:   self.allOk = ok
 8005:   if not cLst:
 8006:    FFdw58(self, "Cannot read control file:\n\n%s" % self.controlFile, title=self.Title)
 8007:    self.cancel()
 8008:    return
 8009:   if pkgName:
 8010:    txt = ""
 8011:    if self.VVXMAG:
 8012:     if   self.VVKTL7  : txt = "_no_restart"
 8013:     elif not self.VVc8YP : txt = "_no_depends"
 8014:    pkgName = "%s%s%s" % (pkgName, txt, self.packageExt)
 8015:    self.VVZI3n = self.VV6hPq + pkgName
 8016:    self.VVpnvE = True
 8017:    errTxt = ""
 8018:   else:
 8019:    self.VVZI3n  = ""
 8020:    self.VVpnvE = False
 8021:   if VVpQCY:
 8022:    if   pkgName.startswith(self.VVW8yV) : self.VVuolg = VVUytA + self.VVHfwN + "/"
 8023:    elif pkgName.startswith(self.VVy1b0) : self.VVuolg = VVhDOZ + self.VVHfwN + "/"
 8024:    else            : self.VVuolg = self.Path
 8025:   lst = []
 8026:   if self.VVXMAG : fg = "
 8027:   else    : fg = ""
 8028:   bg = "
 8029:   lst.append((bg + "Source Path" , fg + self.Path      , ""))
 8030:   lst.append((bg + "Installation" , fg + "#f#00ffff88#" + self.VVuolg, ""))
 8031:   lst.append((bg + "Package File" , "#f#0000ff00#" + self.VVZI3n  , ""))
 8032:   lst.append((bg + "Control File" , "#f#00777777#" + self.controlFile  , ""))
 8033:   if self.grnBtn:
 8034:    if   self.VVdTT5 == 1: act = "Add commands to %s after installation." % FFjt5L("Restart GUI" , VVz22H)
 8035:    elif self.VVdTT5 == 2: act = "Add commands to %s after installation." % FFjt5L("Reboot Device", VVz22H)
 8036:    else      : act = "No action."
 8037:    lst.append((bg + "Post Install" , bg + act, ""))
 8038:   lst.extend(cLst)
 8039:   if self.tbl:
 8040:    self.tbl.VVMqQ9(lst, isSort=False)
 8041:   elif lst:
 8042:    if self.VVyCS0: bg, typ = "
 8043:    else   : bg, typ = "#0a002a2a", "IPK"
 8044:    VVu8qI = self.VVWIEE
 8045:    VVwWmA = ("Create %s" % typ , self.VVHhAo , [])
 8046:    VVwSzI = ("Post Install"  , self.VVTj6Y , [])
 8047:    VVScQz = ("Installation Path" , self.VV2HEG  , [])
 8048:    VV4QTJ = ("Change Version"  , self.VVOMxR  , [])
 8049:    header  = ("Field" , "Value" , "Remarks" )
 8050:    widths  = (15  , 67  , 18  )
 8051:    self.tbl = FFUQ0v(self, None, title=self.Title, header=header, VVGape=lst, width=1800, height=1000, VV3cHe=widths, VVwdmN=30, VVu8qI=VVu8qI, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVKDPJ=2
 8052:         , VVwltY=bg, VVkxBG=bg, VVemyB=bg
 8053:         , VVbcr0="#00333333", VVJKqd="#06443333", VVX9AA="#0a332244")
 8054:    self.VV168u()
 8055:  def VV168u(self):
 8056:   for ndx, (field, val, rem) in enumerate(self.tbl.VVrrm9()):
 8057:    if rem:
 8058:     self.tbl.VVrqBw(ndx)
 8059:     break
 8060:  def cancel(self):
 8061:   if self.tbl: self.tbl.cancel()
 8062:   self.close()
 8063:  def VVWIEE(self, VV6A99):
 8064:   if self.newControlPath:
 8065:    if self.VVXMAG:
 8066:     self.VVrzU0()
 8067:    else:
 8068:     txt  = "Control Files were created in:\n%s\n\n" % FFjt5L(self.newControlPath, VVA4XU)
 8069:     txt += FFjt5L("Keep these files ?", VV1fx4)
 8070:     FFRMYv(self, self.cancel, txt, callBack_No=self.VVrzU0, title="Create Package", VVAgUy=True)
 8071:   else:
 8072:    self.cancel()
 8073:  def VVrzU0(self):
 8074:   FFpwZS("rm -rf '%s'" % self.newControlPath)
 8075:   self.cancel()
 8076:  def VVFIaW(self, cPath):
 8077:   pkg, ver, dsc, arc = "Package", "Version", "Description", "Architecture"
 8078:   dic = {}
 8079:   for line in FFL19l(cPath):
 8080:    if ":" in line:
 8081:     subj, _, val = line.partition(":")
 8082:     subj, val = subj.strip(), val.strip()
 8083:     if subj: dic[subj] = val
 8084:    elif iMatch(r"^\s+\S", line):
 8085:     line = line.strip()
 8086:     if line and dsc in dic:
 8087:      dic[dsc] = " - ".join((dic[dsc], line))
 8088:   pkgPatt = r"^[a-z]+[a-z0-9+-_.]+$"
 8089:   verPatt = r"^[a-zA-Z0-9_+-.~]*$"
 8090:   lenErr = "Must be > 1 char"
 8091:   frmErr = "Format error"
 8092:   lst = []
 8093:   pName =  pVer = pArc = ""
 8094:   ok = True
 8095:   for subj in (pkg, ver, dsc, arc):
 8096:    val = dic.get(subj, "")
 8097:    err = ""
 8098:    if val:
 8099:     if subj == pkg:
 8100:      pName = val
 8101:      if   len(val) < 2    : err = lenErr
 8102:      elif not iMatch(pkgPatt, val): err = frmErr
 8103:     elif subj == ver:
 8104:      pVer = val
 8105:      if   len(val) < 2    : err = lenErr
 8106:      elif not iMatch(verPatt, val): err = frmErr
 8107:     elif subj == arc:
 8108:      pArc = val
 8109:    else:
 8110:     err = "Missing value"
 8111:    lst.append((subj, val, ("#f#00ff8000#" if err else "") + err))
 8112:    if ok and err:
 8113:     ok = False
 8114:   for k, v in dic.items():
 8115:    if not k in (pkg, ver, dsc, arc):
 8116:     lst.append((k, v, ""))
 8117:   pkgName = ""
 8118:   if all((pName, pVer, pArc)):
 8119:    pkgName = "%s_%s_%s" % (pName, pVer, pArc)
 8120:    pkgName = pkgName.replace(" ", "")
 8121:   return lst, pkgName, ok
 8122:  def VVTNjW(self, VVpQCY):
 8123:   self.VVHfwN   = FFxtW5(self.Path)
 8124:   self.VVHfwN   = "_".join(self.VVHfwN.split())
 8125:   self.VVcMkC = self.VVHfwN.lower()
 8126:   self.VVXMAG = FFlpqQ(self.VVHfwN, self.Path)
 8127:   if self.VVXMAG and self.VVcMkC.endswith(VVXRGG.lower()):
 8128:    self.VVcMkC += "el"
 8129:   if self.VVXMAG : self.VV6hPq = FF0cqc()
 8130:   else    : self.VV6hPq = FFoUor()
 8131:   self.VV6hPq = FFoWxR(self.VV6hPq)
 8132:   if not VVmJwX(self.controlPath):
 8133:    FFpwZS("mkdir '%s'" % self.controlPath)
 8134:    self.newControlPath = self.controlPath
 8135:   else:
 8136:    self.newControlPath = ""
 8137:   mode = self.VVQWPv()
 8138:   if FFCyVu(self.controlFile):
 8139:    lines = FFL19l(self.controlFile)
 8140:    for line in lines:
 8141:     if line.strip().startswith("Package") and line.count(":") == 1:
 8142:      self.origPackageName = line.split(":")[1].strip()
 8143:      break
 8144:   else:
 8145:    if self.VVXMAG : version, description, maintainer = VVJ6zn , VVzOp7, "AMAJamry - " + CCJaSw.VVCcoN()
 8146:    else    : version, description, maintainer = "v1.0"   , self.VVHfwN , self.VVHfwN
 8147:    txt = ""
 8148:    txt += "Package: %s\n"  % self.VVSZM1(mode)
 8149:    txt += "Version: %s\n"  % version
 8150:    txt += "Description: %s\n" % description
 8151:    txt += "Maintainer: %s\n" % maintainer
 8152:    txt += "Architecture: all\n"
 8153:    txt += "Priority: optional\n"
 8154:    txt += "Section: base\n"
 8155:    txt += ("Homepage: %s\n" % CCJaSw.VVCcoN()) if self.VVXMAG else ""
 8156:    if self.VVXMAG and self.VVc8YP:
 8157:     txt += "Recommends: xz (>= 5), zip, p7zip, unrar, bzip2, ffmpeg, python-requests | python3-requests, python-imaging | python3-pillow, ar (>= 2) | enigma2-plugin-extensions-opkg-tools | binutils\n"
 8158:    with open(self.controlFile, "w") as f:
 8159:     f.write(txt)
 8160:   if self.VVXMAG : t = VVh9hj
 8161:   else    : t = self.VVHfwN
 8162:   self.VVIJmH(self.prermFile, "echo 'Removing package : %s ...'\n" % t)
 8163:   if self.VVXMAG : txt = (r'find %s \( -name "*.pyo" -o -name "*.pyc" \) -type f -delete' % self.Path) + "\n"
 8164:   else    : txt = ""
 8165:   self.VVIJmH(self.postrmFile, txt + "echo 'Package removed.'\n")
 8166:   if self.VVXMAG : self.VVIJmH(self.preinstFile, "echo 'Installing %s (%s) ...'\n" % (VVh9hj, VVJ6zn))
 8167:   else    : self.VVIJmH(self.preinstFile, "echo 'Installing Package : %s ...'\n" % self.VVHfwN)
 8168:   if VVpQCY and not mode == self.VVvd6z:
 8169:    self.VVdTT5 = 1
 8170:   txt = self.VV7CfH(0 if self.VVKTL7 else self.VVdTT5)
 8171:   canChange = True
 8172:   self.grnBtn = True
 8173:   if FFCyVu(self.postinstFile):
 8174:    fText = FFYVq0(self.postinstFile).strip()
 8175:    if txt.strip() == fText:
 8176:     canChange = False
 8177:    else:
 8178:     for action in range(3):
 8179:      if fText.strip() == self.VV7CfH(action).strip():
 8180:       break
 8181:     else:
 8182:      canChange = False
 8183:      self.grnBtn = False
 8184:   if canChange:
 8185:    with open(self.postinstFile, "w") as f:
 8186:     f.write(txt)
 8187:   FFpwZS("chmod 755 '%s' '%s' '%s' '%s' " % (self.preinstFile, self.postinstFile, self.prermFile, self.postrmFile))
 8188:  def VVIJmH(self, path, lines):
 8189:   if not FFCyVu(path):
 8190:    with open(path, "w") as f:
 8191:     f.write("#!/bin/bash\n")
 8192:     f.write(lines)
 8193:     f.write("exit 0\n")
 8194:  def VV7CfH(self, action):
 8195:   sep  = "echo '%s'\n" % SEP
 8196:   txt = "#!/bin/bash\n" + sep
 8197:   if action == 0:
 8198:    txt += "echo '--- FINISHED ---'\n"
 8199:    txt += sep
 8200:    txt += "echo 'You may need to Restart GUI.'\n"
 8201:   elif action == 1:
 8202:    txt += "echo 'RESTARTING GUI ...'\n"
 8203:    txt += sep
 8204:    txt += "%s\n" % CCp90q.VV0los()
 8205:   elif action == 2:
 8206:    txt += "echo 'REBOOTING DEVICE ...'\n"
 8207:    txt += sep
 8208:    txt += "sleep 3; reboot\n"
 8209:   else:
 8210:    return ""
 8211:   txt += "exit 0\n"
 8212:   return txt
 8213:  def VVTj6Y(self, VV6A99, title, txt, colList):
 8214:   if self.tbl["keyGreen"].getVisible():
 8215:    VV3wat = []
 8216:    VV3wat.append(("No Action" , "noAction" ))
 8217:    VV3wat.append(("Restart GUI" , "VV9qqT" ))
 8218:    VV3wat.append(("Reboot Device", "rebootDev" ))
 8219:    FFLFTC(self, self.VVJNdj, title="Package Installation Option (after completing installation)", VV3wat=VV3wat)
 8220:  def VVJNdj(self, item=None):
 8221:   if item is not None:
 8222:    if   item == "noAction"  : self.VVdTT5 = 0
 8223:    elif item == "VV9qqT" : self.VVdTT5 = 1
 8224:    elif item == "rebootDev" : self.VVdTT5 = 2
 8225:    self.VVTNjW(False)
 8226:    self.VVYJMU()
 8227:  def VV2HEG(self, VV6A99, title, txt, colList):
 8228:   rootPath = FFjt5L("/%s/" % self.VVHfwN, VVFuwR)
 8229:   VV3wat = []
 8230:   VV3wat.append(("Current Path"       , "toCurrent"  ))
 8231:   VV3wat.append(VVAL3j)
 8232:   VV3wat.append(FFsLU5("Extension Path"   , "toExtensions" , not self.VVuolg.startswith(VVUytA)))
 8233:   VV3wat.append(FFsLU5("System Plugins Path"  , "toSystemPlugins" , not self.VVuolg.startswith(VVhDOZ)))
 8234:   VV3wat.append(VVAL3j)
 8235:   VV3wat.append(("Package Name in Root : %s" % rootPath , "toRootPath"  ))
 8236:   VV3wat.append(('Root "/"'        , "toRoot"   ))
 8237:   VV3wat.append(VVAL3j)
 8238:   VV3wat.append(("Pick Path with File Manager ..."  , "toOthers"  ))
 8239:   FFLFTC(self, self.VVjWlA, title="Installation Path", VV3wat=VV3wat)
 8240:  def VVjWlA(self, item=None):
 8241:   if item is not None:
 8242:    if   item == "toCurrent"  : self.VVO0Ka(FFx9pN(self.Path, True))
 8243:    elif item == "toExtensions"  : self.VVO0Ka(VVUytA)
 8244:    elif item == "toSystemPlugins" : self.VVO0Ka(VVhDOZ)
 8245:    elif item == "toRootPath"  : self.VVO0Ka("/")
 8246:    elif item == "toRoot"   : self.VVO0Ka("/", False)
 8247:    elif item == "toOthers"   : self.session.openWithCallback(self.VV67SG, BF(CClYaF, mode=CClYaF.VV9N82, VV1pbK=FF0cqc()))
 8248:  def VV67SG(self, path):
 8249:   if len(path) > 0:
 8250:    self.VVO0Ka(path)
 8251:  def VVO0Ka(self, parent, withPackageName=True):
 8252:   if withPackageName : self.VVuolg = parent + self.VVHfwN + "/"
 8253:   else    : self.VVuolg = "/"
 8254:   mode = self.VVQWPv()
 8255:   FFpwZS(r"sed -i '/Package/c\Package: %s' %s" % (self.VVSZM1(mode), self.controlFile))
 8256:   self.VVYJMU()
 8257:  def VVOMxR(self, VV6A99, title, txt, colList):
 8258:   if FFCyVu(self.controlFile):
 8259:    lines = FFL19l(self.controlFile)
 8260:    version = ""
 8261:    for line in lines:
 8262:     if ":" in line:
 8263:      parts = line.split(":")
 8264:      key  = parts[0].strip()
 8265:      val  = parts[1].strip()
 8266:      if key == "Version":
 8267:       version = val
 8268:       break
 8269:    if version : FF4z45(self, self.VV1vpN, title="Change Package Version", defaultText=version, message="Enter Version:")
 8270:    else  : FFdw58(self, "Version not found or incorrectly set !")
 8271:   else:
 8272:    FF8Wsn(self, self.controlFile)
 8273:  def VV1vpN(self, VVRD20):
 8274:   if VVRD20:
 8275:    version, color = self.VVIuvk(VVRD20, False)
 8276:    if color == VVGCYL:
 8277:     FFpwZS(r"sed -i '/Version:/c\Version: %s' %s" % (VVRD20, self.controlFile))
 8278:     self.VVYJMU()
 8279:    else:
 8280:     FFdw58(self, "Incorrect Version Syntax !\n\nAllowed characters : letter, digits and _+-.~")
 8281:  def VVSZM1(self, mode):
 8282:   prefix, name = "", ""
 8283:   package = self.origPackageName or self.VVcMkC
 8284:   if package.startswith(self.VVmbMf):
 8285:    span = iSearch(r"(.+-)(.+)", package)
 8286:    if span:
 8287:     prefix, name = span.group(1).strip(), span.group(2)
 8288:   if not name:
 8289:    prefix, name = self.VVmbMf, package
 8290:   prefix = iSub(r"([^a-z0-9+-.]+)", r"-", prefix)
 8291:   name = iSub(r"([^a-z0-9+-.]+)", r"-", name)
 8292:   if   mode == self.VVUbo0 : prefix = self.VVW8yV
 8293:   elif mode == self.VVcz78 : prefix = self.VVy1b0
 8294:   return (prefix + name).lower()
 8295:  def VVQWPv(self):
 8296:   if   self.VVuolg.startswith(VVUytA) : return self.VVUbo0
 8297:   elif self.VVuolg.startswith(VVhDOZ) : return self.VVcz78
 8298:   else            : return self.VVvd6z
 8299:  def VVIuvk(self, val, isPackage):
 8300:   if   isPackage : pattern = r"^[a-z]+[a-z0-9+-_.]+$"
 8301:   else   : pattern = r"^[a-zA-Z0-9_+-.~]*$"
 8302:   if iMatch(pattern, val) and len(val) >= 2 : return val, VVGCYL
 8303:   else          : return val, VVYjI5
 8304:  def VVHhAo(self, VV6A99, title, txt, colList):
 8305:   if not self.VVpnvE:
 8306:    FFdw58(self, "Please fix Control File errors first.")
 8307:    return
 8308:   obfVars = obfErr = None
 8309:   if self.VVXMAG:
 8310:    obfVars, obfErr = self.VVcs8G()
 8311:   parent  = FFx9pN(self.VVuolg, True)
 8312:   newPath  = parent[1:]
 8313:   symlink  = parent[1:] + self.VVHfwN
 8314:   symlinkTo = FFVc4H(self.Path)
 8315:   instPathInfo=  (self.VVuolg, parent, newPath, symlink, symlinkTo)
 8316:   pType  = "deb" if self.VVyCS0 else "ipk"
 8317:   pName  = self.VVHfwN
 8318:   outFile  = self.VVZI3n
 8319:   resFiles = [self.Path]
 8320:   cntrlFiles = [self.controlFile]
 8321:   for f in (self.preinstFile, self.postinstFile, self.prermFile, self.postrmFile):
 8322:    if FFCyVu(f):
 8323:     cntrlFiles.append(f)
 8324:   CCts4c.VVyKy5(self, pType=pType, pName=pName, outFile=outFile, cntrlFiles=cntrlFiles, resFiles=resFiles, instPathInfo=instPathInfo, cbFnc=BF(self.VVvwIL, obfVars, obfErr))
 8325:  def VVvwIL(self, obfVars, obfErr):
 8326:   if obfVars:
 8327:    err = obfErr
 8328:    if not err:
 8329:     myP, obfP = obfVars
 8330:     if not FFpwZS("mv -f '%splugin.py' '%s'" % (obfP, myP)): err = "Cannot restore plug"
 8331:     if not FFpwZS("mv -f '%smain.py' '%s'" % (obfP, myP)): err = "Cannot restore main"
 8332:    if err:
 8333:     FFdw58(self, err, title="OBF Error")
 8334:  def VVcs8G(self):
 8335:   myP  = VV231J
 8336:   obfP = "%sOBF/" % VV231J
 8337:   plug = "%splugin.py" % myP
 8338:   main = "%smain.py" % myP
 8339:   lst  = iGlob("%s*main_final.py" % obfP)
 8340:   obfVars = (myP, obfP)
 8341:   if not VVmJwX(obfP) : return obfVars, "No OBF Dir"
 8342:   if not len(lst) == 1 : return obfVars, "No OBF File"
 8343:   if not FFCyVu(plug) : return obfVars, "No plug File"
 8344:   if not FFCyVu(main) : return obfVars, "No main File"
 8345:   if not FFpwZS("cp -f '%s' '%s' '%s'" % (plug, main, obfP)) : return obfVars, "Cannot copy to OBF"
 8346:   if not FFpwZS("cp -f %s*main_final.py '%s'" % (obfP, plug)): return obfVars, "Cannot OBF to main"
 8347:   if not FFpwZS("rm -f '%s'" % main)       : return obfVars, "Cannot del main"
 8348:   return obfVars, ""
 8349: class CCts4c(Screen):
 8350:  def __init__(self, session, title="", pType="", pName="", outFile="", cntrlFiles="", resFiles=None, instPathInfo="", cbFnc=None):
 8351:   self.skin, self.VVfOli = FFiNEe(VVmSQ6, 1400, 900, 50, 30, 20, "
 8352:   self.session   = session
 8353:   self.Title    = title or "Package Maker (%s)" % pName
 8354:   self.pType    = pType
 8355:   self.pName    = pName
 8356:   self.outFile   = outFile
 8357:   self.cntrlFiles   = cntrlFiles
 8358:   self.resFiles   = resFiles
 8359:   self.instPathInfo  = instPathInfo
 8360:   self.cbFnc    = cbFnc
 8361:   if pType == "deb": self.tarParam, self.tarExt = "-cJf", ".tar.xz"
 8362:   else    : self.tarParam, self.tarExt = "-czf", ".tar.gz"
 8363:   self.isTar    = pType == "tar"
 8364:   self.totalObj   = len(resFiles)
 8365:   self.VVRhqH = "packaging_result"
 8366:   self.tmpDir    = "/tmp/_%s/" % VVh9hj
 8367:   self.dataDir   = self.tmpDir + "DATA/"
 8368:   self.controlDir   = self.tmpDir + "CONTROL/"
 8369:   self.debBinFile   = self.tmpDir + "debian-binary"
 8370:   self.controlFile  = self.tmpDir + "control" + self.tarExt
 8371:   self.resLstFile   = self.tmpDir + "resLst"
 8372:   self.allInRoot   = False
 8373:   self.VVuolg  = ""
 8374:   FFZMxC(self, self.Title, addScrollLabel=True)
 8375:   FFBep1(self, { "ok": self.VV0awf })
 8376:   self.onShown.append(self.VV7OzD)
 8377:  def VV7OzD(self):
 8378:   self.onShown.remove(self.VV7OzD)
 8379:   self["myLabel"].VV5kEH(VVRhqH=self.VVRhqH)
 8380:   self["myLabel"].appendText("Process started ...")
 8381:   FFIElK(self.VVv7Ck)
 8382:  def VV0awf(self):
 8383:   pass
 8384:  def VVDiQh(self, txt):
 8385:   self["myLabel"].appendText(txt + "\n")
 8386:  def VVq36d(self, txt="FAILED"):
 8387:   self.VVDiQh(FFjt5L("\n%s\n\nProcess Stopped !" % txt, VVz22H))
 8388:   self.VVBB9M()
 8389:  def VVBB9M(self):
 8390:   self.VVcECy()
 8391:   if self.cbFnc:
 8392:    self.cbFnc()
 8393:  def VVcECy(self, txt="FAILED"):
 8394:   FFpwZS("rm -rf '%s'"  % self.tmpDir)
 8395:  def VVv7Ck(self):
 8396:   self.VVDiQh("Checking Resources ...")
 8397:   if self.totalObj > 1:
 8398:    self.resFiles, dirLst, filLst, errLst, mntLst, rmDirLst, totDuplDir, totDuplFil = CCts4c.VVm09O(self.resFiles)
 8399:    txt = ".. Valid Resources List\t: %s\n" % len(self.resFiles)
 8400:    if errLst  : txt += ".. Invalid Files/Dirs\t: %s\n... %s\n" % (len(errLst), FFjt5L("\n... ".join(errLst), VVo7S9, VVA4XU))
 8401:    if totDuplDir : txt += ".. Removed Duplicate Dirs\t: %s\n"  % totDuplDir
 8402:    if totDuplFil : txt += ".. Removed Duplicate File\t: %s\n"  % totDuplFil
 8403:    if mntLst  : txt += ".. Removed Mount Paths\t: %s\n"   % len(mntLst)
 8404:    if rmDirLst  : txt += ".. Ignored dirs (child listed)\t: %s" % len(rmDirLst)
 8405:    self.VVDiQh(FFjt5L(txt.rstrip("\n"), VVA4XU))
 8406:    if not self.resFiles:
 8407:     self.VVq36d("No valid resources")
 8408:     return
 8409:   elif self.totalObj == 1 and not FFCyVu(self.resFiles[0]):
 8410:    self.VVq36d("Invalid or unreachable file/dir:\n%s" % self.resFiles[0])
 8411:    return
 8412:   self.VVcECy()
 8413:   FFwgGB(self.outFile)
 8414:   self.VVDiQh("Creating working dirs ...")
 8415:   if not FFpwZS("mkdir -p '%s'"  % self.tmpDir):
 8416:    self.VVq36d("Cannot create working dir.")
 8417:    return
 8418:   if not self.isTar:
 8419:    if not FFpwZS("mkdir -p '%s'" % self.controlDir):
 8420:     self.VVq36d("Cannot create /tmp/ dir.")
 8421:     return
 8422:    if self.instPathInfo:
 8423:     VVuolg, parent, newPath, symlink, symlinkTo = self.instPathInfo
 8424:     newPath  = self.dataDir + newPath
 8425:     symlink  = self.dataDir + symlink
 8426:     symlinkTo = symlinkTo
 8427:     self.allInRoot = VVuolg == "/"
 8428:     self.VVuolg = VVuolg.rstrip("/")
 8429:     if not FFpwZS("mkdir -p '%s'" % newPath):
 8430:      self.VVq36d("Cannot create full path.")
 8431:      return
 8432:     if not FFpwZS("ln -sf '%s' '%s';" % (symlinkTo, symlink)):
 8433:      self.VVq36d("Cannot create resources link.")
 8434:      return
 8435:    self.VVDiQh("Creating debian-binary file ...")
 8436:    if not FF7ymp("echo '2.0' > '%s'" % self.debBinFile):
 8437:     self.VVq36d("Cannot create bin file.")
 8438:     return
 8439:    lst = self.cntrlFiles
 8440:    for f in lst:
 8441:     if not FFpwZS("cp -f '%s' '%s'" % (f, self.controlDir)):
 8442:      self.VVq36d("Cannot read file:\n%s" % f)
 8443:      return
 8444:     newF = os.path.join(self.controlDir, os.path.basename(f))
 8445:     FFJvhj(newF)
 8446:     if not FFpwZS("chmod 755 '%s'" % newF):
 8447:      self.VVq36d("Cannot chmod file:\n%s" % newF)
 8448:      return
 8449:    self.VVDiQh("Archiving control files ...")
 8450:    cmd  = "cd '%s';" % self.controlDir
 8451:    cmd += "tar %s '%s' ./*;" % (self.tarParam, self.controlFile)
 8452:    if not FFpwZS(cmd):
 8453:     self.VVq36d("Cannot archive control files.")
 8454:     return
 8455:   self.VVDiQh("Archiving data files ...")
 8456:   if self.totalObj > 1:
 8457:    self.resFiles.sort(key=lambda x: x[0].lower())
 8458:    with open(self.resLstFile, "w") as resF:
 8459:     for item in self.resFiles:
 8460:      item = item.lstrip("/")
 8461:      if item:
 8462:       resF.write("%s\n" % item)
 8463:   FFIElK(self.VVze04)
 8464:  def VVze04(self):
 8465:   if self.isTar: dataFile = self.outFile
 8466:   else   : dataFile = self.tmpDir + "data" + self.tarExt
 8467:   tarExclude = "--exclude CONTROL --exclude DEBIAN --exclude __pycache__"
 8468:   if FFlpqQ(self.pName, self.outFile):
 8469:    tarExclude += " --exclude OBF --exclude *.pyo --exclude *.pyc"
 8470:   if self.instPathInfo:
 8471:    self.tarParam = self.tarParam.replace("-c", "-ch")
 8472:    cmd = "cd '%s';" % self.dataDir
 8473:    if self.allInRoot:
 8474:     cmd += "tar -C '%s' %s %s '%s' ./" % (self.resFiles[0], tarExclude, self.tarParam, dataFile)
 8475:    else:
 8476:     cmd += "tar %s %s '%s' '.%s'" % (tarExclude, self.tarParam, dataFile, self.VVuolg)
 8477:   else:
 8478:    if self.totalObj > 1:
 8479:     cmd = "tar -C / %s %s '%s' -T '%s'" % (tarExclude, self.tarParam, dataFile, self.resLstFile)
 8480:    elif self.totalObj == 1:
 8481:     cmd = "tar -C / %s %s '%s' '%s'" % (tarExclude, self.tarParam, dataFile, self.resFiles[0].lstrip("/"))
 8482:    else:
 8483:     cmd = ""
 8484:   if cmd:
 8485:    resp = FF3xOt(cmd)
 8486:    if resp:
 8487:     self.VVq36d(FFjt5L("\n".join(resp), VVyFI2, VVz22H))
 8488:     return
 8489:   else:
 8490:    if not FFpwZS("cp -f '%sdata%s' '%s'" % (VVIp2p, self.tarExt, self.tmpDir)):
 8491:     self.VVq36d("Cannot copy temporary data.%s" % self.tarExt)
 8492:     return
 8493:   if not self.isTar:
 8494:    self.VVDiQh("Creating %s ..." % self.pType.upper())
 8495:    arResp = FF3xOt("ar -r '%s' '%s' '%s' '%s';" % (self.outFile, self.debBinFile, self.controlFile, dataFile))
 8496:    if len(arResp) > 1 or not FFCyVu(self.outFile):
 8497:     self.VVq36d(FFjt5L("\n".join(arResp), VVyFI2, VVz22H))
 8498:     return
 8499:   self.VVBB9M()
 8500:   self.VVDiQh("Done.\n\nResult:\n%s\n" % FFjt5L(self.outFile, VVSGsk))
 8501:  @staticmethod
 8502:  def VVm09O(lst):
 8503:   lines = list(map(str.strip, lst))
 8504:   cleanLst, dirLst, filLst, errLst, mntLst, rmDirLst = [], [], [], [], [], []
 8505:   for item in lst:
 8506:    item = item.strip()
 8507:    if   os.path.ismount(item) : mntLst.append(item)
 8508:    elif os.path.isdir(item) : dirLst.append(FFoWxR(item))
 8509:    elif os.path.isfile(item) : filLst.append(item)
 8510:    else       : errLst.append(item)
 8511:   totDir = len(dirLst)
 8512:   dirLst = list(set(dirLst))
 8513:   totDuplDir = totDir - len(dirLst)
 8514:   totFil = len(filLst)
 8515:   filLst = list(set(filLst))
 8516:   totDuplFil = totFil - len(filLst)
 8517:   cleanLst.extend(list(set(filLst)))
 8518:   for tDir in dirLst:
 8519:    for fil in cleanLst:
 8520:     if fil.startswith(tDir):
 8521:      rmDirLst.append(tDir)
 8522:      break
 8523:    else:
 8524:     cleanLst.append(tDir)
 8525:   cleanLst.sort(key=lambda x: x.lower())
 8526:   return cleanLst, dirLst, filLst, errLst, mntLst, rmDirLst, totDuplDir, totDuplFil
 8527:  @staticmethod
 8528:  def VVyKy5(SELF, **kwargs):
 8529:   if CCeSkW.VVq71e(SELF):
 8530:    SELF.session.open(CCts4c, **kwargs)
 8531: class CCeSkW(Screen, CCEzue):
 8532:  def __init__(self, session):
 8533:   self.skin, self.VVfOli = FFiNEe(VVWp3I, 850, 900, 50, 40, 30, "#221a001a", "#22110011", 30)
 8534:   self.session   = session
 8535:   self.lastListAllRow  = -1
 8536:   self.lastRemoveAllRow = -1
 8537:   self.lastRemoveExtRow = -1
 8538:   self.lastPickedRow  = -1
 8539:   self.holdPkgColor  = "#f#00ff8800#"
 8540:   self.instPkgColor  = "#f#0000ff00#"
 8541:   CCEzue.__init__(self)
 8542:   c1, c2, c3, c4 = VVJEMb, VVZtfx, VVIH76, VVFuwR
 8543:   VV3wat = []
 8544:   VV3wat.append((c1 + "Plugins Browser"        , "pluginsBrowser"   ))
 8545:   VV3wat.append(VVAL3j)
 8546:   VV3wat.append((c2 + "Download/Install Packages (from feeds)"  , "downloadInstallPackages" ))
 8547:   VV3wat.append(VVAL3j)
 8548:   VV3wat.append((c3 + "Remove Packages (show all)"     , "VVlXsDsAll"  ))
 8549:   VV3wat.append((c3 + "Remove Packages (Plugins/SoftCams/Skins)" , "removePluginSkinSoftCAM" ))
 8550:   VV3wat.append(VVAL3j)
 8551:   VV3wat.append((c2 + "Update Packages List from Feeds"    , "VV3sSc"  ))
 8552:   VV3wat.append((c2 + "Upgradable Packages"       , "VVgIEp" ))
 8553:   VV3wat.append(VVAL3j)
 8554:   VV3wat.append((c4 + "Package Creator (ipk/deb/tar)"    , "packageCreator"   ))
 8555:   VV3wat.append(VVAL3j)
 8556:   VV3wat.append((c4 + "Generate Packages.gz (from ipk/deb directory)", "VVtB0a"  ))
 8557:   VV3wat.append(VVAL3j)
 8558:   VV3wat.append(("Packaging Tool"         , "VV5EzU"   ))
 8559:   VV3wat.append(("Active Feeds"          , "VV4p0x"   ))
 8560:   FFZMxC(self, title="Plugins Tools", VV3wat=VV3wat)
 8561:   self.onShown.append(self.VV7OzD)
 8562:  def VV7OzD(self):
 8563:   self.onShown.remove(self.VV7OzD)
 8564:   FF4IPF(self["myMenu"])
 8565:   FF2GM8(self)
 8566:  def VVPr1F(self):
 8567:   item = FFTmHZ(self)
 8568:   if item is not None:
 8569:    if   item == "pluginsBrowser"    : CCFZr4.VVsCNi(self.session)
 8570:    elif item == "downloadInstallPackages"  : FFimQ3(self, BF(self.VV3v9Q, 0))
 8571:    elif item == "VVlXsDsAll"   : FFimQ3(self, BF(self.VV3v9Q, 1))
 8572:    elif item == "removePluginSkinSoftCAM"    : FFimQ3(self, BF(self.VV3v9Q, 2))
 8573:    elif item == "VV3sSc"   : CCeSkW.VV3sSc(self)
 8574:    elif item == "VVgIEp"  : self.VVgIEp()
 8575:    elif item == "packageCreator"    : self.VV37Fz()
 8576:    elif item == "VVtB0a"   : self.VVtB0a()
 8577:    elif item == "VV5EzU"    : self.VV5EzU()
 8578:    elif item == "VV4p0x"    : self.VV4p0x()
 8579:    else          : self.close()
 8580:  @FFOAKH()
 8581:  def VV4p0x(self):
 8582:   VVAkuK = []
 8583:   totAll = 0
 8584:   for path in CCeSkW.VVrmJV():
 8585:    tot = 0
 8586:    with open(path, "r") as f:
 8587:     for line in f:
 8588:      if line.startswith("Package"):
 8589:       tot += 1
 8590:       totAll += 1
 8591:    if tot:
 8592:     VVAkuK.append((os.path.basename(path), str(tot)))
 8593:   if VVAkuK:
 8594:    VVW5y5 = "Total Packages = %s" % totAll
 8595:    VVAkuK.sort(key=lambda x: x[0].lower())
 8596:    header  = ("Feed","Packages")
 8597:    widths  = (82  , 18  )
 8598:    VVLIqP = (LEFT  , CENTER )
 8599:    FFUQ0v(self, None, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, width=1000, VVwdmN=26, VVW5y5=VVW5y5, VVKDPJ=2)
 8600:   else:
 8601:    self.VVwTG2("Cannot read packages list !")
 8602:  def VVgIEp(self, VV6A99=None):
 8603:   FFimQ3(VV6A99 or self, BF(self.VVaCeD, VV6A99))
 8604:  def VVaCeD(self, VV6A99):
 8605:   fLst, feedDic, instDic = self.VVLY1Q()
 8606:   lst = set()
 8607:   for pkg, (ver, dsc, inst, hold) in instDic.items():
 8608:    if pkg in feedDic:
 8609:     ver1, dsc1, inst1, hold1 = feedDic[pkg]
 8610:     if CCeSkW.VVohK9(ver, ver1) < 0:
 8611:      if hold : hold, c1 = "Yes", self.holdPkgColor
 8612:      else : hold = c1 = ""
 8613:      lst.add((c1 + pkg, c1 + ver, c1 + ver1, c1 + hold))
 8614:   if lst:
 8615:    VVAkuK = list(lst)
 8616:    VVAkuK.sort(key=lambda x: FFd1WZ(x[0]).lower())
 8617:    if VV6A99:
 8618:     VV6A99.VVMqQ9(VVAkuK, isSort=False)
 8619:    else:
 8620:     bg = "
 8621:     VVwSzI = ("Upgrade"  , self.VVGNBx   , [])
 8622:     VVScQz = ("Package Info." , self.VVU1Iy    , [])
 8623:     VV4QTJ = ("Hold Update" , self.VVv7u0 , [])
 8624:     header  = ("Package", "Current Version" , "New Version" , "Hold Upd." )
 8625:     widths  = ( 40  , 25    , 25   , 10   )
 8626:     VVLIqP = ( LEFT , LEFT    , LEFT   , CENTER  )
 8627:     tbl = FFUQ0v(self, None, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, width=1700, VVwdmN=26, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVSLOq=CFG.lastFindPackages, VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#00114455")
 8628:     tbl.VVIOX6(BF(self.VVhLnz, tbl))
 8629:   else:
 8630:    FFjADj(self, "Nothing to upgrade", 1500)
 8631:    if VV6A99: VV6A99.cancel()
 8632:  def VVGNBx(self, VV6A99, title, txt, colList):
 8633:   pkg, curV, newVer, holdState = VV6A99.VV5crm()
 8634:   if holdState:
 8635:    FF28n1(VV6A99, "Change Hold State first", 1000)
 8636:   else:
 8637:    cmd = FF5sZa(VVwFAi, pkg)
 8638:    FFbi5l(self, cmd, title="Installing : %s" % pkg, VVoasw=BF(self.VVgIEp, VV6A99))
 8639:  @FFOAKH(par=1)
 8640:  def VVv7u0(self, VV6A99, title, txt, colList):
 8641:   pkg, curV, newVer, holdState = VV6A99.VV5crm()
 8642:   cmd = FF5sZa(VVw6qo if holdState else VVofV3, pkg)
 8643:   FFpwZS(cmd)
 8644:   holdLst = self.VVhDfd(pkg)
 8645:   holdState = c1 = ""
 8646:   if len(holdLst) == 1 and holdLst[0][0] == pkg:
 8647:    holdState, c1 = "Yes", self.holdPkgColor
 8648:   VV6A99.VViSLW((c1 + pkg, c1 + curV, c1 + newVer, c1 + holdState))
 8649:   self.VVhLnz(VV6A99)
 8650:  def VVhLnz(self, VV6A99):
 8651:   pkg, curV, newVer, holdState = VV6A99.VV5crm()
 8652:   VV6A99["keyBlue"].setText("%s Update" % ("Allow" if holdState else "Hold"))
 8653:  def VVtB0a(self):
 8654:   if CCeSkW.VVq71e(self):
 8655:    self.session.openWithCallback(self.VVKCPV, BF(CClYaF, mode=CClYaF.VV9N82, VV1pbK=CFG.lastFeedPkgsDir.getValue()))
 8656:  @FFOAKH()
 8657:  def VVKCPV(self, path):
 8658:   title = "Feed Packages.gz Creator"
 8659:   if len(path) > 0:
 8660:    FFjt1c(CFG.lastFeedPkgsDir, path)
 8661:    files = []
 8662:    lst = iGlob(path + "*.ipk")
 8663:    totIpk = len(lst)
 8664:    for f in lst:
 8665:     files.append(os.path.basename(f))
 8666:    lst = iGlob(path + "*.deb")
 8667:    totDeb = len(lst)
 8668:    for f in lst:
 8669:     files.append(os.path.basename(f))
 8670:    lst = None
 8671:    if len(files) > 0:
 8672:     files.sort(key=lambda x: x[0].lower())
 8673:    else:
 8674:     FFdw58(self, "No ipk/deb files found in:\n\n%s" % path)
 8675:     return
 8676:    pFile = os.path.join(path, "Packages")
 8677:    gFile = "%s.gz" % pFile
 8678:    tFile = os.path.join(path, "Packages.stamps")
 8679:    with open(pFile, "w") as pF:
 8680:     with open(tFile, "w") as tF:
 8681:      for fName in files:
 8682:       fPath = os.path.join(path, fName)
 8683:       txt, mTime = CCeSkW.VVy0xB(fPath)
 8684:       pF.write("%s\n" % txt)
 8685:       tF.write("%s\n" % mTime)
 8686:    FFwgGB(gFile)
 8687:    os.system("gzip -k '%s'" % pFile)
 8688:    c = VVJEMb
 8689:    txt  = "%s: %s\n" % (FFjt5L("Processed Files:", c), len(files))
 8690:    txt += "  ipk   : %s\n" % totIpk
 8691:    txt += "  deb  : %s\n" % totDeb
 8692:    txt += "\n%s\n" % FFjt5L("Output Files:", c)
 8693:    txt += "  %s\n" % pFile
 8694:    txt += "  %s\n" % gFile
 8695:    txt += "  %s" % tFile
 8696:    FF4lCP(self, txt)
 8697:  def VV5EzU(self):
 8698:   pkg = FFUaC8()
 8699:   aptT = "apt - Advanced Package Tool" if FFayeZ("apt") else ""
 8700:   txt = {"ipkg": "Itsy", "opkg": "Open", "dpkg": "Debian"}.get(pkg, "")
 8701:   txt = "%s - %s Package Management System" % (pkg, txt) if txt else ""
 8702:   txt += "%s%s" % ("\n\nand\n\n" if txt and aptT else "", aptT)
 8703:   FFipXT(self, txt or "No packaging tools found!")
 8704:  def VV3v9Q(self, mode, Filter="", VV6A99=None):
 8705:   fdPath = Filter[5:] if Filter.startswith("feed=") else ""
 8706:   fLst, feedDic, instDic = self.VVLY1Q(fdPath)
 8707:   if fdPath and not feedDic:
 8708:    FFjADj(VV6A99, "No packages !", 1200)
 8709:    return
 8710:   if mode == 0: dic = feedDic.copy()
 8711:   else  : dic = instDic.copy()
 8712:   feedDic = instDic = None
 8713:   if mode == 2:
 8714:    words = ("extensions", "systemplugins", "softcams", "skin")
 8715:    for pkg in list(dic):
 8716:     if not pkg.startswith("enigma2-plugin-") and not any(x in pkg for x in words):
 8717:      del dic[pkg]
 8718:   if mode == 0 and Filter and not fdPath:
 8719:    word = Filter.lower()
 8720:    if word.endswith("s"): word = word[:-1]
 8721:    for pkg in list(dic):
 8722:     if not word in pkg:
 8723:      del dic[pkg]
 8724:    if not dic:
 8725:     FFjADj(VV6A99, "Not found", 1500)
 8726:     return
 8727:   VVGape = []
 8728:   for pkg, (ver, dsc, inst, hold) in dic.items():
 8729:    holdT = instT = c1 = ""
 8730:    if   hold    : c1, holdT = self.holdPkgColor, "Yes"
 8731:    elif inst and mode == 0 : c1, instT = self.instPkgColor, "Yes"
 8732:    VVGape.append((c1+ pkg, c1 + ver, c1 + dsc, c1 + instT, c1 + holdT))
 8733:   if VVGape:
 8734:    VVGape.sort(key=lambda x: FFd1WZ(x[0]).lower())
 8735:   else:
 8736:    FFdw58(self, "No packages found!")
 8737:    return
 8738:   if mode == 0:
 8739:    c1 = VVZtfx
 8740:    if Filter and not Filter == "All":
 8741:     if fdPath: title = "Feed = %s" % os.path.basename(fdPath)
 8742:     else  : title = "Filter = %s" % Filter
 8743:     title = "Download/Install ... %s" % FFjt5L(title, c1)
 8744:    else:
 8745:     title = FFjt5L("Download/Install Packages (from feeds)", c1)
 8746:   if VV6A99:
 8747:    VV6A99.VVMqQ9(VVGape, title, VV5YRVMsg=False, isSort=False)
 8748:    self.VVYtzC(mode, VV6A99)
 8749:   else:
 8750:    if mode == 0:
 8751:     VVC51D = self.lastListAllRow
 8752:     VVu8qI = self.VVxsZe
 8753:     VVwWmA = ("Install" , self.VVVcWW     , [])
 8754:     VVwSzI = ("Download" , self.VVyZYM     , [])
 8755:     VV4QTJ = ("Filter"  , BF(self.VVHZMd, fLst) , [])
 8756:     width = 1800
 8757:     widths = (43, 18, 32, 7, 0)
 8758:    else:
 8759:     if mode == 1:
 8760:      VVC51D  = self.lastRemoveAllRow
 8761:      VVu8qI = self.VVpRSq
 8762:     else:
 8763:      VVC51D  = self.lastRemoveExtRow
 8764:      VVu8qI = self.VVYcPT
 8765:     VVwWmA = ("Uninstall" , self.VVlXsD        , [])
 8766:     VVwSzI = None
 8767:     VV4QTJ = ("Hold Update", BF(self.VVyBrK, mode), [])
 8768:     width = 1550
 8769:     widths = (55, 35, 0, 0, 10)
 8770:    bg = "#11191111"
 8771:    VVScQz = ("Package Info." , self.VVU1Iy  , [])
 8772:    header   = ("Package", "Version" , "Description" , "Inst." , "Hold Upd." )
 8773:    VVLIqP  = (LEFT  , LEFT  , LEFT   , CENTER , CENTER  )
 8774:    tbl = FFUQ0v(self, None, header=header, VVGape=VVGape, VV3cHe=widths, VVLIqP=VVLIqP, width=width, height=1000, VVwdmN=26, VVu8qI=VVu8qI, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVC51D=VVC51D, VVSLOq=CFG.lastFindPackages
 8775:       , VVwltY="#22110011", VVkxBG=bg, VVemyB=bg, VVJKqd="#00004444", VVbcr0="#00333333")
 8776:    if mode != 0:
 8777:     tbl.VVIOX6(BF(self.VVYtzC, mode, tbl))
 8778:  def VVHZMd(self, fLst, VV6A99, title, txt, colList):
 8779:   VV3wat = []
 8780:   VV3wat.append(("All Packages", "All"))
 8781:   VV3wat.append(VVAL3j)
 8782:   VV3wat.append(("Feed ...", "fdPath"))
 8783:   VV3wat.append(VVAL3j)
 8784:   VV3wat.append(("enigma2-plugin-extensions" , "enigma2-plugin-extensions" ))
 8785:   VV3wat.append(("enigma2-plugin-systemplugins" , "enigma2-plugin-systemplugins"))
 8786:   VV3wat.append(VVAL3j)
 8787:   for word in ("Alsa", "Dream", "Drivers", "Enigma", "Extensions", "Feeds", "Firmware", "Fonts", "GLibc", "GStreamer", "Kernel", "Lib", "Linux", "Locale", "Modules", "Network", "Octagon", "PIcons", "Perl", "Pkg", "Plugin", "Python", "Samba", "Settings", "Skin", "SoftCam", "SystemPlugins", "Tools", "Util", "Zip"):
 8788:    VV3wat.append((word, word))
 8789:   FFLFTC(self, BF(self.VVheDx, fLst, VV6A99), VV3wat=VV3wat, title="Select Filter")
 8790:  def VVheDx(self, fLst, VV6A99, item=None):
 8791:   if item:
 8792:    def VVZwiy(txt):
 8793:     if txt: FFimQ3(VV6A99, BF(self.VV3v9Q, 0, Filter=txt, VV6A99=VV6A99), title="Filtering ...")
 8794:    if item == "fdPath":
 8795:     lst = [(os.path.basename(f), "feed=%s" % f) for f in fLst]
 8796:     if lst : FFLFTC(self, VVZwiy, VV3wat=lst, title="Select Feed")
 8797:     else : FF28n1(VV6A99, "Not feed list", 2000)
 8798:    else:
 8799:     VVZwiy(item)
 8800:  def VVLY1Q(self, fdPath=""):
 8801:   fLst, feedDic = CCeSkW.VVPNlD(fdPath)
 8802:   instDic = CCeSkW.VVuPwl()
 8803:   for pkg, (ver, dsc, inst, hold) in instDic.items():
 8804:    if not dsc:
 8805:     if pkg in feedDic: newDsc = feedDic[pkg][1]
 8806:     else    : newDsc = self.VVcRZW(pkg)
 8807:     if newDsc:
 8808:      instDic[pkg] = (ver, newDsc, inst, hold)
 8809:   for pkg, (ver, dsc, inst, hold) in instDic.items():
 8810:    if pkg in feedDic:
 8811:     ver1, dsc1, inst1, hold1 = feedDic[pkg]
 8812:     if ver == ver1:
 8813:      feedDic[pkg] = (ver1, dsc1, inst, hold)
 8814:   return fLst, feedDic, instDic
 8815:  @staticmethod
 8816:  def VVPNlD(fdPath):
 8817:   if fdPath: fLst = [fdPath]
 8818:   else  : fLst = CCeSkW.VVrmJV()
 8819:   return fLst, CCeSkW.VVLR8b(fLst)
 8820:  @staticmethod
 8821:  def VVuPwl():
 8822:   fLst = [CCeSkW.VVqSoq()]
 8823:   return CCeSkW.VVLR8b(fLst)
 8824:  def VVhDfd(self, toFind=""):
 8825:   dic = CCeSkW.VVuPwl()
 8826:   lst = set()
 8827:   for pkg, (ver, dsc, inst, hold) in dic.items():
 8828:    if hold:
 8829:     if toFind:
 8830:      if pkg == toFind:
 8831:       return [(pkg, ver)]
 8832:     else:
 8833:      lst.add((pkg, ver))
 8834:   return lst
 8835:  @staticmethod
 8836:  def VVLR8b(fLst):
 8837:   dic = {}
 8838:   tab = lambda line: line.partition(":")[2].strip()
 8839:   for path in fLst:
 8840:    try:
 8841:     with open(path, "r") as f:
 8842:      pkg = ver = dsc = sta = ""
 8843:      for line in f:
 8844:       if ":" in line:
 8845:        line = line.strip()
 8846:        if   line.startswith("Package")  : pkg = tab(line)
 8847:        elif line.startswith("Version")  : ver = tab(line)
 8848:        elif line.startswith("Status")   : sta = tab(line)
 8849:        elif line.startswith("Description") : dsc = tab(line)
 8850:       elif iMatch(r"^\s+\S", line):
 8851:        dsc = " - ".join((dsc, line.strip()))
 8852:       elif not line.strip():
 8853:        staL = sta.lower()
 8854:        hold = "hold" in staL
 8855:        inst = "installed" in staL and not "not-installed" in staL
 8856:        if pkg: dic[pkg] = (ver, dsc, inst, hold)
 8857:        pkg = ver = dsc = sta = ""
 8858:    except:
 8859:     pass
 8860:   return dic
 8861:  @staticmethod
 8862:  def VVrmJV():
 8863:   dirs = set()
 8864:   span = iSearch(r"option\s+lists_dir\s+(\/.+\/.+)", FFYVq0("/etc/opkg/opkg.conf"))
 8865:   if span and VVmJwX(span.group(1)): dirs.add(span.group(1))
 8866:   for s in ("apt", "opkg", "ipkg"):
 8867:    path = "/var/lib/%s/lists" % s
 8868:    if VVmJwX(path): dirs.add(path)
 8869:   files = []
 8870:   for d in dirs: files.extend(iGlob(FFoWxR(d) + "*"))
 8871:   files = [f for f in files if os.path.isfile(f) and not f.endswith("/status")]
 8872:   files.sort()
 8873:   return files
 8874:  @staticmethod
 8875:  def VVqSoq():
 8876:   for p in ("lib", "lib64"):
 8877:    p = "/var/%s/dpkg/status" % p
 8878:    if FFCyVu(p):
 8879:     return p
 8880:   span = iSearch(r"option\s+status_file\s+(\/.+\/.+)", FFYVq0("/etc/opkg/opkg.conf"))
 8881:   if span and VVmJwX(span.group(1)):
 8882:    return span.group(1)
 8883:   else:
 8884:    for s in ("opkg", "ipkg"):
 8885:     path = "/var/lib/%s/status" % s
 8886:     if FFCyVu(path):
 8887:      return path
 8888:   return ""
 8889:  def VVcRZW(self, pkg):
 8890:   dsc = ""
 8891:   for s in ("opkg", "ipkg"):
 8892:    fil = "/var/lib/%s/info/%s.control" % (s, pkg)
 8893:    if FFCyVu(fil):
 8894:     for line in FFL19l(fil):
 8895:      if ":" in line:
 8896:       line = line.strip()
 8897:       if   line.startswith("Description") : dsc = line.partition(":")[2].strip()
 8898:       elif line and line.startswith(" ") : dsc += " - " + line.strip()
 8899:   return dsc
 8900:  def VVxsZe(self, VV6A99):
 8901:   self.lastListAllRow = VV6A99.VVGTqU()
 8902:   VV6A99.cancel()
 8903:  def VVpRSq(self, VV6A99):
 8904:   self.lastRemoveAllRow = VV6A99.VVGTqU()
 8905:   VV6A99.cancel()
 8906:  def VVYcPT(self, VV6A99):
 8907:   self.lastRemoveExtRow = VV6A99.VVGTqU()
 8908:   VV6A99.cancel()
 8909:  def VVbOv6(self, VV6A99):
 8910:   self.lastPickedRow  = VV6A99.VVGTqU()
 8911:   VV6A99.cancel()
 8912:  @FFOAKH(par=2)
 8913:  def VVyBrK(self, mode, VV6A99, title, txt, colList):
 8914:   pkg, ver, desc, inst, holdState = VV6A99.VV5crm()
 8915:   cmd = FF5sZa(VVw6qo if holdState else VVofV3, pkg)
 8916:   FFpwZS(cmd)
 8917:   holdLst = self.VVhDfd(pkg)
 8918:   holdState = c1 = ""
 8919:   if len(holdLst) == 1 and holdLst[0][0] == pkg:
 8920:    holdState, c1 = "Yes", self.holdPkgColor
 8921:   VV6A99.VViSLW((c1 + pkg, c1 + ver, c1 + desc, c1 + inst, c1 + holdState))
 8922:   self.VVYtzC(mode, VV6A99)
 8923:  def VVYtzC(self, mode, VV6A99):
 8924:   if mode in (1, 2):
 8925:    pkg, ver, desc, inst, holdState = VV6A99.VV5crm()
 8926:    VV6A99["keyBlue"].setText("%s Update" % ("Allow" if holdState else "Hold"))
 8927:  @FFOAKH(par=1)
 8928:  def VVcm7J(self, VVIHf1, grnTxt, grnFnc):
 8929:   instDic = CCeSkW.VVuPwl()
 8930:   VVGape = [(pkg, ver) for pkg, (ver, dsc, inst, hold) in instDic.items()]
 8931:   if not VVGape:
 8932:    self.VVwTG2("Cannot read installed packages !")
 8933:    return
 8934:   VVGape.sort(key=lambda x: x[0].lower())
 8935:   VVu8qI = self.VVbOv6
 8936:   VVwSzI = (grnTxt   , grnFnc     , [])
 8937:   VVScQz = ("Package Info." , self.VVU1Iy , [])
 8938:   header = ("Package", "Version" )
 8939:   widths = (65  , 35  )
 8940:   FFUQ0v(self, None, title=grnTxt, header=header, VVGape=VVGape, VV3cHe=widths, VVwdmN=30, VVu8qI=VVu8qI, VVwSzI=VVwSzI, VVScQz=VVScQz, VVC51D=self.lastPickedRow, VVSLOq=CFG.lastFindPackages
 8941:     , VVwltY="#22110011", VVkxBG="#22191111", VVemyB="#22191111", VVJKqd="#00003030", VVbcr0="#00333333")
 8942:  def VVU1Iy(self, VV6A99, title, txt, colList):
 8943:   FFimQ3(VV6A99, BF(CCeSkW.VVLFsP, self, colList[0]))
 8944:  def VVlXsD(self, VV6A99, title, txt, colList):
 8945:   pkg, ver, desc, inst, holdState = VV6A99.VV5crm()
 8946:   if holdState: FF28n1(VV6A99, "Change Hold State first", 1000)
 8947:   else  : self.VVsxwI(VV6A99)
 8948:  def VVsxwI(self, VV6A99):
 8949:   VV3wat = []
 8950:   VV3wat.append(("Remove Package"        , "remove_ExistingPackage" ))
 8951:   VV3wat.append(("Remove Package (force remove)"    , "remove_ForceRemove"  ))
 8952:   VV3wat.append(("Remove Package (ignore failed dependencies)" , "remove_IgnoreDepends" ))
 8953:   FFLFTC(self, BF(self.VVGeqK, VV6A99)  , VV3wat=VV3wat)
 8954:  def VVGeqK(self, VV6A99, item):
 8955:   if item:
 8956:    pkg, ver, desc, inst, holdState = VV6A99.VV5crm()
 8957:    if   item == "remove_ExistingPackage" : cmdOpt = VVAdjB
 8958:    elif item == "remove_ForceRemove"  : cmdOpt = VV9Fg4
 8959:    elif item == "remove_IgnoreDepends"  : cmdOpt = VVYJEp
 8960:    FFRMYv(self, BF(self.VVt1Qf, VV6A99, cmdOpt, pkg), "Remove Package ?\n\n%s" % pkg)
 8961:  def VVt1Qf(self, VV6A99, cmdOpt, pkg):
 8962:   cmd = FF5sZa(cmdOpt, pkg)
 8963:   if cmd : FFbi5l(self, cmd, VVoasw=BF(self.VVipSj, VV6A99, pkg))
 8964:   else : FFfone(self)
 8965:  def VVipSj(self, VV6A99, pkg):
 8966:   if not CCeSkW.VVvDqA(pkg):
 8967:    VV6A99.VVtM2v()
 8968:    if VV6A99.VVn1uo() == 0:
 8969:     VV6A99.cancel()
 8970:   FF2Wqb()
 8971:  def VVVcWW(self, VV6A99, title, txt, colList):
 8972:   VV3wat = []
 8973:   VV3wat.append(("Install Package"        , "install_CheckVersion" ))
 8974:   VV3wat.append(("Install Package (force reinstall)"   , "install_ForceReinstall" ))
 8975:   VV3wat.append(("Install Package (force overwrite)"   , "install_ForceOverwrite" ))
 8976:   VV3wat.append(("Install Package (force downgrade)"   , "install_ForceDowngrade" ))
 8977:   VV3wat.append(("Install Package (ignore failed dependencies)" , "install_IgnoreDepends" ))
 8978:   FFLFTC(self, BF(self.VV2pyB, VV6A99), VV3wat=VV3wat)
 8979:  def VV2pyB(self, VV6A99, item):
 8980:   if item:
 8981:    pkg, ver, desc, inst, holdState = VV6A99.VV5crm()
 8982:    if   item == "install_CheckVersion"  : cmdOpt = VVwFAi
 8983:    elif item == "install_ForceReinstall" : cmdOpt = VVj9MD
 8984:    elif item == "install_ForceOverwrite" : cmdOpt = VVD9EU
 8985:    elif item == "install_ForceDowngrade" : cmdOpt = VVRA2G
 8986:    elif item == "install_IgnoreDepends" : cmdOpt = VVA8Es
 8987:    FFRMYv(self, BF(self.VVtlTi, pkg, VV6A99, cmdOpt), "Install Package ?\n\n%s" % pkg)
 8988:  def VVtlTi(self, pkg, VV6A99, cmdOpt):
 8989:   cmd = FF5sZa(cmdOpt, pkg)
 8990:   if cmd : FFbi5l(self, cmd, VVoasw=BF(self.VVMrFd, pkg, VV6A99), VV62hm=True)
 8991:   else : FFfone(self)
 8992:  def VVMrFd(self, pkg, VV6A99):
 8993:   FF2Wqb()
 8994:   if CCeSkW.VVvDqA(pkg):
 8995:    c1 = self.instPkgColor
 8996:    pkg, ver, desc, inst, holdState = VV6A99.VV5crm()
 8997:    row = (c1 + pkg.strip(), c1 + ver.strip(), c1 + desc.strip(), c1 + "Yes", c1 + holdState)
 8998:    VV6A99.VViSLW(row)
 8999:  def VVyZYM(self, VV6A99, title, txt, colList):
 9000:   pkg = colList[0]
 9001:   FFRMYv(self, BF(self.VVe60B, pkg), "Download Package ?\n\n%s" % pkg)
 9002:  def VVe60B(self, pkg):
 9003:   if CCuqoc.VVSuvZ():
 9004:    iCmd = FF5sZa(VVaS8u, pkg)
 9005:    dCmd = FF5sZa(VVUty9, pkg)
 9006:    dest = FFzQP1()
 9007:    if iCmd and dCmd:
 9008:     cTxt = lambda x, fg: " echo -e '\n%s' %s;" % (x, FFSPDv(x, fg))
 9009:     cmd  = "echo -e 'Downloading : %s';" % pkg
 9010:     cmd += "FILE1=$(%s '%s' | grep Filename | awk '{print $2}');" % (iCmd, pkg)
 9011:     cmd += 'if [ -z "$FILE1" ]; then'
 9012:     cmd += " echo -e '\nPackage : %s\n';" % pkg
 9013:     cmd += " echo -e $FILE1"
 9014:     cmd +=    cTxt("Not available on feed (update packages list and try again.)", VVYjI5)
 9015:     cmd += "else"
 9016:     cmd += " cd '%s';" % dest
 9017:     cmd +=   FFb2oQ(' rm -f "$FILE1"')
 9018:     cmd += " %s;" % dCmd
 9019:     cmd += ' if [ -f "%s$FILE1" ]; then' % dest
 9020:     cmd +=    cTxt("Downloaded to:", VVSGsk)
 9021:     cmd += '  echo "%s$FILE1";' % dest
 9022:     cmd += ' fi;'
 9023:     cmd += 'fi;'
 9024:     FFZQVC(self, cmd, VV26L0=[VVYjI5, "error:", "collected errors:", "failed", "not found"], VV62hm=True)
 9025:    else:
 9026:     FFfone(self)
 9027:   else:
 9028:    FFdw58(self, "No internet connection !")
 9029:  @staticmethod
 9030:  def VV3sSc(SELF):
 9031:   cmd = FFoY7E(VVaNvq)
 9032:   if cmd : FFbi5l(SELF, cmd, VV62hm=True, title="Available Packages List Upadate")
 9033:   else : FFfone(SELF)
 9034:  @staticmethod
 9035:  def VVV8mM(path):
 9036:   pkg = err = ""
 9037:   if VVmJwX(path):
 9038:    for line in FF3xOt(FF5sZa(VV0RRE, "*%s*" % path)):
 9039:     span = iSearch(r"(.+) - |(.+):", line)
 9040:     if span:
 9041:      pkg = span.group(1) or span.group(2)
 9042:      break
 9043:    if not pkg:
 9044:     err = "No package info !"
 9045:   else:
 9046:    err = "Path not found !"
 9047:   return pkg, err
 9048:  @staticmethod
 9049:  def VVLFsP(SELF, package, title=""):
 9050:   title = title or package
 9051:   fileExt = ""
 9052:   txt = instTime = ""
 9053:   c1 = VVcPtB
 9054:   info1 = []
 9055:   info2 = []
 9056:   infoCmd = FF5sZa(VVaS8u, package)
 9057:   if not infoCmd:
 9058:    FFfone(SELF, title=title)
 9059:    return
 9060:   info0 = FF3xOt(infoCmd, trim=False)
 9061:   if package.startswith("/") and info0:
 9062:    title = os.path.basename(package)
 9063:    info1 = info0
 9064:    for line in info0:
 9065:     line = line.strip()
 9066:     fld, _, val = line.partition(":")
 9067:     if fld == "Package" and val:
 9068:      fileExt = os.path.splitext(package)[1].strip(".").upper()
 9069:      package = val.strip()
 9070:      if CCeSkW.VVvDqA(package):
 9071:       info2 = FF3xOt(FF5sZa(VVaS8u, package), trim=False)
 9072:      break
 9073:   else:
 9074:    info2 = info0
 9075:   if info1:
 9076:    txt += FFGEAF("%s File Info" % (fileExt or "Package"), c1)
 9077:    txt += CCeSkW.VV2yzc(info1)[2] + "\n"
 9078:   if info2:
 9079:    txt1, txt2, txt3, instTime = CCeSkW.VV2yzc(info2)
 9080:    if txt1 and txt2:
 9081:     txt += FFGEAF("Package Version", c1)
 9082:     txt += txt1 + "\n"
 9083:     txt += FFGEAF("Installed Version", c1) + "\n"
 9084:     txt += txt2 + "\n"
 9085:    else:
 9086:     txt += FFGEAF("System Info", c1)
 9087:     txt += txt3 + "\n"
 9088:   if not info1 and not info2:
 9089:    txt += FFGEAF("Package Info", c1)
 9090:    txt += "No package information !\n\n"
 9091:   isInst = CCeSkW.VVvDqA(package)
 9092:   txt += FFGEAF("Package State", c1)
 9093:   txt += "  %s" % (FFjt5L("Installed", VVJEMb) if isInst else FFjt5L("Not Installed", VVz22H))
 9094:   txt += "\t%s\n\n" % instTime
 9095:   if isInst:
 9096:    files = FF3xOt(FF5sZa(VVjZ1L, package) + " | grep -e '^/'")
 9097:    files.sort()
 9098:    txt += FFGEAF("Resources", c1)
 9099:    if files: txt += "\n".join(files)
 9100:    else : txt += "  None"
 9101:   FF4lCP(SELF, txt, title=title, width=1700, height=1000, VVwdmN=28, VVllEU=30, titleBg="#11000022", VVemyB="#11000a11", VVRhqH=package)
 9102:  @staticmethod
 9103:  def VV2yzc(info):
 9104:   instTime = lastFld  = ""
 9105:   pkgCount = 0
 9106:   lines1 = []
 9107:   lines2 = []
 9108:   lines = lines1
 9109:   color = VVFuwR
 9110:   for line in info:
 9111:    fld, sep, val = line.partition(":")
 9112:    if sep:
 9113:     fld, val = fld.strip(), val.strip()
 9114:     if fld == "Package":
 9115:      pkgCount += 1
 9116:      if pkgCount > 1:
 9117:       lines = lines2
 9118:       color = VVJEMb
 9119:     elif fld == "Installed-Time":
 9120:      tm = val.strip()
 9121:      if tm.isdigit():
 9122:       instTime = FFTS4w(float(tm), wDay=True)
 9123:     lastFld = fld
 9124:    else:
 9125:     if lastFld == "Conffiles":
 9126:      val = fld.strip()
 9127:      Len = len(lines)
 9128:      last = Len - 1
 9129:      if Len > 0 and lines[last] == (lines[last][0], ""):
 9130:       lines[last] = (lines[last][0], val)
 9131:       continue
 9132:     else:
 9133:      val = fld
 9134:     fld = ""
 9135:    fld = fld.strip()
 9136:    if fld or val.strip():
 9137:     if fld: fld = FFjt5L(fld, color)
 9138:     lines.append((fld, val))
 9139:   txt1 = ""
 9140:   for fld, val in lines1:
 9141:    txt1 += "%s\t: %s\n" % (fld, val)
 9142:   txt2 = ""
 9143:   for fld, val in lines2:
 9144:    txt2 += "%s\t: %s\n" % (fld, val)
 9145:   txt3 = txt1
 9146:   if txt2:
 9147:    txt3 += "\n%s\n" % SEP + txt2
 9148:   return txt1, txt2, txt3, instTime
 9149:  @staticmethod
 9150:  def VVgrug():
 9151:   return FFpwZS("if [[ \"$(ar -V 2> /dev/null | grep 'GNU ar')\" ]]; then exit 0; else exit 1; fi")
 9152:  @staticmethod
 9153:  def VVvDqA(pkg):
 9154:   instDic = CCeSkW.VVuPwl()
 9155:   return pkg in instDic
 9156:  @staticmethod
 9157:  def VVq71e(SELF):
 9158:   if not CCeSkW.VVgrug():
 9159:    FFRMYv(SELF, BF(FFbi5l, SELF, FFvQ9y(), title="Installing 'ar'"), "'ar' package is required.\n\nInstall ?")
 9160:    return False
 9161:   else:
 9162:    pFound, pBBox = FFmCnY("xz")
 9163:    if not pFound   : title, ques = "Install 'xz'", "'xz' package is required.\n\nInstall ?"
 9164:    elif pFound and pBBox : title, ques = "Upgrade 'xz'", "Found BusyBox xz. A higher version is required.\n\nUpgrade ?"
 9165:    else     : return True
 9166:    FFRMYv(SELF, BF(FFbi5l, SELF, FFKbNE(), title=title), ques, title=title)
 9167:    return False
 9168:  @staticmethod
 9169:  def VVy0xB(path):
 9170:   txt = mTime = ""
 9171:   if FFCyVu(path):
 9172:    fName = os.path.basename(path)
 9173:    isDeb = os.path.splitext(fName)[1] == ".deb"
 9174:    if isDeb: ext, tarP = "xz", "J"
 9175:    else : ext, tarP = "gz", "z"
 9176:    txt += FFQ45w("ar -p '%s' control.tar.%s | tar %sxO ./control" % (path, ext, tarP))
 9177:    txt += "\n"
 9178:    txt += "Size: %s\n" % FFXhoc(path)
 9179:    txt += "Filename: %s\n" % fName
 9180:    txt += "MD5sum: %s\n" % FFTKR0("md5sum '%s' | cut -b-32" % path)
 9181:    txt += "SHA256sum: %s\n" % FFTKR0("sha256sum '%s' | cut -b-64"  % path)
 9182:    mTime = "%s %s" % (FFTKR0("stat -c%%Y '%s'" % path), fName)
 9183:   return txt, mTime
 9184:  @staticmethod
 9185:  def VVohK9(ver1, ver2):
 9186:   def VVZwiy(x):
 9187:    if   x == '~' : return -1
 9188:    elif x.isdigit(): return 0
 9189:    elif not x  : return 0
 9190:    elif x.isalpha(): return ord(x)
 9191:    else   : return ord(x) + 256
 9192:   def VVjX9E(val, ref):
 9193:    while val or ref:
 9194:     first_diff = 0
 9195:     while (val and not val[0].isdigit()) or (ref and not ref[0].isdigit()):
 9196:      vc = VVZwiy(val[0]) if val else 0
 9197:      rc = VVZwiy(ref[0]) if ref else 0
 9198:      if vc != rc:
 9199:       return vc - rc
 9200:      val = val[1:]
 9201:      ref = ref[1:]
 9202:     val = val.lstrip('0')
 9203:     ref = ref.lstrip('0')
 9204:     while val and ref and val[0].isdigit() and ref[0].isdigit():
 9205:      if not first_diff:
 9206:       first_diff = ord(val[0]) - ord(ref[0])
 9207:      val = val[1:]
 9208:      ref = ref[1:]
 9209:     if val and val[0].isdigit() : return 1
 9210:     if ref and ref[0].isdigit() : return -1
 9211:     if first_diff    : return first_diff
 9212:    return 0
 9213:   return VVjX9E(ver1, ver2)
 9214:  @staticmethod
 9215:  def VV2PRQ(curVer, webVer):
 9216:   webVer = webVer.strip().replace("version=", "")
 9217:   tab = lambda x: iSub(r"[^\d\.]", "", x.replace("_", "."))
 9218:   cur, web = tab(curVer), tab(webVer)
 9219:   upd = CCeSkW.VVohK9(cur, web) < 0
 9220:   return curVer.replace("v", ""), webVer, upd
 9221: class CCwnHL():
 9222:  def VVNXsZ(self, isRef, onlyEpg=False):
 9223:   self.shareIsRef   = isRef
 9224:   self.onlyEpg   = onlyEpg
 9225:   self.shareFilePrefix = "ajpanel_share_%s_" % ("ref" if self.shareIsRef else "data")
 9226:   self.shareFilePath  = ""
 9227:   FFb0NN()
 9228:   self.VVvxPw()
 9229:  def VVvxPw(self):
 9230:   files = FFkzic(FF7TOv(), self.shareFilePrefix + "*.xml")
 9231:   if files:
 9232:    files.sort()
 9233:    VV3wat = []
 9234:    for fil in files:
 9235:     VV3wat.append((os.path.basename(fil), fil))
 9236:    if self.shareIsRef : VVwltY, VVkxBG = "#22221133", "#22221133"
 9237:    else    : VVwltY, VVkxBG = "#22003344", "#22002233"
 9238:    VVwJOl  = ("Add new File", self.VVNwnz)
 9239:    FFLFTC(self, self.VVPQD2, VV3wat=VV3wat, width=1100, VVwJOl=VVwJOl, VVtboQ="", VVyRCy=4, VVwltY=VVwltY, VVkxBG=VVkxBG)
 9240:   else:
 9241:    FFRMYv(self, self.VVhT9v, "No files found.\n\nCreate a new file ?")
 9242:  def VVhT9v(self):
 9243:   path = self.VV8dIQ()
 9244:   if FFCyVu(path) : self.VVvxPw()
 9245:   else    : FF28n1(self, "Cannot create file", 1500)
 9246:  def VVNwnz(self, VV7tND, path):
 9247:   path = self.VV8dIQ()
 9248:   VV7tND.VV5HD3((os.path.basename(path), path), isSort=True)
 9249:  def VV8dIQ(self):
 9250:   path = "%s%s%s.xml" % (FF7TOv(), self.shareFilePrefix, FFjTQe())
 9251:   with open(path, "w") as f:
 9252:    f.write('<?xml version="1.0" encoding="utf-8"?>\n<share>\n\n\t<ch>\n\t\t<name1>Channel-1</name1>  <ref1>5001:0:1:22:22:22:22:0:0:0</ref1>\n\t\t<name2>Channel-2</name2>  <ref2>4097:0:1:22:22:22:22:0:0:0</ref2>\n\t</ch>\n\n</share>')
 9253:   return path
 9254:  @FFOAKH()
 9255:  def VVPQD2(self, path=None):
 9256:   if not path: return
 9257:   if not FFCyVu(path):
 9258:    FF8Wsn(self, path)
 9259:    return
 9260:   elif not CClYaF.VVSOog(self, path, FFGNZA()):
 9261:    return
 9262:   else:
 9263:    self.shareFilePath = path
 9264:   if not CCid3A.VVAilv(self):
 9265:    return
 9266:   tree = CCYrUm.VVkotG(self, self.shareFilePath)
 9267:   if not tree:
 9268:    return
 9269:   refLst = CCMvE7.VVit2n()
 9270:   def VVJi7Q(VVPxk5):
 9271:    if   FF4qbN(VVPxk5): return FFjt5L("DVB", VVJEMb)
 9272:    elif VVPxk5 in refLst     : return FFjt5L("IPTV", VVJEMb)
 9273:    else         : return ""
 9274:   VVAkuK= []
 9275:   errColor= "
 9276:   num  = 1
 9277:   dupl = 0
 9278:   for ch in tree.getroot():
 9279:    ok, srcName, srcRef, dstName, dstRef = self.VVLTjY(ch)
 9280:    if ok:
 9281:     srcTxt = VVJi7Q(srcRef)
 9282:     dstTxt = VVJi7Q(dstRef)
 9283:     srcName, dstName = srcName.strip(), dstName.strip()
 9284:     skip = False
 9285:     for num1, srcName1, srcRef1, srcTxt1, dstName1, dstRef1, dstTxt1, remark1 in VVAkuK:
 9286:      if (srcRef, dstRef, dstName) == (srcRef1, dstRef1, dstName1):
 9287:       dupl += 1
 9288:       break
 9289:     else:
 9290:      if  srcRef == dstRef : remark, c1, c2 = "4", errColor, errColor
 9291:      elif srcTxt and dstTxt : remark, c1, c2 = "0", ""  , ""
 9292:      elif dstTxt    : remark, c1, c2 = "1", errColor, ""
 9293:      elif srcTxt    : remark, c1, c2 = "2", ""  , errColor
 9294:      else     : remark, c1, c2 = "3", errColor, errColor
 9295:      c3 = "#f#0000ff00#" if remark == "0" else errColor
 9296:      VVAkuK.append((c3 + str(num), c1 + srcName, c1 + srcRef, c1 + srcTxt, c2 + dstName, c2 + dstRef, c2 + dstTxt, remark))
 9297:      num += 1
 9298:   refLst = None
 9299:   if VVAkuK:
 9300:    if self.shareIsRef : VVwltY, VVkxBG, optTxt = "#1a221133", "#1a221133", "Share Reference"
 9301:    else    : VVwltY, VVkxBG, optTxt = "#1a003344", "#1a002233", "Copy EPG" if self.onlyEpg else "Copy EPG/PIcons"
 9302:    VVCOpO = (""    , BF(self.VVAJyn, dupl) , [])
 9303:    VV2ytr = (""    , self.VVpKs1    , [])
 9304:    VVwWmA = ("Delete Entry" , self.VVSkmM   , [])
 9305:    VVwSzI = ("Add Entry"  , self.VVm5jD , [])
 9306:    VVScQz = (optTxt   , self.VVXUtT  , [])
 9307:    header  = ("Num" , "Source" , "Source Ref." ,"Type" , "Destination" , "Dest. Ref." , "Type", "Remark" )
 9308:    widths  = (8  , 25  , 15   , 6  , 25   , 15   , 6  , 0   )
 9309:    VVLIqP = (CENTER , LEFT  , LEFT   ,CENTER , LEFT   , LEFT   , CENTER, CENTER )
 9310:    VV6A99 = FFUQ0v(self, None, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=24, VVCOpO=VVCOpO, VV2ytr=VV2ytr, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVScQz=VVScQz, VVHPI7=True, VVMfsO=1, VVSLOq=CFG.lastFindServices
 9311:          , VVwltY=VVwltY, VVkxBG=VVkxBG, VVemyB=VVkxBG, VVJKqd="#0a000000")
 9312:   else:
 9313:    FFdw58(self, "No valid sharing data found in:\n\n%s" % self.shareFilePath)
 9314:  def VVAJyn(self, dupl, VV6A99, title, txt, colList):
 9315:   if dupl:
 9316:    VV6A99.VV6fGE("Skipped %d duplicate%s" % (dupl, FFcacr(dupl)), 2000)
 9317:  def VVpKs1(self, VV6A99, title, txt, colList):
 9318:   def VVJi7Q(key, val): return "%s\t: %s\n" % (key, val or FFjt5L("?", VVyFI2))
 9319:   Keys = VV6A99.VVeVZB()
 9320:   Vals = VV6A99.VV5crm()
 9321:   txt = ""
 9322:   for i in range(len(Keys) - 1):
 9323:    txt += VVJi7Q(Keys[i], Vals[i])
 9324:    if i in (0, 3, 6):
 9325:     txt += "\n"
 9326:   remark = colList[7]
 9327:   txt1 = "Remarks\t: "
 9328:   c1, c2 = VVSGsk, VVyFI2
 9329:   if   remark == "0": txt1 += c1 + "Valid"
 9330:   elif remark == "1": txt1 += c2 + "Source channel is not in system"
 9331:   elif remark == "2": txt1 += c2 + "Destination channel is not in system"
 9332:   elif remark == "3": txt1 += c2 + "Both channels are not in system"
 9333:   elif remark == "4": txt1 += c2 + "Both channels have same Reference"
 9334:   FF4lCP(self, txt + txt1, title=title)
 9335:  def VVLTjY(self, chElem):
 9336:   srcName = chElem.find("name1")
 9337:   srcRef  = chElem.find("ref1")
 9338:   dstName = chElem.find("name2")
 9339:   dstRef  = chElem.find("ref2")
 9340:   patt = r"((?:[A-Fa-f0-9]+:){9}(?:[A-Fa-f0-9]+))"
 9341:   if srcName is not None and srcRef is not None and dstName is not None and dstRef is not None:
 9342:    lst = [srcName.text or "", srcRef.text or "", dstName.text or "", dstRef.text or ""]
 9343:    for i, text in enumerate(lst):
 9344:     lst[i] = str(text.encode("UTF-8").decode())
 9345:    srcName, srcRef, dstName, dstRef = lst
 9346:    span = iSearch(patt, srcRef)
 9347:    if span:
 9348:     srcRef = span.group(1).upper()
 9349:     span = iSearch(patt, dstRef)
 9350:     if span:
 9351:      dstRef = span.group(1).upper()
 9352:      return True, srcName.strip(), srcRef.strip(":"), dstName.strip(), dstRef.strip(":")
 9353:   return False, "", "", "", ""
 9354:  def VVSkmM(self, VV6A99, title, txt, colList):
 9355:   if VV6A99.VVGTqU() == 0 and VV6A99.VVn1uo() == 1:
 9356:    isLast, ques = True, "This is the last entry.\n\nDelete File ?"
 9357:   else:
 9358:    isLast, ques = False, "Delete current row ?"
 9359:   FFRMYv(self, BF(self.VVsDPB, isLast, VV6A99), ques)
 9360:  def VVsDPB(self, isLast, VV6A99):
 9361:   if isLast:
 9362:    FFwgGB(self.shareFilePath)
 9363:    VV6A99.cancel()
 9364:   else:
 9365:    num, srcName, srcRef, srcType, dstName, dstRef, dstType, remark = VV6A99.VV5crm()
 9366:    if self.VVzEs4(srcName, srcRef, dstName, dstRef):
 9367:     VV6A99.VVtM2v()
 9368:     VV6A99.VV8IgX()
 9369:     FF1mVE(VV6A99, "Deleted", 500)
 9370:    else:
 9371:     FF28n1(VV6A99, "Cannot delete from file", 2000)
 9372:  def VVm5jD(self, VV6A99, title, txt, colList):
 9373:   if self.shareIsRef : self.VVHGxg(VV6A99)
 9374:   else    : FFLFTC(self, BF(self.VVFHpo, VV6A99), VV3wat=[("DVB to IPTV", "iptv"), ("DVB to DVB", "dvb")], width=600, title="Source and Destination")
 9375:  def VVFHpo(self, VV6A99, item):
 9376:   if item:
 9377:    if   item == "iptv" : fnc = self.VVHGxg(VV6A99)
 9378:    elif item == "dvb" : fnc = self.VV85rZ(VV6A99)
 9379:  @FFOAKH("Loading Services ...", par=1)
 9380:  def VV85rZ(self, VV6A99):
 9381:   lst, err = CCYrUm.VVJud0(self, CCYrUm.VVp2Ed)
 9382:   if not lst:
 9383:    FFdw58(self, "No DVB Services !")
 9384:    return
 9385:   lst = [(VV1wIO, VVPxk5 + ":", sat) for VV1wIO, chProv, sat, VVPxk5 in lst]
 9386:   lst.sort(key=lambda x: x[0].lower())
 9387:   chkLst = [(srcRef + ":", dstRef + ":", dstName) for num, srcName, srcRef, srcTxt, dstName, dstRef, dstTxt, remark in VV6A99.VVrrm9()]
 9388:   VVfaDBLst = []
 9389:   try:
 9390:    bg = "#11001100"
 9391:    self.session.open(CCjS4V, lst, chkLst=chkLst, srcPath=self.shareFilePath, dstPath=self.shareFilePath
 9392:        , title="Chain DVB to DVB Channel", mnuTitle2="Destination Channel", mnuTitle3="Source", blueTitle="Add Entry"
 9393:        , blueFnc=BF(self.VVqlLf, VV6A99, VVfaDBLst), delFnc=None
 9394:        , widths2=(70, 0, 30), aligns2=(LEFT, LEFT, CENTER), tBg=bg, bBg=bg, bg1=bg, bg2=bg)
 9395:   except:
 9396:    pass
 9397:  @FFOAKH("Loading Services ...", par=1)
 9398:  def VVHGxg(self, VV6A99):
 9399:   lst = CCwnHL.VVcON6()
 9400:   if not lst:
 9401:    FFdw58(self, "No IPTV Services !")
 9402:    return
 9403:   lst = [(name, ref + ":") for name, bouquet, url, ref in lst]
 9404:   chkLst = [(srcRef + ":", dstRef + ":", dstName) for num, srcName, srcRef, srcTxt, dstName, dstRef, dstTxt, remark in VV6A99.VVrrm9()]
 9405:   VVfaDBLst = [r + ":" for r in CCMvE7.VVit2n()]
 9406:   try:
 9407:    self.session.open(CCjS4V, lst, chkLst=chkLst, srcPath=self.shareFilePath, dstPath=self.shareFilePath
 9408:        , title="Chain DVB to IPTV Channel", mnuTitle2="IPTV Chan Name", mnuTitle3="IPTV Reference", blueTitle="Add Entry"
 9409:        , blueFnc=BF(self.VVqlLf, VV6A99, VVfaDBLst), delFnc=None
 9410:        , widths2=(60, 40), fonts2=(0, 1))
 9411:   except:
 9412:    pass
 9413:  @FFOAKH(par=3)
 9414:  def VVqlLf(self, VV6A99, VVfaDBLst, bindCls):
 9415:   c1  = VVJEMb
 9416:   title= bindCls.Title
 9417:   outF = bindCls.dstPath
 9418:   d  = bindCls.VVzYMA()
 9419:   srcName, srcRef, srcTxt = d["name"]  , d["VVPxk510"].rstrip(":"), ""
 9420:   dstName, dstRef, dstTxt = d["mnuTxt"], d["mnuRef"].rstrip(":")  , ""
 9421:   if   FF4qbN(srcRef)  : srcTxt = FFjt5L("DVB", c1)
 9422:   elif srcRef.rstrip(":") + ":" in VVfaDBLst : srcTxt = FFjt5L("IPTV", c1)
 9423:   if   FF4qbN(dstRef)  : dstTxt = FFjt5L("DVB", c1)
 9424:   elif dstRef.rstrip(":") + ":" in VVfaDBLst : dstTxt = FFjt5L("IPTV", c1)
 9425:   if srcRef == dstRef:
 9426:    FFjADj(bindCls, "Cannot add (same Reference)", 2000)
 9427:   else:
 9428:    for ndx, (num1, srcName1, srcRef1, srcTxt1, dstName1, dstRef1, dstTxt1, remark1) in enumerate(VV6A99.VVrrm9()):
 9429:     if (srcRef, dstRef, dstName) == (srcRef1, dstRef1, dstName1):
 9430:      FFdw58(self, "Already added in row Num-%d" % (ndx + 1))
 9431:      break
 9432:    else:
 9433:     if self.VVAHBa(srcName, srcRef, dstName, dstRef):
 9434:      VV6A99.VV1MqZ((str(VV6A99.VVn1uo() + 1), srcName, srcRef, srcTxt, dstName, dstRef, dstTxt, "0"))
 9435:      FFG2sB(bindCls, "Saved", 800)
 9436:      bindCls.VVfC5O((d["VVPxk510"], d["mnuRef"], d["mnuTxt"]))
 9437:     else:
 9438:      FFjADj(bindCls, "Cannot edit XML File", 2000)
 9439:  @staticmethod
 9440:  def VVcON6():
 9441:   VVAkuK = []
 9442:   files  = CCkEI5.VVjMS6()
 9443:   patt  = r"
 9444:   if files:
 9445:    for path in files:
 9446:     txt = FFYVq0(path)
 9447:     span = iSearch(r"
 9448:     if span : VVY5Mx = span.group(1)
 9449:     else : VVY5Mx = ""
 9450:     VVY5Mx_lCase = VVY5Mx.lower()
 9451:     for match in iFinditer(patt, txt, IGNORECASE):
 9452:      VVPxk5 = match.group(1).upper().strip(":")
 9453:      url  = match.group(2).strip()
 9454:      VV1wIO = match.group(3).strip()
 9455:      VVAkuK.append((VV1wIO, VVY5Mx, url, VVPxk5))
 9456:   return VVAkuK
 9457:  def VVAHBa(self, srcName, srcRef, dstName, dstRef):
 9458:   tree = CCYrUm.VVkotG(self, self.shareFilePath)
 9459:   if not tree:
 9460:    return False
 9461:   root = tree.getroot()
 9462:   ch = iElem.Element("ch")
 9463:   root.append(ch)
 9464:   name  = iElem.SubElement(ch, "name1")
 9465:   ref   = iElem.SubElement(ch, "ref1")
 9466:   name.text = srcName
 9467:   ref.text = srcRef
 9468:   name  = iElem.SubElement(ch, "name2")
 9469:   ref   = iElem.SubElement(ch, "ref2")
 9470:   name.text = dstName
 9471:   ref.text = dstRef
 9472:   self.VVuOoS(tree, root)
 9473:   return True
 9474:  def VVzEs4(self, srcName1, srcRef1, dstName1, dstRef1):
 9475:   tree = CCYrUm.VVkotG(self, self.shareFilePath)
 9476:   if not tree:
 9477:    return False
 9478:   tableLst = [srcName1, srcRef1, dstName1, dstRef1]
 9479:   found = False
 9480:   root = tree.getroot()
 9481:   for ch in root:
 9482:    ok, srcName, srcRef, dstName, dstRef = self.VVLTjY(ch)
 9483:    if ok and [srcName, srcRef, dstName, dstRef] == tableLst:
 9484:     root.remove(ch)
 9485:     found = True
 9486:   if found:
 9487:    self.VVuOoS(tree, root)
 9488:   return found
 9489:  def VVuOoS(self, tree, root, withComments=True):
 9490:   xmlTxt = iElem.tostring(root)
 9491:   txt  = CCYrUm.VVRyHN(xmlTxt)
 9492:   parser = CCYrUm.CC9usG()
 9493:   if withComments : parser = iElem.XMLParser(target=parser)
 9494:   else   : parser = None
 9495:   root = iElem.fromstring(txt, parser=parser)
 9496:   tree._setroot(root)
 9497:   tree.write(self.shareFilePath, encoding="UTF-8")
 9498:  def VVXUtT(self, VV6A99, title, txt, colList):
 9499:   if self.onlyEpg:
 9500:    self.VV38cQ(VV6A99, "epg")
 9501:   else:
 9502:    if self.shareIsRef:
 9503:     FFRMYv(self, BF(self.VVQPvJ, VV6A99), "Copy all References from Source to Destination ?")
 9504:    else:
 9505:     VV3wat = []
 9506:     VV3wat.append(("Copy EPG\t (All List)" , "epg"  ))
 9507:     VV3wat.append(("Copy Picons\t (All List)" , "picon" ))
 9508:     FFLFTC(self, BF(self.VV38cQ, VV6A99), VV3wat=VV3wat, width=1000)
 9509:  def VV38cQ(self, VV6A99, item=None):
 9510:   if item:
 9511:    if   item == "epg" : fnc, txt = self.VV7fpu  , "EPG"
 9512:    elif item == "picon": fnc, txt = self.VVTlsd , "PIcons"
 9513:    title = "Copy %s" % txt
 9514:    tot   = VV6A99.VVn1uo()
 9515:    FFRMYv(self, BF(fnc, VV6A99, title), "Overwrite %s for %d Service%s ?" % (FFjt5L(txt, VV1fx4), tot, FFcacr(tot)), title=title)
 9516:  @FFOAKH(par=1)
 9517:  def VVQPvJ(self, VV6A99):
 9518:   files = CCkEI5.VVjMS6()
 9519:   totChange = 0
 9520:   if files:
 9521:    for path in files:
 9522:     txt = FFYVq0(path)
 9523:     toSave = False
 9524:     for num, srcName, srcRef, srcTxt, dstName, dstRef, dstTxt, remark in VV6A99.VVrrm9():
 9525:      if remark == "0":
 9526:       srcPart = ":".join(srcRef.split(":")[1:]) + ":"
 9527:       dstPart = ":".join(dstRef.split(":")[1:]) + ":"
 9528:       txt, tot = iSubn(r"(
 9529:       if tot:
 9530:        toSave = True
 9531:        totChange += tot
 9532:     if toSave:
 9533:      with open(path, "w") as f:
 9534:       f.write(txt)
 9535:   if totChange > 0:
 9536:    FFfpyJ()
 9537:   tot = VV6A99.VVn1uo()
 9538:   skp = tot - totChange
 9539:   txt  = "Processed\t: %d\n" % tot
 9540:   txt += "Changed\t: %d\n"  % totChange
 9541:   if skp > 0: txt += "Skipped\t: %d\n"  % skp
 9542:   FF4lCP(self, txt)
 9543:  @FFOAKH(par=1)
 9544:  def VVTlsd(self, VV6A99, title):
 9545:   if not iCopyfile:
 9546:    FFdw58(self, "Module not found:\n\nshutil", title=title)
 9547:    return
 9548:   pPath = CCafIt.VVjkKT()
 9549:   totFound = totDone = totSame = totErr = 0
 9550:   for num, srcName, srcRef, srcTxt, dstName, dstRef, dstTxt, remark in VV6A99.VVrrm9():
 9551:    srcPng = pPath + srcRef.replace(":", "_") + ".png"
 9552:    dstPng = pPath + dstRef.replace(":", "_") + ".png"
 9553:    if FFCyVu(srcPng):
 9554:     totFound += 1
 9555:     if srcPng == dstPng:
 9556:      totSame += 1
 9557:     else:
 9558:      try:
 9559:       iCopyfile(srcPng, dstPng)
 9560:       totDone += 1
 9561:      except:
 9562:       totErr += 1
 9563:   txt  = "Services\t: %d\n" % VV6A99.VVn1uo()
 9564:   txt += "Found\t: %d\n" % totFound
 9565:   txt += "Copied\t: %d"  % totDone
 9566:   if totSame: txt += "\nSame Ref.\t: %d" % totSame
 9567:   if totErr : txt += "\nErrors\t: %d"  % totErr
 9568:   FF4lCP(self, txt, title=title)
 9569:  @FFOAKH(par=1)
 9570:  def VV7fpu(self, VV6A99, title):
 9571:   txt, err = CC5TsO.VVDL6A(VV6A99, title)
 9572:   if err : FFdw58(self, err, title=title)
 9573:   else : FF4lCP(self, txt, title=title)
 9574:  class CC9usG(iElem.TreeBuilder):
 9575:   def comment(self, data):
 9576:    self.start(iElem.Comment, {})
 9577:    self.data(data)
 9578:    self.end(iElem.Comment)
 9579:  @staticmethod
 9580:  def VVkotG(SELF, path, withComments=True, title=""):
 9581:   try:
 9582:    if withComments:
 9583:     try:
 9584:      return iElem.parse(path, parser=iElem.XMLParser(target=CCYrUm.CC9usG()))
 9585:     except:
 9586:      return iElem.parse(path)
 9587:   except Exception as e:
 9588:    CCwnHL.VVBfGR(SELF, path, str(e), title)
 9589:    return None
 9590:  @staticmethod
 9591:  def VVBfGR(SELF, path, err, title=None):
 9592:   txt  = "%s\n%s\n\n" % (FFjt5L("XML Parse Error in:", VVyFI2), path)
 9593:   txt += "%s\n%s\n\n" % (FFjt5L("Error:", VVyFI2), str(err))
 9594:   FF4lCP(SELF, txt, VVemyB="#11220000", titleBg="#11330000", title=title or FFGNZA().strip())
 9595:  @staticmethod
 9596:  def VVRyHN(xmlTxt):
 9597:   txt = iSub(r">[\n\s]*", ">" , xmlTxt.decode("UTF-8"))
 9598:   txt = iSub(r"([^12])>\s*<" , r"\1>\n<", txt)
 9599:   txt = iSub(r"ref1>\s*<name2", r"ref1>\n<name2", txt)
 9600:   txt = iSub(r"</ref2></ch>" , r"</ref2>\n</ch>\n", txt)
 9601:   txt = iSub(r"<ch>"   , r"\t<ch>", txt)
 9602:   txt = iSub(r"</ch>"   , r"\t</ch>", txt)
 9603:   txt = iSub(r"<name1>"  , r"\t\t<name1>", txt)
 9604:   txt = iSub(r"<name2>"  , r"\t\t<name2>", txt)
 9605:   txt = iSub(r"(<!-- .+ -->)" , r"\t\1\n", txt)
 9606:   txt = iSub(r"<share>"  , r"<share>\n", txt)
 9607:   return txt
 9608: class CCiEqS(Screen):
 9609:  def __init__(self, session, title):
 9610:   self.skin, self.VVfOli = FFiNEe(VVDEl1, 600, 300, 30, 0, 0, "#22112211", "#0a223322", 35, VVeFSs=40)
 9611:   self.session  = session
 9612:   self.index   = 1
 9613:   self.totSec   = 0
 9614:   FFZMxC(self, title=title)
 9615:   FFRLNq(self["keyYellow"], "Reset")
 9616:   self["signTitle"] = Label("+/-")
 9617:   self["hourTitle"] = Label("Hour")
 9618:   self["minTitle"] = Label("Min")
 9619:   self["sign"]  = Label("+")
 9620:   self["hour"]  = Label("00")
 9621:   self["min"]   = Label("00")
 9622:   self.list   = [self["sign"], self["hour"], self["min"]]
 9623:   FFHlAU(self,
 9624:   {
 9625:    "ok" : self.VVQi42 ,
 9626:    "green" : self.VVQi42 ,
 9627:    "yellow": self.VVPzLw ,
 9628:    "up" : self.VVx0di  ,
 9629:    "down" : self.VVDBsZ ,
 9630:    "left" : self.VVziFC ,
 9631:    "right" : self.VVLe1s ,
 9632:    "cancel": self.close
 9633:   })
 9634:   self.onShown.append(self.VV7OzD)
 9635:  def VV7OzD(self):
 9636:   self.onShown.remove(self.VV7OzD)
 9637:   FFWgBS(self)
 9638:   self.VVwhvR()
 9639:  def VVQi42(self):
 9640:   sign = self["sign"].getText()
 9641:   hour = self["hour"].getText()
 9642:   min  = self["min"].getText()
 9643:   seconds = int(hour) * 3600 + int(min) * 60
 9644:   seconds *= 1 if sign == "+" else -1
 9645:   self.close(seconds)
 9646:  def VVPzLw(self):
 9647:   self["sign"].setText("+")
 9648:   self["hour"].setText("00")
 9649:   self["min"].setText("00")
 9650:  def VVx0di(self)  : self.VVtR6o(1)
 9651:  def VVDBsZ(self) : self.VVtR6o(-1)
 9652:  def VVziFC(self) : self.VVwhvR(-1)
 9653:  def VVLe1s(self) : self.VVwhvR(1)
 9654:  def VVwhvR(self, box=0):
 9655:   self.index += box
 9656:   if   self.index < 0     : self.index = len(self.list) - 1
 9657:   elif self.index > len(self.list) - 1: self.index = 0
 9658:   for obj in self.list: FFZ0AC(obj, "#06405040")
 9659:   FFZ0AC(self.list[self.index], "#0a225577")
 9660:  def VVtR6o(self, increment):
 9661:   if self.index == 0:
 9662:    sign = self.list[0].getText()
 9663:    if   sign == "+": sign = "-"
 9664:    elif sign == "-": sign = "+"
 9665:    self.list[0].setText(sign)
 9666:   else:
 9667:    if self.index == 1 : min, max, step = 0, 23, 1
 9668:    else    : min, max, step = 0, 45, 15
 9669:    val = int(self.list[self.index].getText()) + increment * step
 9670:    if val < min: val = max
 9671:    if val > max: val = min
 9672:    self.list[self.index].setText("%02d" % val)
 9673: class CCDJgl():
 9674:  def __init__(self, SELF, mode=0):
 9675:   self.SELF   = SELF
 9676:   self.Title   = "XML-TV Tools"
 9677:   self.xmltv_path  = FF0cqc() + "epg/"
 9678:   self.VVVvc0  = ""
 9679:   self.curChName  = ""
 9680:   self.curChTitle  = ""
 9681:   self.curPath  = ""
 9682:   self.curTotTags  = 0
 9683:   self.displayName = ""
 9684:   self.adjustedTime = 0
 9685:   self.curChanRefFile = self.xmltv_path + CFG.xmlTvChannelRefFile.getValue()
 9686:   self.skipLst  = ("hd+", "hd", "fhd+", "fhd", "4k", "tv", "hd_en", "beinsports.com", "elcienma", "elifeon", "jawwy", "ooredoo", "shahid", "sattv", "switch", "tod", "whatson")
 9687:   self.blackStar  = b"\xe2\x9c\xa6".decode("UTF-8")
 9688:   if mode == 0:
 9689:    CCDJgl.VVT11L()
 9690:    self.VVa96Z(self.SELF)
 9691:   else:
 9692:    self.tbl = SELF
 9693:    if   mode == 1: CCDJgl.VVuIyO(SELF, cbf=self.VVnlje, toTable=True)
 9694:    elif mode == 2: CCDJgl.VVuIyO(SELF)
 9695:    elif mode == 3: CCDJgl.VVJavA(SELF)
 9696:  @FFOAKH("Collecting Files ...", par=1)
 9697:  def VVa96Z(self, SELF, goToFile=None):
 9698:   lst = self.VV9Gev()
 9699:   if lst:
 9700:    wTxt = "Reading names ..."
 9701:    bg = "#11001020"
 9702:    VV2ytr = (""      , self.VVQ7kk    , [])
 9703:    VVwWmA = ("Delete File"   , self.VVF3D7   , [])
 9704:    VVwSzI = ("XML File Channels"  , BF(self.VVFnPM, False), [], wTxt)
 9705:    VVScQz = ("More Options"   , self.VVdbe3   , [])
 9706:    VV4QTJ = ("EPG for Current Chan" , BF(self.VVFnPM, True) , [], wTxt)
 9707:    header  = ("File" , "Size", "Type")
 9708:    widths  = (64  , 14 , 22 )
 9709:    VVLIqP = (LEFT  , CENTER, LEFT )
 9710:    self.tbl = FFUQ0v(self.SELF, None, title=self.Title, header=header, VVGape=lst, VVLIqP=VVLIqP, VV3cHe=widths, width=1600, VVwdmN=28, VV2ytr=VV2ytr, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ
 9711:         , VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#06554455", VVbcr0="#00333333")
 9712:   else:
 9713:    FFRMYv(self.SELF, BF(CCi3sj, self.SELF, BF(self.VVa96Z, self.SELF)), "No xml Files in:\n\n%s\n\nDownload ?" % self.xmltv_path, title=self.Title)
 9714:  def VV572m(self, newPath=None):
 9715:   if newPath:
 9716:    lst = self.VV9Gev()
 9717:    if lst:
 9718:     self.tbl.VVMqQ9(lst, VVDpzd=BF(self.VVpXyS, newPath), VV5YRVMsg=True)
 9719:  def VVpXyS(self, newPath, VV6A99, title, txt, colList):
 9720:   if newPath:
 9721:    self.tbl.VVn5CC(0, os.path.basename(newPath))
 9722:  def VV9Gev(self):
 9723:   lst = []
 9724:   for f in iGlob("%s*.xml" % self.xmltv_path):
 9725:    sz, typ = self.VVduuJ(f)
 9726:    if sz > -1:
 9727:     if   sz > 200000000 : c1 = "#f#00ff4000#"
 9728:     elif sz > 10000000 : c1 = "#f#00ff8033#"
 9729:     else    : c1 = "#f#00aaffaa#"
 9730:     lst.append((os.path.basename(f), c1 + CClYaF.VV99gM(sz, mode=4), typ))
 9731:   if lst : return sorted(lst, key=lambda x: x[0].lower())
 9732:   else : return []
 9733:  def VVduuJ(self, path):
 9734:   sz = FFXhoc(path)
 9735:   orng =   "#f#00ff8033#"
 9736:   if sz == -1:
 9737:    return sz, orng + "Not found"
 9738:   else:
 9739:    defF = CFG.xmlTvChannelRefFile.getValue()
 9740:    c1 = "#f#0055ff55#" if defF == os.path.basename(path) else "#f#00cccccc#"
 9741:    try:
 9742:     for ndx, (event, elem) in enumerate(iElem.iterparse(path, events=("start", ))):
 9743:      if ndx == 0:
 9744:       if   elem.tag == "tv"  : return sz, "#f#00888888#" + "Events"
 9745:       elif elem.tag == "channels" : return sz, c1 + "Reference"
 9746:       else      : return sz, orng + 'Unknown tag "%s"' % elem.tag
 9747:    except Exception as e:
 9748:     return sz, orng + str(e)[:50]
 9749:  def VVQ7kk(self, VV6A99, title, txt, colList):
 9750:   fName, szTxt, Type = VV6A99.VV5crm()
 9751:   ttl = lambda x, y: "%s:\n%s\n\n" % (FFjt5L(x, VVZtfx), y)
 9752:   txt  = ttl("File", fName)
 9753:   txt += ttl("Size", szTxt)
 9754:   txt += ttl("Type", Type)
 9755:   path = self.xmltv_path + fName
 9756:   if 1 < FFXhoc(path) < 500:
 9757:    txt += ttl("File Contents", FFYVq0(path).strip())
 9758:   FF4lCP(self.tbl, txt, title=title)
 9759:  def VVdbe3(self, VV6A99, title, txt, colList):
 9760:   fName, szTxt, Type = VV6A99.VV5crm()
 9761:   defF = CFG.xmlTvChannelRefFile.getValue()
 9762:   canView = defF and FFCyVu(self.xmltv_path + defF)
 9763:   self.curPath = self.xmltv_path + colList[0].strip()
 9764:   c1, c2, c3, c4 = VVJEMb, VVFuwR, VVZtfx, VV1fx4
 9765:   VV3wat = []
 9766:   VV3wat.append((c1 + "Change Current Channel"   , "zap"  ))
 9767:   VV3wat.append(VVAL3j)
 9768:   VV3wat.append((c2 + "Read Current Channel EPG"  , "curEv" ))
 9769:   VV3wat.append(VVAL3j)
 9770:   VV3wat.append((c2 + "Save Current Channel EPG"  , "saveCur" ))
 9771:   VV3wat.append((c2 + "Save Current Channel-Group EPG" , "saveGrp" ))
 9772:   VV3wat.append(VVAL3j)
 9773:   VV3wat.append((c3 + "Download XML-TV File"   , "dlnd" ))
 9774:   VV3wat.append(VVAL3j)
 9775:   VV3wat.append((c1 + "Analyze Selected XML File Tags" , "chk" ))
 9776:   VV3wat.append(VVAL3j)
 9777:   VV3wat.append(FFsLU5("View Channel-Reference Table" , "refTable", canView, c4))
 9778:   VV3wat.append((    "Set Channel-Reference File" , "refPick" ))
 9779:   VV3wat.append(VVAL3j)
 9780:   VV3wat.append(FFsLU5("Chain References to File Channels", "bind" , "Events" in Type , c1))
 9781:   FFLFTC(self.tbl, self.VVKU4F, VV3wat=VV3wat, width=950, VVyRCy=3, title="XML File Options", VVwltY="#11110022", VVkxBG="#11110022", VVoCB2="#08663300")
 9782:  def VVKU4F(self, item):
 9783:   if   item == "zap"  : CCYrUm.VVGvmp()
 9784:   elif item == "curEv" : CCDJgl.VVuIyO(self.tbl, cbf=self.VVnlje, toTable=True)
 9785:   elif item == "saveCur" : CCDJgl.VVuIyO(self.tbl, cbf=self.VV572m)
 9786:   elif item == "saveGrp" : CCDJgl.VVJavA(self.tbl, cbf=self.VV572m)
 9787:   elif item == "dlnd"  : CCi3sj(self.tbl, self.VV572m)
 9788:   elif item == "chk"  : self.VVmSkv(self.curPath)
 9789:   elif item == "refTable" : self.VVlVPK(self.tbl)
 9790:   elif item == "refPick" : self.VVcEfE()
 9791:   elif item == "bind"  : CCDJgl.VV8f7q(self.tbl, self.curPath)
 9792:  @FFOAKH(par=1)
 9793:  def VVlVPK(self, tbl):
 9794:   title = "Channel-Reference File (Error)"
 9795:   refLst, err = self.VVQhlB(self.xmltv_path + CFG.xmlTvChannelRefFile.getValue())
 9796:   if err:
 9797:    FFRMYv(self.tbl, self.VVcEfE, "%s\n\nOpen a new file ?" % (err), title=title)
 9798:    return
 9799:   elif not refLst:
 9800:    FFRMYv(self.tbl, self.VVcEfE, "No records in:\n%s\n\nOpen a new file ?" % (os.path.basename(self.curChanRefFile)), title=title)
 9801:    return
 9802:   refLst = [(nm, rf, CCYrUm.VVMJTa(rf, unknown="")) for nm, rf in refLst]
 9803:   bg = "
 9804:   refLst.sort(key=lambda x: x[0].lower())
 9805:   header   = ("Channel Name", "Reference" , "Source" )
 9806:   widths   = (46    , 42   , 12  )
 9807:   VVLIqP  = (LEFT    , LEFT   , CENTER )
 9808:   FFUQ0v(self.tbl, None, title=CFG.xmlTvChannelRefFile.getValue(), header=header, VVGape=refLst, VVLIqP=VVLIqP, VV3cHe=widths, width=1600, VVwdmN=28, VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#0a805000", VVbcr0="#00333333")
 9809:  def VVcEfE(self):
 9810:   title = "Channel-Reference File"
 9811:   defF = CFG.xmlTvChannelRefFile.getValue()
 9812:   lst = []
 9813:   for fName, szTxt, Type in self.tbl.VVrrm9():
 9814:    if "Reference" in Type:
 9815:     lst.append((FFjt5L(fName, VVSGsk) if fName == defF else fName, fName))
 9816:   if lst : FFLFTC(self.tbl, self.VVYU1b, VV3wat=sorted(lst, key=lambda x: x[1].lower()), title=title, width=1400)
 9817:   else : self.VVQ5VQ("No Channel-Reference files in:\n\n%s" % self.xmltv_path, title=title)
 9818:  def VVYU1b(self, fName):
 9819:   if fName:
 9820:    if self.xmltv_path + fName == self.xmltv_path + CFG.xmlTvChannelRefFile.getValue():
 9821:     FFjADj(self.tbl, "No change", 1000)
 9822:    else:
 9823:     FFjt1c(CFG.xmlTvChannelRefFile, fName)
 9824:     FFjADj(self.tbl, "Saved", 800, isGrn=True)
 9825:     defF = CFG.xmlTvChannelRefFile.getValue()
 9826:     for ndx, (fName, szTxt, Type) in enumerate(self.tbl.VVrrm9()):
 9827:      if "Reference" in Type:
 9828:       if fName == defF: color = "#0055ff55"
 9829:       else   : color = "#00cccccc"
 9830:       self.tbl.VVmMYI(ndx, 2, 8, FFRUST(color))
 9831:       self.tbl.VVmMYI(ndx, 2, 9, FFRUST(color))
 9832:  def VVRDQa(self):
 9833:   VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(self.tbl)
 9834:   if VV1wIO and VVPxk5:
 9835:    self.VVVvc0 = VVPxk5
 9836:    self.curChName = VV1wIO
 9837:    self.curChTitle = "Current Ch. : %s" % FFjt5L(self.curChName, VVGCYL)
 9838:    return True
 9839:   else:
 9840:    self.VVQ5VQ("Cannot get current channel data.")
 9841:    return False
 9842:  def VVF3D7(self, VV6A99, title, txt, colList):
 9843:   fName = colList[0].strip()
 9844:   FFRMYv(self.tbl, BF(self.VVaLYo, VV6A99, self.xmltv_path + fName), "Delete:\n\n%s" % fName, title=self.Title)
 9845:  def VVaLYo(self, VV6A99, path):
 9846:   FFwgGB(path)
 9847:   if FFCyVu(path):
 9848:    FF28n1(self.tbl, "Not deleted", 1000)
 9849:   else:
 9850:    VV6A99.VVtM2v()
 9851:    if VV6A99.VVn1uo() == 0:
 9852:     VV6A99.cancel()
 9853:  def VVFnPM(self, isCurChan, VV6A99, title, txt, colList):
 9854:   self.curPath = self.xmltv_path + colList[0].strip()
 9855:   if isCurChan and not self.VVRDQa():
 9856:    return
 9857:   self.VVAGJR(self.curPath)
 9858:   if self.curTotTags == -1:
 9859:    return
 9860:   chLst, err = self.VV3o1S(self.curPath)
 9861:   if not err:
 9862:    if isCurChan: self.VVAiqL(chLst)
 9863:    else  : self.VVN50a(chLst)
 9864:   VV6A99.VVrmMb()
 9865:  def VVAiqL(self, chLst):
 9866:   if self.VVRDQa():
 9867:    CCJaSw.VV5YpJ(self.tbl, CFG.xmlTvNameCompRatio, "Name Similarity Ratio (%)", cbFnc=BF(self.VVbGHQ, self.tbl, chLst), isSave=True)
 9868:  @FFOAKH("Filtering names ...", par=1)
 9869:  def VVbGHQ(self, tbl, chLst):
 9870:   mRatio  = CFG.xmlTvNameCompRatio.getValue()
 9871:   VVVvc0 = self.VVVvc0.rstrip(":").upper()
 9872:   curName  = self.curChName.lower()
 9873:   lst   = []
 9874:   for name, chId, VVPxk5, iconUrl, isIcon, isRef in chLst:
 9875:    if VVPxk5 == VVVvc0:
 9876:     lst.append((name, chId, "100", iconUrl, isIcon))
 9877:    else:
 9878:     tName = name.lower().replace(self.blackStar, "")
 9879:     span = iSearch(r".+[|:]\s*(.+)", tName)
 9880:     if span:
 9881:      tName = span.group(1) or name
 9882:     tName = " ".join([x for x in tName.split() if x not in self.skipLst])
 9883:     ratio = CCafIt.VV8e0X(curName, tName)
 9884:     if ratio > mRatio:
 9885:      lst.append((name, chId, str(ratio), iconUrl, isIcon))
 9886:   if lst:
 9887:    bg = "
 9888:    tName = "Closest Name ( > %s%% )" % mRatio
 9889:    lst.sort(key=lambda x: int(x[2]), reverse=True)
 9890:    VV2ytr = ("", self.VV6CHS  , [])
 9891:    VVu1YM  = ("", self.VVJGp2 , [], "Checking file ...")
 9892:    VVW5y5   = "OK = Filter New Events"
 9893:    header  = (tName, "ID" , "Ratio" , "iconUrl" , "PIcon" )
 9894:    widths  = (88 , 0  , 0   , 0   , 12  )
 9895:    VVLIqP = (LEFT , LEFT , CENTER , CENTER , CENTER )
 9896:    FFUQ0v(self.tbl, None, title=self.curChTitle, header=header, VVGape=lst, VVLIqP=VVLIqP, VV3cHe=widths, width=1200, VVwdmN=30, VV2ytr=VV2ytr, VVu1YM=VVu1YM, VVW5y5=VVW5y5, VVKDPJ=2
 9897:      , VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#0a805000", VVbcr0="#00333333")
 9898:   else:
 9899:    self.VVQ5VQ("No %s%% similar name in:\n\n%s" % (mRatio, os.path.basename(self.curPath)), title=self.curChName)
 9900:   self.tbl.VVrmMb()
 9901:  def VV6CHS(self, VV6A99, title, txt, colList):
 9902:   name, chId, ratio, iconUrl, isIcon = VV6A99.VV5crm()
 9903:   CCvjVs.VV0Xds(self.tbl, VV7VUc=CCvjVs.VVbSwV, title=title, params=(txt, iconUrl))
 9904:  def VVN50a(self, chLst):
 9905:   refLst, err = self.VVQhlB(self.xmltv_path + CFG.xmlTvChannelRefFile.getValue())
 9906:   if err:
 9907:    FFRMYv(self.tbl, self.VVcEfE, "%s\n\nOpen a new file ?" % (err), title="Channel-Reference File (error)")
 9908:    return
 9909:   refDict = dict(refLst)
 9910:   lst = []
 9911:   for name, chId, VVPxk5, iconUrl, isIcon, isRef in chLst:
 9912:    if not VVPxk5 and chId in refDict:
 9913:     VVPxk5, isRef = refDict[chId], "Yes"
 9914:    lst.append((name, chId, VVPxk5, iconUrl, isIcon, isRef))
 9915:   bg = "#0a302a20"
 9916:   lst.sort(key=lambda x: x[0].lower())
 9917:   VVlJfJ = self.VVfCDC
 9918:   VV2ytr = (""      , self.VVOmdx    , [])
 9919:   VVwSzI = ("Import EPG (Auto)"  , self.VVjpzD , [])
 9920:   VVScQz = ("Multi-Select"   , self.VV0uk9   , [])
 9921:   VV4QTJ = ("Filter EPG to File"  , self.VVzwHR  , [])
 9922:   header   = ("Channel", "ID" , "VVPxk5" , "iconUrl" , "PIcon" , "Ref.")
 9923:   widths   = (80  , 0  , 0   , 0   , 10  , 10 )
 9924:   VVLIqP  = (LEFT  , CENTER, CENTER , CENTER , CENTER , CENTER)
 9925:   FFUQ0v(self.tbl, None, title=os.path.basename(self.curPath), header=header, VVGape=lst, VVLIqP=VVLIqP, VV3cHe=widths, width=1300, VVwdmN=30, VV2ytr=VV2ytr, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVlJfJ=VVlJfJ
 9926:     , VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#00005566", VVbcr0="#00333333")
 9927:  def VVOmdx(self, VV6A99, title, txt, colList):
 9928:   name, chId, VVPxk5, iconUrl, isIcon, isRef = VV6A99.VV5crm()
 9929:   sat = CCYrUm.VVMJTa(VVPxk5, unknown="")
 9930:   txt  = "Channel\t: %s\n" % name
 9931:   if VVPxk5 : txt += "Reference\t: %s\n" % VVPxk5
 9932:   if sat  : txt += "Source\t: %s\n" % sat
 9933:   if iconUrl : txt += "\n%s:\n%s" % (FFjt5L("Icon URL", VVFuwR), iconUrl)
 9934:   CCvjVs.VV0Xds(self.tbl, VV7VUc=CCvjVs.VVbSwV, title=title, params=(txt, iconUrl))
 9935:  def VV0uk9(self, VV6A99, title, txt, colList):
 9936:   CCzSCo(self.SELF, VV6A99, addSep=False).VV9VR2(None, None, width=700)
 9937:  def VVfCDC(self, VV6A99):
 9938:   VV6A99.VVucBj()
 9939:   VV6A99.VVuDSc()
 9940:   if VV6A99.VVXWPu:
 9941:    VV6A99.VVO1tN("OK = Select")
 9942:    if VV6A99.VVc5NH():
 9943:     VV6A99.VVsd6P()
 9944:     VV6A99.VVbpCf()
 9945:   else:
 9946:    VV6A99.VVO1tN("")
 9947:    VV6A99.VVsd6P()
 9948:    VV6A99.VVbpCf()
 9949:  def VVzwHR(self, VV6A99, title, txt, colList):
 9950:   if VV6A99["keyBlue"].getVisible():
 9951:    if VV6A99.VVXWPu : tot = VV6A99.VVc5NH()
 9952:    else        : tot = 1
 9953:    FFRMYv(self.tbl, BF(self.VVSsBP, VV6A99), "Save data for %s selected channel%s to file ?" % (FFjt5L(tot, VVSGsk), FFcacr(tot)), title=self.curChTitle)
 9954:  def VVSsBP(self, VV6A99):
 9955:   CCh3tv.VV7Nf4(self.tbl, VVLL7M="Reading events ...", VVIZBP=CCh3tv.VVgJkc
 9956:       , VVixvy  = BF(self.VV0cfX, VV6A99)
 9957:       , VVbYwR = self.VVmEyX )
 9958:  def VV0cfX(self, VV6A99, VVXyP6):
 9959:   self.tmpPath = ""
 9960:   totTags = self.VVvoni(self.curPath, VVXyP6)
 9961:   if totTags == -1:
 9962:    return
 9963:   if not VVXyP6 or VVXyP6.isCancelled:
 9964:    return
 9965:   VVXyP6.VVq8NF(totTags)
 9966:   self.tmpTitle = "Filter EPG to File"
 9967:   self.tmpTotCh = self.tmpTotEv = self.tmpTotValid = self.tmpTotRep = 0
 9968:   if VV6A99.VVXWPu : rows = VV6A99.VVbF9W()
 9969:   else        : rows = [VV6A99.VV5crm()]
 9970:   idLst = [x[1] for x in rows]
 9971:   if not CCDJgl.VVyHvM(self.tbl, self.Title):
 9972:    return
 9973:   tName = FFfCtV(rows[0][0], r"-").replace(" ", "_")
 9974:   totCh = len(rows)
 9975:   if totCh > 1:
 9976:    tName += "_(+%s_other%s)" % (totCh - 1, FFcacr(totCh - 1))
 9977:   self.tmpPath = "%s_%s_%s.xml" % (self.curPath[:-4], tName, FFjTQe())
 9978:   self.tmpFileFooter = "</tv>\n"
 9979:   progLst = set()
 9980:   with open(self.tmpPath, "w") as f:
 9981:    f.write('<?xml version="1.0" encoding="UTF-8"?>\n')
 9982:    f.write('<tv generator-info-name="%s-%s-EPG-Filter">\n' % (VVh9hj, VVJ6zn))
 9983:    try:
 9984:     for event, elem in iElem.iterparse(self.curPath, events=("end", )):
 9985:      if not VVXyP6 or VVXyP6.isCancelled:
 9986:       return
 9987:      VVXyP6.VVxtQs(1)
 9988:      if elem.tag == "programme":
 9989:       prId = FFwW5m(elem, "channel")
 9990:       if prId in idLst:
 9991:        self.tmpTotEv += 1
 9992:        start = FFwW5m(elem, "start")
 9993:        stop  = FFwW5m(elem, "stop")
 9994:        if start and stop:
 9995:         tmpId = (start, stop, prId)
 9996:         if tmpId in progLst:
 9997:          self.tmpTotRep +=1
 9998:         else:
 9999:          self.tmpTotValid += 1
10000:          progLst.add(tmpId)
10001:          f.write(FFT8ma(elem)+ "\n")
10002:       elem.clear()
10003:      elif elem.tag == "channel":
10004:       if FFwW5m(elem, "id") in idLst:
10005:        self.tmpTotCh += 1
10006:        f.write(FFT8ma(elem) + "\n")
10007:       elem.clear()
10008:      if self.tmpTotCh:
10009:       totValid = FFjt5L(self.tmpTotValid, VVSGsk if self.tmpTotValid else VVYjI5)
10010:       if not VVXyP6 or VVXyP6.isCancelled:
10011:        return
10012:       VVXyP6.VVaks5("Channels: %s        Events: %s     Valid: %s" % (self.tmpTotCh, self.tmpTotEv, totValid))
10013:    except Exception as e:
10014:     self.VVre5F(str(e), title=self.tmpTitle)
10015:     VVXyP6.VVlmol()
10016:     return
10017:    f.write(self.tmpFileFooter)
10018:    self.tmpFileFooter = ""
10019:  def VVmEyX(self, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
10020:   if threadErr or self.tmpTotEv == 0:
10021:    FFwgGB(self.tmpPath)
10022:    if self.tmpTotEv == 0:
10023:     FFdw58(self.tbl, "No valid events.", title=self.tmpTitle)
10024:   else:
10025:    note = ""
10026:    if self.tmpFileFooter:
10027:     note = FFjt5L("\n\n  ... Cancelled at %s %%" % int(threadCounter * 100 / threadTotal), VVz22H)
10028:     with open(self.tmpPath, "a") as f:
10029:      f.write(self.tmpFileFooter)
10030:    repTxt = FFjt5L("   ( Repeated Event Time : %s )" % self.tmpTotRep, VVz22H) if self.tmpTotRep else ""
10031:    txt  = "Channels\t: %s\n" % self.tmpTotCh
10032:    txt += "Found Events\t: %s%s\n" % (self.tmpTotEv, repTxt)
10033:    txt += "Filtered Events\t: %s\n\n" % self.tmpTotValid
10034:    txt += "%s\n%s" % (FFjt5L("Output File:", VVSGsk), self.tmpPath)
10035:    txt += note
10036:    FF4lCP(self.tbl, txt, title=self.tmpTitle)
10037:    self.VV572m(self.tmpPath)
10038:  def VVmSkv(self, path):
10039:   CCh3tv.VV7Nf4(self.tbl, VVIZBP=CCh3tv.VVgJkc
10040:       , VVixvy  = self.VVTPh3
10041:       , VVbYwR = self.VVHwU4)
10042:  def VVTPh3(self, VVXyP6):
10043:   VVXyP6.VVNc18 = {}
10044:   totTags = self.VVvoni(self.curPath, VVXyP6)
10045:   if totTags == -1:
10046:    return
10047:   if not VVXyP6 or VVXyP6.isCancelled:
10048:    return
10049:   VVXyP6.VVaks5("Validating XML Tags ...")
10050:   VVXyP6.VVq8NF(totTags)
10051:   tDict = {}
10052:   try:
10053:    for event, elem in iElem.iterparse(self.curPath, events=("end", )):
10054:     if not VVXyP6 or VVXyP6.isCancelled:
10055:      return
10056:     VVXyP6.VVxtQs(1)
10057:     tDict[elem.tag] = tDict.get(elem.tag, 0) + 1
10058:     elem.clear()
10059:   except Exception as e:
10060:    VVXyP6.VVNc18["xErr"] = str(e)
10061:    return
10062:   if tDict:
10063:    lst = [(key, val) for key, val in tDict.items()]
10064:    lst.sort(key=lambda x: x[0].lower())
10065:    c1 = VVFuwR
10066:    txt  = FFjt5L("File:\n", c1)
10067:    txt += "%s\n\n" % self.curPath
10068:    txt += FFjt5L("XML Tags (total = %s):\n" % totTags, c1)
10069:    for key, val in lst:
10070:     txt += "%s\t: %s\n" % (key, val)
10071:    if not VVXyP6 or VVXyP6.isCancelled: return
10072:    VVXyP6.VVNc18["txt"] = txt
10073:    VVXyP6.VVNc18["ttl"] = "XML Tags Validation : %sOK" % VVSGsk
10074:   else:
10075:    VVXyP6.VVNc18["err"] = "No xml tags in:\n\n%s" % self.curPath
10076:  def VVHwU4(self, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
10077:   if   "err"  in VVNc18 : self.VVQ5VQ(VVNc18["err"])
10078:   elif "xErr" in VVNc18 : self.VVre5F(VVNc18["xErr"])
10079:   elif "txt"  in VVNc18 : FF4lCP(self.tbl, VVNc18["txt"], height=1050, title=VVNc18["ttl"])
10080:  def VVAGJR(self, path):
10081:   fName = os.path.basename(path)
10082:   sz = FFXhoc(path)
10083:   if sz > -1:
10084:    return True
10085:   else:
10086:    FF8Wsn(self.tbl, path, title=self.Title)
10087:    return False
10088:  def VVvoni(self, path, VVXyP6):
10089:   infPath = path + ".tot_tags"
10090:   try: sz, mTm = FFXhoc(path), os.path.getmtime(path)
10091:   except: sz, mTm = -1, 0
10092:   if not self.VVAGJR(path):
10093:    FFwgGB(infPath)
10094:    return -1
10095:   try:
10096:    tot = self.VV4Jmq(path, infPath, sz, mTm)
10097:    if tot:
10098:     return tot
10099:    else:
10100:     tot = 0
10101:     with ioOpen(path, "r", encoding="UTF-8") as f:
10102:      for line in f:
10103:       tot += line.count("</") + line.count("/>")
10104:       if not VVXyP6 or VVXyP6.isCancelled:
10105:        return -1
10106:       VVXyP6.VVaks5("Counting Tags : %s" % tot)
10107:      self.VVu262(path, infPath, tot, sz, mTm)
10108:      return tot
10109:   except Exception as e:
10110:    self.VVre5F(str(e))
10111:    FFwgGB(infPath)
10112:    return -1
10113:  def VVu262(self, path, infPath, tot, sz, mTm):
10114:   try:
10115:    with open(infPath, "w") as f:
10116:     f.write("%s,%s,%s" % (int(sz), mTm, tot))
10117:   except:
10118:    pass
10119:  def VV4Jmq(self, path, infPath, sz, mTm):
10120:   try:
10121:    sz1, mTm1, tot = FFYVq0(infPath).strip().split(",")
10122:    if (str(sz), str(mTm)) == (sz1, mTm1):
10123:     return int(tot)
10124:   except:
10125:    pass
10126:   FFwgGB(infPath)
10127:   return 0
10128:  @staticmethod
10129:  def VVQhlB(path):
10130:   if not CFG.xmlTvChannelRefFile.getValue(): return [], "This requires Channel-Reference File."
10131:   elif not FFCyVu(path)     : return [], ("File not found:\n%s" % path)
10132:   else          : return CCDJgl.VVQiv6(path)
10133:  @staticmethod
10134:  def VVQiv6(path):
10135:   lst = set()
10136:   err = ""
10137:   try:
10138:    for ndx, (event, elem) in enumerate(iElem.iterparse(path, events=("start", ))):
10139:     if ndx == 0 and elem.tag != "channels":
10140:      err = "Invalid Channel-Reference File !"
10141:      break
10142:     elif elem.tag == "channel":
10143:      chId = FFwW5m(elem, "id")
10144:      if chId:
10145:       VVPxk5 = FFax4p(elem)
10146:       span = iSearch(r"^((?:[A-Fa-f0-9]+:){9}(?:[A-Fa-f0-9]+))", VVPxk5)
10147:       if span:
10148:        lst.add((chId, span.group(1).upper()))
10149:     elem.clear()
10150:   except Exception as e:
10151:    err = str(e)
10152:   return list(lst), err
10153:  def VV3o1S(self, path, VVwb7n=True):
10154:   lst = set()
10155:   err = err1 = ""
10156:   try:
10157:    for ndx, (event, elem) in enumerate(iElem.iterparse(path, events=("start", ))):
10158:     if ndx == 0 and elem.tag != "tv":
10159:      err = "Not XML-TV Format:\n\n%s" % path
10160:      break
10161:     elif elem.tag == "channel":
10162:      chId = FFwW5m(elem, "id")
10163:      if chId:
10164:       name = FF6Tbq(elem, "display-name")
10165:       if name:
10166:        VVPxk5 = FF6Tbq(elem, "reference").rstrip(":").upper()
10167:        iconUrl = FFaJfl(elem, "icon", "src")
10168:        isIcon = "Yes" if iconUrl else ""
10169:        isRef = "Yes" if VVPxk5 else ""
10170:        lst.add((name, chId, VVPxk5, iconUrl, isIcon, isRef))
10171:      elem.clear()
10172:     elif elem.tag == "programme":
10173:      elem.clear()
10174:      break
10175:   except Exception as e:
10176:    err1 = str(e)
10177:   if not lst:
10178:    err = "No channel names in:\n\n%s" % os.path.basename(self.curPath)
10179:   if VVwb7n:
10180:    if   err : self.VVQ5VQ(err)
10181:    elif err1: self.VVre5F(err1)
10182:   return lst, err or err1
10183:  def VVl2nN(self, chIdSet, VVXyP6):
10184:   tab = lambda x, y: "%s\t: %s\n" % (x, y)
10185:   tabLst = lambda x, y: tab(x, " , ".join(y))
10186:   now  = int(iTime())
10187:   try:
10188:    chan = ""
10189:    for event, elem in iElem.iterparse(self.curPath, events=("start", )):
10190:     if not VVXyP6 or VVXyP6.isCancelled:
10191:      return
10192:     VVXyP6.VVxtQs(1)
10193:     if elem.tag == "programme":
10194:      self.tmpTotEv += 1
10195:      chan = FFwW5m(elem, "channel")
10196:      if chan in chIdSet:
10197:       startTS = self.VVpWUX(FFwW5m(elem, "start"))
10198:       stopTS  = self.VVpWUX(FFwW5m(elem, "stop"))
10199:       if startTS and stopTS and stopTS > startTS:
10200:        dur = stopTS - startTS
10201:        if startTS > now or now < startTS + dur:
10202:         self.tmpTotNew += 1
10203:         director = writer = producer = actor = rating = ""
10204:         Title = FF6Tbq(elem, "title")
10205:         descSh = FF6Tbq(elem, "sub-title")
10206:         descLng = FF6Tbq(elem, "desc")
10207:         Date = FF6Tbq(elem, "date")
10208:         country = FF6Tbq(elem, "country")
10209:         cat  = FFFE2m(elem, "category")
10210:         episode = FFFE2m(elem, "episode-num")
10211:         iconUrl = FFaJfl(elem, "icon", "src")
10212:         cred = elem.find("credits")
10213:         if not cred is None:
10214:          director= FFFE2m(cred, "director")
10215:          writer = FFFE2m(cred, "writer")
10216:          producer= FFFE2m(cred, "producer")
10217:          actor = FFFE2m(cred, "actor")
10218:         rate = elem.find("rating")
10219:         if not rate is None:
10220:          rSys = FFaJfl(elem, "rating", "system")
10221:          rating = FF6Tbq(rate, "value") + ((" (%s)" % rSys) if rSys else "")
10222:         desc = ""
10223:         if Date  : desc += tab("Date", Date)
10224:         if country : desc += tab("Country", country)
10225:         if rating : desc += tab("Rating", rating)
10226:         if cat  : desc += tabLst("Category", cat)
10227:         if episode : desc += tabLst("Episode", episode)
10228:         if director : desc += tabLst("Director", director)
10229:         if writer : desc += tabLst("Writer", writer)
10230:         if producer : desc += tabLst("Producer", producer)
10231:         if actor : desc += tabLst("Actors", actor)
10232:         if desc  : descLng = "%s\n\n%s" % (desc.rstrip(), descLng)
10233:         startTxt= FFTS4w(startTS).replace(" ", "   ")
10234:         startTS = str(int(startTS))
10235:         durTxt = FFFHEC(dur)
10236:         dur  = str(int(dur))
10237:         isDesc = "Yes" if desc else ""
10238:         isIcon = "Yes" if iconUrl else ""
10239:         yield chan, (startTxt, startTS, durTxt, dur, Title, descSh, descLng, iconUrl, isDesc, isIcon)
10240:        else:
10241:         self.tmpTotOld += 1
10242:         yield None, None
10243:     elif elem.tag == "channel":
10244:      pass
10245:     if elem.tag != "tv":
10246:      elem.clear()
10247:   except Exception as e:
10248:    self.tmpTotErr = str(e)
10249:    yield chan, None
10250:  def VVJGp2(self, VV6A99, title, txt, colList):
10251:   name, chId, ratio, iconUrl, isIcon = VV6A99.VV5crm()
10252:   self.displayName = name
10253:   CCh3tv.VV7Nf4(self.tbl, VVIZBP=CCh3tv.VVgJkc
10254:       , VVixvy  = BF(self.VV2SYm, {chId})
10255:       , VVbYwR = self.VVKr2D )
10256:   VV6A99.VVrmMb()
10257:  def VV2SYm(self, chIdSet, VVXyP6):
10258:   self.curTotTags = self.VVvoni(self.curPath, VVXyP6)
10259:   if self.curTotTags == -1:
10260:    return
10261:   if not VVXyP6 or VVXyP6.isCancelled:
10262:    return
10263:   VVXyP6.VVaks5("Reading Events ...")
10264:   VVXyP6.VVq8NF(self.curTotTags)
10265:   VVXyP6.VVNc18 = set()
10266:   self.tmpTotEv = self.tmpTotNew = self.tmpTotOld = 0
10267:   self.tmpTotErr = ""
10268:   for retChId, row in self.VVl2nN(chIdSet, VVXyP6):
10269:    if not VVXyP6 or VVXyP6.isCancelled:
10270:     return
10271:    if self.tmpTotErr:
10272:     self.VVre5F(self.tmpTotErr)
10273:     VVXyP6.VVlmol()
10274:     return
10275:    elif row:
10276:     VVXyP6.VVNc18.add(row)
10277:    txt = "Events: %d   (%s new)" % (self.tmpTotEv, FFjt5L(self.tmpTotNew, VVSGsk if self.tmpTotNew else VVYjI5))
10278:    VVXyP6.VVaks5(txt)
10279:  def VVKr2D(self, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
10280:   if threadErr:
10281:    pass
10282:   elif VVNc18:
10283:    self.VVnlje(FFjt5L(self.displayName, VV1fx4), VVNc18)
10284:   elif VVRI6P:
10285:    if self.tmpTotOld: txt = "No new event.\n\nFound %s expired event%s." % (self.tmpTotOld, FFcacr(self.tmpTotOld))
10286:    else     : txt = "No valid events data !"
10287:    self.VVQ5VQ(txt, title=self.curChName)
10288:  def VVnlje(self, VV1wIO, evLst):
10289:   if not self.VVRDQa():
10290:    return
10291:   title = "EPG for : %s" % VV1wIO
10292:   evLst = sorted(list(evLst), key=lambda x: int(x[1]))
10293:   VV2ytr = (""      , self.VVembo    , [])
10294:   VVwSzI = ("Import All Events"  , self.VVUVPi , [])
10295:   VVScQz = ("Reset Times"   , self.VV5BI8   , [])
10296:   VV4QTJ = ("Adjust All Start Time" , self.VV3b1s  , [])
10297:   header  = ("Start Time" , "start" ,"Duration" , "dur" , "Title" , "Summary" , "desc", "iconUrl" , "Descr." , "Poster" )
10298:   widths  = (20   , 0   , 10  , 0  , 30  , 26  , 0  , 0   , 7   , 7   )
10299:   VVLIqP = (CENTER  , CENTER ,CENTER  , CENTER, LEFT  , LEFT  , LEFT , LEFT  , CENTER , CENTER )
10300:   tbl = FFUQ0v(self.tbl, None, title=title, header=header, VVGape=evLst, VVLIqP=VVLIqP, VV3cHe=widths, width=1800, VVwdmN=24, VV2ytr=VV2ytr, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ)
10301:   tbl.VVAHUl()
10302:  def VVembo(self, VV6A99, title, txt, colList):
10303:   startTxt, startTS, durTxt, dur, Title, descSh, descLng, iconUrl, isDesc, isIcon = VV6A99.VV5crm()
10304:   ttl = lambda x, y: "%s:\n%s\n\n" % (FFjt5L(x, VVFuwR), y)
10305:   txt  = "Start Time\t: %s\n" % startTxt
10306:   txt += "Duration\t: %s\n\n" % durTxt
10307:   txt += ttl("Title", Title)
10308:   if descSh : txt += ttl("Summary", descSh)
10309:   if descLng: txt += ttl("Description", descLng)
10310:   CCvjVs.VV0Xds(self.tbl, VV7VUc=CCvjVs.VVbSwV, title=title, params=(txt, iconUrl))
10311:  def VVUVPi(self, VV6A99, title, txt, colList):
10312:   tot  = VV6A99.VVn1uo()
10313:   ques = "Add %s event%s to current channel from:\n\n%s" % (tot, FFcacr(tot), FFjt5L(self.displayName, VV1fx4))
10314:   FFRMYv(self.tbl, BF(self.VVFzpn, VV6A99), ques, title=self.curChTitle)
10315:  @FFOAKH(par=1)
10316:  def VVFzpn(self, VV6A99):
10317:   lst = []
10318:   for startTxt, startTS, durTxt, dur, Title, descSh, descLng, iconUrl, isDesc, isIcon in VV6A99.VVrrm9():
10319:    lst.append((int(startTS), int(dur), Title, descSh, descLng, 1))
10320:   totEv, totOK = CC5TsO.VV8M7K(self.VVVvc0, lst)
10321:   if totOK > 0:
10322:    CC5TsO.VVYLja()
10323:    CCYrUm.VV0iSP(self.tbl.session)
10324:   txt = "Total Events\t: %s\n" % totEv
10325:   txt += "Total Added\t: %s\n" % totOK
10326:   FF4lCP(self.tbl, txt, title=self.curChName)
10327:  def VVjpzD(self, VV6A99, title, txt, colList):
10328:   title = "Import EPG (Auto)"
10329:   if VV6A99.VVXWPu : rows = VV6A99.VVbF9W()
10330:   else        : rows = [VV6A99.VV5crm()]
10331:   totRef = 0
10332:   for name, chId, VVPxk5, iconUrl, isIcon, isRef in rows:
10333:    if VVPxk5: totRef += 1
10334:   totSel = len(rows)
10335:   if totRef:
10336:    ques = "Selected channels = %s ( %s with Reference )\n\nImport events for %s channel%s ?" % (totSel, totRef, totRef, FFcacr(totRef))
10337:    FFRMYv(self.tbl, BF(self.VVUWSc, title, rows), ques, title=title)
10338:   else:
10339:    s = FFcacr(totSel)
10340:    self.VVQ5VQ("No Reference%s for the selected channel%s in:\n\n%s" % (s, s, CFG.xmlTvChannelRefFile.getValue()), title=title)
10341:  def VVUWSc(self, title, rows):
10342:   CCh3tv.VV7Nf4(self.tbl, VVLL7M="Reading events ...", VVIZBP=CCh3tv.VVgJkc
10343:       , VVixvy  = BF(self.VVfz01, title, rows)
10344:       , VVbYwR = BF(self.VVWr3M, title) )
10345:  def VVfz01(self, title, rows, VVXyP6):
10346:   totTags = self.VVvoni(self.curPath, VVXyP6)
10347:   if totTags == -1:
10348:    return
10349:   if not VVXyP6 or VVXyP6.isCancelled:
10350:    return
10351:   VVXyP6.VVq8NF(totTags)
10352:   self.tmpTotEv = self.tmpTotNew = self.tmpTotOld = self.tmpTotAdd = self.tmpTotNoRef = self.tmpTotCh = self.tmpTotChDone = 0
10353:   self.tmpTotErr = ""
10354:   chIdSet = set()
10355:   refDict = {}
10356:   for name, chId, VVPxk5, iconUrl, isIcon, isRef in rows:
10357:    if iMatch(r"^([A-Fa-f0-9]+:){9}(?:[A-Fa-f0-9]+)", VVPxk5):
10358:     chIdSet.add(chId)
10359:     refDict[chId] = VVPxk5
10360:     self.tmpTotCh += 1
10361:    else:
10362:     self.tmpTotNoRef += 1
10363:   if not chIdSet:
10364:    self.VVQ5VQ("Channel Reference not found in file.", title=title)
10365:    return
10366:   lst = []
10367:   doneCh = set()
10368:   oldChId = newChId = ""
10369:   for retChId, row in self.VVl2nN(chIdSet, VVXyP6):
10370:    if not VVXyP6 or VVXyP6.isCancelled:
10371:     return
10372:    if self.tmpTotErr:
10373:     self.VVre5F(self.tmpTotErr)
10374:     VVXyP6.VVlmol()
10375:     return
10376:    elif row:
10377:     if not VVXyP6 or VVXyP6.isCancelled:
10378:      return
10379:     doneCh.add(retChId)
10380:     self.tmpTotChDone = len(doneCh)
10381:     VVPxk5 = refDict.get(retChId, "")
10382:     startTxt, startTS, durTxt, dur, Title, descSh, descLng, iconUrl, isDesc, isIcon = row
10383:     lst = [(int(startTS), int(dur), Title, descSh, descLng, 1)]
10384:     totEv, totOK = CC5TsO.VV8M7K(VVPxk5, lst)
10385:     self.tmpTotAdd += totOK
10386:    txt = "Events: %d   (%s new)" % (self.tmpTotEv, FFjt5L(self.tmpTotNew, VVSGsk if self.tmpTotNew else VVYjI5))
10387:    VVXyP6.VVaks5(txt)
10388:  def VVWr3M(self, title, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
10389:   if threadCounter > 0:
10390:    tab = lambda x, y: "%s\t: %s\n" % (x, y)
10391:    txt  = ""
10392:    txt += tab("Channels", self.tmpTotCh)
10393:    txt += tab("Processed", self.tmpTotChDone)
10394:    txt += "\n"
10395:    if self.tmpTotNoRef: txt += tab("No Reference", self.tmpTotNoRef)
10396:    txt += tab("Total Events", self.tmpTotNew + self.tmpTotOld)
10397:    txt += tab("Added Events", self.tmpTotAdd)
10398:    if self.tmpTotOld: txt += tab("Old Events", self.tmpTotOld)
10399:    if not threadCounter == threadTotal:
10400:     txt += FFjt5L("\n  ... Cancelled at %s %%" % int(threadCounter * 100 / threadTotal), VVz22H)
10401:    FF4lCP(self.tbl, txt, title=title, width=1500)
10402:    if self.tmpTotAdd > 0:
10403:     CC5TsO.VVYLja()
10404:     CCYrUm.VV0iSP(self.tbl.session)
10405:  def VV3b1s(self, VV6A99, title, txt, colList):
10406:   self.tbl.session.openWithCallback(BF(self.VV3mYS, VV6A99), CCiEqS, "Adjust Event Start Time")
10407:  @FFOAKH(par=1)
10408:  def VV3mYS(self, VV6A99, sec=None):
10409:   if sec is not None:
10410:    if sec == 0:
10411:     newSec = -self.adjustedTime
10412:     self.adjustedTime = 0
10413:    else:
10414:     newSec = sec
10415:     self.adjustedTime += sec
10416:    lst = []
10417:    for ndx, (startTxt, startTS, durTxt, dur, Title, descSh, descLng, iconUrl, isDesc, isIcon) in enumerate(VV6A99.VVrrm9()):
10418:     startTS = int(startTS) + newSec
10419:     startTxt =  FFTS4w(startTS).replace(" ", "   ")
10420:     lst.append((startTxt, str(startTS), durTxt, dur, Title, descSh, descLng, iconUrl, isDesc, isIcon))
10421:    VV6A99.VVMqQ9(lst)
10422:    if self.adjustedTime:
10423:     VV6A99.VVQ7id()
10424:     VV6A99["keyYellow"].setText("Reset Times ( %s %s )" % ("-" if self.adjustedTime < 0 else "+", FFFHEC(abs(self.adjustedTime))))
10425:    else:
10426:     VV6A99.VVAHUl()
10427:  def VV5BI8(self, VV6A99, title, txt, colList):
10428:   self.VV3mYS(VV6A99, 0)
10429:  def VVpWUX(self, tm):
10430:   try:
10431:    span = iSearch(r"(\d{14})(?:\s+([+-])(\d\d)(\d\d))*", tm)
10432:    if span:
10433:     dateTime, sign, hh,mm = span.groups()
10434:     tStamp = mktime(datetime.strptime(dateTime, "%Y%m%d%H%M%S").timetuple())
10435:     if sign and hh and mm:
10436:      gmt = (int(hh) * 3600 + int(mm) * 60)
10437:      if sign == "-":
10438:       gmt *= -1
10439:      tStamp -= gmt
10440:     return tStamp - iTimezone
10441:   except:
10442:    pass
10443:   return 0
10444:  def VVQ5VQ(self, err, title=""):
10445:   FFdw58(self.tbl, err, title=title or self.Title)
10446:  def VVre5F(self, err, title=""):
10447:   CCwnHL.VVBfGR(self.tbl, os.path.basename(self.curPath), str(err), title=title or self.Title)
10448:  @staticmethod
10449:  def VVLnhF(timeStamp):
10450:   return datetime.fromtimestamp(timeStamp + iTimezone).strftime("%Y%m%d%H%M%S +0000")
10451:  @staticmethod
10452:  def VVX583(txt):
10453:   return txt.replace("&", "&#38;")
10454:  @staticmethod
10455:  def VVZwxs(txt):
10456:   d = { "&lt;" : "<" , "&#60;": "<"
10457:    , "&gt;" : ">" , "&#62;": ">"
10458:    , "&apos;" : "'" , "&#39;": "'", "&#x27;": "'"
10459:    , "&quot;" : '"' , "&#34;": '"'
10460:    , "&amp;" : "&" , "&#38;": "&"
10461:    , "&nbsp;" : " "
10462:    , "&#09;" : "\t"
10463:    , "&#10;" : "\n"
10464:    , "&#13;" : "\n"
10465:    , "&#91;" : "["
10466:    , "&#93;" : "]"
10467:    , "&#124;" : "|"
10468:    }
10469:   for key, val in d.items():
10470:    if key in txt:
10471:     txt = txt.replace(key, val)
10472:   return txt
10473:  @staticmethod
10474:  def VVyHvM(SELF, title=""):
10475:   path = FF0cqc() + "epg/"
10476:   if FFpwZS("mkdir -p '%s'" % path):
10477:    return path
10478:   else:
10479:    FFdw58(SELF, "Cannot create EPG directory:\n\n%s" % path, title=title or FFGNZA().strip())
10480:    return ""
10481:  @staticmethod
10482:  def VVT11L():
10483:   path = FF0cqc() + "epg/"
10484:   fName = "ajpanel_channels.xml"
10485:   refF = path + fName
10486:   if not FFCyVu(refF) and FFpwZS("mkdir -p '%s'" % path):
10487:    with open(refF, "w") as f:
10488:     f.write('<?xml version="1.0" encoding="utf-8"?>\n<channels>\n</channels>\n')
10489:  @staticmethod
10490:  @FFOAKH()
10491:  def VVuIyO(SELF, cbf=None, toTable=False):
10492:   title = "Read Current Channel EPG" if toTable else "Seve Current Channel Events"
10493:   VVwb7n = lambda x: FFdw58(SELF, x, title=title)
10494:   VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(SELF)
10495:   if not VV1wIO or not VVPxk5:
10496:    VVwb7n("Cannot get current channel data.")
10497:    return
10498:   ec, inst = CC5TsO.VVo0fG()
10499:   if not inst:
10500:    VVwb7n("Cannot access EPG Cache !")
10501:    return
10502:   try:
10503:    evList = inst.lookupEvent([CC5TsO.VVhAdK, (VVPxk5.rstrip(":"), 0, -1, -1)])
10504:   except:
10505:    evList = []
10506:   if not evList:
10507:    FFdw58(SELF, "No EPG.", title=VV1wIO)
10508:    return
10509:   lst = []
10510:   for start, dur, Title, descrS, descrL, pc, genre in evList:
10511:    startTxt= FFTS4w(start).replace(" ", "   ")
10512:    startTS = str(int(start))
10513:    durTxt = FFFHEC(dur)
10514:    if descrS == "Not Applicable":
10515:     descrS = ""
10516:    more = ""
10517:    if pc:
10518:     for Sys, val in pc: more += "Parental Control (%s) : %s\n" % (Sys.strip(), val)
10519:    if genre:
10520:     for g in genre: more += "Genre : %s\n" % str(g)
10521:    if more:
10522:     descrL = more.rstrip() + ("\n" + descrL if descrL else "")
10523:    lst.append((startTxt, startTS, FFFHEC(dur), str(int(dur)), Title, descrS, descrL, "", "Yes" if descrL else "", ""))
10524:   if toTable:
10525:    cbf(FFjt5L(VV1wIO, VVSGsk), lst)
10526:    return
10527:   epgDir = CCDJgl.VVyHvM(SELF, title)
10528:   if not epgDir:
10529:    return
10530:   tName = FFfCtV(VV1wIO, r"-").replace(" ", "_")
10531:   path = "%sajpanel_xmltv_%s_%s.xml" % (epgDir, tName, FFjTQe())
10532:   with open(path, "w") as f:
10533:    if not VVPxk5.endswith(":"): VVPxk5 += ":"
10534:    f.write('<?xml version="1.0" encoding="UTF-8"?>\n')
10535:    f.write('<tv generator-info-name="%s-%s-EPG-Export">\n' % (VVh9hj, VVJ6zn))
10536:    f.write('<channel id="%s"><display-name lang="en">%s</display-name></channel>\n' % (VV1wIO, VV1wIO))
10537:    f.write('<channel id="%s"><display-name lang="en">%s</display-name><reference>%s</reference></channel>\n' % (VV1wIO, VV1wIO, VVPxk5))
10538:    for startTxt, startTS, durTxt, dur, Title, descSh, descLng, iconUrl, isDesc, isIcon in lst:
10539:     end = int(startTS) + int(dur)
10540:     start = CCDJgl.VVLnhF(int(startTS))
10541:     stop  = CCDJgl.VVLnhF(end)
10542:     f.write('<programme start="%s" stop="%s" channel="%s">\n'   % (start, stop, VV1wIO))
10543:     f.write('\t<title lang="en">%s</title>\n'      % CCDJgl.VVX583(Title))
10544:     if descSh: f.write('\t<sub-title lang="en">%s</sub-title>\n' % CCDJgl.VVX583(descSh))
10545:     f.write('\t<desc lang="en">%s</desc>\n'       % CCDJgl.VVX583(descLng))
10546:     f.write('</programme>\n')
10547:    f.write("</tv>\n")
10548:   tot = len(evList)
10549:   FFipXT(SELF, "Saved %d event%s to:\n\n%s\n%s" % (tot, FFcacr(tot), epgDir, os.path.basename(path)), title=VV1wIO)
10550:   if cbf: cbf(path)
10551:  @staticmethod
10552:  @FFOAKH()
10553:  def VVJavA(SELF, cbf=None):
10554:   title = "Save EPG to File"
10555:   VVwb7n = lambda x: FFdw58(SELF, x, title=title)
10556:   ec, inst = CC5TsO.VVo0fG()
10557:   if not inst:
10558:    VVwb7n("Cannot access EPG Cache !")
10559:    return
10560:   srvLst = CCMvE7.VVqZTI()
10561:   if not srvLst:
10562:    VVwb7n("No services found in:\n\n%s" % rootSrc)
10563:    return
10564:   srvLst.sort(key=lambda x: x[1].lower())
10565:   srvLst = [[VV1wIO, VVPxk5.rstrip(":"), 0] for x, (VVPxk5, VV1wIO) in enumerate(srvLst)]
10566:   epgDir = CCDJgl.VVyHvM(SELF, title)
10567:   if not epgDir:
10568:    return
10569:   VVPxk5, refName, rootRef, rootName, inBouquet, rootSrc = CCjThi.VVZhZh()
10570:   path  = "%sajpanel_xmltv_%s_%s.xml" % (epgDir, FFfCtV(rootName or rootSrc, r"_"), FFjTQe())
10571:   tPath = "/tmp/ajp_xmltv"
10572:   totChk = totCh = totEv = totPc = totGenre = 0
10573:   with open(tPath, "w") as f:
10574:    for ndx, (VV1wIO, VVPxk5, flag) in enumerate(srvLst):
10575:     totChk += 1
10576:     try:
10577:      evList = inst.lookupEvent([CC5TsO.VVhAdK, (VVPxk5.rstrip(":"), 0, -1, -1)])
10578:     except:
10579:      evList = []
10580:     if evList:
10581:      srvLst[ndx][2] = 1
10582:      totCh += 1
10583:      totEv += len(evList)
10584:      for start, dur, Title, descrS, descrL, pc, genre in evList:
10585:       end = start + dur
10586:       start = CCDJgl.VVLnhF(start)
10587:       stop  = CCDJgl.VVLnhF(end)
10588:       f.write('<programme start="%s" stop="%s" channel="%s">\n' % (start, stop, VV1wIO))
10589:       f.write('\t<title lang="en">%s</title>\n'    % CCDJgl.VVX583(Title))
10590:       if descrS and not "Not Applicable" in descrS:
10591:        f.write('\t<sub-title lang="en">%s</sub-title>\n' % CCDJgl.VVX583(descrS))
10592:       f.write('\t<desc lang="en">%s</desc>\n'     % CCDJgl.VVX583(descrL))
10593:       if pc:
10594:        for Sys, val in pc:
10595:         totPc += 1
10596:         f.write('\t<rating system="%s"><value>%s</value></rating>\n' % (Sys.strip(), val))
10597:       if genre:
10598:        for item in genre:
10599:         totGenre += 1
10600:         f.write('\t<category lang="en">%s</category>\n' % str(item))
10601:       f.write('</programme>\n')
10602:   if totEv:
10603:    err = ""
10604:    try:
10605:     with open(path, "w") as f:
10606:      f.write('<?xml version="1.0" encoding="UTF-8"?>\n')
10607:      f.write('<tv generator-info-name="%s-%s-EPG-Export">\n' % (VVh9hj, VVJ6zn))
10608:      for VV1wIO, VVPxk5, flag in srvLst:
10609:       if flag:
10610:        if not VVPxk5.endswith(":"): VVPxk5 += ":"
10611:        f.write('<channel id="%s"><display-name lang="en">%s</display-name><reference>%s</reference></channel>\n' % (VV1wIO, VV1wIO, VVPxk5))
10612:      with open(tPath, "r") as tmpf:
10613:       for line in tmpf.readlines():
10614:        f.write(line)
10615:      f.write("</tv>\n")
10616:     tab = lambda x, y: "%s\t: %s\n" % (x, y)
10617:     txt  = ""
10618:     txt += tab("Group", rootSrc)
10619:     txt += tab("Name", rootName or rootSrc)
10620:     txt += "\n"
10621:     txt += tab("Channels", totCh)
10622:     txt += tab("Events", totEv)
10623:     if totGenre : txt += tab("Category", totGenre)
10624:     if totPc : txt += tab("P. Control", totPc)
10625:     txt += "\n%s\n%s" % (FFjt5L("Output File:", VVSGsk), path)
10626:     FF4lCP(SELF, txt, title=title, width=1500)
10627:     if cbf: cbf(path)
10628:    except Exception as e:
10629:     FFwgGB(path)
10630:     VVwb7n("Error during data export:\n\n%s" % str(e))
10631:   else:
10632:    FFdw58(SELF, "No EPG from %s channel%s in:\n\n%s" % (totChk, FFcacr(totChk), rootName or rootSrc), title=VV1wIO)
10633:   FFwgGB(tPath)
10634:  @staticmethod
10635:  def VVtrWY(path):
10636:   lst = set()
10637:   try:
10638:    for ndx, (event, elem) in enumerate(iElem.iterparse(path, events=("start", ))):
10639:     if ndx == 0 and elem.tag != "tv":
10640:      return [], "File is not XML-TV Format:\n%s" % FFjt5L(path, VVYjI5)
10641:      break
10642:     elif elem.tag == "channel":
10643:      chId = FFwW5m(elem, "id")
10644:      name = FF6Tbq(elem, "display-name")
10645:      if chId and name:
10646:       lst.add((name, chId))
10647:      elem.clear()
10648:     elif elem.tag == "programme":
10649:      elem.clear()
10650:      break
10651:   except Exception as e:
10652:    return [], str(e)
10653:   return sorted(list(lst)), ""
10654:  @staticmethod
10655:  @FFOAKH("Validating Files ...")
10656:  def VV8f7q(SELF, epgF):
10657:   title = "Chain Channel Reference to XML-TV Channel Name"
10658:   epgDir = CCDJgl.VVyHvM(SELF, title)
10659:   if epgDir: outF = epgDir + "ajpanel_channels.xml"
10660:   else  : return
10661:   if FFCyVu(outF):
10662:    chkLst, err = CCDJgl.VVQiv6(outF)
10663:    if err:
10664:     CCwnHL.VVBfGR(SELF, outF, err, title=title)
10665:     return
10666:    else:
10667:     chkLst = [(ref + ":", id, id) for id, ref in chkLst]
10668:   else:
10669:    chkLst = []
10670:   lst, err = CCDJgl.VVtrWY(epgF)
10671:   if err:
10672:    CCwnHL.VVBfGR(SELF, outF, err, title=title)
10673:   else:
10674:    try:
10675:     SELF.session.open(CCjS4V, lst, chkLst=chkLst, srcPath=epgF, dstPath=outF
10676:         , title=title, mnuTitle2="XMLTV Display Name", mnuTitle3="XMLTV Channel ID", blueTitle="Add Entry"
10677:         , blueFnc=CCDJgl.VV0sVM, delFnc=CCDJgl.VVPrBx)
10678:    except:
10679:     pass
10680:  @staticmethod
10681:  @FFOAKH()
10682:  def VV0sVM(bindCls):
10683:   title= bindCls.Title
10684:   outF = bindCls.dstPath
10685:   d  = bindCls.VVzYMA()
10686:   if not d["VVPxk510"]:
10687:    FFjADj(bindCls, "Invalid Reference !", 800)
10688:    return
10689:   line = '\t<!-- %s --><channel id="%s">%s</channel><!-- %s -->\n' % (d["source"], d["mnuRef"], d["VVPxk510"], d["name"])
10690:   try:
10691:    if FFCyVu(outF):
10692:     txt = FFYVq0(outF)
10693:     with open(outF, "w") as f:
10694:      f.write(txt.replace("</channels>", "").strip() + "\n%s\n</channels>\n" % line)
10695:    else:
10696:     with open(outF, "w") as f:
10697:      f.write('<?xml version="1.0" encoding="utf-8"?>\n')
10698:      f.write('<channels>\n\n')
10699:      f.write(line)
10700:      f.write('\n</channels>\n')
10701:    FFG2sB(bindCls, "Saved", 800)
10702:    bindCls.VVfC5O((d["VVPxk510"], d["mnuRef"], d["mnuTxt"]))
10703:   except Exception as e:
10704:    CCwnHL.VVBfGR(bindCls, outF, e, title=title)
10705:  @staticmethod
10706:  @FFOAKH()
10707:  def VVPrBx(bindCls):
10708:   title= bindCls.Title
10709:   outF = bindCls.dstPath
10710:   d  = bindCls.VVzYMA()
10711:   try:
10712:    lines = FFL19l(outF, keepends=True)
10713:    with open(outF, "w") as f:
10714:     for line in lines:
10715:      if not d["mnuRef"] in line and not d["VVPxk510"] in line:
10716:       f.write(line)
10717:    FFG2sB(bindCls, "Deleted", 800)
10718:    bindCls.VVNA0C((d["VVPxk510"], d["mnuRef"], d["mnuTxt"]))
10719:   except Exception as e:
10720:    CCwnHL.VVBfGR(bindCls, outF, e, title=title)
10721: class CCjS4V(ChannelSelectionBase):
10722:  def __init__(self, session, VV3wat, chkLst=None, srcPath="", dstPath="", pickMode=0, perc1=50, aligns2=None, widths2=None, fonts2=None, title="", mnuTitle1="", mnuTitle2="", mnuTitle3="", blueTitle="", blueFnc=None, delFnc=None, tBg="
10723:   self.skin, self.VVfOli = FFiNEe(VVkFCt, 1800, 1000, 30, 10, 10, tBg, bBg, 30, VVeFSs=40, VV0Ay7=2, VVUuJZ={"perc1": perc1, "perc2": widths2[0] if widths2 else 50, "tbg1": tBg1, "tbg2": tBg2, "bg1": bg1, "bg2": bg2})
10724:   self.session  = session
10725:   self.VV3wat  = VV3wat
10726:   self.chkLst   = chkLst or []
10727:   self.srcPath  = srcPath
10728:   self.dstPath  = dstPath
10729:   self.pickMode  = pickMode
10730:   self.aligns2  = aligns2
10731:   self.widths2  = widths2
10732:   self.fonts2   = fonts2
10733:   self.Title   = title or "Chain Channel Reference"
10734:   self.mnuTitle1  = mnuTitle1 or "Source Channels"
10735:   self.mnuTitle2  = mnuTitle2
10736:   self.mnuTitle3  = mnuTitle3
10737:   self.blueTitle  = blueTitle or "Add Selection to file"
10738:   self.blueFnc  = blueFnc
10739:   self.delFnc   = delFnc
10740:   self.bg2   = bg2
10741:   self.totRows  = 18
10742:   self.VV8c7y  = 40
10743:   self.curMenu  = 1
10744:   self.VVwdmN  = int(self.VV8c7y * 0.82)
10745:   self.cursCur  = "#08885500"
10746:   self.cursNorm  = "#08223333"
10747:   self.curRef   = ""
10748:   self.cancelTime  = 0
10749:   self.added   = False
10750:   self.lastChannel = self.VVtpQU()
10751:   self.tpData   = CC3Z54()
10752:   self.isVti   = CC674y.VV1LWx()
10753:   FFZMxC(self, title=self.Title)
10754:   self["myMenu"]  = MenuList([], True, eListboxPythonMultiContent)
10755:   self["myTitle1"] = Label(self.mnuTitle1)
10756:   self["myTitle2"] = Label(self.mnuTitle2)
10757:   self["myTitle3"] = Label(self.mnuTitle3)
10758:   self["myFrm1"]  = Label()
10759:   self["myFrm2"]  = Label()
10760:   FFRLNq(self["keyRed"] , "Group = Favourite")
10761:   FFRLNq(self["keyGreen"] , "Show Chains")
10762:   FFRLNq(self["keyYellow"], "Find Close Name")
10763:   FFRLNq(self["keyBlue"] , self.blueTitle)
10764:   if self.pickMode == 0: self["keyBlue"].hide()
10765:   self["keyGreen"].hide()
10766:   try:
10767:    from difflib import get_close_matches as iClosest
10768:    self.iClosest = iClosest
10769:   except:
10770:    self.iClosest = None
10771:   ChannelSelectionBase.__init__(self, session)
10772:   self.bouquet_mark_edit = 0
10773:   FFHlAU(self,
10774:   {
10775:    "ok"  : self.VVPr1F  ,
10776:    "cancel" : self.cancel  ,
10777:    "info"  : self.VVauE3 ,
10778:    "menu"  : self.VVEzGg ,
10779:    "tv"  : self.VVQVyP,
10780:    "red"  : self.VVp5CU ,
10781:    "green"  : self.VVgd7n,
10782:    "yellow" : self.VVSXdh,
10783:    "blue"  : self.VVsL1P ,
10784:    "down"  : self.VVDBsZ  ,
10785:    "up"  : self.VVx0di   ,
10786:    "left"  : self.VVziFC  ,
10787:    "right"  : self.VVLe1s  ,
10788:    "pageUp" : self.VVLlE3  ,
10789:    "chanUp" : self.VVLlE3  ,
10790:    "pageDown" : self.VVSYHQ ,
10791:    "chanDown" : self.VVSYHQ ,
10792:    "next"  : self.VVylpm  ,
10793:    "last"  : self.VVGc2k
10794:   }, name="ChannelSelectBaseActions", prio=-2)
10795:   FFHlAU(self, {})
10796:   self.onShown.append(self.VV7OzD)
10797:   self.onClose.append(self.onExit)
10798:  def VV7OzD(self):
10799:   self.onShown.remove(self.VV7OzD)
10800:   FF6W0I(self)
10801:   FFWgBS(self)
10802:   obj  = self["myMenu"]
10803:   objL = obj.l
10804:   self.VV64T6()
10805:   FF4IPF(obj, bg=self.cursNorm)
10806:   objL.setFont(0, gFont(VVNhAq, self.VVwdmN))
10807:   objL.setFont(1, gFont(VVNhAq, int(self.VVwdmN * 0.7)))
10808:   objL.setItemHeight(self.VV8c7y)
10809:   obj.setList(self.VV23Cq())
10810:   obj.setList(obj.list)
10811:   obj  = self["list"]
10812:   objL = obj.l
10813:   self.setTvMode()
10814:   self.showFavourites()
10815:   obj.setMode(1)
10816:   self.VV3sWT()
10817:   FF4IPF(obj, bg=self.cursCur)
10818:   obj.onSelectionChanged.append(self.VVFA1G)
10819:   objL.setItemHeight(self.VV8c7y)
10820:   try:
10821:    objL.setColor(objL.eventForeground, parseColor("#00ffffaa"))
10822:    objL.setItemsDistances(15)
10823:   except:
10824:    pass
10825:   objL.setColor(objL.serviceEventProgressbarColor, parseColor("#0000ff00"))
10826:   objL.setColor(objL.serviceEventProgressbarColorSelected, parseColor("#0000ff00"))
10827:   objL.setColor(objL.serviceEventProgressbarBorderColor, parseColor("#00ffffff"))
10828:   self.VVvDEf()
10829:   self.VVRUZw()
10830:  def onExit(self):
10831:   self["list"].onSelectionChanged = []
10832:  def VVEzGg(self):
10833:   VV3wat = []
10834:   VV3wat.append(("Go to Current Playing Channel" , "cur" ))
10835:   VV3wat.append(("Go to Original Playing Channel" , "orig"))
10836:   if self.chkLst:
10837:    VV3wat.append(VVAL3j)
10838:    VV3wat.append(("Next Chained Service"  , "chain0"))
10839:    VV3wat.append(("Previous Chained Service" , "chain1"))
10840:   if self.delFnc:
10841:    VV3wat.append(VVAL3j)
10842:    VV3wat.append(FFsLU5("Delete Selected Chain", "del" , self.VVuUsf(), VVz22H))
10843:   VV3wat.append(VVAL3j)
10844:   VV3wat.append(("Exit  (or double-Cancel)", "exit"))
10845:   FFLFTC(self, self.VVeDfm, title="Options", VV3wat=VV3wat)
10846:  def VVeDfm(self, item):
10847:   if item:
10848:    if   item == "cur"  : self.VVqfeT(False)
10849:    elif item == "orig"  : self.VVqfeT(True)
10850:    elif item == "chain0" : self.VVUSFL()
10851:    elif item == "chain1" : self.VVSefD()
10852:    elif item == "del"  : self.VVN1I2()
10853:    elif item == "exit"  : self.close()
10854:  def VVPr1F(self):
10855:   if self.curMenu == 1:
10856:    serv = self.getCurrentSelection()
10857:    if serv.flags & 7 == 7:
10858:     self.enterPath(serv)
10859:     if not len(self.servicelist.getList()):
10860:      self.keyGoUp()
10861:      FF28n1(self, "No Services", 500)
10862:     self.VV3sWT()
10863:     serv = self.session.nav.getCurrentlyPlayingServiceReference()
10864:     if serv:
10865:      try: self.setCurrentSelectionAlternative(serv)
10866:      except: self.setCurrentSelection(serv)
10867:    elif serv.flags == 0:
10868:     FFnfiC(self.session, self.curRef)
10869:     FFSqRh(self, "Cancel to go back to table")
10870:   self.VVRUZw()
10871:  def VVN1I2(self):
10872:   self.delFnc(self)
10873:   self.VVRUZw()
10874:  def cancel(self):
10875:   serv = self.getCurrentSelection()
10876:   if iTime() - self.cancelTime < 0.6:
10877:    self.close()
10878:   elif self.curMenu == 2:
10879:    self.VVziFC()
10880:   elif len(self.servicePath) <= 1:
10881:    FF28n1(self, "Double Cancel to exit", 500)
10882:    self.cancelTime = iTime()
10883:   else:
10884:    self.keyGoUp()
10885:    self.VV3sWT()
10886:    self.VVRUZw()
10887:    self.cancelTime = iTime()
10888:  def VVauE3(self):
10889:   lst= []
10890:   d  = self.VVzYMA()
10891:   def VVZwiy(x, y):
10892:    if y: lst.append((c + x, y))
10893:   c, s = "#b#11440044#", "Source Channel - "
10894:   VVZwiy(s + "Name"  , d["name"])
10895:   VVZwiy(s + "Reference" , "" if "ORDER BY" in d["noPhpRef"] else d["noPhpRef"])
10896:   VVZwiy(s + "Source" , d["source"] + (" (%s)" % d["satLong"]) if d["satLong"] else "")
10897:   VVZwiy(s + "Path"  , d["path"])
10898:   VVZwiy(s + "Parent" , d["rootName"])
10899:   VVZwiy(s + "ParentPath", d["rootPath"])
10900:   c, s = "#b#11001122#", "Destination Channel - "
10901:   VVZwiy(s + "Row Number", "%d of %d" % (d["mnuRowNum"], len(self.VV3wat)))
10902:   VVZwiy(s + self.mnuTitle2, d["mnuTxt"])
10903:   VVZwiy(s + self.mnuTitle3, d["mnuRef"])
10904:   VVZwiy(s + "Source File", self.srcPath)
10905:   VVZwiy(s + "Output File", self.dstPath)
10906:   FFUQ0v(self, None, title=self.Title, VVGape=lst, VV3cHe=(40, 60), width=1700, VVwdmN=28, VVJKqd="#0a333333", VVbcr0="#00333333", VVKDPJ=1)
10907:  def VVgd7n(self):
10908:   if self["keyGreen"].getVisible():
10909:    self.VVGCzn()
10910:  def VVsL1P(self):
10911:   if self["keyBlue"].getVisible():
10912:    if self.added:
10913:     FFjADj(self, "Already Added.", 1000)
10914:    else:
10915:     self.blueFnc(self)
10916:     self.VVFA1G()
10917:  def VVx0di(self):
10918:   if self.curMenu == 1: self.moveUp()
10919:   else    : self["myMenu"].up()
10920:   self.VVRUZw()
10921:  def VVDBsZ(self):
10922:   if self.curMenu == 1: self.moveDown()
10923:   else    : self["myMenu"].down()
10924:   self.VVRUZw()
10925:  def VVLlE3(self):
10926:   if self.curMenu == 1: self.servicelist.instance.moveSelection(self.servicelist.instance.pageUp)
10927:   else    : self["myMenu"].pageUp()
10928:   self.VVRUZw()
10929:  def VVSYHQ(self):
10930:   if self.curMenu == 1: self.servicelist.instance.moveSelection(self.servicelist.instance.pageDown)
10931:   else    : self["myMenu"].pageDown()
10932:   self.VVRUZw()
10933:  def VVGc2k(self):
10934:   if self.curMenu == 1: self["list"].moveToPrevMarker()
10935:   else    : self["myMenu"].moveToIndex(0)
10936:  def VVylpm(self):
10937:   if self.curMenu == 1: self["list"].moveToNextMarker()
10938:   else    : self["myMenu"].moveToIndex(len(self["myMenu"].list) - 1)
10939:  def VVziFC(self):
10940:   if self.curMenu == 2:
10941:    self.curMenu = 1
10942:    self.VVRUZw()
10943:  def VVLe1s(self):
10944:   if self.curMenu == 1:
10945:    self.curMenu = 2
10946:    self.VVRUZw()
10947:  def VVtpQU(self):
10948:   root = None
10949:   serv = self.session.nav.getCurrentlyPlayingServiceReference()
10950:   if serv:
10951:    root = InfoBar.instance.servicelist.getRoot()
10952:   return serv, root
10953:  def VVqfeT(self, isOrig):
10954:   if isOrig: serv, root = self.lastChannel
10955:   else  : serv, root = self.VVtpQU()
10956:   if serv and root:
10957:    try:
10958:     self.enterPath(root)
10959:     self.servicelist.setCurrent(serv)
10960:    except:
10961:     try:
10962:      self.showAllServices()
10963:      self.servicelist.setCurrent(serv)
10964:     except:
10965:      pass
10966:    self.VV3sWT()
10967:    self.VVziFC()
10968:    d = self.VVzYMA()
10969:    self["keyRed"].setText("Group = %s" % d["gName"])
10970:   else:
10971:    FF28n1(self, "Not found", 800)
10972:  @FFOAKH()
10973:  def VVSXdh(self):
10974:   d = self.VVzYMA()
10975:   lst = [item[0] for item in self.VV3wat]
10976:   lst.extend([item[1] for item in self.VV3wat])
10977:   bestLst = self.iClosest(d["name"], lst, 1, 0.6)
10978:   if bestLst : self.VVyoOq(bestLst[0])
10979:   else  : FFjADj(self, "Not found.", 500)
10980:  def VVyoOq(self, id):
10981:   for ndx, item in enumerate(self.VV3wat):
10982:    txt = item[0]
10983:    ref = item[1]
10984:    if txt == id or ref == id:
10985:     self["myMenu"].moveToIndex(ndx)
10986:     self.VVRUZw()
10987:     break
10988:  def VVLlJi(self):
10989:   return [item[0] for item in self.chkLst]
10990:  @FFOAKH()
10991:  def VVUSFL(self):
10992:   refs = self.VVLlJi()
10993:   cNdx = self.servicelist.getCurrentIndex()
10994:   lst = self.servicelist.getList()
10995:   for ndx, serv in enumerate(lst):
10996:    if ndx > cNdx and serv and serv.toString() in refs:
10997:     self.servicelist.moveToIndex(ndx)
10998:     self.VVRUZw()
10999:     break
11000:   else:
11001:    FFjADj(self, "Not found", 1000)
11002:  @FFOAKH()
11003:  def VVSefD(self):
11004:   refs = self.VVLlJi()
11005:   cNdx = self.servicelist.getCurrentIndex()
11006:   if cNdx > 0:
11007:    lst = self.servicelist.getList()
11008:    for ndx in range(cNdx-1, -1, -1):
11009:     serv = lst[ndx]
11010:     if serv and serv.toString() in refs:
11011:      self.servicelist.moveToIndex(ndx)
11012:      self.VVRUZw()
11013:      return
11014:   FFjADj(self, "Not found", 1000)
11015:  def VVGCzn(self):
11016:   d = self.VVzYMA()
11017:   lst = []
11018:   lst2 = []
11019:   for srcRef, dstRef, dstName in self.chkLst:
11020:    if d["VVPxk510"] == srcRef:
11021:     txt1 = FFjt5L(dstName, VVA4XU)
11022:     for ndx, item in enumerate(self.VV3wat):
11023:      mTxt = item[0]
11024:      mRef = item[1]
11025:      if (mTxt, mRef) == (dstName,  dstRef):
11026:       txt1 = FFjt5L(item[0], VVJEMb) + FFjt5L("  (%s)" % item[1], VVo7S9)
11027:       lst.append((txt1, (ndx, dstName)))
11028:       break
11029:     else:
11030:      lst2.append((txt1, (-1, dstName)))
11031:   if lst or lst2:
11032:    lst.sort(key=lambda x: x[0].lower())
11033:    lst2.sort(key=lambda x: x[0].lower())
11034:    if lst and lst2 : lst.append(VVAL3j)
11035:    if lst2   : lst.extend(lst2)
11036:    title = "Item%s Linked to : %s" % (FFcacr(len(lst)), FFjt5L(d["name"], VVJEMb))
11037:    FFLFTC(self, self.VVPUpF, VV3wat=lst, width=1300, VVyRCy=3, title=title, VVwltY="#11001122", VVkxBG="#11001122", VVoCB2="#11330000")
11038:   else:
11039:    FF28n1(self, "Not found", 800)
11040:  def VVPUpF(self, item):
11041:   if not item: return
11042:   if item[0] == -1:
11043:    FFdw58(self, "Not found in current list.\n\nProbably added from another list.", item[1])
11044:   else:
11045:    self["myMenu"].moveToIndex(item[0])
11046:    self.VVLe1s()
11047:    self.VVRUZw()
11048:  def VVRUZw(self):
11049:   if self.VVuUsf() : tBg, cBg, self.added = "#00ff8000", "#00ff0000", True
11050:   else        : tBg, cBg, self.added = "#00ffffff", self.cursCur, False
11051:   FFGUI5(self["myTitle1"], tBg)
11052:   FFGUI5(self["myTitle2"], tBg)
11053:   FFGUI5(self["myTitle3"], tBg)
11054:   if self.curMenu == 1:
11055:    CCKg9B(self, self["list"])
11056:    FF4IPF(self["list"], bg=cBg)
11057:    FF4IPF(self["myMenu"], bg=self.cursNorm)
11058:   else:
11059:    CCKg9B(self, self["myMenu"])
11060:    FF4IPF(self["list"], bg=self.cursNorm)
11061:    FF4IPF(self["myMenu"], bg=cBg)
11062:   for obj in ("list", "myMenu"):
11063:    inst = self[obj].instance
11064:    inst.setSelectionEnable(0)
11065:    inst.setSelectionEnable(1)
11066:  def VVfC5O(self, item):
11067:   self.chkLst.append(item)
11068:   self.VVRUZw()
11069:  def VVNA0C(self, item):
11070:   self.chkLst.remove(item)
11071:   self.VVRUZw()
11072:  def VVuUsf(self):
11073:   d = self.VVzYMA()
11074:   return (d["VVPxk510"], d["mnuRef"], d["mnuTxt"]) in self.chkLst
11075:  def VVzYMA(self):
11076:   serv = self.getCurrentSelection()
11077:   d = {"name": "", "rootName": "", "VVPxk5": "", "VVPxk510": "", "noPhpRef": "", "rootRef": "", "gName": "", "source": "", "satLong": "", "path": "", "rootPath": ""}
11078:   ndx, txt, ref = self.VVYu3Y()
11079:   d["mnuRowNum"], d["mnuTxt"], d["mnuRef"] = ndx + 1, txt, ref
11080:   if serv:
11081:    VVPxk5   = serv.toString()
11082:    path   = CCLSIv.VVijn5(VVPxk5, mode=1)
11083:    if "ORDER BY" in path: path = ""
11084:    span = iSearch(r"((?:[A-Fa-f0-9]+[:]){10})", VVPxk5)
11085:    if span  : d["VVPxk510"] = span.group(1)
11086:    if not path : d["satLong"]   = FFec0y(VVPxk5, True)
11087:    d["VVPxk5"] = VVPxk5
11088:    d["name"]  = FFCjjv(VVPxk5)
11089:    d["source"]  = CCYrUm.VVMJTa(VVPxk5, unknown="")
11090:    d["noPhpRef"]= iSub(r"[&?]mode=.+end=", r"", VVPxk5, flags=IGNORECASE)
11091:    d["path"]  = path
11092:    rootRef   = self.getRoot().toString()
11093:    rootPath  = CCLSIv.VVijn5(rootRef, mode=1)
11094:    if "ORDER BY" in rootPath: rootPath = ""
11095:    gNum, gName  = self.VVOlkd(rootRef)
11096:    d["rootRef"] = rootRef
11097:    d["rootName"]= FFCjjv(rootRef)
11098:    d["gName"]  = gName
11099:    d["rootPath"]= rootPath
11100:   return d
11101:  def VVYu3Y(self):
11102:   ndx = self["myMenu"].l.getCurrentSelectionIndex()
11103:   txt = self.VV3wat[ndx][0]
11104:   ref = self.VV3wat[ndx][1]
11105:   return ndx, txt, ref
11106:  def VVQVyP(self):
11107:   try:
11108:    if   self.mode == 0: self.setRadioMode()
11109:    elif self.mode == 1: self.setTvMode()
11110:    serv = self.getCurrentSelection()
11111:    if serv.flags & 7 == 7:
11112:     self.enterPath(serv)
11113:    rootRef = self["list"].getRoot().toString()
11114:    gNum, gName = self.VVOlkd(rootRef)
11115:    self.VVCiA3(gNum)
11116:    self.VVRUZw()
11117:   except:
11118:    pass
11119:   self.VVvDEf()
11120:  def VVvDEf(self):
11121:   self["myTitle"].setText("  %s \t\t %s" % (self.Title, FFjt5L("Radio" if self.mode == 1 else "TV", VVo7S9)))
11122:  def VVOlkd(self, VVPxk5):
11123:   if   "(satellitePosition == " in VVPxk5: return 2, "Satellite"
11124:   elif "Current transponder" in VVPxk5 : return 2, "Transponder"
11125:   elif "(provider == " in VVPxk5   : return 3, "Provider"
11126:   elif "FROM BOUQUET" in VVPxk5   : return 4, "Favourite"
11127:   else         : return 1, "ALL"
11128:  def VVp5CU(self):
11129:   FFLFTC(self, self.VVCiA3, width=500, VV3wat=[("All", 1), ("Satellites", 2), ("Provider", 3), ("Favourites", 4)], title="Channels Group")
11130:  def VVCiA3(self, g):
11131:   if g:
11132:    if   g == 1: self.showAllServices()
11133:    elif g == 2: self.showSatellites()
11134:    elif g == 3: self.showProviders()
11135:    elif g == 4: self.showFavourites()
11136:    self.VV3sWT()
11137:    self.VVRUZw()
11138:    self["keyRed"].setText("Group = " + {1:"All", 2:"Satellites", 3:"Provider", 4:"Favourites", }.get(g, "?"))
11139:  def VV23Cq(self):
11140:   totCol = len(self.VV3wat[0])
11141:   align = self.aligns2 or [LEFT] * totCol
11142:   font = self.fonts2 or [0] * totCol
11143:   fg  = [FFRUST("#00ffffff")] * totCol
11144:   fg[1] = FFRUST("#00666666")
11145:   bg  = FFRUST(self.bg2)
11146:   sFg  = [FFRUST("#00ffffff")] * totCol
11147:   sFg[1] = FFRUST("#00888888")
11148:   w  = self["myMenu"].instance.size().width()
11149:   if self.widths2 : widths = [w * r / 100 for r in self.widths2]
11150:   else   : widths = [w  // totCol] * totCol
11151:   rows  = []
11152:   for rNdx, row in enumerate(self.VV3wat):
11153:    cols = [rNdx]
11154:    posX = 0
11155:    for cNdx, txt in enumerate(row):
11156:     gap = (0 if align[cNdx] == CENTER else 8)
11157:     cols.append(CCnES5.VVNynG( posX + gap, 0
11158:               , widths[cNdx] - gap, self.VV8c7y
11159:               , font[cNdx]
11160:               , align[cNdx] | RT_VALIGN_CENTER
11161:               , txt
11162:               , fg[cNdx]
11163:               , bg
11164:               , sFg[cNdx]
11165:               , None
11166:               , 0
11167:               , None
11168:               ))
11169:     posX += widths[cNdx]
11170:    rows.append(cols)
11171:   return rows
11172:  def VV64T6(self):
11173:   inst = self["myMenu"].instance
11174:   sz = inst.size()
11175:   w, h = sz.width(), sz.height()
11176:   self.VV8c7y = h // self.totRows
11177:   diff = h % self.totRows
11178:   if diff:
11179:    for obj in ("list", "myMenu", "myFrm1", "myFrm2"):
11180:     inst = self[obj].instance
11181:     w, h = inst.size().width(), inst.size().height()
11182:     inst.resize(eSize(*(w, h - diff)))
11183:    inst = self.instance
11184:    w, h = inst.size().width(), inst.size().height()
11185:    inst.resize(eSize(*(w, h - diff)))
11186:    screenSize = getDesktop(0).size()
11187:    inst.move(ePoint((screenSize.width() - w) // 2, (screenSize.height() - h) // 2))
11188:    for name in ("keyRed", "keyGreen", "keyYellow", "keyBlue", "myBar", "myLine"):
11189:     obj = self[name]
11190:     inst = obj.instance
11191:     pos = obj.getPosition()
11192:     obj.instance.move(ePoint(pos[0], pos[1] - diff))
11193:  def VV3sWT(self):
11194:   obj = self["list"]
11195:   objL= obj.l
11196:   objL.setItemHeight(self.VV8c7y)
11197:   numFontSz = int(self.VV8c7y * 0.45)
11198:   objL.setElementFont(objL.celServiceNumber, gFont(VVNhAq, numFontSz))
11199:   objL.setElementFont(objL.celServiceName, gFont(VVNhAq, self.VVwdmN))
11200:   objL.setElementFont(objL.celServiceInfo, gFont(VVNhAq, int(self.VV8c7y * 0.60)))
11201:   if self.isVti:
11202:    return
11203:   try:
11204:    inst = obj.instance
11205:    numW = self.VVGhIc(inst, gFont(VVNhAq, numFontSz), inst.size(), "0000").width()
11206:    rowW = inst.size().width() - 30
11207:    nameW = rowW - (numW + obj.fieldMargins + obj.progressBarWidth + obj.fieldMargins)
11208:    serv = self.getCurrentSelection()
11209:    objL.setElementPosition(objL.celServiceNumber, eRect(0, 0, numW, self.VV8c7y))
11210:    if serv and serv.flags == 0 : left = numW + obj.fieldMargins
11211:    else      : left = 10
11212:    objL.setElementPosition(objL.celServiceName, eRect(left, 0, nameW, self.VV8c7y))
11213:    objL.setElementPosition(objL.celServiceEventProgressbar, eRect(rowW - obj.progressBarWidth, 0, obj.progressBarWidth, self.VV8c7y))
11214:   except:
11215:    pass
11216:  def VVGhIc(self, instance, font, targetSize, txt):
11217:   from enigma import eLabel
11218:   return eLabel.calculateTextSize(font, txt, targetSize)
11219:  def VVFA1G(self):
11220:   self["keyBlue"].hide()
11221:   serv = self.getCurrentSelection()
11222:   if serv and serv.flags == 0:
11223:    self.curRef = serv.toString()
11224:    txt = CCYrUm.VVMJTa(self.curRef, unknown="")
11225:    tpTxt = self.tpData.VVNNi3(self.curRef)
11226:    if tpTxt: txt += " (%s)" % tpTxt
11227:    if txt : txt += " - "
11228:    txt = (txt + self.curRef).strip()
11229:    if len(txt) > 61: txt = txt[:61] + ".."
11230:    if self.pickMode in (0, 2): self["keyBlue"].show()
11231:   else:
11232:    self.curRef = ""
11233:    txt = self.mnuTitle1
11234:    if self.pickMode in (1, 2): self["keyBlue"].show()
11235:   self["myTitle1"].setText(txt)
11236:   self.VVRUZw()
11237:   if self.VVzYMA()["VVPxk510"] in self.VVLlJi():
11238:    self["keyGreen"].show()
11239:   else:
11240:    self["keyGreen"].hide()
11241: class CCi3sj():
11242:  def __init__(self, SELF, cbf=None):
11243:   self.SELF  = SELF
11244:   self.cbf  = cbf
11245:   self.Title  = "Download XML-TV File"
11246:   self.urlsPath = FF0cqc() + "ajpanel_epg_source"
11247:   self.dstPath = FF0cqc() + "epg/"
11248:   self.tbl  = None
11249:   self.lastPath = ""
11250:   if not FFCyVu(self.urlsPath):
11251:    FF8Wsn(self.SELF, self.urlsPath, title=self.Title)
11252:    return
11253:   self.epgDir = CCDJgl.VVyHvM(SELF, self.Title)
11254:   if not self.epgDir:
11255:    return
11256:   lst = self.VVEP93()
11257:   if lst:
11258:    if self.tbl:
11259:     self.tbl.VVMqQ9(lst)
11260:    else:
11261:     lst.sort(key=lambda x: x[0].lower())
11262:     bg = "
11263:     VVu8qI = self.VVGDVP
11264:     VVwSzI = ("Download", self.VVo3JE, [])
11265:     header  = ("File", "URL", "Exists" )
11266:     widths  = (28  , 64 , 8   )
11267:     VVLIqP = (LEFT  , LEFT , CENTER )
11268:     self.tbl = FFUQ0v(self.SELF, None, title=self.Title, header=header, VVGape=lst, VV3cHe=widths, VVLIqP=VVLIqP, width=1700, VVwdmN=26, VVu8qI=VVu8qI, VVwSzI=VVwSzI, VVwltY="#00004455", VVkxBG=bg, VVemyB=bg, VVJKqd="#0a665533", VVbcr0="#00333333", VVX9AA="#00552222")
11269:   else:
11270:    FFdw58(self.SELF, "No valid URLs in:\n\n%s" % path, title=self.Title + " (xml/gz/xz)" )
11271:  def VVGDVP(self, VV6A99):
11272:   if self.lastPath and self.cbf:
11273:    self.cbf(self.lastPath)
11274:   VV6A99.cancel()
11275:  def VVEP93(self):
11276:   lst = []
11277:   for url in FFL19l(self.urlsPath):
11278:    url = url.strip()
11279:    if not url.startswith("#") and url.endswith((".gz", ".xz", ".xml")) and not url.endswith((".tar.gz", ".tar.xz")):
11280:     fName = os.path.basename(url)
11281:     if fName.endswith((".gz", ".xz")) : fName = fName[:-3]
11282:     if not fName.endswith(".xml")  : fName += ".xml"
11283:     lst.append((fName, url, "Yes" if FFCyVu(self.dstPath + fName) else ""))
11284:   return lst
11285:  def VVo3JE(self, VV6A99, title, txt, colList):
11286:   fName, url, exist = VV6A99.VV5crm()
11287:   for ext, tool in {".gz": "gzip", ".xz":"xz"}.items():
11288:    if url.endswith(ext) and not FFayeZ(tool):
11289:     FFdw58(self.tbl, 'Please install "%s" to handle the "%s" files.' % (tool, ext), title=self.Title)
11290:     return
11291:   ques = "Download%s:\n\n%s" % (" (%s)" % FFjt5L("and overwrite", VVz22H) if FFCyVu(self.epgDir + fName) else "", fName)
11292:   FFRMYv(self.tbl, BF(self.VVObj8, self.tbl, url, fName), ques, title=self.Title)
11293:  @FFOAKH("Downloading ...", par=1, clearMsg=False)
11294:  def VVObj8(self, tbl, url, fName):
11295:   path, err = FFx9uM(url, os.path.basename(url), timeout=3, tmpPath=self.epgDir)
11296:   if path:
11297:    self.VVBhun(self.tbl, path)
11298:   else:
11299:    FFdw58(self.tbl, "Download Error:\n\n%s" % err, title=self.Title)
11300:    FF28n1(self.tbl)
11301:  @FFOAKH("Extracting ...", par=1)
11302:  def VVBhun(self, tbl, path):
11303:   if path.endswith((".gz", ".xz")):
11304:    txt = FFQ45w("%s -fd '%s'" % ("gzip" if path.endswith("gz") else "xz", path))
11305:    if not txt:
11306:     src = path[:-3]
11307:     path = src
11308:     if not path.endswith(".xml"):
11309:      path = src + ".xml"
11310:     if not FFpwZS("mv -f '%s' '%s'" % (src, path)):
11311:      FFdw58(self.tbl, "Cannot rename the downloaded file:\n\n%s" % src, title=self.Title)
11312:      return
11313:    else:
11314:     FFdw58(self.tbl, "Cannot extract:\n%s\n\n( %s )" % (path, txt), title=self.Title)
11315:     return
11316:   self.lastPath = path
11317:   FF1mVE(self.tbl, "Downloaded")
11318:   try:
11319:    fName, url, exist = self.tbl.VV5crm()
11320:    self.tbl.VViSLW((fName, url, FFjt5L("New", VVSGsk)))
11321:   except:
11322:    pass
11323: class CC5TsO(Screen, CCwnHL):
11324:  VV9Ht1  = "BDTSE"
11325:  VVhAdK  = "BDTSEPW"
11326:  VVEj5l   = "save"
11327:  VVss6k   = "load"
11328:  VVctP1  = "flushEPG"
11329:  def __init__(self, session):
11330:   self.skin, self.VVfOli = FFiNEe(VVWp3I, 1000, 1000, 50, 40, 30, "#22110011", "#22110022", 30)
11331:   self.session  = session
11332:   c1, c2, c3, c4, c5 = VVJEMb, VVFuwR, VVJEMb, VVGCYL, VVz22H
11333:   valid, path, sz, szTxt, modTm = CC5TsO.VV0Zhh()
11334:   qUrl, VVZcRP, VVfaDB = CCkEI5.VVs0fr(self)
11335:   VV3wat = []
11336:   VV3wat.append((c1 + "XML-TV Tools", "xmltvTools"))
11337:   VV3wat.append(VVAL3j)
11338:   VV3wat.append((c2 + "Read Current Channel EPG"  , "curEv" ))
11339:   VV3wat.append(VVAL3j)
11340:   VV3wat.append((c2 + "Save Current Channel EPG"  , "saveCur" ))
11341:   VV3wat.append((c2 + "Save Current Channel-Group EPG" , "saveGrp" ))
11342:   VV3wat.append(VVAL3j)
11343:   VV3wat.append((c3 + "EPG Events Counter"    , "evCount" ))
11344:   VV3wat.append(VVAL3j)
11345:   VV3wat.append((c4 + "Cache File Info.", "inf"))
11346:   VV3wat.append(VVAL3j)
11347:   fTxt = " (%s)" % os.path.basename(path) if valid else ""
11348:   VV3wat.append(FFsLU5("Save EPG to File%s" % fTxt , self.VVEj5l, valid))
11349:   VV3wat.append(FFsLU5("Load EPG from File%s" % fTxt , self.VVss6k, valid))
11350:   VV3wat.append(VVAL3j)
11351:   VV3wat.append((c5 + "Delete EPG (from RAM only)", self.VVctP1))
11352:   VV3wat.append(VVAL3j)
11353:   VV3wat.append(FFsLU5("Update Current Bouquet EPG/PIcons (from IPTV Server)", "VVFT2F", qUrl or "chCode" in VVfaDB))
11354:   VV3wat.append(("Copy EPG between Channels (from xml file)", "copyEpg" ))
11355:   VV3wat.append(VVAL3j)
11356:   VV3wat.append(("Translate Current Channel EPG", "VVwBbY"))
11357:   FFZMxC(self, title="EPG Tools", VV3wat=VV3wat)
11358:   self.onShown.append(self.VV7OzD)
11359:  def VVPr1F(self):
11360:   item = FFTmHZ(self)
11361:   if item is not None:
11362:    if   item == "xmltvTools"   : CCDJgl(self)
11363:    elif item == "curEv"    : CCDJgl(self, mode=1)
11364:    elif item == "saveCur"    : CCDJgl(self, mode=2)
11365:    elif item == "saveGrp"    : CCDJgl(self, mode=3)
11366:    elif item == "evCount"    : self.VVv148()
11367:    elif item == "inf"     : self.VVdXJt()
11368:    elif item in (self.VVEj5l, self.VVss6k, self.VVctP1):
11369:     reset = item == self.VVss6k
11370:     FFRMYv(self, BF(self.VVvvRZ, item, reset), VVsWSA="Continue ?")
11371:    elif item == "VVFT2F": CCkEI5.VVFT2F(self)
11372:    elif item == "copyEpg"    : self.VVNXsZ(False, onlyEpg=True)
11373:    elif item == "VVwBbY" : self.VVwBbY()
11374:  def VV7OzD(self):
11375:   self.onShown.remove(self.VV7OzD)
11376:   FF4IPF(self["myMenu"])
11377:   FF2GM8(self)
11378:  @FFOAKH()
11379:  def VVvvRZ(self, act, reset=False):
11380:   ok = CC5TsO.VVdThy(act)
11381:   if ok:
11382:    if reset:
11383:     CCYrUm.VV0iSP(self.session)
11384:    FFipXT(self, "Done")
11385:   else:
11386:    FFipXT(self, "Failed!")
11387:  def VVdXJt(self):
11388:   title = "EPG Cache File"
11389:   valid, path, sz, szTxt, modTm = CC5TsO.VV0Zhh()
11390:   if path:
11391:    if valid: txt = "File Path\t: %s\n\nFile Size\t: %s\n\nModified\t: %s\n" % (path, szTxt or "?", modTm)
11392:    else : txt = "System Settings: %s\n\n%s" % (path, FFjt5L("File not found (check System EPG settings).", VVz22H))
11393:    FF4lCP(self, txt, title=title)
11394:   else:
11395:    FFdw58(self, "Cannot read Path Settings !", title=title)
11396:  @FFOAKH()
11397:  def VVv148(self):
11398:   title = "EPG Events Counter"
11399:   ec, inst = CC5TsO.VVo0fG()
11400:   if not inst:
11401:    FFdw58(self, "Cannot access EPG Cache !", title=title)
11402:    return
11403:   lst = CCYrUm.VV3FRU("1:7:")
11404:   lst = [(n, r.rstrip(":"), FFec0y(r, False)) for r, n in lst]
11405:   lst2 = CCMvE7.VVIjNS()
11406:   lst.extend([(n, r.rstrip(":"), "IPTV") for r, n in lst2])
11407:   lst2 = None
11408:   VVAkuK = []
11409:   totEv = 0
11410:   for n, r, t in lst:
11411:    evList = inst.lookupEvent([CC5TsO.VV9Ht1, (r.rstrip(":"), 0, -1, -1)])
11412:    tot = len(evList)
11413:    if tot:
11414:     totEv += tot
11415:     VVAkuK.append((n, r, t, str(tot)))
11416:   if VVAkuK:
11417:    title += FFjt5L("  ( Total Events = %s )" % totEv, VVA4XU)
11418:    bg = "#0a112525"
11419:    VVAkuK.sort(key=lambda x: x[0].lower())
11420:    header  = ("Name" , "Reference" , "Source" , "EPG Events" )
11421:    widths  = (40  , 40   , 8   , 12   )
11422:    VVLIqP = (LEFT  , LEFT   , CENTER , CENTER )
11423:    VV6A99 = FFUQ0v(self, None, title=title, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VVpCEu=True, width=1800, height=950, VV3cHe=widths, VVwdmN=28
11424:          , VVwltY=bg, VVkxBG=bg, VVemyB=bg)
11425:   else:
11426:    FFdw58(self, "No channels with cached EPG !", title=title)
11427:  def VVwBbY(self):
11428:   title = "Translate Current Channel EPG"
11429:   bg = "#11101010"
11430:   VVu1YM  = (""   , BF(self.VVqDKc, title, True) , [])
11431:   VVwSzI = ("Start"  , BF(self.VVqDKc, title, False), [])
11432:   VV4QTJ = ("Language" , self.VVmOvU         , [])
11433:   widths  = (50 , 50 )
11434:   VVLIqP = (LEFT , CENTER)
11435:   FFUQ0v(self, None, title=title, VVGape=self.VVz1nR(), VVLIqP=VVLIqP, VV3cHe=widths, width=900, VVYUmm=20, VVwdmN=30, VVu1YM=VVu1YM, VVwSzI=VVwSzI, VV4QTJ=VV4QTJ, VVKDPJ=2
11436:     , VVwltY="#11201010", VVkxBG=bg, VVemyB=bg, VVJKqd="#00004455", VVbcr0=bg)
11437:  def VVz1nR(self):
11438:   ch = dict(self.VVkQ4u())
11439:   VVAkuK = []
11440:   VVAkuK.append(("Event Name Language" , ch.get(CFG.epgLangTitle.getValue(), "")))
11441:   VVAkuK.append(("Description Language", ch.get(CFG.epgLangDescr.getValue(), "")))
11442:   return VVAkuK
11443:  def VVmOvU(self, VV6A99, title, txt, colList):
11444:   ndx = VV6A99.VVGTqU()
11445:   title = colList[0]
11446:   confItem = CFG.epgLangTitle if ndx == 0 else CFG.epgLangDescr
11447:   CCJaSw.VV5YpJ(self, confItem, title, lst=self.VVkQ4u(), cbFnc=BF(self.VVS4PG, VV6A99), isSave=True)
11448:  def VVS4PG(self, VV6A99):
11449:   for ndx, row in enumerate(self.VVz1nR()):
11450:    VV6A99.VVEOou(ndx, row)
11451:   FF1mVE(VV6A99, "Saved", 600)
11452:  def VVkQ4u(self):
11453:   lst = [("", "DISABLED")]
11454:   for line in FFL19l("%sajpanel_lang" % VVIp2p):
11455:    span = iSearch(r"\s*(.+)\s*,\s*(.+)\s*", line)
11456:    if span:
11457:     lst.append((span.group(1), span.group(2)))
11458:   return lst
11459:  def VVqDKc(self, Title, isAsk, VV6A99, title, txt, colList):
11460:   tVal, dVal = CFG.epgLangTitle.getValue(), CFG.epgLangDescr.getValue()
11461:   if not (tVal or dVal):
11462:    FF28n1(VV6A99, "Change Language", 700)
11463:   else:
11464:    VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(self)
11465:    VVPxk5, evList, err = CC5TsO.VVVHZD(VVPxk5)
11466:    fnc = BF(self.VVyZ3o, Title, VVPxk5, evList, VV6A99)
11467:    if   err : FFdw58(self, err, title=Title)
11468:    elif isAsk : FFRMYv(self, fnc, "Start ?", title=Title)
11469:    else  : fnc()
11470:  def VVyZ3o(self, title, VVPxk5, evList, VV6A99):
11471:   CCh3tv.VV7Nf4(self, VVLL7M=title, titleBg="#22003344", bodyBg="#22001122"
11472:       , VVixvy  = BF(self.VV8Eiv, evList)
11473:       , VVbYwR = BF(self.VVhb4S, VV6A99, title, VVPxk5))
11474:  def VV8Eiv(self, evList, VVXyP6):
11475:   totEv = len(evList)
11476:   newLst = []
11477:   totErrName = totErrShort = totErrLong = totSkip = 0
11478:   VVXyP6.VVq8NF(totEv)
11479:   VVXyP6.VVNc18 = (newLst, totEv, totErrName, totErrShort, totErrLong, totSkip)
11480:   lang = CFG.epgLangDescr.getValue()
11481:   for ev in evList:
11482:    trName, trShort, trLong, errName, errShort, errLong = CC5TsO.VVZXHh(*ev[2:5])
11483:    totErrName  += errName
11484:    totErrShort += errShort
11485:    totErrLong  += errLong
11486:    if not VVXyP6 or VVXyP6.isCancelled:
11487:     return
11488:    VVXyP6.VVxtQs(1)
11489:    VVXyP6.VVYQKA(len(newLst), ev[2] if len(ev[2]) < 22 else ev[2][:22] + " ...")
11490:    name1, short1, long1 = ev[2:5]
11491:    if (name1, short1, long1) != (trName, trShort, trLong):
11492:     item = list(ev)
11493:     item[2], item[3], item[4] = trName, trShort, trLong
11494:     item.append(1)
11495:     newLst.append(tuple(item))
11496:    else:
11497:     totSkip += 1
11498:    VVXyP6.VVNc18 = (newLst, totEv, totErrName, totErrShort, totErrLong, totSkip)
11499:  def VVhb4S(self, VV6A99, title, VVPxk5, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
11500:   newLst, totEv, totErrName, totErrShort, totErrLong, totSkip = VVNc18
11501:   if newLst: totEv, totOK = CC5TsO.VV8M7K(VVPxk5, newLst)
11502:   else  : totOK = 0
11503:   if totOK:
11504:    CC5TsO.VVYLja()
11505:    CCYrUm.VV0iSP(self.session)
11506:   txt  = "Events\t: %d\n"  % totEv
11507:   txt += "Processed\t: %d\n" % len(newLst)
11508:   txt += "Changed\t: %d\n" % totOK
11509:   if totSkip : txt += "Skipped\t: %d \t... Same language\n" % totSkip
11510:   if any((totErrName, totErrShort, totErrLong)):
11511:    txt += "\nErrors:\n"
11512:    if totErrName : txt += "  Event Name\t: %d\n" % totErrName
11513:    if totErrShort: txt += "  Description\t: %d\n" % totErrShort
11514:    if totErrLong : txt += "  Description\t: %d\n" % totErrLong
11515:   FF4lCP(self, txt, title=title)
11516:   VV6A99.cancel()
11517:  @staticmethod
11518:  def VVZXHh(eName, eShort, eLong):
11519:   eName, eShort, eLong = eName.strip(), eShort.strip(), eLong.strip()
11520:   tVal, dVal = CFG.epgLangTitle.getValue(), CFG.epgLangDescr.getValue()
11521:   lang, lst, resLst, errLst = (tVal, dVal, dVal), (eName, eShort, eLong), ["", "", ""], [0, 0, 0]
11522:   def VVJi7Q(ndx):
11523:    if lst[ndx] and lang[ndx]:
11524:     txt, err = CC5TsO.VV6IMT(lst[ndx], lang[ndx])
11525:     resLst[ndx], errLst[ndx] = txt, 1 if err else 0
11526:   thLst = []
11527:   for ndx in range(3):
11528:    th = iThread(name="ajp_%d" % ndx, target=BF(VVJi7Q, ndx))
11529:    th.start()
11530:    thLst.append(th)
11531:   for th in thLst: th.join()
11532:   trName, trShort, trLong = resLst[0] or eName, resLst[1] or eShort, resLst[2] or eLong
11533:   errName, errShort, errLong = errLst
11534:   return trName, trShort, trLong, errName, errShort, errLong
11535:  @staticmethod
11536:  def VV6IMT(txt, toLang):
11537:   txt = txt.strip()
11538:   if txt:
11539:    qUrl = "%s%s&q=%s" % ("=lt&otua=ls&?m/moc.elgoog.etalsnart//:sptth"[::-1], toLang, FFSiPR(txt))
11540:    txt, err = CCkEI5.VVzVZL(qUrl, timeout=1, allowDocType=True)
11541:    if err:
11542:     return "", err
11543:    else:
11544:     txt = FFXarh(txt)
11545:     ndx  = txt.find('<div class="result-container">')
11546:     if ndx > -1:
11547:      txt = txt[ndx + 30:]
11548:      ndx  = txt.find("</div>")
11549:      if ndx > -1:
11550:       return str(CC5TsO.VV5Bjk(txt[:ndx])).strip(), ""
11551:    return "", "Could not translate"
11552:   else:
11553:    return "", "Nothing to translate"
11554:  @staticmethod
11555:  def VV0Zhh():
11556:   path = szTxt = modTm = ""
11557:   valid = sz = 0
11558:   try: path = config.misc.epgcache_filename.getValue()
11559:   except: pass
11560:   if FFCyVu(path):
11561:    valid = 1
11562:    sz = FFXhoc(path)
11563:    szTxt = CClYaF.VV99gM(sz) if sz > -1 else ""
11564:    modTm = FFTS4w(os.path.getmtime(path))
11565:   return valid, path, sz, szTxt, modTm
11566:  @staticmethod
11567:  def VVo0fG():
11568:   try:
11569:    from enigma import eEPGCache
11570:    return eEPGCache, eEPGCache.getInstance()
11571:   except:
11572:    return None, None
11573:  @staticmethod
11574:  def VVYLja():
11575:   CC5TsO.VVdThy(CC5TsO.VVEj5l)
11576:  @staticmethod
11577:  def VVdThy(act):
11578:   ec, inst = CC5TsO.VVo0fG()
11579:   if inst and hasattr(ec, act):
11580:    try:
11581:     exec("inst.%s()" % act)
11582:     return True
11583:    except:
11584:     pass
11585:   return False
11586:  @staticmethod
11587:  def VVVHZD(VVPxk5):
11588:   ec, inst = CC5TsO.VVo0fG()
11589:   if inst:
11590:    try:
11591:     evList = inst.lookupEvent([CC5TsO.VV9Ht1, (VVPxk5.rstrip(":"), 0, -1, 20160)])
11592:     if evList: return VVPxk5, evList, ""
11593:     else  : return VVPxk5, [], "No System EPG"
11594:    except:
11595:     return VVPxk5, [], "EPG Read-Error !"
11596:   else:
11597:    return VVPxk5, [], "Cannot read EPG Cache !"
11598:  @staticmethod
11599:  def VV8M7K(VVPxk5, events, longDescDays=0):
11600:   ec, inst = CC5TsO.VVo0fG()
11601:   totEv, totOK, fnc = 0, 0, None
11602:   if inst:
11603:    if   hasattr(ec, "importEvents"): fnc = inst.importEvents
11604:    elif hasattr(ec, "importEvent") : fnc = inst.importEvent
11605:   if fnc:
11606:    for data in events:
11607:     totEv += 1
11608:     try:
11609:      if longDescDays and data[0] > iTime() + 86400 * longDescDays:
11610:       data = data[:4] + ("",) + data[5:]
11611:      fnc(VVPxk5, (data,))
11612:      totOK += 1
11613:     except:
11614:      pass
11615:   return totEv, totOK
11616:  @staticmethod
11617:  def VVgoJl(SELF):
11618:   serv = SELF.session.nav.getCurrentlyPlayingServiceReference()
11619:   if serv:
11620:    ec, inst = CC5TsO.VVo0fG()
11621:    if ec:
11622:     event = inst.lookupEventTime(serv, -1, 0)
11623:     if event:
11624:      return CC5TsO.VVjO5v(event)
11625:    try:
11626:     info = eServiceCenter.getInstance().info(serv)
11627:     event = info and info.getEvent(serv)
11628:     if event:
11629:      return CC5TsO.VVjO5v(event)
11630:    except:
11631:     pass
11632:    VV1wIO = serv.getName()
11633:    if VV1wIO:
11634:     return [VV1wIO] + [""] * 6
11635:   return [CC3rDi(SELF.session).VV1wIO] + [""] * 6
11636:  @staticmethod
11637:  def VVMZqx(SELF):
11638:   fPath, fDir, fName = CClYaF.VV4zSS(SELF)
11639:   if fName:
11640:    return os.path.splitext(fName)[0]
11641:   evName, evTime, evDur, evShort, evDesc, genre, PR = CC5TsO.VVgoJl(SELF)
11642:   s = CC3rDi(SELF.session)
11643:   if s.isDvb:
11644:    return evName if any((evTime, evDur, evShort, evDesc, genre, PR)) else ""
11645:   elif " >> " in s.VV1wIO:
11646:    ev = s.VV1wIO.partition(" >> ")[2].strip()
11647:    if ev: return ev
11648:   return evName
11649:  @staticmethod
11650:  def VVjO5v(event):
11651:   evName = event.getEventName().strip()    or ""
11652:   evTime = event.getBeginTime()      or ""
11653:   evDur = event.getDuration()      or ""
11654:   evShort = event.getShortDescription().strip()  or ""
11655:   evDesc = event.getExtendedDescription().strip() or ""
11656:   genre, PR = CC5TsO.VVadPU(event)
11657:   return evName, evTime, evDur, evShort, evDesc, genre, PR
11658:  @staticmethod
11659:  def VVj18Y(VVPxk5):
11660:   service = eServiceReference(VVPxk5)
11661:   evLst = []
11662:   if service:
11663:    ec, inst = CC5TsO.VVo0fG()
11664:    try:
11665:     if inst:
11666:      for evNum in range(2):
11667:       event = inst.lookupEventTime(service, -1, evNum)
11668:       evName, evTime, evDur, evShort, evDesc, genre, PR = CC5TsO.VVjO5v(event)
11669:       evEnd = evPos = evRem = evCom = 0
11670:       evTimeTxt = evPosTxt = evDurTxt = evEndTxt = evRemTxt = evComTxt = ""
11671:       if evTime and evDur:
11672:        evEnd = evTime + evDur
11673:        evTimeTxt = FFTS4w(evTime)
11674:        evEndTxt  = FFTS4w(evEnd)
11675:        evDurTxt  = FFFHEC(evDur)
11676:        now = int(iTime())
11677:        if now > evTime and now < evEnd:
11678:         evPos = now - evTime
11679:         evPosTxt = FFFHEC(evPos)
11680:         evRem = evEnd - now
11681:         evRemTxt = FFFHEC(evRem)
11682:        elif now < evTime:
11683:         evCom = evTime - now
11684:         evComTxt = FFFHEC(evCom)
11685:       evLst.append((evName, evShort, evDesc, genre, PR, evTime, evTimeTxt, evDur, evDurTxt, evEnd, evEndTxt, evPos, evPosTxt, evRem, evRemTxt, evCom, evComTxt))
11686:    except:
11687:     pass
11688:   return evLst
11689:  @staticmethod
11690:  def VVadPU(event):
11691:   genre = PR = ""
11692:   try:
11693:    genre  = CC5TsO.VVB7eC(event.getGenreData().getLevel1(), event.getGenreData().getLevel2())
11694:    age = event.getParentalData().getRating()
11695:    PR  = CC5TsO.VV0aka(age)
11696:   except:
11697:    pass
11698:   return genre, PR
11699:  @staticmethod
11700:  def VV0aka(age):
11701:   if   age == 0 : return "Undefinded (all ages)"
11702:   elif age > 15 : return "Rated by broadcaster (%d)" % age
11703:   else   : return "Minimum Age = %d years" % (age + 3)
11704:  @staticmethod
11705:  def VVB7eC(L1, L2):
11706:   if   L1 <= 0  : return "Undefined Content"
11707:   elif L1 >= 15  : return "User Defined Genre"
11708:   elif L1 > 12  : return "Unlisted Genre"
11709:   else:
11710:    MG, SG = CC5TsO.VVpfDV()
11711:    if MG and SG:
11712:     key = "%d,%d" % (L1, L2)
11713:     if key in SG   : return SG[key].title()
11714:     elif L1 - 1 < len(MG) : return MG[L1 - 1] .title()
11715:     else     : return "Unknown Genre"
11716:    else:
11717:     return ""
11718:  @staticmethod
11719:  def VVpfDV():
11720:   path = VVIp2p + "_sup_genre"
11721:   MG = SG = ""
11722:   if FFCyVu(path):
11723:    MG = iFindall(r"\d,0;(\w+\s?\w+)", FFYVq0(path), IGNORECASE)
11724:    SG = iFindall(r"(\d+,\d+);(.+)", FFYVq0(path), IGNORECASE)
11725:    if SG: SG = dict(SG)
11726:   return MG, SG
11727:  @staticmethod
11728:  def VVDL6A(VV6A99, title):
11729:   ec, inst = CC5TsO.VVo0fG()
11730:   if not inst:
11731:    return "", "Cannot access EPG Cache !"
11732:   totFound = totEvents = totSuccess = totInvalid = totEvErr = 0
11733:   for num, srcName, srcRef, srcTxt, dstName, dstRef, dstTxt, remark in VV6A99.VVrrm9():
11734:    if remark == "0":
11735:     try:
11736:      evList = inst.lookupEvent([CC5TsO.VV9Ht1, (srcRef.rstrip(":"), 0, -1, 20160)])
11737:     except:
11738:      totEvErr += 1
11739:      evList = []
11740:     if evList:
11741:      totFound += 1
11742:      lst = []
11743:      for item in evList:
11744:       lst.append((item[0], item[1], item[2], item[3], item[4], 1))
11745:      totEv, totOK = CC5TsO.VV8M7K(dstRef, lst)
11746:      totEvents += totEv
11747:      totSuccess += totOK
11748:    else:
11749:     totInvalid += 1
11750:   if totSuccess > 0:
11751:    CC5TsO.VVYLja()
11752:    CCYrUm.VV0iSP(VV6A99.session)
11753:   txt  = "Services\t: %d\n"  % VV6A99.VVn1uo()
11754:   txt += "Invalid Ref.\t: %s\n" % totInvalid
11755:   txt += "With Events\t: %d\n\n" % totFound
11756:   txt += "Found Events\t: %d\n" % totEvents
11757:   txt += "Copied Events\t: %d\n" % totSuccess
11758:   if totEvErr:
11759:    txt += "EPG Errors\t: %d" % totEvErr
11760:   return txt, ""
11761:  @staticmethod
11762:  def VVwlye(VVPxk5):
11763:   ec, inst = CC5TsO.VVo0fG()
11764:   if inst and VVPxk5:
11765:    try:
11766:     return inst.lookupEvent([CC5TsO.VVhAdK, (VVPxk5.rstrip(":"), 0, -1, -1)])
11767:    except:
11768:     pass
11769:   return []
11770:  @staticmethod
11771:  def VVotRV(info, VVPxk5):
11772:   evLst = []
11773:   if info:
11774:    for evNum in range(2):
11775:     try:
11776:      ev = info.getEvent(evNum)
11777:      evLst.append(CC5TsO.VVjO5v(ev))
11778:     except:
11779:      pass
11780:   if not evLst and VVPxk5:
11781:    serv = eServiceReference(VVPxk5)
11782:    ec, inst = CC5TsO.VVo0fG()
11783:    if serv and inst:
11784:     for evNum in range(2):
11785:      try:
11786:       ev = inst.lookupEventTime(serv, -1, evNum)
11787:       evLst.append(CC5TsO.VVjO5v(ev))
11788:      except:
11789:       pass
11790:   if not evLst and VVPxk5:
11791:    try:
11792:     serv = eServiceReference(VVPxk5)
11793:     info = serv and eServiceCenter.getInstance().info(serv)
11794:     if info:
11795:      ev = info.getEvent(serv)
11796:      evLst.append(CC5TsO.VVjO5v(ev))
11797:    except:
11798:     pass
11799:   return evLst
11800:  @staticmethod
11801:  def VV73bj(evList, totTr=0):
11802:   tab = lambda x, y: "%s\t: %s\n" % (x, y) if y else ""
11803:   tab2= lambda x, y: "%s\t:\n%s\n" % (x, y) if y else ""
11804:   sep = FFjt5L("_" * 33 + "\n", VVo7S9)
11805:   now = iTime()
11806:   epg = ""
11807:   for evNum, (start, dur, Title, descrS, descrL, pc, genre)in enumerate(evList, start=1):
11808:    startTxt = endTxt = durTxt = ""
11809:    isCurEv = False
11810:    try:
11811:     startTxt= FFTS4w(start).replace(" ", "   ")
11812:     endTxt = FFTS4w(start + dur).replace(" ", "   ")
11813:     durTxt = FFFHEC(dur)
11814:     isCurEv = start < now and (start + dur) > now
11815:    except:
11816:     pass
11817:    descrS = str(descrS).strip()
11818:    if descrS == "Not Applicable":
11819:     descrS = ""
11820:    descrL = str(descrL).strip()
11821:    more = ""
11822:    if pc:
11823:     for Sys, val in pc: more += "Parental Control (%s) : %s\n" % (Sys.strip(), val)
11824:    if genre:
11825:     for g in genre: more += "Genre : %s\n" % str(g)
11826:    if more:
11827:     descrL = more.rstrip() + ("\n" + descrL if descrL else "")
11828:    Title2 = lang = ""
11829:    if totTr > 0 and evNum <= totTr:
11830:     trName, trShort, trLong, errName, errShort, errLong = CC5TsO.VVZXHh(Title, descrS, descrL)
11831:     descrS, descrL = trShort, trLong
11832:     if Title and trName and Title != trName:
11833:      Title2 = FFjt5L(trName, VVFuwR)
11834:      lang = " (%s)" % CFG.epgLangDescr.getValue().upper()
11835:    if isCurEv : evFg, descrFg, txt = VVz22H , VVZtfx, "     (CURRENT EVENT)"
11836:    else  : evFg, descrFg, txt = VVwdUw , VVA4XU  , ""
11837:    epg += sep
11838:    epg += tab("Event"   , FFjt5L(str(evNum) + txt, evFg))
11839:    epg += tab("Start"   , startTxt)
11840:    epg += tab("Title"   , FFjt5L(Title, VVFuwR) if Title else "")
11841:    epg += tab("Title" + lang , FFjt5L(Title2, VVFuwR) if Title2 else "")
11842:    epg += tab("Start"   , startTxt)
11843:    epg += tab("End"   , endTxt)
11844:    epg += tab("Duration"  , durTxt)
11845:    epg += tab2("Summary"  , FFjt5L(descrS, VVA4XU) if descrS else "")
11846:    epg += tab2("Description" , FFjt5L(descrL, descrFg) if descrL else "")
11847:   return epg
11848:  @staticmethod
11849:  def VV5Bjk(txt):
11850:   try:
11851:    from HTMLParser import HTMLParser
11852:    return HTMLParser().unescape(txt)
11853:   except:
11854:    pass
11855:   try:
11856:    import html.parser
11857:    return html.parser.HTMLParser().unescape(txt)
11858:   except:
11859:    pass
11860:   try:
11861:    import html
11862:    return html.unescape(txt)
11863:   except:
11864:    pass
11865:   return txt
11866: class CCYrUm(Screen, CCwnHL):
11867:  VVO0DT  = 0
11868:  VVL3Ny = 1
11869:  VV56GN  = 2
11870:  VVbJ5s  = 3
11871:  VVp2Ed = 4
11872:  VVXNWJ = 5
11873:  VVmjC7 = 6
11874:  def __init__(self, session):
11875:   self.skin, self.VVfOli = FFiNEe(VVWp3I, 1000, 1040, 50, 40, 30, "#22000033", "#22000011", 30)
11876:   self.session   = session
11877:   self.filterObj    = None
11878:   self.VVAG2D = None
11879:   self.lastfilterUsed  = None
11880:   self.servFilterInFilter = False
11881:   VV3wat = self.VVLywV()
11882:   FFZMxC(self, VV3wat=VV3wat, title="Services/Channels")
11883:   self.onShown.append(self.VV7OzD)
11884:  def VV7OzD(self):
11885:   self["myMenu"].setList(self.VVLywV())
11886:   FF4IPF(self["myMenu"])
11887:   FF2GM8(self)
11888:  def VVLywV(self):
11889:   VV3wat = []
11890:   c = VVJEMb
11891:   VV3wat.append((c + "Open Player Bar"         , "openPlayer"   ))
11892:   VV3wat.append((c + "Open Signal Monitor"        , "openSignal"   ))
11893:   VV3wat.append((c + "Current Service Information"      , "currentServiceInfo" ))
11894:   VV3wat.append(VVAL3j)
11895:   c = VVFuwR
11896:   VV3wat.append((c + "Services (Lock, Hide, Delete, Add to Fav)"  , "VVQexT" ))
11897:   VV3wat.append((c + "Services (Transponders)"       , "VVEaAz"))
11898:   VV3wat.append((VVyFI2 + "More tables ..."     , "VVRb4u"  ))
11899:   c = VVZtfx
11900:   VV3wat.append(VVAL3j)
11901:   VV3wat.append(FFsLU5("Import Bouquets from Backup Files"  , "VVtXW3", iTar, c ))
11902:   VV3wat.append((c + 'Export Services to "channels.xml"'    , "VVTcc4"       ))
11903:   VV3wat.append((c + "Copy EPG/PIcons between Channels (from xml file)" , "copyEpgPicons"       ))
11904:   c = VVIH76
11905:   VV3wat.append(VVAL3j)
11906:   VV3wat.append((c + "Satellites Services Cleaner"      , "VVX96j"  ))
11907:   VV3wat.append((c + "Invalid Services Cleaner"       , "VVq2o6" ))
11908:   c = VVIH76
11909:   VV3wat.append(VVAL3j)
11910:   VV3wat.append((c + "Delete Channels with no names"     , "VVHSqx" ))
11911:   VV3wat.append((c + "Delete Empty Bouquets"       , "VVkTJd"  ))
11912:   VV3wat.append(VVAL3j)
11913:   VVkMso, VVEuxL = CCYrUm.VVBN5t()
11914:   if FFCyVu(VVkMso):
11915:    enab = FFCyVu(VVEuxL)
11916:    if enab: VV3wat.append(("Enable Hidden Services List"    , "enableHiddenChannels" ))
11917:    else   : VV3wat.append(("Disable Hidden Services List"   , "disableHiddenChannels" ))
11918:   VV3wat.append(("Reset Parental Control Settings"      , "VV7C5D" ))
11919:   VV3wat.append(("Reload Channels and Bouquets"       , "VV8d5Y" ))
11920:   return VV3wat
11921:  def VVPr1F(self):
11922:   item = FFTmHZ(self)
11923:   if item is not None:
11924:    if   item == "openPlayer"      : CCqWM2.VVHc02(self.session)
11925:    elif item == "openSignal"      : FFdXBl(self.session, reopen=True)
11926:    elif item == "currentServiceInfo"    : CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVvrVY)
11927:    elif item == "VVQexT"   : self.VVQexT()
11928:    elif item == "VVEaAz"  : self.VVEaAz()
11929:    elif item == "VVRb4u"    : self.VVRb4u()
11930:    elif item == "VVtXW3" : CC9xd9.VVtXW3(self)
11931:    elif item == "VVTcc4"     : self.VVTcc4()
11932:    elif item == "copyEpgPicons"     : self.VVNXsZ(False)
11933:    elif item == "VVX96j"    : self.VVX96j()
11934:    elif item == "VVq2o6"   : self.VVq2o6()
11935:    elif item == "VVHSqx"   : self.VVHSqx()
11936:    elif item == "VVkTJd"    : self.VVkTJd(self)
11937:    elif item == "enableHiddenChannels"    : self.VVm5xh(True)
11938:    elif item == "disableHiddenChannels"   : self.VVm5xh(False)
11939:    elif item == "VV7C5D"   : FFRMYv(self, self.VV7C5D, "Reset and Restart ?")
11940:    elif item == "VV8d5Y"     : CCYrUm.VV8d5Y(self)
11941:  def VVRb4u(self):
11942:   VV3wat = []
11943:   VV3wat.append(("Services (IDs)"       , "VV3eXE"))
11944:   VV3wat.append(VVAL3j)
11945:   VV3wat.append(("Services (Parental-Control List)"   , "VVreo3" ))
11946:   VV3wat.append(("Services (Hidden List)"     , "VVXQWm"  ))
11947:   VV3wat.append(("Services with PIcons for the System"  , "VVt2Rn1"  ))
11948:   VV3wat.append(("Services without PIcons for the System" , "VVt2Rn2"  ))
11949:   VV3wat.append(VVAL3j)
11950:   VV3wat.append(("Transponders (Statistics)"    , "TranspondersStats"  ))
11951:   VV3wat.append(("Satellites.xml (Statistics)"    , "VV0k8o"  ))
11952:   FFLFTC(self, None, VV3wat=VV3wat, title="Service Information", VVOa1G=self.VVxAwA)
11953:  def VVxAwA(self, item):
11954:   if item:
11955:    VV7tND, txt, ref, ndx = item
11956:    if   ref == "VV3eXE" : self.VV3eXE(VV7tND, txt)
11957:    elif ref == "VVreo3" : self.VVreo3(VV7tND, txt)
11958:    elif ref == "VVXQWm"  : self.VVXQWm(VV7tND, txt)
11959:    elif ref == "VVt2Rn1"  : self.VVt2Rn(VV7tND, txt, True)
11960:    elif ref == "VVt2Rn2"  : self.VVt2Rn(VV7tND, txt, False)
11961:    elif ref == "TranspondersStats"   : self.VVCPXM(VV7tND, txt)
11962:    elif ref == "VV0k8o"  : self.VV0k8o(VV7tND, txt)
11963:  def VVTcc4(self):
11964:   VV3wat = []
11965:   VV3wat.append(("All DVB-S/C/T Services", "all"))
11966:   VV3wat.extend(CCMvE7.VVlHzq())
11967:   FFLFTC(self, self.VVm3LS, VV3wat=VV3wat, title="", VVU8mZ=True)
11968:  @FFOAKH()
11969:  def VVm3LS(self, item=None):
11970:   if item:
11971:    txt, ref, ndx = item
11972:    if ref == "all" : lst = CCYrUm.VV3FRU("1:7:")
11973:    else   : lst = FFZcDI(eServiceReference(ref))
11974:    if lst:
11975:     tot = len(lst)
11976:     if tot > 0:
11977:      rows = []
11978:      for r, n in lst:
11979:       sat = CCYrUm.VVMJTa(r)
11980:       rows.append('<!-- %s --><channel id="%s">%s</channel><!-- %s -->\n' % (sat, n, r, n))
11981:      if rows:
11982:       rows.sort()
11983:       fPath = "%schannels_%s.xml" % (FFeAlZ(), FFjTQe())
11984:       with open(fPath, "w") as f:
11985:        f.write('<?xml version="1.0" encoding="utf-8"?>\n')
11986:        f.write('<channels>\n\n')
11987:        for row in rows: f.write(row)
11988:        f.write('\n</channels>\n')
11989:       FFipXT(self, "Saved %d service%s to:\n\n%s" % (tot, FFcacr(tot), fPath))
11990:       return
11991:    FF28n1(self, "No Services found !", 1500)
11992:  @staticmethod
11993:  @FFOAKH()
11994:  def VV8d5Y(SELF):
11995:   FFfpyJ()
11996:   FFipXT(SELF, "Finished\n\nReloaded Channels and Bouquets")
11997:  @FFOAKH()
11998:  def VVQexT(self):
11999:   self.VVAG2D = None
12000:   self.lastfilterUsed  = None
12001:   self.filterObj   = CCoErY(self)
12002:   VVAkuK, err = CCYrUm.VVJud0(self, self.VVO0DT)
12003:   if VVAkuK:
12004:    VVAkuK.sort(key=lambda x: x[0].lower())
12005:    VVu1YM  = ("Zap"   , self.VVUJjB     , [])
12006:    VV2ytr = (""    , self.VVuuEx , [])
12007:    VVScQz = ("Options"  , self.VV3Uay , [])
12008:    VVwSzI = ("Current Service", self.VVRyTu , [])
12009:    VV4QTJ = ("Filter"   , self.VVFuTd  , [], "Loading Filters ...")
12010:    header   = ("Name" , "Provider", "Sat.", "Reference" , "PC"  , "Hidden" )
12011:    widths   = (24  , 20  , 9  , 34   , 6   , 7   )
12012:    VVLIqP  = (LEFT  , LEFT  , CENTER, LEFT    , CENTER , CENTER )
12013:    FFUQ0v(self, None, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVu1YM=VVu1YM, VV2ytr=VV2ytr, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVSLOq=CFG.lastFindServices)
12014:  @FFOAKH()
12015:  def VVEaAz(self):
12016:   self.VVAG2D = None
12017:   self.lastfilterUsed  = None
12018:   self.filterObj   = CCoErY(self)
12019:   VVAkuK, err = CCYrUm.VVJud0(self, self.VVL3Ny)
12020:   if VVAkuK:
12021:    VVAkuK.sort(key=lambda x: x[0].lower())
12022:    VVu1YM  = ("Zap"   , self.VVUJjB      , [])
12023:    VV2ytr = (""    , self.VVuuEx  , [])
12024:    VVwSzI = ("Current Service", self.VVRyTu  , [])
12025:    VVScQz = ("Options"  , self.VVucSu , [])
12026:    VV4QTJ = ("Filter"   , self.VVsXuX  , [], "Loading Filters ...")
12027:    header   = ("Name" , "Provider", "Type", "Ref.", "Sat.", "Transponder" , "Freq." , "Pol.", "FEC" , "SR" )
12028:    widths   = (25  , 24  , 14 , 0.01 , 9  , 0.02   , 8   , 5  , 7  , 8  )
12029:    VVLIqP  = (LEFT  , LEFT  , CENTER, CENTER, CENTER, CENTER   , CENTER , CENTER, CENTER, CENTER)
12030:    FFUQ0v(self, None, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVu1YM=VVu1YM, VV2ytr=VV2ytr, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVSLOq=CFG.lastFindServices)
12031:  def VV3Uay(self, VV6A99, title, txt, colList):
12032:   servName = colList[0].strip()
12033:   VVPxk5  = colList[3].strip()
12034:   pcState  = colList[4].strip()
12035:   hidState = colList[5].strip()
12036:   mSel = CCzSCo(self, VV6A99, setsOk=True, setsBlue=True)
12037:   VV3wat = []
12038:   isMulti = VV6A99.VVXWPu
12039:   c1 = VVyFI2
12040:   if isMulti:
12041:    VV6a8O = VV6A99.VVf3uT(3)
12042:    tot = len(VV6a8O)
12043:    if VV6a8O:
12044:     VV3wat.append(("Add Selection to Parental Control"  , "VVfINz1" ))
12045:     VV3wat.append(("Remove Selection from Parental Control" , "VVfINz2" ))
12046:     VV3wat.append(VVAL3j)
12047:     VV3wat.append(("Add Selection to Hidden Services"   , "VVszQY1" ))
12048:     VV3wat.append(("Remove Selection from Hidden Services" , "VVszQY2" ))
12049:     VV3wat.append(VVAL3j)
12050:     VV3wat.append((c1 + "Delete %s service%s" % (tot, FFcacr(tot)), "VVwGwW"))
12051:     VV3wat.append(VVAL3j)
12052:   else:
12053:    pc = pcState == "No"
12054:    hid = hidState == "No"
12055:    VV3wat.append(FFsLU5("Add to Parental Control"  , "VVtkcA1" , pc  ))
12056:    VV3wat.append(FFsLU5("Remove from Parental Control" , "VVtkcA2" , not pc ))
12057:    VV3wat.append(VVAL3j)
12058:    VV3wat.append(FFsLU5("Add to Hidden Services"  , "VVUEX71" , hid  ))
12059:    VV3wat.append(FFsLU5("Remove from Hidden Services" , "VVUEX72" , not hid ))
12060:    VV3wat.append(VVAL3j)
12061:    VV3wat.append((c1 + "Delete Selected Service"    , "VVwGwW"     ))
12062:    VV3wat.append(VVAL3j)
12063:   cbFncDict = { "VVtkcA1" : BF(self.VVtkcA, VV6A99, VVPxk5, True)
12064:      , "VVtkcA2" : BF(self.VVtkcA, VV6A99, VVPxk5, False)
12065:      , "VVUEX71" : BF(self.VVUEX7, VV6A99, VVPxk5, True)
12066:      , "VVUEX72" : BF(self.VVUEX7, VV6A99, VVPxk5, False)
12067:      , "VVfINz1" : BF(self.VVfINz, VV6A99, True)
12068:      , "VVfINz2" : BF(self.VVfINz, VV6A99, False)
12069:      , "VVszQY1" : BF(self.VVszQY, VV6A99, True)
12070:      , "VVszQY2" : BF(self.VVszQY, VV6A99, False)
12071:      , "VVwGwW"  : BF(self.VVwGwW, VV6A99, isMulti, servName, VVPxk5)
12072:      }
12073:   VV3wat1, cbFncDict1 = CCYrUm.VVuGRo(self, VV6A99, servName, 3)
12074:   VV3wat.extend(VV3wat1)
12075:   for key, val in cbFncDict1.items(): cbFncDict[key] = val
12076:   mSel.VV9VR2(VV3wat, cbFncDict)
12077:  def VVucSu(self, VV6A99, title, txt, colList):
12078:   servName = colList[0]
12079:   mSel = CCzSCo(self, VV6A99, setsOk=True, setsBlue=True)
12080:   VV3wat, cbFncDict = CCYrUm.VVuGRo(self, VV6A99, servName, 3)
12081:   mSel.VV9VR2(VV3wat, cbFncDict)
12082:  @staticmethod
12083:  def VVuGRo(SELF, VV6A99, servName, VVeVVi):
12084:   tot = VV6A99.VVc5NH()
12085:   if tot > 0:
12086:    sTxt = FFjt5L("%d Service%s" % (tot, FFcacr(tot)), VVFuwR)
12087:    VV3wat = [("Add %s to Bouquet ..." % sTxt   , "addToBouquet_multi" )]
12088:   else:
12089:    servName = FFzBfi(servName)
12090:    if len(servName) > 20: servName = servName[:20] + ".."
12091:    servName = FFjt5L(servName, VVFuwR)
12092:    VV3wat = [('Add "%s" to Bouquet ...' % servName , "addToBouquet_one" )]
12093:   cbFncDict = { "addToBouquet_multi" : BF(CCYrUm.VVfYKK, SELF, VV6A99, VVeVVi, True)
12094:      , "addToBouquet_one" : BF(CCYrUm.VVfYKK, SELF, VV6A99, VVeVVi, False)
12095:      }
12096:   return VV3wat, cbFncDict
12097:  @staticmethod
12098:  def VVfYKK(SELF, VV6A99, VVeVVi, isMulti):
12099:   picker = CCMvE7(SELF, VV6A99, "Add to Bouquet", BF(CCYrUm.VVx16i, VV6A99, VVeVVi, isMulti))
12100:  @staticmethod
12101:  def VVx16i(VV6A99, VVeVVi, isMulti):
12102:   if isMulti : VV6a8O = VV6A99.VVf3uT(VVeVVi)
12103:   else  : VV6a8O = [VV6A99.VV5crm()[VVeVVi]]
12104:   chUrlLst = []
12105:   for ref in VV6a8O:
12106:    chUrlLst.append(ref)
12107:   return chUrlLst
12108:  def VVtkcA(self, VV6A99, VVPxk5, isAddToBlackList):
12109:   self.VVQsvO(VV6A99, [VVPxk5], isAddToBlackList)
12110:  def VVfINz(self, VV6A99, isAddToBlackList):
12111:   VV6a8O = VV6A99.VVf3uT(3)
12112:   if not VV6a8O:
12113:    FFdw58(self, "Nothing selected", title="Change Parental-Control State")
12114:    return
12115:   self.VVQsvO(VV6A99, VV6a8O, isAddToBlackList)
12116:  @FFOAKH(par=1, clearMsg=False)
12117:  def VVQsvO(self, VV6A99, VV6a8O, isAddToBlackList):
12118:   for ndx, VVPxk5 in enumerate(VV6a8O):
12119:    VVPxk5 = VVPxk5.strip()
12120:    if not VVPxk5.endswith(":"):
12121:     VVPxk5 += ":"
12122:     VV6a8O[ndx] = VVPxk5
12123:   changed = False
12124:   if isAddToBlackList:
12125:    if isAddToBlackList:
12126:     with open(VV3W4d, "a") as f:
12127:      for VVPxk5 in VV6a8O:
12128:       f.write(VVPxk5 + "\n")
12129:       changed = True
12130:   elif FFCyVu(VV3W4d):
12131:    lines = FFL19l(VV3W4d)
12132:    if lines:
12133:     for VVPxk5 in VV6a8O:
12134:      while VVPxk5 in lines:
12135:       ndx = lines.index(VVPxk5)
12136:       lines[ndx] = ""
12137:       changed = True
12138:     if changed:
12139:      with open(VV3W4d, "w") as f:
12140:       for line in lines:
12141:        if line:
12142:         f.write(line + "\n")
12143:   if changed:
12144:    from Components.ParentalControl import parentalControl
12145:    parentalControl.open()
12146:    isMulti = VV6A99.VVXWPu
12147:    if isMulti:
12148:     self.VVfqnU(VV6A99, len(VV6a8O))
12149:    else:
12150:     if VVPxk5.endswith(":"):
12151:      VVPxk5 = VVPxk5[:-1]
12152:     self.VVSMmQ(VV6A99, VVPxk5)
12153:     VV6A99.VVrmMb()
12154:   else:
12155:    VV6A99.VV6fGE("No changes")
12156:  @FFOAKH(par=1)
12157:  def VVUEX7(self, VV6A99, VVPxk5, isHide):
12158:   title = "Change Hidden State"
12159:   if FF4qbN(VVPxk5):
12160:    ret = FFz2bQ(VVPxk5, isHide)
12161:    if ret : self.VVSMmQ(VV6A99, VVPxk5)
12162:    else : FFdw58(self, "Cannot Hide/Unhide this channel.", title=title)
12163:   else:
12164:    FFdw58(self, "Cannot Hide/Unhide this channel.\n\n(Invalid transponder)", title=title)
12165:  def VVSMmQ(self, VV6A99, VVPxk5):
12166:   VVAkuK, err = CCYrUm.VVJud0(self, self.VVO0DT, VV2W2o=[3, [VVPxk5], False])
12167:   done = False
12168:   if VVAkuK:
12169:    data = VVAkuK[0]
12170:    if data[3] == VVPxk5:
12171:     done = VV6A99.VViSLW(data)
12172:   if not done:
12173:    self.VVJz5e(VV6A99, VV6A99.VVpVUj(), self.VVO0DT)
12174:  def VVfqnU(self, VV6A99, totRefCodes):
12175:   VVAkuK, err = CCYrUm.VVJud0(self, self.VVO0DT, VV2W2o=self.VVAG2D)
12176:   VV6A99.VVMqQ9(VVAkuK, VVDpzd=BF(self.VV881E, totRefCodes))
12177:  def VV881E(self, totRefCodes, VV6A99, title, txt, colList):
12178:   VV6A99.VVW3QY()
12179:   FFG2sB(VV6A99, "%d Processed" % totRefCodes, 1000)
12180:  @FFOAKH(par=1, clearMsg=False)
12181:  def VVszQY(self, VV6A99, isHide):
12182:   VV6a8O = VV6A99.VVf3uT(3)
12183:   if not VV6a8O:
12184:    FFdw58(self, "Nothing selected", title="Change Hidden State")
12185:    return
12186:   totChanges = 0
12187:   for VVPxk5 in VV6a8O:
12188:    ret = FFz2bQ(VVPxk5, isHide, skipReload=True)
12189:    if ret:
12190:     totChanges += 1
12191:   if totChanges > 0:
12192:    FFfpyJ(True)
12193:    self.VVfqnU(VV6A99, len(VV6a8O))
12194:   else:
12195:    VV6A99.VV6fGE("No changes")
12196:  def VVwGwW(self, VV6A99, isMulti, servName, VVPxk5):
12197:   c1 = VVYjI5
12198:   if isMulti:
12199:    refLst = VV6A99.VVf3uT(3)
12200:    tot = len(refLst)
12201:    ques = "Delete %s service%s ?" % (FFjt5L(str(tot), c1), FFcacr(tot))
12202:   else:
12203:    refLst, ques = [VVPxk5], c1 + servName
12204:   FFRMYv(self, BF(self.VV5Tsj, VV6A99, refLst), ques, title="Delete Services")
12205:  @FFOAKH("Deleting ...", par=1, clearMsg=False)
12206:  def VV5Tsj(self, VV6A99, refLst):
12207:   totDb, totBouqF, totBouqLn, err = CCYrUm.VVa7Nz(self, refLst)
12208:   if err:
12209:    FFdw58(self, err, title="Delete Services")
12210:   elif any((totDb, totBouqF, totBouqLn)):
12211:    if len(refLst) == VV6A99.VVn1uo():
12212:     self.VVAG2D = self.lastfilterUsed = None
12213:     self.VVfqnU(VV6A99, len(refLst))
12214:     VV6A99.VV0ZtI("Filter = All")
12215:    else:
12216:     self.VVfqnU(VV6A99, len(refLst))
12217:   else:
12218:    FF28n1(VV6A99, "No change", 1000)
12219:  def VVFuTd(self, VV6A99, title, txt, colList):
12220:   inFilterFnc = BF(self.VVLAGo, VV6A99) if self.VVAG2D else None
12221:   self.filterObj.VVmRCa(1, VV6A99, 2, BF(self.VVzHVk, VV6A99), inFilterFnc=inFilterFnc)
12222:  def VVzHVk(self, VV6A99, item):
12223:   self.VVpYI4(VV6A99, False, item, 2, self.VVO0DT)
12224:  def VVLAGo(self, VV6A99, VV7tND, item):
12225:   self.VVpYI4(VV6A99, True, item, 2, self.VVO0DT)
12226:  def VVsXuX(self, VV6A99, title, txt, colList):
12227:   inFilterFnc = BF(self.VV2QJU, VV6A99) if self.VVAG2D else None
12228:   self.filterObj.VVmRCa(2, VV6A99, 4, BF(self.VVKAml, VV6A99), inFilterFnc=inFilterFnc)
12229:  def VVKAml(self, VV6A99, item):
12230:   self.VVpYI4(VV6A99, False, item, 4, self.VVL3Ny)
12231:  def VV2QJU(self, VV6A99, VV7tND, item):
12232:   self.VVpYI4(VV6A99, True, item, 4, self.VVL3Ny)
12233:  def VVadaM(self, VV6A99, title, txt, colList):
12234:   inFilterFnc = BF(self.VVAAgP, VV6A99) if self.VVAG2D else None
12235:   self.filterObj.VVmRCa(0, VV6A99, 4, BF(self.VVolPW, VV6A99), inFilterFnc=inFilterFnc)
12236:  def VVolPW(self, VV6A99, item):
12237:   self.VVpYI4(VV6A99, False, item, 4, self.VV56GN)
12238:  def VVAAgP(self, VV6A99, VV7tND, item):
12239:   self.VVpYI4(VV6A99, True, item, 4, self.VV56GN)
12240:  def VVpYI4(self, VV6A99, isInFilter, item, satCol, mode):
12241:   self.servFilterInFilter = isInFilter
12242:   if self.lastfilterUsed and self.lastfilterUsed == [item, satCol, mode]:
12243:    return
12244:   self.lastfilterUsed = [item, satCol, mode]
12245:   if   item.startswith("__s__") : col, words, title = satCol, item[5:] , item[5:]
12246:   elif item.startswith("__w__") : col, words, title = 0  , item[5:] , item[5:]
12247:   elif item == "parentalControl" : col, words, title = 4  , "Yes"  , "Parental Control"
12248:   elif item == "hiddenServices" : col, words, title = 5  , "Yes"  , "Hidden Services"
12249:   elif item == "selectedTP"  :
12250:    tp = VV6A99.VVeE40(5)
12251:    col, words, title = 5  , tp , tp
12252:   elif item == "emptyTP"   : col, words, title = 6  , "-"  , "Channels with no Transponder"
12253:   elif item == "radio"   : col, words, title = 3  , ""  , "Radio Services"
12254:   elif item == "streamRelay"  : col, words, title = 3  , ""  , "Stream Relay Services"
12255:   else       : col, words, title = None , "All"  , "All"
12256:   title = "Filter = %s" % title
12257:   if len(title) > 55:
12258:    title = title[:55] + ".."
12259:   if col is None:
12260:    self.VVAG2D = None
12261:   elif item == "radio":
12262:    words = ["1:0:2:", "1:0:7:", "1:0:A:"]
12263:    self.VVAG2D = [col, words, True]
12264:   elif item == "streamRelay":
12265:    words = CCYrUm.VVtXqQ()
12266:    if not words:
12267:     FF28n1(VV6A99, "Not found", 1000)
12268:     self.lastfilterUsed = None
12269:     return
12270:    self.VVAG2D = [col, words, False]
12271:   else:
12272:    words, asPrefix = CCoErY.VVPBNm(words)
12273:    self.VVAG2D = [col, words, asPrefix]
12274:   if words: FFimQ3(VV6A99, BF(self.VVJz5e, VV6A99, title, mode), clearMsg=False)
12275:   else : FF28n1(VV6A99, "Incorrect filter", 2000)
12276:  def VVJz5e(self, VV6A99, title, mode):
12277:   VVAkuK, err = CCYrUm.VVJud0(self, mode, VV2W2o=self.VVAG2D, VVXwzE=False)
12278:   if self.servFilterInFilter:
12279:    lst = []
12280:    for row in VV6A99.VVrrm9():
12281:     try:
12282:      ndx = VVAkuK.index(tuple(list(map(str.strip, row))))
12283:      lst.append(VVAkuK[ndx])
12284:     except:
12285:      pass
12286:    VVAkuK = lst
12287:   if VVAkuK:
12288:    VVAkuK.sort(key=lambda x: x[0].lower())
12289:    VV6A99.VVMqQ9(VVAkuK, title)
12290:   else:
12291:    FF28n1(VV6A99, "Not found!", 1500)
12292:    self.lastfilterUsed = None
12293:  def VVM14T(self, title, VVGape, VVu1YM=None, VV2ytr=None, VVwWmA=None, VVwSzI=None, VVScQz=None, VV4QTJ=None):
12294:   VVwSzI = ("Current Service", self.VVRyTu, [], )
12295:   header  = ("Name" , "Provider", "Sat.", "Reference" )
12296:   widths  = (29  , 27  , 9  , 35   )
12297:   VVLIqP = (LEFT  , LEFT  , CENTER, LEFT    )
12298:   FFUQ0v(self, None, title=title, header=header, VVGape=VVGape, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVu1YM=VVu1YM, VV2ytr=VV2ytr, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVSLOq=CFG.lastFindServices)
12299:  def VVRyTu(self, VV6A99, title, txt, colList):
12300:   self.VVBe8O(VV6A99)
12301:  def VVZRWy(self, VV6A99, title, txt, colList):
12302:   self.VVBe8O(VV6A99, True)
12303:  def VVBe8O(self, VV6A99, isFromDetails=False):
12304:   VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(self)
12305:   if VVPxk5:
12306:    if isFromDetails:
12307:     VVPxk5  = VVPxk5.upper()
12308:     parts  = VVPxk5.split(":")
12309:     Namespace = parts[6].zfill(8)
12310:     SID   = parts[3].zfill(4)
12311:     TSID  = parts[4].zfill(4)
12312:     ONID  = parts[5].zfill(4)
12313:     colDict  = { 0:VV1wIO, 5:Namespace, 6:SID, 7:TSID, 8:ONID }
12314:     VV6A99.VVPkdw(colDict, VVwb7n=True)
12315:    else:
12316:     VV6A99.VVn5CC(3, VVPxk5, True)
12317:    return
12318:   FFdw58(self, "Cannot read current Reference Code !")
12319:  @FFOAKH(par=1)
12320:  def VV3eXE(self, obj, title):
12321:   self.VVAG2D = None
12322:   self.lastfilterUsed  = None
12323:   self.filterObj   = CCoErY(self)
12324:   VVAkuK, err = CCYrUm.VVJud0(self, self.VV56GN)
12325:   if VVAkuK:
12326:    VVAkuK.sort(key=lambda x: x[0].lower())
12327:    VV2ytr = (""    , self.VVELXv , []      )
12328:    VVwSzI = ("Current Service", self.VVZRWy  , []      )
12329:    VV4QTJ = ("Filter"   , self.VVadaM   , [], "Loading Filters ..." )
12330:    VVu1YM  = ("Zap"   , self.VVkxsz      , []      )
12331:    header   = ("Name" , "Provider", "Type-Val", "Type" , "Sat.", "Namespace" ,"SID" , "TSID", "ONID" )
12332:    widths   = (24  , 22  , 0   , 16  , 9  , 11   , 6  , 6  , 6    )
12333:    VVLIqP  = (LEFT  , LEFT  , CENTER , CENTER , CENTER, CENTER  , CENTER, CENTER, CENTER )
12334:    FFUQ0v(self, None, title=title, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVu1YM=VVu1YM, VV2ytr=VV2ytr, VVwSzI=VVwSzI, VV4QTJ=VV4QTJ, VVSLOq=CFG.lastFindServices)
12335:  def VVELXv(self, VV6A99, title, txt, colList):
12336:   VVPxk5 = self.VVcfmi(colList)
12337:   self.VVXmmB(VV6A99, title, txt + "Reference\t: %s" % VVPxk5, colList[0], VVPxk5)
12338:  def VVuuEx(self, VV6A99, title, txt, colList):
12339:   self.VVXmmB(VV6A99, title, txt, colList[0], colList[3])
12340:  def VVXmmB(self, VV6A99, title, txt, VV1wIO, VVPxk5):
12341:   rowNum = "Row: %s/%s" % (VV6A99.VVGTqU() + 1, VV6A99.VVn1uo())
12342:   CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVL8mi, params=(VVPxk5, VV1wIO, rowNum, txt))
12343:  def VVUJjB(self, VV6A99, title, txt, colList):
12344:   CCqWM2.VVHc02(self.session, VVaHNe=colList[3], zapFnc=BF(self.VVJl3U, VV6A99, 0))
12345:  def VVkxsz(self, VV6A99, title, txt, colList):
12346:   CCqWM2.VVHc02(self.session, VVaHNe=self.VVcfmi(colList), zapFnc=BF(self.VVJl3U, VV6A99, 1))
12347:  def VVJl3U(self, VV6A99, mode, val):
12348:   if val == 1 : VV6A99.VVIRjv()
12349:   else  : VV6A99.VVgexy()
12350:   colList = VV6A99.VV5crm()
12351:   if mode == 1: VVPxk5 = self.VVcfmi(colList)
12352:   else  : VVPxk5 = colList[3]
12353:   return VVPxk5
12354:  def VVcfmi(self, colList):
12355:   VV1wIO, chProv, servTypeHex, STYPE, sat, NameSpace, SID, TSID, ONID = colList
12356:   VVPxk5 = "1:0:%s:%s:%s:%s:%s:0:0:0" % (servTypeHex, SID.lstrip("0"), TSID.lstrip("0"), ONID.lstrip("0"), NameSpace.lstrip("0"))
12357:   VVPxk5 = VVPxk5.replace("::", ":0:")
12358:   return VVPxk5
12359:  @staticmethod
12360:  def VVaZcW(VVkMso, mode=0):
12361:   lines = FFL19l(VVkMso, encLst=["UTF-8"])
12362:   return CCYrUm.VVBshb(lines, mode)
12363:  @staticmethod
12364:  def VVBshb(lines, mode):
12365:   lst = []
12366:   header = "transponders" if mode < 10 else "services"
12367:   if header in lines:
12368:    lines = lines[lines.index(header) + 1:]
12369:    if "end" in lines:
12370:     lines = lines[:lines.index("end")]
12371:     if len(lines) % 3 == 0:
12372:      for i in range(0, len(lines), 3):
12373:       if   mode in (0, 10): lst.append((lines[i], lines[i + 1], lines[i + 2]))
12374:       elif mode in (1, 11): lst.append(lines[i].upper())
12375:       elif mode in (2, 12): lst.append(lines[i + 1])
12376:       elif mode in (3, 13): lst.append(lines[i + 2])
12377:       elif mode == 14:
12378:        span = iSearch(r"(\S+)\s+(PID)\s+(\d+)", lines[i + 1], IGNORECASE)
12379:        if span:
12380:         lst.append((lines[i], " ".join(span.groups()), lines[i + 2]))
12381:   return lst
12382:  @staticmethod
12383:  def VVPXMf(VVkMso):
12384:   lines = FFL19l(VVkMso, encLst=["UTF-8"])
12385:   topPart = []
12386:   for ln in lines:
12387:    if ln.strip() == "transponders": break
12388:    topPart.append(ln)
12389:   endPart = []
12390:   for ln in lines[::-1]:
12391:    if ln.strip() == "end": break
12392:    endPart.insert(0, ln)
12393:   tpLst = CCYrUm.VVBshb(lines, mode=0)
12394:   srvLst = CCYrUm.VVBshb(lines, mode=10)
12395:   return topPart, tpLst, srvLst, endPart
12396:  @staticmethod
12397:  def VVoYZY(VVkMso, topPart, tpLst, srvLst, endPart):
12398:   with open(VVkMso, "w") as f:
12399:    for ln in topPart: f.write("%s\n" % ln)
12400:    f.write("transponders\n")
12401:    for item in tpLst: f.write("%s\n%s\n%s\n" % item)
12402:    f.write("end\n")
12403:    f.write("services\n")
12404:    for item in srvLst: f.write("%s\n%s\n%s\n" % item)
12405:    f.write("end\n")
12406:    for ln in endPart: f.write("%s\n" % ln)
12407:  @staticmethod
12408:  def VVJud0(SELF, mode, VV2W2o=None, VVXwzE=True, VV49Lf=True):
12409:   VVkMso, err = CCYrUm.VVQwcg(SELF, VV49Lf)
12410:   if err:
12411:    return None, err
12412:   asPrefix = False
12413:   if VV2W2o:
12414:    filterCol = VV2W2o[0]
12415:    filterWords = VV2W2o[1]
12416:    asPrefix = VV2W2o[2]
12417:    filterWords = list(filterWords)
12418:    for ndx, item in enumerate(filterWords):
12419:     filterWords[ndx] = item.strip().lower()
12420:   else:
12421:    filterWords = None
12422:   if mode == CCYrUm.VVO0DT:
12423:    blackList = None
12424:    if FFCyVu(VV3W4d):
12425:     blackList = FFL19l(VV3W4d)
12426:     if blackList:
12427:      blackList = set(blackList)
12428:   elif mode == CCYrUm.VVL3Ny:
12429:    tp = CC3Z54()
12430:   VVY1oT, VVvwHc = FF07Sg()
12431:   if mode in (CCYrUm.VVXNWJ, CCYrUm.VVmjC7):
12432:    VVAkuK = {}
12433:   else:
12434:    VVAkuK = []
12435:   tagFound = False
12436:   with ioOpen(VVkMso, "r", encoding="utf-8") as f:
12437:    lines = []
12438:    for line in f:
12439:     line = str(line).strip()
12440:     if tagFound:
12441:      if line == "end":
12442:       break
12443:      lines.append(line)
12444:      if len(lines) >= 3:
12445:       chCode = lines[0].upper()
12446:       VV1wIO = lines[1]
12447:       chProv = lines[2]
12448:       if chCode.count(":") > 4 and not "," in chCode:
12449:        parts  = chCode.split(":")
12450:        SID   = parts[0]
12451:        NameSpace = parts[1]
12452:        TSID  = parts[2]
12453:        ONID  = parts[3]
12454:        STYPE  = parts[4]
12455:       else:
12456:        SID = NameSpace = TSID = ONID = STYPE = SNUM = VVPxk5 = ""
12457:       chProvOrig = chProv
12458:       if ","  in chProv : chProv = chProv.split(",")[0].strip()
12459:       if "p:" in chProv : chProv = chProv.split("p:")[1].strip()
12460:       if len(VV1wIO) == 0 : VV1wIO = "-"
12461:       if len(chProv) == 0 : chProv = "-"
12462:       s = NameSpace.zfill(8)[:4]
12463:       val = int(s, 16)
12464:       sat = FFS0T2(val)
12465:       try:
12466:        sTypeInt = int(STYPE)
12467:        servTypeHex = (hex(sTypeInt))[2:].upper()
12468:       except:
12469:        sTypeInt = 0
12470:        servTypeHex = "0"
12471:       if mode == CCYrUm.VV56GN:
12472:        if sTypeInt in VVY1oT:
12473:         STYPE = VVvwHc[sTypeInt]
12474:        tRow = (VV1wIO, chProv, servTypeHex, STYPE, sat, NameSpace, SID, TSID, ONID)
12475:        if filterWords:
12476:         tmp = tRow[filterCol].lower()
12477:         if asPrefix:
12478:          if any(tmp.startswith(x) for x in filterWords) : VVAkuK.append(tRow)
12479:         elif any(x in tmp for x in filterWords)    : VVAkuK.append(tRow)
12480:        else:
12481:         VVAkuK.append(tRow)
12482:       else:
12483:        VVPxk5 = "1:0:%s:%s:%s:%s:%s:0:0:0" % (servTypeHex, SID.lstrip("0"), TSID.lstrip("0"), ONID.lstrip("0"), NameSpace.lstrip("0") )
12484:        VVPxk5 = VVPxk5.replace("::", ":0:")
12485:        if mode == CCYrUm.VVXNWJ:
12486:         VVAkuK[VVPxk5.replace(":", "_")] = (VV1wIO, sat, 1)
12487:        elif mode == CCYrUm.VVmjC7:
12488:         VVAkuK[VV1wIO] = VVPxk5
12489:        elif mode == CCYrUm.VVO0DT:
12490:         if blackList and VVPxk5 + ":" in blackList : isBlackList = "Yes"
12491:         else          : isBlackList = "No"
12492:         flag = iSearch(r"f:([A-Fa-f0-9]+)", chProvOrig)
12493:         if flag and int(flag.group(1), 16) & 2 == 2 : hidStr = "Yes"
12494:         else          : hidStr =  "No"
12495:         tRow = (VV1wIO, chProv, sat, VVPxk5, isBlackList, hidStr)
12496:         if filterWords:
12497:          tmp = tRow[filterCol].lower()
12498:          if asPrefix:
12499:           if any(tmp.startswith(x) for x in filterWords) : VVAkuK.append(tRow)
12500:          elif any(x in tmp for x in filterWords)    : VVAkuK.append(tRow)
12501:         else:
12502:          VVAkuK.append(tRow)
12503:        elif mode == CCYrUm.VVL3Ny:
12504:         if sTypeInt in VVY1oT:
12505:          STYPE = VVvwHc[sTypeInt]
12506:         freq, pol, fec, sr, syst = tp.VVFGvS(VVPxk5)
12507:         if not "-S" in syst:
12508:          sat = syst
12509:         if freq == "-" : tpStr = "-"
12510:         else   : tpStr = sat + " " + freq + " " + pol + " " + fec + " " + sr
12511:         tRow = (VV1wIO, chProv, STYPE, VVPxk5, sat, tpStr, freq, pol, fec, sr)
12512:         if filterWords:
12513:          tmp = tRow[filterCol].lower()
12514:          if asPrefix:
12515:           if any(tmp.startswith(x) for x in filterWords) : VVAkuK.append(tRow)
12516:          elif any(x in tmp for x in filterWords)    : VVAkuK.append(tRow)
12517:         else:
12518:          VVAkuK.append(tRow)
12519:        elif mode == CCYrUm.VVbJ5s:
12520:         flag = iSearch(r"f:([A-Fa-f0-9]+)", chProvOrig)
12521:         if flag and int(flag.group(1), 16) & 2 == 2:
12522:          VVAkuK.append((VV1wIO, chProv, sat, VVPxk5))
12523:        elif mode == CCYrUm.VVp2Ed:
12524:         VVAkuK.append((VV1wIO, chProv, sat, VVPxk5))
12525:       lines = []
12526:     elif line == "services":
12527:      tagFound = True
12528:   if not VVAkuK and VVXwzE:
12529:    FFdw58(SELF, "No services found!")
12530:   return VVAkuK, ""
12531:  @staticmethod
12532:  def VVa7Nz(SELF, refLst):
12533:   VVkMso, err = CCYrUm.VVQwcg(None, VV49Lf=False)
12534:   if err: return 0, 0, 0, err
12535:   topPart, tpLst, srvLst, endPart = CCYrUm.VVPXMf(VVkMso)
12536:   if not all((tpLst, srvLst)): return 0, 0, 0, "Lamedb List error"
12537:   refLst = [x.rstrip(":").upper() for x in refLst]
12538:   oldLen = len(srvLst)
12539:   srvLst = [(chCd, chNm, chPr) for chCd, chNm, chPr in srvLst if CCYrUm.VVR51d(chCd) not in refLst]
12540:   totDb = oldLen - len(srvLst)
12541:   if totDb: CCYrUm.VVoYZY(VVkMso, topPart, tpLst, srvLst, endPart)
12542:   totBouqF, totBouqLn = CCYrUm.VVQrWd(refLst)
12543:   if any((totDb, totBouqF, totBouqLn)): FFfpyJ()
12544:   return totDb, totBouqF, totBouqLn, ""
12545:  @staticmethod
12546:  def VVQrWd(refLst):
12547:   totF = totDel = 0
12548:   for path in CCMvE7.VVHtVA():
12549:    lines1, lines2 = FFL19l(path), []
12550:    if not lines1: continue
12551:    for line in lines1:
12552:     span = iSearch(r"
12553:     if span and span.group(1).rstrip(":").upper() in refLst:
12554:      totDel += 1
12555:     else:
12556:      lines2.append(line)
12557:    if lines1 != lines2:
12558:     totF += 1
12559:     with open(path, "w") as f:
12560:      f.write("\n".join(lines2) + "\n")
12561:   return totF, totDel
12562:  @FFOAKH(par=1)
12563:  def VVreo3(self, obj, title):
12564:   if FFCyVu(VV3W4d):
12565:    lines = FFL19l(VV3W4d)
12566:    if lines:
12567:     newRows = []
12568:     VVAkuK, err = CCYrUm.VVJud0(self, self.VVp2Ed)
12569:     if VVAkuK:
12570:      lines = set(lines)
12571:      for item in VVAkuK:
12572:       VVPxk5 = item[3] + ":"
12573:       if VVPxk5 in lines:
12574:        newRows.append((item[0], item[1], item[2], VVPxk5))
12575:      if newRows:
12576:       VVAkuK = newRows
12577:       VVAkuK.sort(key=lambda x: x[0].lower())
12578:       VV2ytr = ("", self.VVuuEx, [])
12579:       VVu1YM  = ("Zap", self.VVUJjB    , [])
12580:       self.VVM14T(title, VVAkuK, VVu1YM=VVu1YM, VV2ytr=VV2ytr)
12581:      else:
12582:       FF4lCP(self, "No matching Reference Code found !\n\nPC Lines\t: %d\nLameDB\t: %d" % (len(lines), len(VVAkuK)))
12583:    else:
12584:     FFipXT(self, "No active Parental Control services.", FFGNZA())
12585:   else:
12586:    FF8Wsn(self, VV3W4d)
12587:  @FFOAKH(par=1)
12588:  def VVXQWm(self, obj, title):
12589:   VVAkuK, err = CCYrUm.VVJud0(self, self.VVbJ5s)
12590:   if VVAkuK:
12591:    VVAkuK.sort(key=lambda x: x[0].lower())
12592:    VV2ytr = ("" , self.VVuuEx , [])
12593:    VVu1YM  = ("Zap", self.VVUJjB     , [])
12594:    self.VVM14T(title, VVAkuK, VVu1YM=VVu1YM, VV2ytr=VV2ytr)
12595:   elif err:
12596:    pass
12597:   else:
12598:    FFipXT(self, "No hidden services.", FFGNZA())
12599:  @FFOAKH()
12600:  def VVq2o6(self):
12601:   title = "Services unused in Tuner Configuration"
12602:   VVkMso, err = CCYrUm.VVQwcg(self, title=title)
12603:   if err:
12604:    return
12605:   nsLst = set()
12606:   usedSats = CCYrUm.VVOjKz()
12607:   for tuner in usedSats:
12608:    for item in tuner[1]:
12609:     ns = self.VVUScr(str(item[0]))
12610:     nsLst.add(ns)
12611:   sysLst = CCYrUm.VV3FRU("1:7:")
12612:   tpLst  = CCYrUm.VVaZcW(VVkMso, mode=1)
12613:   VVAkuK = []
12614:   for VVPxk5, VV1wIO in sysLst:
12615:    servID = CCYrUm.VVlPsR(VVPxk5)
12616:    tpID = CCYrUm.VVIoyj(VVPxk5)
12617:    refNs = VVPxk5.split(":")[6].zfill(8)[:4]
12618:    if not tpID in tpLst or not refNs in nsLst:
12619:     VVAkuK.append((VV1wIO, FFec0y(VVPxk5, False), VVPxk5, servID))
12620:   if VVAkuK:
12621:    VVAkuK.sort(key=lambda x: x[0].lower())
12622:    VVScQz = ("Options"   , BF(self.VVmXsf, title), [])
12623:    header   = ("Name" , "Media" , "Reference" , '"lamedb" Code' )
12624:    widths   = (55  , 10  , 0    , 35    )
12625:    VVLIqP  = (LEFT  , CENTER , LEFT   , CENTER   )
12626:    FFUQ0v(self, None, title=title, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVScQz=VVScQz, VVwltY="#0a001122", VVkxBG="#0a001122", VVemyB="#0a001122", VVJKqd="#00004455", VVbcr0="#0a333333", VVX9AA="#11331100", VVSLOq=CFG.lastFindServices)
12627:   else:
12628:    FFipXT(self, "No invalid service found !", title=title)
12629:  def VVmXsf(self, Title, VV6A99, title, txt, colList):
12630:   mSel = CCzSCo(self, VV6A99)
12631:   isMulti = VV6A99.VVXWPu
12632:   if isMulti : txt = "Remove %s Services" % FFjt5L(VV6A99.VVc5NH(), VVyFI2)
12633:   else  : txt = "Remove : %s" % FFjt5L(VV6A99.VV5crm()[0], VVyFI2)
12634:   VV3wat = [(txt, "del")]
12635:   cbFncDict = {"del": BF(self.VV7uds, VV6A99, Title)}
12636:   mSel.VV9VR2(VV3wat, cbFncDict)
12637:  @FFOAKH(par=1)
12638:  def VV7uds(self, VV6A99, title):
12639:   VVkMso, err = CCYrUm.VVQwcg(self, title=title)
12640:   if err:
12641:    return
12642:   isMulti = VV6A99.VVXWPu
12643:   skipLst = []
12644:   if isMulti : skipLst = VV6A99.VVf3uT(3)
12645:   else  : skipLst = [VV6A99.VV5crm()[3]]
12646:   tpLst = CCYrUm.VVaZcW(VVkMso, mode=0)
12647:   servLst = CCYrUm.VVaZcW(VVkMso, mode=10)
12648:   tmpDbFile = VVkMso + ".tmp"
12649:   lines   = FFL19l(VVkMso)
12650:   skip = False
12651:   with open(tmpDbFile, "w") as f:
12652:    for line in lines:
12653:     tLine = line.strip()
12654:     if tLine == "services":
12655:      skip = True
12656:      f.write(line + "\n")
12657:      for item in servLst:
12658:       if not item[0].upper() in skipLst:
12659:        for L in item:
12660:         f.write(L + "\n")
12661:     elif skip and tLine == "end":
12662:      skip = False
12663:     if not skip:
12664:      f.write(line + "\n")
12665:   FFpwZS("mv -f '%s' '%s'" % (tmpDbFile, VVkMso))
12666:   VVAkuK = []
12667:   for row in VV6A99.VVrrm9():
12668:    if not row[3] in skipLst:
12669:     VVAkuK.append(row)
12670:   FFfpyJ()
12671:   FF4lCP(self, "Removed Services : %d" % len(skipLst), title="Remove Services")
12672:   if VVAkuK:
12673:    VV6A99.VVMqQ9(VVAkuK, title)
12674:    VV6A99.VVW3QY()
12675:   else:
12676:    VV6A99.cancel()
12677:  @FFOAKH(par=1)
12678:  def VVCPXM(self, obj, title):
12679:   VVkMso, err = CCYrUm.VVQwcg(self)
12680:   if err:
12681:    return
12682:   totT, totC, totA, totS, totS2, satList = self.VVbKoL(VVkMso)
12683:   txt = FFjt5L("Total Transponders:\n\n", VVGCYL)
12684:   txt += "   DVB-S    Satellite\t: %d \n"  % totS
12685:   txt += "   DVB-S2  Satellite\t: %d\n"  % totS2
12686:   txt += "   DVB-T    Terrestrial\t: %d\n" % totT
12687:   txt += "   DVB-C    Cable\t: %d\n"   % totC
12688:   txt += "   DVB-A    ATSC\t: %d\n"   % totA
12689:   if satList and len(satList) > 0:
12690:    txt += FFjt5L("\nSatellite Transponders (Total=%d):\n\n" % (totS + totS2), VVGCYL)
12691:    uniqSat = []
12692:    for sat in satList:
12693:     if not sat in uniqSat:
12694:      uniqSat.append(sat)
12695:    uniqSat.sort(key=lambda x: int(x))
12696:    for item in uniqSat:
12697:     txt += "   %s\t: %d\n" % (FF2qmC(item), satList.count(item))
12698:   FF4lCP(self, txt, title)
12699:  def VVbKoL(self, VVkMso):
12700:   totT = totC = totA = totS = totS2 = 0
12701:   satList = []
12702:   tagFound = False
12703:   with ioOpen(VVkMso, "r", encoding="utf-8") as f:
12704:    lines = []
12705:    for line in f:
12706:     line = str(line).strip()
12707:     if tagFound:
12708:      if line == "end"    : break
12709:      elif line.startswith("t")  : totT += 1
12710:      elif line.startswith("c")  : totC += 1
12711:      elif line.startswith("a")  : totA += 1
12712:      elif line.startswith("s"):
12713:       c = line.count(":")
12714:       if   c > 9: totS2 += 1
12715:       elif c > 5: totS  += 1
12716:       if c > 5:
12717:        satList.append(line.split(":")[4])
12718:     elif line == "transponders":
12719:      tagFound = True
12720:   return totT, totC, totA, totS, totS2, satList
12721:  @FFOAKH(par=1)
12722:  def VV0k8o(self, obj, title):
12723:   p1 = "/etc/enigma2/satellites.xml"
12724:   p2 = "/etc/tuxbox/satellites.xml"
12725:   if   FFCyVu(p1) : path = p1
12726:   elif FFCyVu(p2) : path = p2
12727:   else    : path = ""
12728:   if not path:
12729:    FF8Wsn(self, "%s\n.. or ..\n%s" % (p1, p2), title=title)
12730:    return
12731:   elif not CClYaF.VVSOog(self, path, title):
12732:    return
12733:   if not CCid3A.VVAilv(self):
12734:    return
12735:   tree = CCYrUm.VVkotG(self, path, title=title)
12736:   if not tree:
12737:    return
12738:   VVAkuK = []
12739:   root  = tree.getroot()
12740:   totTpColor = "#f#00FFFF55#"
12741:   for sat in root.findall("sat"):
12742:    name = str(sat.get("name", "").encode("UTF-8").decode())
12743:    pos  = sat.get("position", "")
12744:    totTp = len(sat)
12745:    hor = ver = cirL = cirR = unk = 0
12746:    dvbS = dvbS2 = dvbUnk = 0
12747:    for tp in sat.findall("transponder"):
12748:     pol = tp.get("polarization")
12749:     if   pol == "0" : hor += 1
12750:     elif pol == "1" : ver += 1
12751:     elif pol == "2" : cirL += 1
12752:     elif pol == "3" : cirR += 1
12753:     Sys = tp.get("system")
12754:     if   Sys == "0" : dvbS += 1
12755:     elif Sys == "1" : dvbS2 += 1
12756:    try:
12757:     posNum = int(pos)
12758:     if posNum == 1801:
12759:      posCalc = "180.1E"
12760:     else:
12761:      if posNum < 0:
12762:       posNum += 3600
12763:      posCalc = FFS0T2(posNum)
12764:    except:
12765:     posCalc = "?"
12766:     pos  = "-9999"
12767:    if " " in name : posXml, name = name.split(" ", 1)
12768:    else   : posXml = posCalc
12769:    bg = "" if posCalc.endswith("W") else "#b#00003333#"
12770:    VVAkuK.append((bg + name, pos, posXml, posCalc, totTpColor + str(totTp), str(hor), str(ver), str(cirL), str(cirR), str(dvbS), str(dvbS2)))
12771:   if VVAkuK:
12772:    VVAkuK.sort(key=lambda x: int(x[1]))
12773:    VVwSzI = ("Current Satellite", BF(self.VVqKgU, 3), [])
12774:    header   = ("Satellite" , "Pos #" , "xml Pos" , "Position", "TP" , "Hor" , "Ver" , "Circ-L" , "Circ-R" , "DVB-S" , "DVB-S2" )
12775:    widths   = (36    , 8   , 0   , 10  , 6  , 5  , 5  , 7   , 7   , 8   , 8   )
12776:    VVLIqP  = (LEFT   , CENTER , CENTER , CENTER , CENTER, CENTER, CENTER, CENTER , CENTER , CENTER , CENTER )
12777:    FFUQ0v(self, None, title=path, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=25, VViZ3s=1, VVwSzI=VVwSzI, VVSLOq=CFG.lastFindSatName)
12778:   else:
12779:    FFdw58(self, "No data found !", title=title)
12780:  def VVqKgU(self, satCol, VV6A99, title, txt, colList):
12781:   sat = FFec0y(CC3rDi(self.session).VVPxk5, False)
12782:   for ndx, row in enumerate(VV6A99.VVrrm9()):
12783:    if sat == row[satCol].strip():
12784:     VV6A99.VVrqBw(ndx)
12785:     break
12786:   else:
12787:    FF28n1(VV6A99, "Not in list", 1500)
12788:  @FFOAKH()
12789:  def VVX96j(self):
12790:   satLst = nimmanager.getSatList()
12791:   if not satLst:
12792:    FFdw58(self, "No Satellites found !")
12793:    return
12794:   usedSats = CCYrUm.VVOjKz()
12795:   VVAkuK = []
12796:   for sat in satLst:
12797:    tunerLst = []
12798:    for tuner, sats in usedSats:
12799:     if sat in sats:
12800:      tunerLst.append(tuner)
12801:    tunerLst.sort()
12802:    tuners = " , ".join(tunerLst) if tunerLst else ""
12803:    posVal = sat[0]
12804:    if posVal > 1800: posTxt = str(posVal - 3600)
12805:    else   : posTxt = str(posVal)
12806:    VVAkuK.append((sat[1], posTxt, FFS0T2(sat[0]), tuners, str(posVal)))
12807:   if VVAkuK:
12808:    VVemyB = "
12809:    VVAkuK.sort(key=lambda x: int(x[1]))
12810:    VVwSzI = ("Current Satellite" , BF(self.VVqKgU, 2) , [])
12811:    VVScQz = ("Options"   , self.VVVp6V  , [])
12812:    header   = ("Satellite" , "Pos #" , "Position", "Tuners" , "posVal" )
12813:    widths   = ( 50    , 10  , 10  , 30  , 0   )
12814:    VVLIqP  = ( LEFT  , CENTER , CENTER , CENTER , CENTER )
12815:    FFUQ0v(self, None, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=28, VVwSzI=VVwSzI, VVScQz=VVScQz, VVwltY=VVemyB, VVkxBG=VVemyB, VVemyB=VVemyB, VVJKqd="#0a884400", VVSLOq=CFG.lastFindSatName)
12816:   else:
12817:    FFdw58(self, "No data found !")
12818:  def VVVp6V(self, VV6A99, title, txt, colList):
12819:   mSel = CCzSCo(self, VV6A99)
12820:   isMulti = VV6A99.VVXWPu
12821:   if isMulti : txt = "Remove ALL Services on %s Satellites" % FFjt5L(VV6A99.VVc5NH(), VVyFI2)
12822:   else  : txt = "Remove ALL Services on : %s" % FFjt5L(VV6A99.VV5crm()[0], VVyFI2)
12823:   VV3wat = []
12824:   VV3wat.append((txt, "deleteSat"))
12825:   VV3wat.append(VVAL3j)
12826:   VV3wat.append(("Delete Empty Bouquets", "VVkTJd"))
12827:   cbFncDict = { "deleteSat"   : BF(self.VVGqva, VV6A99)
12828:      , "VVkTJd" : BF(self.VVkTJd, VV6A99)
12829:      }
12830:   mSel.VV9VR2(VV3wat, cbFncDict)
12831:  @FFOAKH(par=1)
12832:  def VVGqva(self, VV6A99):
12833:   posLst = []
12834:   isMulti = VV6A99.VVXWPu
12835:   posLst = []
12836:   if isMulti : posLst = VV6A99.VVf3uT(4)
12837:   else  : posLst = [VV6A99.VV5crm()[4]]
12838:   nsLst = []
12839:   for pos in posLst:
12840:    nsLst.append(self.VVUScr(pos))
12841:   db = eDVBDB.getInstance()
12842:   if db:
12843:    for pos in posLst:
12844:     db.removeServices(-1, -1, -1, int(pos))
12845:   totCh, totBoq = self.VV3Fpq(nsLst)
12846:   FFfpyJ(True)
12847:   FF4lCP(self, "Deleted Satellites:\n%d\n\nDeleted Services:\n%d\n\nCleaned Bouquets:\n%d" % (len(posLst), totCh, totBoq), title="Delete Satellites")
12848:  def VVkTJd(self, winObj):
12849:   title = "Delete Empty Bouquets"
12850:   FFRMYv(self, BF(self.VVnttw, winObj, title), "Delete bouquets with no services ?", title=title)
12851:  @FFOAKH(par=1)
12852:  def VVnttw(self, winObj, title):
12853:   bList = CCMvE7.VVykzu()
12854:   bNames = []
12855:   if bList:
12856:    fList = []
12857:    for bName, bRef in bList:
12858:     bFile = CCMvE7.VV896q(bRef)
12859:     bPath = VVQe79 + bFile
12860:     FFwgGB(bPath)
12861:     bNames.append(bName)
12862:     fList.append(bFile)
12863:    if fList:
12864:     for fil in ("bouquets.tv", "bouquets.radio"):
12865:      path = VVQe79 + fil
12866:      if FFCyVu(path):
12867:       lines = FFL19l(path)
12868:       newLines = []
12869:       for line in lines:
12870:        for bFile in fList:
12871:         if bFile in line:
12872:          break
12873:        else:
12874:         newLines.append(line)
12875:       if newLines:
12876:        with open(path, "w") as f:
12877:         f.write("\n".join(newLines) + "\n")
12878:    FFfpyJ(True)
12879:   if bNames: txt = "%s\n\n%s" % (FFjt5L("Deleted Bouquets:", VVFuwR), "\n".join(bNames))
12880:   else  : txt = "No empty bouquets."
12881:   FF4lCP(self, txt, title=title)
12882:  def VVUScr(self, pos):
12883:   pos = int(pos.strip())
12884:   if pos < 0:
12885:    pos += 3600
12886:   return ("%04x" % pos).upper()
12887:  def VV3Fpq(self, nsLst):
12888:   totCh = totBoq = 0
12889:   files = iGlob("%suserbouquet.*.tv" % VVQe79)
12890:   for srcF in files:
12891:    if FFCyVu(srcF):
12892:     lines = FFL19l(srcF)
12893:     newLines = []
12894:     found = False
12895:     for line in lines:
12896:      span = iSearch(r"
12897:      if span:
12898:       ns = FFARk6(span.group(1))
12899:       if ns in nsLst:
12900:        found = True
12901:        totCh += 1
12902:        continue
12903:      newLines.append(line)
12904:     if found and newLines:
12905:      totBoq += 1
12906:      with open(srcF, "w") as f:
12907:       f.write("\n".join(newLines) + "\n")
12908:   return totCh, totBoq
12909:  @FFOAKH(par=1)
12910:  def VVt2Rn(self, VV7tND, title, isWithPIcons):
12911:   piconsPath = CCafIt.VVjkKT()
12912:   if VVmJwX(piconsPath):
12913:    totalPicons = 0
12914:    for fName, fType in CCafIt.VVq4T1(piconsPath):
12915:     if fName:
12916:      totalPicons +=1
12917:    if totalPicons > 0:
12918:     VVAkuK, err = CCYrUm.VVJud0(self, self.VVp2Ed)
12919:     if VVAkuK:
12920:      channels = []
12921:      for (VV1wIO, chProv, sat, VVPxk5) in VVAkuK:
12922:       fName = VVPxk5.replace(":", "_") + ".png"
12923:       pFile = FFZK2V(piconsPath, fName)
12924:       if isWithPIcons:
12925:        if pFile:
12926:         channels.append((VV1wIO, chProv, sat, VVPxk5))
12927:       else:
12928:        if not pFile:
12929:         channels.append((VV1wIO, chProv, sat, VVPxk5))
12930:      totalServices = len(VVAkuK)
12931:      totalFound  = len(channels)
12932:      if isWithPIcons:
12933:       totalWithPIcons  = totalFound
12934:       totalMissingPIcons = totalServices - totalWithPIcons
12935:      else:
12936:       totalMissingPIcons = totalFound
12937:       totalWithPIcons  = totalServices - totalMissingPIcons
12938:      def VVJi7Q(key, val):
12939:       return "%s\t\t: %s\n" % (key, str(val))
12940:      txt = ""
12941:      txt += VVJi7Q("PIcons Path"  , piconsPath)
12942:      txt += VVJi7Q("Total PIcons" , totalPicons)
12943:      txt += "\n"
12944:      txt += VVJi7Q("Total services" , totalServices)
12945:      txt += VVJi7Q("With PIcons"  , totalWithPIcons)
12946:      txt += VVJi7Q("Missing PIcons" , totalMissingPIcons)
12947:      if totalFound == 0:
12948:       FF4lCP(self, txt)
12949:      else:
12950:       VV2ytr     = (""      , self.VVuuEx , [])
12951:       if isWithPIcons : VV4QTJ = ("Export Current PIcon", self.VVS9oC    , [])
12952:       else   : VV4QTJ = None
12953:       VVScQz     = ("Statistics", FF4lCP, [txt])
12954:       VVu1YM      = ("Zap", self.VVUJjB, [])
12955:       channels.sort(key=lambda x: x[0].lower())
12956:       self.VVM14T(title, channels, VVu1YM=VVu1YM, VV2ytr=VV2ytr, VVScQz=VVScQz, VV4QTJ=VV4QTJ)
12957:    else:
12958:     FFdw58(self, "No picons found in path:\n\n%s" % piconsPath)
12959:   else:
12960:    FFdw58(self, "PIcons path not found.\n\n%s" % piconsPath)
12961:  def VVS9oC(self, VV6A99, title, txt, colList):
12962:   png, path = CCafIt.VV81vh(colList[3], colList[0])
12963:   if path:
12964:    CCafIt.VVqLQB(self, png, path)
12965:  @staticmethod
12966:  def VVBN5t():
12967:   VVkMso  = "%slamedb" % VVQe79
12968:   VVEuxL = "%slamedb.disabled" % VVQe79
12969:   return VVkMso, VVEuxL
12970:  @staticmethod
12971:  def VVmPK0():
12972:   VVOVzS  = "%slamedb5" % VVQe79
12973:   VVb8I6 = "%slamedb5.disabled" % VVQe79
12974:   return VVOVzS, VVb8I6
12975:  def VVm5xh(self, isEnable):
12976:   VVkMso, VVEuxL = CCYrUm.VVBN5t()
12977:   if isEnable and not FFCyVu(VVEuxL):
12978:    FFipXT(self, "Already enabled.")
12979:   elif not isEnable and not FFCyVu(VVkMso):
12980:    FFdw58(self, "LameDB File not found!")
12981:   else:
12982:    if isEnable : word = "Enable"
12983:    else  : word = "Disable"
12984:    FFRMYv(self, BF(self.VVQP3B, isEnable), "%s Hidden Channels ?" % word)
12985:  def VVQP3B(self, isEnable):
12986:   VVkMso , VVEuxL = CCYrUm.VVBN5t()
12987:   VVOVzS, VVb8I6 = CCYrUm.VVmPK0()
12988:   cmd = ""
12989:   if isEnable:
12990:    word = "Enabled"
12991:    cmd += "if [ -f '%s' ]; then mv -f '%s' '%s'; fi;"   % (VVEuxL, VVEuxL, VVkMso)
12992:    cmd += "if [ -f '%s' ]; then mv -f '%s' '%s'; fi;"   % (VVb8I6, VVb8I6, VVOVzS)
12993:   else:
12994:    word = "Disabled"
12995:    cmd += "if [ -f '%s' ]; then cp -f '%s' '%s'; fi;"   % (VVkMso  , VVkMso , VVEuxL)
12996:    cmd += "if [ -f '%s' ]; then cp -f '%s' '%s'; fi;"   % (VVOVzS , VVOVzS, VVb8I6)
12997:    cmd += "if [ -f '%s' ]; then sed -i 's/,f:2//' '%s'; fi;" % (VVEuxL, VVkMso )
12998:    cmd += "if [ -f '%s' ]; then sed -i 's/,f:2//' '%s'; fi;" % (VVb8I6, VVOVzS)
12999:   ok = FFpwZS(cmd)
13000:   FFfpyJ()
13001:   if ok: FFipXT(self, "Hidden List %s" % word)
13002:   else : FFdw58(self, "Error while restoring:\n\n%s" % fileName)
13003:  def VV7C5D(self):
13004:   cmd = ""
13005:   cmd += "echo -e 'Reading current settings ...';"
13006:   cmd += "cat %s | grep -v 'config.ParentalControl' > /tmp/settings_my_tmp.txt;" % VVfBVj
13007:   cmd += "echo -e 'Applying new settings ...';"
13008:   cmd += "mv /tmp/settings_my_tmp.txt %s" % VVfBVj
13009:   FF28Zd(self, cmd)
13010:  @FFOAKH()
13011:  def VVHSqx(self):
13012:   VVkMso, err = CCYrUm.VVQwcg(self)
13013:   if err:
13014:    return
13015:   tmpFile = "/tmp/ajp_lamedb"
13016:   FFwgGB(tmpFile)
13017:   totChan = totRemoved = 0
13018:   lines = FFL19l(VVkMso, keepends=True)
13019:   with open(tmpFile, "w") as f:
13020:    servFound = False
13021:    servLines = []
13022:    for line in lines:
13023:     if servFound:
13024:      if line.strip() == "end":
13025:       f.write(line)
13026:       break
13027:      else:
13028:       servLines.append(line)
13029:       if len(servLines) == 3:
13030:        if len(servLines[1].strip()) > 0:
13031:         totChan += 1
13032:         f.write(servLines[0])
13033:         f.write(servLines[1])
13034:         f.write(servLines[2])
13035:        else:
13036:         totRemoved += 1
13037:        servLines = []
13038:     else:
13039:      f.write(line)
13040:      if line.strip() == "services":
13041:       servFound = True
13042:   if totRemoved:
13043:    FFRMYv(self, BF(self.VVinPT, tmpFile, VVkMso, totRemoved, totChan)
13044:       , "Delete %d servce%s (out of %d service%s) ?" % (totRemoved, FFcacr(totRemoved), totChan, FFcacr(totChan))
13045:       , callBack_No=BF(self.VVtLkt, tmpFile))
13046:   else:
13047:    FF4lCP(self, "Total Channels\t: %d\nWith no names\t: %d" % (totChan, totRemoved))
13048:  @FFOAKH()
13049:  def VVinPT(self, tmpFile, VVkMso, totRemoved, totChan):
13050:   FFpwZS("mv -f '%s' '%s'" % (tmpFile, VVkMso))
13051:   FFfpyJ()
13052:   FF4lCP(self, "Total Channels\t: %d\nTotal Removed\t: %d" % (totChan, totRemoved))
13053:  def VVtLkt(self, tmpFile):
13054:   FFwgGB(tmpFile)
13055:  @staticmethod
13056:  def VVQwcg(SELF, VV49Lf=True, title=""):
13057:   VVkMso, VVEuxL = CCYrUm.VVBN5t()
13058:   if   not FFCyVu(VVkMso)       : err = "File not found !\n\n%s" % VVkMso
13059:   elif not CClYaF.VVSOog(SELF, VVkMso) : err = "'lamedb' file is not in 'UTF-8' Encoding !"
13060:   else             : err = ""
13061:   if err and VV49Lf:
13062:    FFdw58(SELF, err, title=title)
13063:   return VVkMso, err
13064:  @staticmethod
13065:  def VVIoyj(VVPxk5):
13066:   _, flg, _, _, tsid, nid, ns, _, _, _ = VVPxk5.rstrip(":").split(":")
13067:   if flg == "0": return (":".join([ns.zfill(8), tsid.zfill(4), nid.zfill(4)])).upper()
13068:   else   : return ""
13069:  @staticmethod
13070:  def VVlPsR(VVPxk5):
13071:   _, flg, st, sid, tsid, nid, ns, _, _, _ = VVPxk5.rstrip(":").split(":")
13072:   if flg == "0": return (":".join([sid.zfill(4), ns.zfill(8), tsid.zfill(4), nid.zfill(4), str(int(st, 16)), "0", "0"])).upper()
13073:   else   : return ""
13074:  @staticmethod
13075:  def VVR51d(chCode):
13076:   if chCode.count(":") > 4 and not "," in chCode:
13077:    parts = chCode.split(":")
13078:    SID  = parts[0].lstrip("0")
13079:    NS  = parts[1].lstrip("0")
13080:    TSID = parts[2].lstrip("0")
13081:    ONID = parts[3].lstrip("0")
13082:    STYPE = parts[4]
13083:    try: sTyp = (hex(int(STYPE)))[2:].upper()
13084:    except: sTyp = "0"
13085:    return ("1:0:%s:%s:%s:%s:%s:0:0:0" % (sTyp, SID, TSID, ONID, NS)).replace("::", ":0:").upper()
13086:   else:
13087:    return ""
13088:  @staticmethod
13089:  def VVwhja(lameDbServId):
13090:   return ":".join(lameDbServId.rstrip(":").split(":")[1:4]).upper()
13091:  @staticmethod
13092:  def VV3FRU(servTypes):
13093:   VVX5XV  = eServiceCenter.getInstance()
13094:   VVqzwR   = '%s ORDER BY name' % servTypes
13095:   VV70EN   = eServiceReference(VVqzwR)
13096:   VVM5OH = VVX5XV.list(VV70EN)
13097:   if VVM5OH: return VVM5OH.getContent("CN", False)
13098:   else     : return []
13099:  @staticmethod
13100:  def VVOjKz():
13101:   slotSats = []
13102:   for slot in nimmanager.nim_slots:
13103:    if slot.frontend_id is not None:
13104:     lst = nimmanager.getSatListForNim(slot.frontend_id)
13105:     if lst:
13106:      slotSats.append((slot.getSlotName(), lst))
13107:   return slotSats
13108:  @staticmethod
13109:  def VV0iSP(session):
13110:   serv = session.nav.getCurrentlyPlayingServiceReference()
13111:   if serv:
13112:    shown = InfoBar.instance.shown
13113:    session.nav.stopService()
13114:    session.nav.playService(serv)
13115:    if not shown: InfoBar.instance.hide()
13116:  @staticmethod
13117:  def VVWp6i():
13118:   inst = InfoBar.instance
13119:   return inst and hasattr(inst, "checkStreamrelay") or hasattr(inst, "ToggleStreamrelay")
13120:  @staticmethod
13121:  def VVbfMb():
13122:   try:
13123:    host = config.misc.softcam_streamrelay_url.value
13124:    port = config.misc.softcam_streamrelay_port.value
13125:    return host, port
13126:   except:
13127:    return "", ""
13128:  @staticmethod
13129:  def VVtXqQ():
13130:   lst = []
13131:   for line in FFL19l(VVl57H):
13132:    line = line.strip()
13133:    if iMatch(r"^((?:[A-Fa-f0-9]+:){10})$", line):
13134:     lst.append(line.rstrip(":").upper())
13135:   return lst
13136:  @staticmethod
13137:  def VVMJTa(r, unknown="?"):
13138:   serv = eServiceReference(r)
13139:   if serv:
13140:    path = serv.getPath()
13141:    if not path     : return FFec0y(r, False)
13142:    elif path.startswith("/") : return "Local"
13143:    elif FFHgaY(r)  : return "Stream Relay"
13144:    elif FFUPnc(r)    : return "IPTV"
13145:   return unknown
13146:  @staticmethod
13147:  def VVGvmp():
13148:   try: InfoBar.instance.openServiceList()
13149:   except: pass
13150:  @staticmethod
13151:  def VVotT7():
13152:   inst = InfoBar.instance
13153:   csel = inst and inst.servicelist
13154:   if csel : return csel.lastroot.getValue(), csel.lastservice.getValue()
13155:   else : return "", ""
13156:  @staticmethod
13157:  def VVmEYR():
13158:   try: return [serv[-1] for serv in InfoBar.instance.servicelist.history]
13159:   except: return []
13160:  @staticmethod
13161:  def VVO7YY(session, skipServ=None, mode=0):
13162:   skipServ = skipServ or eServiceReference("")
13163:   hLst = list(reversed(CCYrUm.VVmEYR()))
13164:   if mode in (0, 1):
13165:    for srv in hLst:
13166:     if not srv.getPath().startswith(("/", "http")) and srv != skipServ:
13167:      FFqb3C(session, srv)
13168:      return srv
13169:   if mode in (0, 2):
13170:    for srv in hLst:
13171:     if not srv.getPath().startswith("/") and srv != skipServ:
13172:      FFqb3C(session, srv)
13173:      return srv
13174:   return None
13175: class CCLAzj():
13176:  def __init__(self, gapX=0, gapY=0):
13177:   self.VVagVA  = []
13178:   self["myPicF"]   = Label()
13179:   self["myPicB"]   = Label()
13180:   self["myPic"]   = Pixmap()
13181:   self.VVTOb9()
13182:   x, y, w, h = self.VVfOli["retPar"]
13183:   x -= gapX
13184:   y += gapY
13185:   self.VVagVA = ((x-1, y-1, w+2, h+2), (x, y, w, h), (x, y, w, h))
13186:  def VVKe51(self, gapX, gapY):
13187:   x, y, w, h = self.VVagVA[2]
13188:   x -= gapX
13189:   y += gapY
13190:   self.VVagVA = ((x-1, y-1, w+2, h+2), (x, y, w, h), (x, y, w, h))
13191:  def VVacFr(self, path):
13192:   self.VVTOb9()
13193:   if not (os.path.isfile(path) and CCHmnm.VVMyky(path) == "pic"):
13194:    return False
13195:   sz = FFXhoc(path)
13196:   if sz == 0:
13197:    self.VVJSEE()
13198:    return  False
13199:   x, y, w, h = self.VVagVA[2]
13200:   right = x + w
13201:   newW, newH, err = CC6u6z.VVZLHD(path)
13202:   if not err:
13203:    x1, y1, w, h = CCsyCY.VVF7W0(newW, newH, w, h)
13204:    if newH > newW:
13205:     w, h = int(w * 1.6), int(h * 1.6)
13206:    x = right - w
13207:   self.VVivVL(x, y, w, h)
13208:   if FF0TBx(self["myPic"], path, fncCb_fail=self.VVJSEE):
13209:    self.VVCcPN()
13210:    return True
13211:   else:
13212:    self.VVJSEE()
13213:    return False
13214:  def VVJSEE(self):
13215:   self.VVTOb9()
13216:   if FFkDgm(self["myPic"], "noPic"):
13217:    x, y, w, h = self.VVagVA[2]
13218:    right = x + w
13219:    w = h
13220:    x = right - w
13221:    self.VVivVL(x, y, w, h)
13222:    self.VVCcPN()
13223:  def VVivVL(self, x, y, w, h):
13224:   for i, obj in enumerate(self.VVnXGn()):
13225:    if i == 0: x1, y1, w1, h1 = x-1, y-1, w+2, h+2
13226:    else  : x1, y1, w1, h1 = x, y, w, h
13227:    if all((x, y, w, h)):
13228:     obj.instance.move(ePoint(int(x1), int(y1)))
13229:     obj.instance.resize(eSize(*(int(w1), int(h1))))
13230:  def VVnXGn(self):
13231:   return [self[x] for x in ("myPicF", "myPicB", "myPic")]
13232:  def VVCcPN(self):
13233:   try:
13234:    for w in self.VVnXGn(): w.show()
13235:   except:
13236:    pass
13237:  def VVTOb9(self):
13238:   for w in self.VVnXGn(): w.hide()
13239:  def VVcOjd(self):
13240:   return self["myPicF"].getVisible()
13241:  def VV7L9R(self):
13242:   return self["myPicF"].instance.size().height() if self.VVcOjd() else 0
13243: class CCvjVs(Screen, CCLAzj):
13244:  VVvrVY  = 0
13245:  VVL8mi    = 1
13246:  VVFOKm    = 2
13247:  VVvVii   = 3
13248:  VVZImX   = 4
13249:  VVga62   = 5
13250:  VVXwW0    = 6
13251:  VVhaN2    = 7
13252:  VV1YsH   = 8
13253:  VVUWdA   = 9
13254:  VVFka3   = 10
13255:  VVC2DO   = 11
13256:  VVnSfp   = 12
13257:  VVbSwV   = 13
13258:  def __init__(self, session, VV7VUc, title="", params=None, VVAfO9=""):
13259:   self.skin, self.VVfOli = FFiNEe(VVmSQ6, 1400, 1000, 50, 30, 10, "
13260:   self.session  = session
13261:   self.VV7VUc  = VV7VUc
13262:   self.Title   = title or "Service Info."
13263:   self.params   = params
13264:   self.VVw8tn  = None
13265:   self.VVPxk5  = ""
13266:   self.VVAQqG  = ""
13267:   self.VVZcRP  = ""
13268:   self.VVfaDB  = ""
13269:   self.VV1wIO   = ""
13270:   self.VVfjDB = ""
13271:   self.VVfbmn   = ""
13272:   self.VVAfO9  = VVAfO9
13273:   self.VVrhEU  = ""
13274:   self.chUrl   = ""
13275:   self.VV761e = ""
13276:   self.VVr5Xg  = False
13277:   self.VV8543  = ""
13278:   self.VVBufu  = ""
13279:   self.VVa81G  = ""
13280:   self.VVSqOO  = ""
13281:   self.VVrijt  = False
13282:   self.VVd143 = False
13283:   self.Sep   = FFjt5L("%s\n", VVo7S9) % SEP
13284:   self.VVZLHV = eTimer()
13285:   FFZMxC(self, title=self.Title + FFjt5L("    Processing ...", VVo7S9), addScrollLabel=True)
13286:   CCLAzj.__init__(self)
13287:   FFBep1(self,
13288:   {
13289:    "info" : self.VVRbRj ,
13290:    "ok" : self.cancel   ,
13291:    "cancel": self.cancel
13292:   })
13293:   self.onShown.append(self.VV7OzD)
13294:   self.onClose.append(self.onExit)
13295:  def VV7OzD(self):
13296:   self.onShown.remove(self.VV7OzD)
13297:   self["myLabel"].VV5kEH(VVRhqH="chann_info")
13298:   if   self.VV7VUc == self.VVvrVY : fnc = self.VVuqAd
13299:   elif self.VV7VUc == self.VVL8mi  : fnc = self.VVvXSe
13300:   elif self.VV7VUc == self.VVFOKm  : fnc = self.VVssBC
13301:   elif self.VV7VUc == self.VVvVii  : fnc = self.VVH3xI
13302:   elif self.VV7VUc == self.VVZImX : fnc = self.VVWjq3
13303:   elif self.VV7VUc == self.VVga62  : fnc = self.VVirIt
13304:   elif self.VV7VUc == self.VVXwW0  : fnc = self.VVQKq6
13305:   elif self.VV7VUc == self.VVhaN2  : fnc = self.VVMLUi
13306:   elif self.VV7VUc == self.VV1YsH  : fnc = self.VVjD5m
13307:   elif self.VV7VUc == self.VVUWdA : fnc = self.VVCqbA
13308:   elif self.VV7VUc == self.VVFka3  : fnc = self.VVbU6R
13309:   elif self.VV7VUc == self.VVC2DO : fnc = self.VV3yK2
13310:   elif self.VV7VUc == self.VVnSfp : fnc = self.VVIhUg
13311:   elif self.VV7VUc == self.VVbSwV  : fnc = self.VVF6bP
13312:   try: self.VVZLHV_conn = self.VVZLHV.timeout.connect(self.VVIfcm)
13313:   except: self.VVZLHV.callback.append(self.VVIfcm)
13314:   self.VVZLHV.start(50, False)
13315:   self["myLabel"].setText("\n   Reading Info ...")
13316:   self["myLabel"].VVfu0l()
13317:   FFIElK(fnc)
13318:  def onExit(self):
13319:   self.VVZLHV.stop()
13320:  def cancel(self):
13321:   if self.VVd143:
13322:    self.close()
13323:  def VVuqAd(self):
13324:   try: dum = self.session
13325:   except: return
13326:   s = CC3rDi(self.session)
13327:   if not s.info:
13328:    self.VVJrgW()
13329:    self.VVrijt = self.VVd143 = True
13330:    return
13331:   fPath, fDir, fName = CClYaF.VV4zSS(self)
13332:   self.VVfjDB = fPath
13333:   self.VVw8tn  = s.info
13334:   self.VVPxk5  = s.VVPxk5
13335:   self.VVAQqG  = s.VVAQqG
13336:   self.VVfaDB  = s.VVfaDB
13337:   self.VV1wIO   = s.VV1wIO
13338:   self.VV8543  = self.VVJ25H(s)
13339:   self.VVgvg3(s.VVZcRP)
13340:  def VVvXSe(self):
13341:   self.VVPxk5, self.VV1wIO, rowNum, VVrhEU = self.params
13342:   self.Title += " " * 20 + rowNum
13343:   VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(self)
13344:   if VVPxk5 == self.VVPxk5:
13345:    self.VVuqAd()
13346:   else:
13347:    self.VVrhEU = VVrhEU
13348:    self.VVgvg3(self.VVPxk5)
13349:  def VVssBC(self):
13350:   self.VVPxk5, self.VV1wIO, self.VVrhEU = self.params
13351:   self.VVgvg3(self.VVPxk5)
13352:  def VVH3xI(self):
13353:   self.VVPxk5, self.VV1wIO, self.VVrhEU = self.params
13354:   self.VVgvg3(self.VVPxk5)
13355:  def VVWjq3(self):
13356:   self.VVPxk5, self.VV1wIO, self.VVrhEU = self.params
13357:   self.VVgvg3()
13358:  def VVirIt(self):
13359:   self.VVPxk5, self.VV1wIO, self.VVrhEU, self.VVAfO9 = self.params
13360:   self.VVgvg3()
13361:  def VVQKq6(self):
13362:   self.VVPxk5, self.VV1wIO, self.VVrhEU, self.VVZcRP, self.VVfaDB = self.params
13363:   self.VVgvg3(self.VVfaDB)
13364:  def VVMLUi(self):
13365:   self.VVZcRP, self.VV1wIO, self.VVrhEU, self.VVfbmn = self.params
13366:   self.VVgvg3()
13367:  def VVjD5m(self):
13368:   self.VVPxk5, self.VV1wIO, self.VVrhEU, self.chUrl, self.VVfbmn = self.params
13369:   self.VVgvg3(self.chUrl)
13370:  def VVCqbA(self):
13371:   self.VV1wIO, self.VVrhEU, self.VVfbmn = self.params
13372:   self.VVgvg3()
13373:  def VVbU6R(self):
13374:   self.VVPxk5, self.chUrl, self.VV1wIO, self.VVrhEU, self.VVfbmn = self.params
13375:   self.VVgvg3(self.chUrl)
13376:  def VV3yK2(self):
13377:   self.VV1wIO, self.VVrhEU, self.VVfbmn = self.params
13378:   self.VVgvg3()
13379:  def VVIhUg(self):
13380:   self.VVrhEU, self.VVAfO9 = self.params
13381:   self.VVgvg3()
13382:  def VVF6bP(self):
13383:   self.VVrhEU, self.VVfbmn = self.params
13384:   self.VVfbmn = FFXarh(self.VVfbmn)
13385:   self.VVgvg3()
13386:  def VVIfcm(self):
13387:   if self.VVrijt:
13388:    self["myTitle"].setText("  %s" % self.Title)
13389:    self.VVZLHV.stop()
13390:   if self.VVBufu:
13391:    txt, self.VVBufu = self.VVBufu, ""
13392:    txt = self["myLabel"].getText().strip() + "\n\n" + txt.strip()
13393:    self["myLabel"].setText("\n" + txt, VV47Xm=VV5jA8)
13394:    self.VVkd84()
13395:   if self.VVa81G:
13396:    evLst, self.VVa81G = self.VVa81G, ""
13397:    self.VVe0Wr(evLst)
13398:   if self.VVSqOO:
13399:    path, self.VVSqOO = self.VVSqOO, ""
13400:    self.VVr5Xg = self.VVUUd8(path)
13401:    self.VVTsK1(path)
13402:  def VVJrgW(self):
13403:   txt = self.VVrhEU.strip()
13404:   cTxt = self.VV8543.strip()
13405:   if txt and cTxt : txt += "\n\n%s\n%s" % (self.Sep, cTxt)
13406:   else   : txt += cTxt
13407:   self["myLabel"].setText(txt or "No active service", VV47Xm=VV5jA8)
13408:   self.VVkd84()
13409:  def VVkd84(self):
13410:   self["myLabel"].VVfu0l(minHeight=self.VV7L9R())
13411:  def VVUUd8(self, path):
13412:   isOk = self.VVacFr(path)
13413:   if isOk:
13414:    self.VVkd84()
13415:   return isOk
13416:  def VVgvg3(self, ref=""):
13417:   if ref:
13418:    span = iSearch(r"((?:[A-Fa-f0-9]+[:]){10})*(.+\/\/.+)", ref)
13419:    if span:
13420:     self.VV761e = FFXarh(span.group(1))
13421:     self.VVZcRP = FFXarh(span.group(2))
13422:   if not self.VV761e:
13423:    self.VV761e = CCvjVs.VVHamE(self.VVPxk5) or CCvjVs.VVHamE(self.VVfaDB)
13424:   if self.VVZcRP and not "URL:" in self.VV8543 and not "URL:" in self.VVrhEU:
13425:    self.VVrhEU = self.VVrhEU.rstrip() + "\n\nURL:\n%s\n" % FFjt5L(CCvjVs.VV1sZM(self.VVZcRP), VVA4XU)
13426:   self.VVJrgW()
13427:   FFIElK(self.VVxBDI)
13428:  def VVxBDI(self):
13429:   if not self.VVr5Xg and self.VVAfO9:
13430:    self.VVr5Xg = self.VVUUd8(self.VVAfO9)
13431:   if not self.VVr5Xg and self.VVPxk5:
13432:    png, path = CCafIt.VV81vh(self.VVPxk5, self.VV1wIO)
13433:    if png: self.VVr5Xg = self.VVUUd8(path)
13434:   if not self.VVr5Xg and self.VVAQqG:
13435:    png, path = CCafIt.VV81vh(self.VVAQqG, self.VV1wIO)
13436:    if png: self.VVr5Xg = self.VVUUd8(path)
13437:   FFIElK(self.VVUf6L)
13438:  def VVUf6L(self):
13439:   VVjZ0e = CC5TsO.VVwlye(self.VVPxk5)
13440:   if VVjZ0e: VVo7cK = []
13441:   else  : VVo7cK = CC5TsO.VVotRV(self.VVw8tn, self.VVPxk5)
13442:   iThread(name="ajp_info_pic", target=BF(self.VVE9TW, VVjZ0e, VVo7cK)).start()
13443:   self.VVd143 = True
13444:  def VVE9TW(self, VVjZ0e, VVo7cK):
13445:   try:
13446:    title = FFGEAF("EPG:", VVFuwR)
13447:    epg = ""
13448:    evLst = []
13449:    netOk = CCuqoc.VVSuvZ
13450:    if netOk:
13451:     self.VVvuTk(self.VVfbmn)
13452:     if self.VVZcRP:
13453:      epg, evLst, VVfbmn, err = CCvjVs.VVPhf6(self.VVZcRP)
13454:      self.VVvuTk(VVfbmn)
13455:     if not epg and self.VVZcRP:
13456:      epg, evLst, err = CCkEI5.VV67It(self.VVZcRP)
13457:     if epg : self.VVBufu = title + epg
13458:     if evLst: self.VVa81G = evLst
13459:    if not epg and (VVjZ0e or VVo7cK):
13460:     if   not netOk  : totTr = 0
13461:     elif VVjZ0e  : totTr = 2
13462:     elif VVo7cK : totTr = 2
13463:     self.VVBufu = title + CC5TsO.VV73bj(VVjZ0e or VVo7cK, totTr)
13464:    self.VVMX5q()
13465:   except:
13466:    pass
13467:   self.VVrijt = True
13468:  def VVMX5q(self):
13469:   txt = ""
13470:   if self.VVfjDB:
13471:    txt = CC6u6z.VVZKCF(self.VVfjDB)
13472:   elif self.VVZcRP and self.VV1wIO:
13473:    path, headers = CC6u6z.VVmdd5(self.VVZcRP, self.VV1wIO)
13474:    if path:
13475:     txt = CC6u6z.VVZKCF(path, headers)
13476:   if txt:
13477:    self.VVBufu = txt
13478:  @staticmethod
13479:  def VVPhf6(VVZcRP):
13480:   if "chCode" in VVZcRP:
13481:    p = CC96QG()
13482:    valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVGNGo(VVZcRP)
13483:    uHost = uUser = uPass = uId = ""
13484:    p, pUrl, pUrlAcc, pUrlDnld, pHost, pUser, pPass, err = CC96QG.VV1SNn(host=host, mac=mac, ph1=ph1)
13485:    if all((pHost, pUser, pPass, stID)) : uType, uHost, uUser, uPass, uId = mode, pHost, pUser, pPass, stID
13486:    else        : return "", "", "", "No EPG (invalid URL) !"
13487:   else:
13488:    uType, uHost, uUser, uPass, uId, uChName = CCkEI5.VVNeuG(VVZcRP)
13489:    if not all([uHost, uUser, uPass, uId]):
13490:     return "", "", "", "No EPG (invalid URL) !"
13491:    span = iSearch(r"S\d{2,3}E\d{2,3} \((.+)\)", uChName)
13492:    catID = span.group(1) if span else ""
13493:   qUrl = "%s/player_api.php?username=%s&password=%s&action=" % (uHost, uUser, uPass)
13494:   if   uType in ("live", "itv") : qUrl += "get_simple_data_table&stream_id=%s" % (uId)
13495:   elif uType in ("movie", "vod") : qUrl += "get_vod_info&vod_id=%s" % (uId)
13496:   elif uType == "series" and catID: qUrl += "get_series_info&series_id=%s" % (catID)
13497:   else       : return "", "", "", "Cannot process this channels"
13498:   txt, err = CCkEI5.VVzVZL(qUrl, timeout=3)
13499:   if err: return "", "", "", "No EPG from server (%s)" % err
13500:   epg = VVfbmn = ""
13501:   evLst = []
13502:   if   uType in ("live", "itv") : epg, evLst, err = CCkEI5.VV1q43(txt, mode=3)
13503:   elif uType in ("movie", "vod") : epg, VVfbmn, err = CCkEI5.VVfN18(txt)
13504:   elif uType == "series"   : epg, VVfbmn, err = CCkEI5.VVYkyo(txt, VVZcRP)
13505:   err = "" if epg else "No EPG from server !"
13506:   return epg, evLst, VVfbmn, err
13507:  def VVvuTk(self, url):
13508:   if url and not self.VVr5Xg:
13509:    path, err = FFx9uM(url, "ajp_tmp.png", timeout=2, VVzHui=True)
13510:    if path:
13511:     self.VVSqOO = path
13512:  def VVe0Wr(self, evLst):
13513:   if self.VV761e and evLst:
13514:    totEv, totOK = CC5TsO.VV8M7K(self.VV761e, evLst, longDescDays=7)
13515:    if totOK > 0:
13516:     CC5TsO.VVYLja()
13517:  def VVTsK1(self, path):
13518:   if self.VVr5Xg and self.VV761e and FFCyVu(path) and FFayeZ("ffmpeg"):
13519:    pPath = CCafIt.VVjkKT()
13520:    if VVmJwX(pPath):
13521:     picon = self.VV761e.replace(":", "_") + ".png"
13522:     cmd = CCvjVs.VVQ9GP(path)
13523:     cmd += FFb2oQ("mv -f '%s' '%s%s'" % (path, pPath, picon))
13524:     FFpwZS(cmd)
13525:  def VVJ25H(self, s):
13526:   tab = lambda x, y: "%s\t: %s\n" % (x, y)
13527:   txt = ""
13528:   txt += tab("Service Name", FFjt5L(s.VV1wIO, VVFuwR))
13529:   txt += tab("Channel Num", s.chNum) if s.chNum > 0 else ""
13530:   txt += tab("Provider" , s.prov) if s.prov else ""
13531:   if s.state: txt += tab("State", (FFjt5L(s.state.replace("*", ""), VVz22H) if s.state.startswith("*") else s.state))
13532:   vRes = CCvjVs.VVZHUt(s.info)
13533:   if vRes: txt += tab("Dimensions", vRes)
13534:   aspect = self.VVNYXU(s.info)
13535:   if aspect: txt += tab("Video Format", aspect)
13536:   txt += self.VVJi7Q(s.info, "Video Type", iServiceInformation.sVideoType, 4)
13537:   rate = FFMzWf(s.info, iServiceInformation.sFrameRate)
13538:   if rate.isdigit() and not rate == "0":
13539:    txt += "Frame Rate\t: %s\n" % rate
13540:   if FFxWB5(s.info, iServiceInformation.sIsCrypted) == "1":
13541:    txt += "Crypted\t: Yes\n"
13542:   tot = CCvjVs.VVHlVI(self.session)
13543:   if tot > -1: txt += tab("Audio Tracks", tot)
13544:   tot = CCvjVs.VVbjRo()
13545:   if tot > -1: txt += tab("Subtitles", tot)
13546:   fPath, fDir, fName, picFile = CCvjVs.VVSY7D(self)
13547:   isLocal = False
13548:   isIptv  = len(s.VVfaDB) > 0
13549:   if isIptv:
13550:    txt += tab("Service Type", FFjt5L("Stream-Relay" if FFHgaY(s.VVZcRP) else "IPTV", VVGCYL))
13551:    if s.VVPxk5 and s.VVAQqG and s.VVPxk5 != s.VVAQqG:
13552:     txt += tab("S. Relay Ref.", s.VVAQqG)
13553:    txt += CCvjVs.VVjB93(s.VVfaDB)
13554:   elif fPath:
13555:    isLocal = True
13556:    txt += tab("Reference", s.VVXbok)
13557:    txt += tab("Service Type", "Local Recording")
13558:    txt += tab("File", fName)
13559:    txt += tab("Directory", fDir)
13560:    if FFCyVu(picFile):
13561:     self.VVAfO9 = picFile
13562:   elif s.VVPxk5:
13563:    txt += tab("Reference", s.VVPxk5)
13564:   if s.VVPxk5.startswith("1:64:"):
13565:    return txt
13566:   if not isLocal or s.VVPxk5.endswith(":" + s.VV1wIO):
13567:    bouq = self.VVS8aV(s.VVPxk5, s.VVAQqG, s.VVfaDB, s.VV1wIO)
13568:    if bouq:
13569:     txt += "\n" + bouq
13570:   if not isLocal and not isIptv or s.VVAQqG:
13571:    txt += "\n"
13572:    txt += self.Sep
13573:    namespace = None
13574:    if s.VVPxk5:
13575:     tp = CC3Z54()
13576:     tpTxt, namespace = tp.VVQh97([s.VVPxk5, s.VVAQqG])
13577:     if tpTxt:
13578:      txt += FFjt5L("Tuner:\n", VVFuwR)
13579:      txt += tpTxt
13580:      txt += "\n"
13581:      txt += self.Sep
13582:    txt += FFjt5L("Codes:\n", VVFuwR)
13583:    if namespace: txt += "Namespace\t: %s\n" % namespace
13584:    else  : txt += self.VVJi7Q(s.info, "Namespace", iServiceInformation.sNamespace, 1, 8)
13585:    txt += self.VVJi7Q(s.info, "Video PID" , iServiceInformation.sVideoPID , 2, 4)
13586:    txt += self.VVJi7Q(s.info, "Audio PID" , iServiceInformation.sAudioPID , 2, 4)
13587:    txt += self.VVJi7Q(s.info, "PCR PID" , iServiceInformation.sPCRPID , 2, 4)
13588:    txt += self.VVJi7Q(s.info, "PMT PID" , iServiceInformation.sPMTPID , 2, 4)
13589:    txt += self.VVJi7Q(s.info, "TXT PID" , iServiceInformation.sTXTPID , 2, 4)
13590:    txt += self.VVJi7Q(s.info, "SID"  , iServiceInformation.sSID  , 2, 4)
13591:    txt += self.VVJi7Q(s.info, "ONID"  , iServiceInformation.sONID  , 2, 4)
13592:    txt += self.VVJi7Q(s.info, "TSID"  , iServiceInformation.sTSID  , 2, 4)
13593:   return txt
13594:  def VVJi7Q(self, info, name, what, mode=0, digits=0):
13595:   tab = "\t"
13596:   txt = str(FFMzWf(info, what))
13597:   if len(txt) > 0:
13598:    try  : hexVal = hex(int(txt))[2:].upper()
13599:    except : hexVal = ""
13600:    if digits > 0:
13601:     hexVal = hexVal.zfill(digits)
13602:    if   mode == 1     : txt = hexVal
13603:    elif mode == 2     : txt = "%s\tdec: %s" % (hexVal, txt)
13604:    elif mode == 3     : txt = "Yes" if txt=="1" else "No"
13605:    elif mode == 4     : txt = self.VVfkRn(txt)
13606:    if txt : return "%s%s: %s\n" % (name, tab, txt)
13607:    else : return ""
13608:   else:
13609:    return ""
13610:  def VVfkRn(self, sVideoType):
13611:   codec_data = { -1: "", 0: "MPEG-2", 1: "H.264 (MPEG-4 AVC)", 2: "H.263", 3: "VC1", 4: "MPEG-4 (VC)", 5: "VC1-SM", 6: "MPEG-1", 7: "H.265 (HEVC)", 8: "VP8", 9: "VP9", 10: "XVID", 11: "11", 12: "12", 13: "DIVX 3.11", 14: "DIVX 4", 15: "DIVX 5", 16: "AVS", 17: "17", 18: "VP6", 19: "19", 20: "20", 21: "SPARK" }
13612:   return codec_data.get(int(sVideoType), "")
13613:  def VVS8aV(self, VVPxk5, sRelRef, VVfaDB, VV1wIO):
13614:   VVPxk5 = FFtCD7(VVPxk5, VVfaDB, VV1wIO)
13615:   if not VVPxk5:
13616:    return ""
13617:   fList = []
13618:   txt = FFYVq0(VVQe79 + "bouquets.tv")
13619:   list =  iFindall(r"(userbouquet[.].*[.]tv)", txt, IGNORECASE)
13620:   if list: fList += list
13621:   txt = FFYVq0(VVQe79 + "bouquets.radio")
13622:   list =  iFindall(r"(userbouquet[.].*[.]radio)", txt, IGNORECASE)
13623:   if list: fList.extend(list)
13624:   VVGape = []
13625:   ref1 = FFXarh(VVPxk5)
13626:   for item in fList:
13627:    path = VVQe79 + item
13628:    if FFCyVu(path):
13629:     txt = FFXarh(FFYVq0(path))
13630:     if ref1 in txt or sRelRef and sRelRef in txt:
13631:      span = iSearch(r"
13632:      if span : bName = span.group(1)
13633:      else : bName = "[ No Name ]"
13634:      VVGape.append((bName, os.path.basename(path)))
13635:   if not VVGape:
13636:    return ""
13637:   txt = self.Sep
13638:   if len(VVGape) == 1:
13639:    txt += "%s\t: %s%s\n" % (FFjt5L("Bouquet", VVFuwR), VVGape[0][0], " (%s)" % VVGape[0][1] if VVWe5f else "")
13640:   else:
13641:    txt += FFjt5L("Bouquets:\n", VVFuwR)
13642:    for ndx, item in enumerate(VVGape):
13643:     txt += "%d- %s%s\n" % (ndx + 1, item[0].strip(), " (%s)" % item[1] if VVWe5f else "")
13644:   return txt
13645:  def VVRbRj(self):
13646:   if not VVBvqf:
13647:    return
13648:   def VVJi7Q(key, val):
13649:    return "%s= %s\n" % (key.ljust(12), val)
13650:   txt = ""
13651:   s = CC3rDi(self.session)
13652:   n = ("VVPxk5", "VVZcRP", "VV57TX", "VVfaDB", "VV1wIO", "prov", "state")
13653:   v = (s.VVPxk5, s.VVZcRP, s.VV57TX, s.VVfaDB, s.VV1wIO, s.prov, s.state)
13654:   for i in range(len(n)):
13655:    txt += VVJi7Q(n[i], v[i])
13656:   if "chCode" in s.VVfaDB:
13657:    p = CC96QG()
13658:    valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVGNGo(s.VVZcRP)
13659:    n = ("valid", "ph1", "playHost", "mode", "host", "mac", "epNum", "epId", "chCm", "query")
13660:    v = (valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, query)
13661:    for i in range(len(n)):
13662:     txt += VVJi7Q(n[i], v[i])
13663:   path = "/tmp/ajp_channel_details"
13664:   with open(path, "a") as f:
13665:    f.write("%s\n%s\n" % (SEP, txt))
13666:   FF28n1(self, "Saved to : %s" % path, 1000)
13667:  @staticmethod
13668:  @FFOAKH("Checking Server")
13669:  def VVnMBE(SELF):
13670:   if not CCwhE4.VVOJRa(SELF):
13671:    return
13672:   title = "File Size"
13673:   fSize = "Not received from server"
13674:   VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(SELF)
13675:   seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt = CCqWM2.VVVxSJ(SELF)
13676:   err = url =  fSize = resumable = ""
13677:   if VVZcRP and seekable == 3 and durVal > 0:
13678:    url = iSub(r"[&?]mode=.+end=", r"", VVZcRP, flags=IGNORECASE)
13679:    url = iSub(r"[?]play_token.+", r"", url, flags=IGNORECASE)
13680:    if url.endswith(":" + VV1wIO):
13681:     url = url[:-(len(VV1wIO) + 1)]
13682:    if "chCode" in VVZcRP:
13683:     url = CC96QG.VVqzuM(VVZcRP)
13684:    try:
13685:     import requests
13686:     resp = requests.get(url, headers=CCkEI5.VVgoVw(), timeout=4, stream=True, verify=False)
13687:     if not resp.ok:
13688:      FFdw58(SELF, "Err-%d : %s" % (resp.status_code, resp.reason), title=title)
13689:      return
13690:     hSize = resp.headers.get("Content-Length", "")
13691:     if hSize and hSize.isdigit():
13692:      size = int(hSize)
13693:      fSize = CClYaF.VV99gM(size)
13694:      if "vnd.apple" in resp.headers.get("content-type", ""):
13695:       fSize += FFjt5L(" (M3U/M3U8 File)", VVA4XU)
13696:     else:
13697:      fSize = "No info. from server. Try again later."
13698:     resumable = "Yes" if CCHRcZ.VV5qrn(resp) else "No"
13699:    except requests.Timeout as e: err = "Connection Timeout"
13700:    except      : err = "Connection Error"
13701:   else:
13702:    err = "Not a Movie/Series !"
13703:   def VVVuRT(subj, val):
13704:    return "%s\n%s\n\n" % (FFjt5L("%s:" % subj, VVFuwR), val)
13705:   title = "File Size"
13706:   txt  = VVVuRT(title , fSize or "?")
13707:   txt += VVVuRT("Name" , VV1wIO)
13708:   txt += VVVuRT("URL" , url)
13709:   if resumable: txt += VVVuRT("Supports Download-Resume", resumable)
13710:   if err  : txt += FFjt5L("Error:\n", VVz22H) + err
13711:   FF4lCP(SELF, txt, title=title)
13712:  @staticmethod
13713:  def VVSY7D(SELF):
13714:   fPath, fDir, fName = CClYaF.VV4zSS(SELF)
13715:   if fPath:
13716:    fPic = CCvjVs.VVbTkM(fPath)
13717:    return fPath, fDir, fName, fPic
13718:   else:
13719:    return "", "", "", ""
13720:  @staticmethod
13721:  def VVbTkM(path):
13722:   p = os.path.splitext(path)[0]
13723:   for ext in ("png", "jpg", "bmp", "gif", "jpe", "jpeg"):
13724:    pic = "%s.%s" % (p, ext)
13725:    if FFCyVu(pic):
13726:     return pic
13727:   return ""
13728:  @staticmethod
13729:  def VVQ9GP(path, maxW=132):
13730:   return FFb2oQ("ffmpeg -y -i '%s' -vf scale=-1:%d '%s'" % (path, maxW, path))
13731:  @staticmethod
13732:  def VVi5vZ(VVPxk5):
13733:   VVPxk5 = CCvjVs.VVHamE(VVPxk5)
13734:   if VVPxk5 : return CCafIt.VVjkKT() + VVPxk5.replace(":", "_").upper() + ".png"
13735:   else  : return ""
13736:  @staticmethod
13737:  def VVHamE(VVPxk5):
13738:   span = iSearch(r"^((?:[a-f0-9]+:){9}(?:[a-f0-9]+))", VVPxk5, IGNORECASE)
13739:   return span.group(1).upper() if span else ""
13740:  @staticmethod
13741:  def VV1sZM(url):
13742:   if not FFHgaY(url):
13743:    span = iSearch(r"(?:[A-Fa-f0-9]+[:]){10}(.+)", url, IGNORECASE)
13744:    if span:
13745:     url = span.group(1)
13746:    if not VVBvqf:
13747:     url = iSub(r"[&?]mode=.+end=", "", url, flags=IGNORECASE)
13748:   return FFXarh(url)
13749:  @staticmethod
13750:  def VVjB93(VVPxk5, showUrl=True):
13751:   VVPxk5, VVZcRP, VV57TX, VVfaDB = CC3rDi.VVGg6H(VVPxk5)
13752:   if VVZcRP:
13753:    txt = "Reference\t: %s\n" % VVPxk5
13754:    p = CC96QG()
13755:    valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVGNGo(VVZcRP)
13756:    if valid:
13757:     txt += "Portal Host\t: %s\n" % host
13758:     txt += "Portal MAC\t: %s\n"  % mac
13759:     txt += "Portal Mode\t: %s\n" % {"itv":"Live", "vod":"VOD", "series":"Series"}.get(mode, "?")
13760:    if showUrl:
13761:     txt += "\n"
13762:     txt += FFjt5L("URL:", VVGCYL) + "\n%s\n" % CCvjVs.VV1sZM(VVZcRP)
13763:   else:
13764:    txt = "\n"
13765:    txt += FFjt5L("Reference:", VVGCYL) + "\n%s\n" % VVPxk5
13766:   return txt
13767:  @staticmethod
13768:  def VV0Xds(SELF, **kwargs):
13769:   cbFnc = kwargs.pop("cbFnc", None)
13770:   SELF.session.openWithCallback(cbFnc, CCvjVs, **kwargs)
13771:  @staticmethod
13772:  def VVUxTg(session):
13773:   session.open(CCvjVs, VV7VUc=CCvjVs.VVvrVY)
13774:  @staticmethod
13775:  def VVbjRo():
13776:   try: return len(InfoBar.instance.getCurrentServiceSubtitle().getSubtitleList())
13777:   except: return -1
13778:  @staticmethod
13779:  def VVL5jW():
13780:   try: lst = InfoBar.instance.getCurrentServiceSubtitle().getSubtitleList() or []
13781:   except: lst = []
13782:   tEmb = tFil = 0
13783:   for item in lst:
13784:    if len(item) >= 5:
13785:     typ, src = item[0], item[2]
13786:     if  typ == 0: tEmb += 1
13787:     elif typ == 1: tEmb += 1
13788:     elif typ == 2:
13789:      if  src == 1  : tEmb += 1
13790:      elif 2 <= src <= 6 : tFil += 1
13791:   if   tEmb and not tFil : return 1
13792:   if   tFil and not tEmb : return 2
13793:   elif tFil and tEmb  : return 3
13794:   else     : return 0
13795:  @staticmethod
13796:  def VVHlVI(session):
13797:   try: return session.nav.getCurrentService().audioTracks().getNumberOfTracks() or 0
13798:   except: return -1
13799:  @staticmethod
13800:  def VVNYXU(info):
13801:   if info:
13802:    aspect = FFMzWf(info, iServiceInformation.sAspect)
13803:    if aspect.isdigit():
13804:     aspect = int(aspect)
13805:     if aspect in ( 1, 2, 5, 6, 9, 0xA, 0xD, 0xE ) : return "4:3"
13806:     else           : return "16:9"
13807:   return ""
13808:  @staticmethod
13809:  def VVZHUt(info):
13810:   w = FFMzWf(info, iServiceInformation.sVideoWidth)
13811:   h = FFMzWf(info, iServiceInformation.sVideoHeight)
13812:   if w and h and (w, h) != ("0", "0") : return "%s x %s" % (w, h)
13813:   else        : return ""
13814: class CC96QG():
13815:  def __init__(self):
13816:   self.VVawfw()
13817:   self.VVxRkD    = ""
13818:   self.VVnS6i   = "
13819:   self.VVIrBX   = "#f#11aaffff#Server"
13820:   self.portal_firstResponse = {}
13821:   self.portal_latestResponse = {}
13822:  def VVawfw(self):
13823:   self.VVncdQ   = ""
13824:   self.VVvRlC    = ""
13825:   self.VVtmjV   = ""
13826:   self.VVN9HP = ""
13827:   self.VVnsdh  = ""
13828:   self.VVdDpE = 0
13829:  def VVNf1R(self, url, mac, ph1="", VVwb7n=True):
13830:   self.VVawfw()
13831:   self.VVxRkD = {"s": "/server/load.php", "p": "/portal.php", "q": "/portal1.php"}.get(ph1, "")
13832:   host = self.VVY27l(url)
13833:   if not host:
13834:    if VVwb7n:
13835:     self.VVQ5VQ("Incorrect URL Format !\n\n%s" % url)
13836:    return False
13837:   mac = self.VV1r6n(mac)
13838:   if not host:
13839:    if VVwb7n:
13840:     self.VVQ5VQ("Incorrect MAC Format !\n\n%s" % mac)
13841:    return False
13842:   self.VVncdQ = host
13843:   self.VVvRlC  = mac
13844:   return True
13845:  def VVaM9P(self):
13846:   return {"/server/load.php":"s", "/portal.php":"p", "/portal1.php":"q"}.get(self.VVxRkD, "")
13847:  def VVY27l(self, url):
13848:   if url.endswith("mac=") : url = url[:-4]
13849:   if url.endswith("mac") : url = url[:-3]
13850:   url = url.rstrip("/?")
13851:   if url.endswith("/c") : url = url[:-2]
13852:   url = url.rstrip("/ :")
13853:   span = iSearch(r"(.+)(\/playlist.+mac)", url, IGNORECASE)
13854:   if span:
13855:    url = span.group(1)
13856:   return url
13857:  def VV1r6n(self, mac):
13858:   span = iSearch(r"((?:[A-Fa-f0-9]{2}:){5}[A-Fa-f0-9]{2})", mac, IGNORECASE)
13859:   if span : return span.group(1).upper()
13860:   else : return ""
13861:  def VViTWL(self):
13862:   h = self.portal_firstResponse.get("resHeaders", "")
13863:   if h: return h.get("Server", "")
13864:   else: return ""
13865:  def VVBNue(self):
13866:   res, err = self.VVnjdQ(self.VVxctv())
13867:   self.portal_firstResponse = self.portal_latestResponse
13868:   if "403" in err or "404" in err or res and res.status_code == 200 and not res.text.strip():
13869:    if self.VVncdQ.endswith("/c"):
13870:     self.VVncdQ = self.VVncdQ[:-2]
13871:     res, err = self.VVnjdQ(self.VVxctv())
13872:    elif self.VVncdQ.endswith("/stalker_portal"):
13873:     self.VVncdQ = self.VVncdQ[:-15]
13874:     res, err = self.VVnjdQ(self.VVxctv())
13875:    else:
13876:     self.VVncdQ += "/c"
13877:     res, err = self.VVnjdQ(self.VVxctv())
13878:   token = rand = ""
13879:   if not err:
13880:    try:
13881:     tDict = jLoads(res.text)
13882:     token = FFYjVd(tDict["js"], "token")
13883:     rand  = FFYjVd(tDict["js"], "random")
13884:    except:
13885:     pass
13886:   return token.strip(), rand.strip(), err
13887:  def VVTATM(self, VVwb7n=True):
13888:   if not self.VVxRkD:
13889:    self.VVqjN9()
13890:   err = blkMsg = FFipXTTxt = ""
13891:   try:
13892:    token, rand, err = self.VVBNue()
13893:    if token:
13894:     self.VVtmjV = token
13895:     self.VVN9HP = rand
13896:     if rand:
13897:      self.VVdDpE = 2
13898:     prof, retTxt = self.VVoOAz(True)
13899:     if prof:
13900:      self.VVnsdh = retTxt
13901:      if any(x in retTxt for x in ("device_id mismatch", "old firmware")):
13902:       self.VVdDpE = 3
13903:       prof, retTxt = self.VVoOAz(False)
13904:       if retTxt:
13905:        self.VVnsdh = retTxt
13906:     return token, prof, ""
13907:   except:
13908:    pass
13909:   tErr = err or "Could not get Token from server !"
13910:   if blkMsg or FFipXTTxt:
13911:    tErr += "\n"
13912:    if blkMsg: tErr += "\n%s" % blkMsg
13913:    if FFipXTTxt: tErr += "\n%s" % FFipXTTxt
13914:   if VVwb7n:
13915:    self.VVQ5VQ(tErr)
13916:   return "", "", tErr
13917:  def VVqjN9(self):
13918:   try:
13919:    import requests
13920:    url = self.VVTr19()
13921:    jsFile = "xpcom.common.js"
13922:    res = requests.get("%s/stalker_portal/c/%s" % (url, jsFile), headers=CCkEI5.VVgoVw(), stream=True, timeout=2)
13923:    if not res.ok or not "javascript" in res.headers.get("content-type"):
13924:     res = requests.get("%s/c/%s" % (url, jsFile), headers=CCkEI5.VVgoVw(), stream=True, timeout=2)
13925:    if res.ok and "javascript" in res.headers.get("content-type"):
13926:     patt = ""
13927:     for line in res.iter_lines():
13928:      if len(line) > 500:
13929:       continue
13930:      elif line:
13931:       line = str(line.decode('utf-8'))
13932:       span = iSearch(r"\s*var\s+pattern\s*=\s*\/(.+)\/\s*;", line, IGNORECASE)
13933:       if span:
13934:        patt = span.group(1)
13935:       span = iSearch(r".+ajax_loader.+'(\/.+\.php)'", line, IGNORECASE)
13936:       if span:
13937:        if "portal_path" in line:
13938:         if patt.endswith(r"*\/(.)*"): url += "/c"
13939:         else      : url += "/stalker_portal"
13940:        self.VVncdQ = url
13941:        self.VVxRkD = span.group(1)
13942:        return
13943:   except:
13944:    pass
13945:   self.VVxRkD = "/server/load.php"
13946:  def VVTr19(self):
13947:   url = self.VVncdQ.rstrip("/")
13948:   if url.endswith("/c")    : url = url[:-2]
13949:   if url.endswith("/stalker_portal") : url = url[:-15]
13950:   if url.endswith("/c")    : url = url[:-2]
13951:   return url
13952:  def VVI5kn(self, url, isJsFile=False):
13953:   import requests
13954:   jsFile = "xpcom.common.js" if isJsFile else "version.js"
13955:   res, err = self.VVnjdQ("%s/stalker_portal/c/%s" % (url, jsFile))
13956:   if not res or not "javascript" in res.headers.get("content-type"):
13957:    res, err = self.VVnjdQ("%s/c/%s" % (url, jsFile))
13958:   if res and "javascript" in res.headers.get("content-type"):
13959:    if isJsFile:
13960:     return str(res.content), ""
13961:    else:
13962:     span = iSearch(r"var\s+ver\s*=\s*'(.+)'", res.text, IGNORECASE)
13963:     if span:
13964:      return span.group(1), ""
13965:   return "", err
13966:  def VVoOAz(self, capMac):
13967:   res, err = self.VVnjdQ(self.VVIxOg(capMac))
13968:   if not err:
13969:    try:
13970:     tDict = jLoads(res.text)
13971:     word = "m" + "sg"
13972:     blkMsg = FFYjVd(tDict["js"], "block_%s" % word)
13973:     FFipXTTxt = FFYjVd(tDict["js"], word)
13974:     return tDict, FFipXTTxt.strip() or blkMsg.strip()
13975:    except:
13976:     pass
13977:   return "", ""
13978:  def VVIxOg(self, capMac):
13979:   param = ""
13980:   if self.VVnsdh or self.VVN9HP:
13981:    param = self.getMoreAuth_params(self.getMoreAuth_IDs(self.VVvRlC.upper() if capMac else self.VVvRlC.lower(), self.VVN9HP))
13982:   elif FFQqEJ("bW9sLTI=") in self.VVncdQ:
13983:    param = self.getMoreAuth_basic(self.VVvRlC.upper())
13984:   return self.VVbKTa() + "type=stb&JsHttpRequest=1-xml&action=get_profile" + param
13985:  exec(FFQqEJ("ZGVmIGdldE1vcmVBdXRoX3BhcmFtcyhzZWxmLCBJZCk6DQogcGFyYW0gPSAiJmF1dGhfc2Vjb25kX3N0ZXA9MSZod192ZXJzaW9uPTIuMTctSUItMDAmaHdfdmVyc2lvbl8yPTYyJnNuPSVzJmRldmljZV9pZD0lcyZkZXZpY2VfaWQyPSVzJnNpZ25hdHVyZT0lcyIgJSAoSWRbMF0sIElkWzFdLCBJZFsxXSwgSWRbMl0pDQogcmV0dXJuIHBhcmFtICsgJyZ2ZXI9UGxheWVyIEVuZ2luZSB2ZXJzaW9uOiAweDU4YyZtZXRyaWNzPXsibWFjIjoiJXMiLCJzbiI6IiVzIiwidHlwZSI6IlNUQiIsIm1vZGVsIjoiTUFHMjUwIiwicmFuZG9tIjoiJXMifScgJSAoSWRbM10sIElkWzBdLCBJZFs0XSkNCmRlZiBnZXRNb3JlQXV0aF9JRHMoc2VsZiwgbSwgcik6DQogaW1wb3J0IGhhc2hsaWINCiBtYWNVdGY4ID0gbS5lbmNvZGUoJ3V0Zi04JykNCiBzID0gaGFzaGxpYi5tZDUobWFjVXRmOCkuaGV4ZGlnZXN0KCkudXBwZXIoKVs6MTNdDQogcmV0dXJuIHMsIGhhc2hsaWIuc2hhMjU2KG1hY1V0ZjgpLmhleGRpZ2VzdCgpLnVwcGVyKCksIGhhc2hsaWIuc2hhMjU2KChzICsgbSkuZW5jb2RlKCd1dGYtOCcpKS5oZXhkaWdlc3QoKS51cHBlcigpLCBtLCBy"))
13986:  exec(FFQqEJ("ZGVmIGdldE1vcmVBdXRoX2Jhc2ljKHNlbGYsIG0pOiByZXR1cm4gJyZod192ZXJzaW9uPTEuNy1CRC0wMCZtZXRyaWNzPXsibWFjIjoiJXMiLCJzbiI6IiVzIiwibW9kZWwiOiJNQUcyNTAiLCJ0eXBlIjoiU1RCIn0nICUgKG0sIGhhc2hsaWIubWQ1KG0uZW5jb2RlKCd1dGYtOCcpKS5oZXhkaWdlc3QoKS51cHBlcigpWzoxM10p"))
13987:  def VVIr7V(self, forceMoreInfo=False):
13988:   rows = []
13989:   if not forceMoreInfo:
13990:    rows = self.VVdsoA()
13991:   if len(rows) < 10:
13992:    rows = self.VVJt5a()
13993:   if not rows or len(rows[0]) == 2:
13994:    rows.append(("Host"    , self.VVncdQ ))
13995:    rows.append(("MAC (from URL)" , self.VVvRlC ))
13996:    rows.append(("Token"   , self.VVtmjV ))
13997:    rows.sort(key=lambda x: x[0].lower())
13998:    return rows, 2
13999:   else:
14000:    rows.append(("1", self.VVnS6i  , "MAC" , self.VVvRlC ))
14001:    rows.append(("2", self.VVIrBX, "Host" , self.VVncdQ ))
14002:    rows.append(("2", self.VVIrBX, "Token" , self.VVtmjV ))
14003:    rows.sort(key=lambda x: (x[0], x[2]))
14004:    return rows, 4
14005:  def VVdsoA(self):
14006:   p, pUrl, pUrlAcc, pUrlDnld, pHost, pUser, pPass, err = CC96QG.VV1SNn(host=self.VVncdQ, mac=self.VVvRlC)
14007:   rows = []
14008:   if pUrlAcc:
14009:    res, err = self.VVnjdQ(pUrlAcc)
14010:    if not err:
14011:     try:
14012:      tDict = jLoads(res.text)
14013:      for key, val in tDict["user_info"].items() :
14014:       if any(x in key for x in ("exp_date", "created_at")): val = FFTS4w(int(val))
14015:       if isinstance(val, list): val = str(" , ".join(val))
14016:       else     : val = str(val)
14017:       rows.append(("1", self.VVnS6i, str(key).replace("_", " ").title(), val))
14018:      for key, val in tDict["server_info"].items():
14019:       if "timestamp_now"  in key : val = FFTS4w(int(val))
14020:       else      : val = str(val)
14021:       rows.append(("2", self.VVIrBX, str(key).replace("_", " ").title(), val))
14022:     except:
14023:      pass
14024:   return rows
14025:  def VVJt5a(self):
14026:   token, profile, tErr = self.VVTATM()
14027:   try:
14028:    item = profile["js"]
14029:   except:
14030:    return []
14031:   if not isinstance(item, dict):
14032:    return []
14033:   rows = []
14034:   c  = "#f#11ffff55#"
14035:   rows = []
14036:   for key, val in item.items():
14037:    if not val:
14038:     continue
14039:    try:
14040:     if key == "mac":
14041:      if val and FFBAsJ(val): val = FFQqEJ(val.decode("UTF-8"))
14042:      else     : val = self.VVvRlC
14043:     elif key == "play_token":
14044:      parts = val.split(":")
14045:      if len(parts) == 3:
14046:       pToken = parts[0]
14047:       started = FFTS4w(int(parts[1]))
14048:       if parts[2] : ends = FFTS4w(int(parts[1]) + int(parts[2]))
14049:       else  : ends = ""
14050:       val = "%s (%s ... %s)" % (pToken, started, ends)
14051:     elif key == "aspect":
14052:      val = " , ".join(["%s=%s" % (k, v) for k, v in jLoads(val)["js"].items()])
14053:     elif key in ("created", "last_watchdog"):
14054:      val = FFTS4w(int(val))
14055:     elif isinstance(val, list):
14056:      val = str(" , ".join(val))
14057:     elif isinstance(val, dict):
14058:      val = str(val).replace("u'", "").replace("'", "").strip("{} ")
14059:     else:
14060:      val = str(val).strip()
14061:    except:
14062:     val = str(val)
14063:    rows.append(((str(key).replace("_", " ").title(), str(val))))
14064:   return rows
14065:  def VVsbRz(self, mode, chCm, epNum, epId):
14066:   token, profile, tErr = self.VVTATM(VVwb7n=False)
14067:   if not token:
14068:    return ""
14069:   crLinkUrl = self.VVYCAa(mode, chCm, epNum, epId)
14070:   res, err = self.VVnjdQ(crLinkUrl)
14071:   chUrl = ""
14072:   if not err:
14073:    try: chUrl = FFYjVd(jLoads(res.text)['js'], "cmd")
14074:    except: pass
14075:   chUrl = chUrl.replace("\t", "")
14076:   if " " in chUrl:
14077:    chUrl = chUrl.split(" ")[1].strip(" _")
14078:   chUrl = chUrl.replace(":", "%3a")
14079:   return chUrl
14080:  def VVbKTa(self):
14081:   return self.VVncdQ + self.VVxRkD + "?"
14082:  def VVxctv(self):
14083:   return self.VVbKTa() + "type=stb&action=handshake&JsHttpRequest=1-xml&token="
14084:  def VVryIa(self, mode):
14085:   url = self.VVbKTa() + "type=%s&JsHttpRequest=1-xml&action=" % mode
14086:   if   mode == "itv"  : url += "get_genres"
14087:   elif mode == "vod"  : url += "get_categories&force_ch_link_check="
14088:   elif mode == "series": url += "get_categories"
14089:   return url
14090:  def VVhjC5(self, catID):
14091:   return self.VVbKTa() + "type=series&action=get_ordered_list&sortby=added&movie_id=%s&p=1" % catID
14092:  def VV7Kcq(self, mode, catID, page):
14093:   url = self.VVbKTa() + "type=%s&JsHttpRequest=1-xml&action=get_ordered_list&sortby=number&p=%d&" % (mode, page)
14094:   if mode == "itv": url += "genre=%s" % catID
14095:   else   : url += "category=%s&force_ch_link_check=" % catID
14096:   return url
14097:  def VVLfbI(self, mode, searVV1wIO, catId, page):
14098:   catId = ("&category=%s" % catId) if catId else ""
14099:   return self.VVbKTa() + "type=%s&JsHttpRequest=1-xml&action=get_ordered_list&search=%s&%s&p=%d" % (mode, searVV1wIO, catId, page)
14100:  def VVc7nF(self, stID):
14101:   return self.VVbKTa() + "type=itv&JsHttpRequest=1-xml&action=get_short_epg&ch_id=%s" % stID
14102:  def VVYCAa(self, mode, chCm, serCode, serId):
14103:   url = self.VVbKTa() + "action=create_link&"
14104:   if mode == "series" : url += "type=vod&series=%s&JsHttpRequest=1-xml&cmd=/media/%s.mpg" % (serCode, serId)
14105:   else    : url += "type=%s&cmd=%s&JsHttpRequest=1-xml&forced_storage=0&disable_ad=0&download=0" % (mode, chCm)
14106:   return url
14107:  def VVX37W(self):
14108:   return self.VVbKTa() + "type=itv&JsHttpRequest=1-xml&action=create_link"
14109:  def VVfi1S(self, host, mac, mode, VV1wIO, catID, stID, chNum, chCm, serCode, serId):
14110:   VVPxk5 = self.VVpX1r(catID, stID, chNum)
14111:   query = self.VVn2QP(mode, self.VVaM9P(), FFiPNn(host), FFiPNn(mac), serCode, serId, chCm, catID, stID)
14112:   if   chCm.endswith(".m3u8") : chUrl = "%s?%s" % (chCm, query)
14113:   elif "deviceMac=" in chCm : chUrl = "%s?%s" % (chCm, query)
14114:   else      : chUrl = "%s/j.php?%s" % (host, query)
14115:   chUrl = VVPxk5 + chUrl.replace(":", "%3a") + ":" + VV1wIO
14116:   return VVPxk5, chUrl
14117:  def VVn2QP(self, mode, ph1, host, mac, serCode, serId, chCm, catID, stID):
14118:   query = "mode=%s&ph1=%s&hst=%s&chCode=%s&epNum=%s&epId=%s&cId=%s&sId=%s&chCm=%s&end=" % (mode, ph1, host, mac, serCode, serId, catID, stID, chCm)
14119:   return query.replace("ffmpeg ", "").replace(":", "%3a")
14120:  def VVGNGo(self, url):
14121:   if   "mode=itv"  in url: mode = "itv"
14122:   elif "mode=vod"  in url: mode = "vod"
14123:   elif "mode=series" in url: mode = "series"
14124:   else       : return False, "", "", "", "", "", "", "", "", "", "", ""
14125:   res  = iUrlparse(url)
14126:   scheme = res.scheme
14127:   netloc = res.netloc
14128:   tDict = iUrlparse_qs(res.query)
14129:   ph1  = tDict.get("ph1" , [""])[0].strip()
14130:   host = tDict.get("hst" , [""])[0].strip()
14131:   mac  = tDict.get("chCode", [""])[0].strip()
14132:   epNum = tDict.get("epNum" , [""])[0].strip().replace(":" , "%3a")
14133:   epId = tDict.get("epId" , [""])[0].strip().replace(":" , "%3a")
14134:   chCm = tDict.get("chCm" , [""])[0].strip().replace("ffmpeg ", "").replace(":" , "%3a")
14135:   catID = tDict.get("cId" , [""])[0].strip()
14136:   stID = tDict.get("sId" , [""])[0].strip()
14137:   span = iSearch(r"chCm=(.+)&end=", url, IGNORECASE)
14138:   if span: chCm = span.group(1)
14139:   query = self.VVn2QP(mode, ph1, host, mac, epNum, epId, FFSiPR(chCm), catID, stID)
14140:   if scheme: scheme += "://"
14141:   playHost = scheme + netloc
14142:   host  = FFQqEJ(host)
14143:   mac   = FFQqEJ(mac)
14144:   valid = False
14145:   if self.VVY27l(playHost) and self.VVY27l(host) and self.VVY27l(mac):
14146:    if (mode in ("itv", "vod") and chCm) or (mode == "series" and epNum and epId):
14147:     valid = True
14148:   return valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query
14149:  def VVmjF4(self, url):
14150:   return iSub(r"[&?]mode=.+end=", "", url, flags=IGNORECASE)
14151:  def VVnjdQ(self, url, useCookies=True):
14152:   self.portal_latestResponse = {"url": url, "resErr": ""}
14153:   try: import requests
14154:   except: return "", 'The "Requests" library is not installed'
14155:   err = ""
14156:   crErr = False
14157:   try:
14158:    headers = CCkEI5.VVgoVw()
14159:    if self.VVtmjV:
14160:     headers["Authorization"] = "Bearer %s" % self.VVtmjV
14161:    self.portal_latestResponse["headers"] = headers
14162:    if useCookies : cookies = {"mac": self.VVvRlC, "stb_lang": "en"}
14163:    else   : cookies = None
14164:    self.portal_latestResponse["cookies"] = cookies
14165:    res = requests.get(url, headers=headers, allow_redirects=True, timeout=CFG.portalConnTimeout.getValue(), cookies=cookies)
14166:    self.portal_latestResponse["resHeaders"] = res.headers
14167:    self.portal_latestResponse["resErrCode"] = res.status_code
14168:    if res.ok:
14169:     return res, ""
14170:    else:
14171:     if res.status_code == 407: reason = "Proxy Authentication Required"
14172:     if res.status_code == 423: reason = "Access Locked"
14173:     if res.status_code == 521: reason = "Server Is Down"
14174:     else      : reason = "Unknown"
14175:     err = "Err-%d : %s" % (res.status_code, res.reason or reason)
14176:   except requests.Timeout as e  : crErr, err = True, "Connection Timeout"
14177:   except requests.ConnectionError as e: crErr, err = True, "Connection Error"
14178:   except Exception as e    : crErr, err = True, "Error\n" + str(e)[:120]
14179:   self.portal_latestResponse["resErr"] = err
14180:   self.portal_latestResponse["resCritical"] = crErr
14181:   return "", err
14182:  @staticmethod
14183:  def VVKe8x(url, extraHeaders=None, cookies=None, timeout=3, verify=False):
14184:   resp, txt, err = None, "", ""
14185:   try:
14186:    import requests
14187:    headers = CCkEI5.VVgoVw()
14188:    if extraHeaders: headers.update(extraHeaders)
14189:    resp = requests.get(url, headers=headers, allow_redirects=True, timeout=timeout, cookies=cookies, verify=verify)
14190:    if resp.ok : txt = str(resp.text)
14191:    else  : err = "Error %d\n\n%s" % (resp.status_code, resp.reason)
14192:   except:
14193:    err = "Error while contacting server !"
14194:   return resp, txt, err
14195:  def VVQ5VQ(self, err, title="Portal Browser"):
14196:   FFdw58(self, str(err), title=title)
14197:  def VVdGiv(self, mode):
14198:   if   mode in ("itv"  , CCkEI5.VVgkvV , CCkEI5.VVXewY)  : return "Live"
14199:   elif mode in ("vod"  , CCkEI5.VVgL8R , CCkEI5.VVw3vg)  : return "VOD"
14200:   elif mode in ("series" , CCkEI5.VV6cbr , CCkEI5.VVtP50) : return "Series"
14201:   else                          : return "IPTV"
14202:  def VVvwJ7(self, mode, searVV1wIO):
14203:   return 'Find in %s : %s' % (self.VVdGiv(mode), FFjt5L(searVV1wIO, VVA4XU))
14204:  def VVafii(self, catchup=False):
14205:   VV3wat = []
14206:   VV3wat.append(("Live"    , "live"  ))
14207:   VV3wat.append(("VOD"    , "vod"   ))
14208:   VV3wat.append(("Series"   , "series"  ))
14209:   if catchup:
14210:    VV3wat.append(VVAL3j)
14211:    VV3wat.append(("Catch-up TV" , "catchup"  ))
14212:   VV3wat.append(VVAL3j)
14213:   VV3wat.append(("Account Info." , "accountInfo" ))
14214:   return VV3wat
14215:  @staticmethod
14216:  def VVfs3s(VVZcRP):
14217:   p = CC96QG()
14218:   valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVGNGo(VVZcRP)
14219:   if valid and chCm:
14220:    if   mode == "itv"  : patt = r'.+ch\/(\d+)_'
14221:    elif mode == "vod"  : patt = r'stream_id":"*(\d+)'
14222:    elif mode == "series": patt = r'series_id":"*(\d+)'
14223:    span = iSearch(patt, FFQqEJ(chCm), IGNORECASE)
14224:    if span:
14225:     return span.group(1)
14226:   return ""
14227:  @staticmethod
14228:  def VVqzuM(VVZcRP):
14229:   p = CC96QG()
14230:   valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVGNGo(VVZcRP)
14231:   if valid:
14232:    if CC96QG.VVdkFC(chCm):
14233:     return FFXarh(chCm)
14234:    else:
14235:     ok = p.VVNf1R(host, mac, ph1, VVwb7n=False)
14236:     if ok:
14237:      try:
14238:       chUrl = p.VVsbRz(mode, chCm, epNum, epId)
14239:       return FFXarh(chUrl)
14240:      except:
14241:       pass
14242:   return ""
14243:  @staticmethod
14244:  def VVdkFC(chCm):
14245:   return chCm.startswith("http") and not "//localhost/" in chCm
14246:  @staticmethod
14247:  def VV9eVr(VVZcRP):
14248:   if not "chCode" in VVZcRP: return None, "Not Portal"
14249:   p = CC96QG()
14250:   valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVGNGo(VVZcRP)
14251:   if not valid: return None, "Invalid URL"
14252:   return CC96QG.VV5yj4(host, mac, ph1)
14253:  @staticmethod
14254:  def VV5yj4(host, mac, ph1=""):
14255:   p = CC96QG()
14256:   if not p.VVNf1R(host, mac, ph1=ph1, VVwb7n=False): return None, "Invalid Host/MAC"
14257:   token, profile, tErr = p.VVTATM(VVwb7n=False)
14258:   if not token: return None, tErr
14259:   return p, ""
14260:  @staticmethod
14261:  def VV1SNn(VVZcRP="", host="", mac="", ph1=""):
14262:   pUrl = pUrlAcc = pUrlDnld = pHost = pUser = pPass = err = ""
14263:   if   VVZcRP  : p, err = CC96QG.VV9eVr(VVZcRP)
14264:   elif host and mac : p, err = CC96QG.VV5yj4(host, mac, ph1=ph1)
14265:   else    : p, err = None, "Incorrect fnc params"
14266:   if err:
14267:    return p, pUrl, pUrlAcc, pUrlDnld, pHost, pUser, pPass, err
14268:   url = p.VVX37W()
14269:   res, err = p.VVnjdQ(url)
14270:   try: cmd = FFYjVd(jLoads(res.text)["js"], "cmd")
14271:   except: return p, pUrl, pUrlAcc, pUrlDnld, pHost, pUser, pPass, err
14272:   cmd = cmd.replace("\t", "")
14273:   span = iSearch(r"(http.+)\/(.+)\/(.+)(\/\?.+)", cmd)
14274:   if span:
14275:    pHost = span.group(1)
14276:    pUser = FFSiPR(span.group(2))
14277:    pPass = FFSiPR(span.group(3))
14278:    pUrl = "%s/%s/%s/" % (pHost, pUser, pPass)
14279:    pUrlAcc = "%s/player_api.php?username=%s&password=%s" % (pHost, pUser, pPass)
14280:    pUrlDnld= "%s/get.php?username=%s&password=%s&type=m3u" % (pHost, pUser, pPass)
14281:   else:
14282:    err = "Not found"
14283:   return p, pUrl, pUrlAcc, pUrlDnld, pHost, pUser, pPass, err
14284: class CChyfE(CC96QG):
14285:  def __init__(self):
14286:   CC96QG.__init__(self)
14287:   self.mode   = ""
14288:   self.VVPxk5  = ""
14289:   self.VV1wIO   = ""
14290:   self.VVfaDB  = ""
14291:   self.chCm   = ""
14292:   self.epNum   = ""
14293:   self.epId   = ""
14294:   self.query   = ""
14295:  def VVgBJL(self, VVPxk5, VV1wIO, VVZcRP, VVfaDB):
14296:   valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = self.VVGNGo(VVZcRP)
14297:   if valid:
14298:    if self.VVNf1R(host, mac, ph1, VVwb7n=False):
14299:     self.mode  = mode
14300:     self.VVPxk5 = VVPxk5
14301:     self.VV1wIO  = VV1wIO
14302:     self.VVfaDB = VVfaDB
14303:     self.chCm  = chCm
14304:     self.epNum  = epNum
14305:     self.epId  = epId
14306:     self.query  = query
14307:     return True
14308:   return False
14309:  def VVIguo(self, session):
14310:   chUrl = ""
14311:   try:
14312:    if self.chCm.startswith("Zz1"):
14313:     self.chCm = FFQqEJ(self.chCm[3:])
14314:    else:
14315:     chUrl = self.VVsbRz(self.mode, self.chCm, self.epNum, self.epId)
14316:   except:
14317:    return False
14318:   if CC96QG.VVdkFC(self.chCm) and ("get_download_link" in chUrl or not chUrl):
14319:    chUrl = FFXarh(self.chCm)
14320:    chUrl = FFSiPR(self.chCm)
14321:    chUrl = chUrl.replace("%253a", "%3a")
14322:    if not "?" in chUrl:
14323:     chUrl += "?"
14324:   elif " " in self.chCm or " " in chUrl:
14325:    if " " in chUrl:
14326:     chUrl = chUrl.split(" ")[1]
14327:    if not "?" in chUrl:
14328:     chUrl += "?"
14329:   if not chUrl.startswith("http"):
14330:    return False
14331:   if not self.VVPxk5.endswith(":"):
14332:    self.VVPxk5 += ":"
14333:   chUrl = chUrl.strip()
14334:   chUrl = self.VVPxk5 + chUrl + ":" + self.VV1wIO
14335:   newIptvRef = self.VVvY5A(chUrl, self.VV1wIO)
14336:   bPath = CCMvE7.VVvNtR()
14337:   if newIptvRef:
14338:    newIptvRef1 = newIptvRef
14339:    if CFG.simplePortal.getValue():
14340:     newIptvRef1 = self.VVmjF4(newIptvRef)
14341:    FFnfiC(session, newIptvRef1)
14342:    if self.VVfaDB and newIptvRef and bPath:
14343:     serv = eServiceReference(newIptvRef)
14344:     newCode = serv and serv.toString()
14345:     if newCode:
14346:      self.VVhDjf(self.VVfaDB, newCode, bPath)
14347:    return True
14348:   else:
14349:    return False
14350:  def VVvY5A(self, chUrl, VV1wIO):
14351:   newIptvRef = ""
14352:   playMarks = ("play_token=", "/play/", "lid=")
14353:   for toFind in playMarks:
14354:    if toFind in chUrl:
14355:     ndx = chUrl.find(toFind)
14356:     if ndx > -1:
14357:      ndx = chUrl.find(":", ndx)
14358:      if ndx > -1:
14359:       left  = chUrl[:ndx]
14360:       right  = chUrl[ndx:]
14361:       newIptvRef = left + "&" + self.query + right
14362:     break
14363:   if not newIptvRef:
14364:    x1 = chUrl.find("?")
14365:    if x1 > -1:
14366:     x2 = chUrl[x1:].find(":")
14367:     if x2 > -1:
14368:      newIptvRef = chUrl[:x1+x2] + "&" + self.query + chUrl[x1+x2:]
14369:   if not newIptvRef and VV1wIO:
14370:    VV1wIO = ":" + VV1wIO
14371:    if chUrl.endswith(VV1wIO):
14372:     newIptvRef = chUrl[:-len(VV1wIO)].rstrip("?&") + "&" + self.query + VV1wIO
14373:   return newIptvRef
14374:  def VVhDjf(self, oldCode, newCode, bPath):
14375:   patt = r"((?:[A-Fa-f0-9]+[:]){10}).+(mode=.+)chCm="
14376:   span = iSearch(patt, newCode, IGNORECASE)
14377:   if span:
14378:    newRef, newPar = span.group(1).upper(), span.group(2)
14379:    params = ("ph1", "cId", "sId")
14380:    for par in params:
14381:     newPar = iSub(r"&%s=.*?&" % par, "&", newPar)
14382:    span = iSearch(r"(sId=.+?)&", oldCode)
14383:    sidTxt = span.group(1) if span else ""
14384:    lines = FFL19l(bPath)
14385:    for ndx, line in enumerate(lines):
14386:     span = iSearch(patt, line, IGNORECASE)
14387:     if span and sidTxt in line:
14388:      fileRef, filePar = span.group(1).upper(), span.group(2)
14389:      if newRef == fileRef:
14390:       for par in params:
14391:        filePar = iSub(r"&%s=.*?&" % par, "&", filePar)
14392:       if newPar == filePar:
14393:        lines[ndx] = "
14394:        with open(bPath, "w") as f: f.write("\n".join(lines) + "\n")
14395:        FFfpyJ()
14396: class CC6F0F(Screen):
14397:  def __init__(self, session):
14398:   self.skin, self.VVfOli = FFiNEe(VVlrZA, 510, 510, 30, 0, 0, "#ff000000", "#ff000000", 30, VVU4ws=False)
14399:   self.session  = session
14400:   self.Title   = "Movies Resume History"
14401:   self.tbl   = None
14402:   self.VVRE6N = 0
14403:   FFZMxC(self)
14404:   self.onShown.append(self.VV7OzD)
14405:  def VV7OzD(self):
14406:   self.onShown.remove(self.VV7OzD)
14407:   self.VVvB4L()
14408:  @FFOAKH()
14409:  def VVvB4L(self):
14410:   path, lst, err = CC6F0F.VVjp9r()
14411:   if not lst:
14412:    FFdw58(self, "No resume points.", title=self.Title)
14413:    self.cancel()
14414:    return
14415:   fName, fTxt, VV1wIO, VVu06s = CCzUSd.VVwtlp(self.session)
14416:   self.VVRE6N = grnB = 0
14417:   rows = []
14418:   for fName1 in lst:
14419:    d = CCzUSd.VV0NUN(path + fName1)
14420:    if d:
14421:     if fName == fName1 : c, grnB = "#f#0022ff22#", 1
14422:     else    : c = ""
14423:     prog = str(int(round(100.0 * d["pos"] / d["dur"])))
14424:     rows.append((c + d["nm"], c + FFFHEC(d["dur"] / 90000.0), c + FFFHEC(d["pos"] / 90000.0), "", prog, c + FFTS4w(d["w"]), fName1, d["u"], d["r"]))
14425:    else:
14426:     self.VVRE6N += 1
14427:   if self.tbl:
14428:    self.tbl.VVMqQ9(rows)
14429:   elif rows:
14430:    settTxt = FFjt5L("Settings : ", VVA4XU) + (FFjt5L(CFG.resumeMovies.getText(), VVYjI5 if CFG.resumeMovies.getValue() == "off" else VVJEMb))
14431:    rows.sort(key=lambda x: x[0][12:].lower() if iMatch(r"^\s*
14432:    bg = "#1a111020"
14433:    VVp1bQ = (3, 4, 80, 20)
14434:    VVu8qI = self.cancel
14435:    VVCOpO = (""  , BF(self.VVInj5, False), [])
14436:    VVu1YM  = ("Play" , self.VVXuZ7     , [])
14437:    VV2ytr = (""  , self.VVPO8c    , [])
14438:    VVwSzI = ("Current", BF(self.VVInj5, True) , [])
14439:    VVScQz = ("Options", self.VVSYXm    , [])
14440:    header  = ("Name" , "Duration", "Resume" , "Pos %" , "Pos %" , "Watched" , "File", "Source" , "ref" )
14441:    widths  = (46  , 12  , 12  , 7   , 0.03  , 23  , 0.01 , 0.01  , 0  )
14442:    VVLIqP = (LEFT  , CENTER , CENTER , CENTER , CENTER , CENTER , LEFT , LEFT  , LEFT )
14443:    self.tbl = FFUQ0v(self, None, title=self.Title, VVCNdI=settTxt, header=header, VVGape=rows, VVLIqP=VVLIqP, width=1600, height=900, VV3cHe=widths, VVwdmN=27, VVp1bQ=VVp1bQ, VVCOpO=VVCOpO, VVu1YM=VVu1YM, VVu8qI=VVu8qI, VV2ytr=VV2ytr, VVwSzI=VVwSzI, VVScQz=VVScQz
14444:         , VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#06004455", VVbcr0="#00333333", VVX9AA="#0a332244")
14445:   else:
14446:    FFdw58(self, err, title=self.Title)
14447:    self.cancel()
14448:   if self.tbl:
14449:    if grnB : self.tbl.VVsd6P()
14450:    else : self.tbl.VVucBj()
14451:  def cancel(self, VV6A99=None):
14452:   if self.tbl: self.tbl.cancel()
14453:   self.close()
14454:  def VVXuZ7(self, VV6A99, title, txt, colList):
14455:   CCqWM2.VVHc02(self.session, VVEBd5=False, VVOOLD=False, VVaHNe=colList[8], cbFnc=self.VVvB4L)
14456:  def VVPO8c(self, VV6A99, title, txt, colList):
14457:   txt = "%s\n\n%s" % (title, txt)
14458:   VV1wIO, VVPxk5 = colList[0], colList[8]
14459:   span = iSearch(r"^((?:[a-f0-9]+:){9}(?:[a-f0-9]+))", VVPxk5.strip(), IGNORECASE)
14460:   if span:
14461:    VVPxk5 = span.group(1)
14462:   CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVZImX, params=(VVPxk5, VV1wIO, txt))
14463:  def VVInj5(self, VVwb7n, VV6A99, title, txt, colList):
14464:   fName, fTxt, VV1wIO, VVu06s = CCzUSd.VVwtlp(self.session)
14465:   if fName:
14466:    VV6A99.VVn5CC(6, fName, VVwb7n=VVwb7n)
14467:  def VVSYXm(self, VV6A99, title, txt, colList):
14468:   isMulti = VV6A99.VVXWPu
14469:   rows = VV6A99.VVbF9W()
14470:   ok = not isMulti or isMulti and rows
14471:   VV3wat = []
14472:   VV3wat.append(FFsLU5("Delete All"         , "all", not isMulti, VVz22H))
14473:   VV3wat.append(FFsLU5("Delete Selected Row%s" % FFcacr(len(rows)) , "sel", ok))
14474:   if self.VVRE6N:
14475:    VV3wat.append(VVAL3j)
14476:    VV3wat.append((VVJEMb + "Clear Unreadable Files"  , "bad"))
14477:   params = [VV6A99, isMulti, rows]
14478:   cbFncDict = { "all": BF(self.VVzdsk, params + ["all"])
14479:      , "sel": BF(self.VVzdsk, params + ["sel"])
14480:      , "bad": BF(self.VVzdsk, params + ["bad"])
14481:      }
14482:   CCzSCo(self, VV6A99, setsOk=True).VV9VR2(VV3wat, cbFncDict, width=500)
14483:  def VVzdsk(self, params):
14484:   VV6A99, isMulti, rows, item = params
14485:   if item:
14486:    if item == "sel":
14487:     tot = len(rows)
14488:     if isMulti : ques = "Delete %d Resume Point%s ?" % (tot, FFcacr(tot))
14489:     else  : ques = "Delete Selected Point ?"
14490:    elif item == "all" : ques = "Delete all Resume Points ?"
14491:    elif item == "bad" : ques = "Found %d unusable file%s that could not be added to table.\n\nDelete unusable files ?" % (self.VVRE6N, FFcacr(self.VVRE6N))
14492:    FFRMYv(self, BF(self.VVAzBM, params), ques, title=self.Title)
14493:  def VVAzBM(self, params):
14494:   VV6A99, isMulti, rows, item = params
14495:   path = CCzUSd.VVc5Po("")
14496:   if item == "sel":
14497:    if isMulti:
14498:     for fName in self.tbl.VVf3uT(6):
14499:      FFwgGB(CCzUSd.VVc5Po(fName))
14500:    else:
14501:     FFwgGB(CCzUSd.VVc5Po(self.tbl.VVeE40(6)))
14502:    self.VVvB4L()
14503:   elif item == "all":
14504:    for row in self.tbl.VVrrm9():
14505:     FFwgGB(path + row[6])
14506:    FF8D5P(self.session, "Done")
14507:    self.cancel()
14508:   elif item == "bad":
14509:    path, lst, err = CC6F0F.VVjp9r()
14510:    tot = 0
14511:    for fName in lst:
14512:     d = CCzUSd.VV0NUN(path + fName)
14513:     if not d:
14514:      FFwgGB(path + fName)
14515:      tot += 1
14516:    self.VVRE6N = 0
14517:    FFipXT(self, "Deleted %d unreadable file%s." % (tot, FFcacr(tot)) if tot else "All files are OK.", title=self.Title)
14518:  @staticmethod
14519:  def VVjp9r():
14520:   path = CCzUSd.VVc5Po("")
14521:   try:
14522:    return path, os.listdir(path), ""
14523:   except Exception as e:
14524:    return path, [], str(e)
14525: class CCzUSd():
14526:  def __init__(self, VVeO1i):
14527:   self.VVNzyE = None
14528:   self.VV6Wmd = False
14529:   self.VVbU22 = 0
14530:   self.VV6jnW = 0
14531:   self.VVTBfp = eTimer()
14532:   try: self.VVTBfp_conn = self.VVTBfp.timeout.connect(self.VVHPUa)
14533:   except: self.VVTBfp.callback.append(self.VVHPUa)
14534:   self.VVTBfp.start(500, False)
14535:   self.VVkHre()
14536:  def VVkHre(self):
14537:   path = self.VVc5Po("")
14538:   if VVmJwX(path):
14539:    return os.path.isdir(path)
14540:   else:
14541:    try:
14542:     os.makedirs(path)
14543:     return True
14544:    except:
14545:     return False
14546:  def VVHPUa(self):
14547:   self.VVbU22, self.VV6jnW = CCzUSd.VVaNW3(self.VVeO1i)
14548:   if self.VV6Wmd and self.VVbU22:
14549:    self.VV6Wmd = False
14550:    self.VV44ld()
14551:  def VVlDEX(self):
14552:   self.VV6Wmd = True
14553:  def VV44ld(self):
14554:   fName, fTxt, VV1wIO, VVu06s = CCzUSd.VVwtlp(self.VVeO1i)
14555:   if not fName or self.VVNzyE == fName:
14556:    return
14557:   tDict = CCzUSd.VV0NUN(self.VVc5Po(fName))
14558:   if tDict and "pos" in tDict and "dur" in tDict:
14559:    newPos, newDur = tDict["pos"], tDict["dur"]
14560:    if abs(self.VVbU22 - newPos) // 90000.0 and newPos > 900000 and newPos < self.VVbU22 - 900000:
14561:     InfoBar.instance.doSeek(int(newPos))
14562:     InfoBar.instance.hide()
14563:     self.VVNzyE = fName
14564:  def VVB1ug(self):
14565:   self.VVNzyE = None
14566:   fName, fTxt, VV1wIO, VVu06s = CCzUSd.VVwtlp(self.VVeO1i)
14567:   if not fName or self.VVbU22 == 0:
14568:    return
14569:   if abs(self.VVbU22 - self.VV6jnW) < 90000 * 2:
14570:    FFwgGB(self.VVc5Po(fName))
14571:    return
14572:   if self.VV6jnW > 90000 * 60 and self.VV6jnW < self.VVbU22 - 900000 and self.VVbU22 > 90000 * 60:
14573:    self.VVkHre()
14574:    tDict = {"v":1, "nm": str(VV1wIO), "u": str(fTxt), "r": str(VVu06s), "pos": self.VV6jnW, "dur": self.VVbU22, "w": int(iTime())}
14575:    try:
14576:     import pickle
14577:     with open(self.VVc5Po(fName), 'wb') as f:
14578:      pickle.dump(tDict, f, 2)
14579:    except:
14580:     pass
14581:  @staticmethod
14582:  def VVwtlp(session):
14583:   s = CC3rDi(session)
14584:   fName = fTxt = ""
14585:   conf = CFG.resumeMovies.getValue()
14586:   if   conf in ("a", "i") and FFUl6q(s.VVZcRP): pass
14587:   elif conf in ("a", "l") and s.Path.startswith("/")   : pass
14588:   else              : return fName, fTxt, s.VV1wIO, s.VVu06s
14589:   fName = FFbhOc(s.uniqueId)
14590:   fTxt = s.userTxt
14591:   return fName, fTxt, s.VV1wIO, s.VVu06s
14592:  @staticmethod
14593:  def VV0NUN(fPath):
14594:   try:
14595:    import pickle
14596:    with open(fPath, 'rb') as f:
14597:     d = pickle.load(f)
14598:     if all(k in d for k in ("v", "nm", "u", "r", "pos", "dur", "w")):
14599:      d["nm"], d["u"], d["r"] = str(d["nm"]), str(d["u"]), str(d["r"])
14600:      return d
14601:   except:
14602:    pass
14603:   return None
14604:  @staticmethod
14605:  def VVc5Po(fName):
14606:   return "%sajpanel_resume/%s" % (FF0cqc(), fName)
14607:  @staticmethod
14608:  def VVaNW3(session):
14609:   serv = session.nav.getCurrentService()
14610:   pSeek = serv and serv.seek()
14611:   if not pSeek is None:
14612:    durLst = pSeek.getLength()
14613:    posLst = pSeek.getPlayPosition()
14614:    if durLst[0] == 0 and posLst[0] == 0:
14615:     return durLst[1], posLst[1]
14616:   return 0, 0
14617: class CCo1b7(CCzUSd):
14618:  VVYCbB = "START"
14619:  VVaGf1 = "INFO"
14620:  VV26Iy = "EOF"
14621:  VVEOlk = "End"
14622:  def __init__(self, VVeO1i):
14623:   CCzUSd.__init__(self, VVeO1i)
14624:   self.VVeO1i   = VVeO1i
14625:   self.VVTd3k    = eTimer()
14626:   self.VVJA3Z    = None
14627:   self.VV7LKE  = 0
14628:   self.VVedk0   = ""
14629:   self.VVr4qo   = ""
14630:   self.lastSimulatedEOF  = ""
14631:   self.VVazTO   = ""
14632:   try:
14633:    from Components.ServiceEventTracker import ServiceEventTracker
14634:    from enigma import iPlayableService
14635:    evTrk = ServiceEventTracker(screen=self.VVeO1i.screen, eventmap={iPlayableService.evStart: self.VV4MOb, iPlayableService.evEOF: self.VVqGXQ, iPlayableService.evEnd: self.VVUHQ4, iPlayableService.evUpdatedInfo: self.VVs2rG})
14636:   except:
14637:    pass
14638:   try: self.VVTd3k_conn = self.VVTd3k.timeout.connect(self.VVCjf0)
14639:   except: self.VVTd3k.callback.append(self.VVCjf0)
14640:   self.VVTd3k.start(3000, False)
14641:   self.VVCjf0()
14642:  def VVCjf0(self):
14643:   if not CFG.downloadMonitor.getValue():
14644:    self.VVQoPc()
14645:    return
14646:   lst = CCHRcZ.VVs4T7()
14647:   avPerc = []
14648:   txt = ""
14649:   if lst:
14650:    for path, totSz, logF in lst:
14651:     if totSz:
14652:      totSz = int(totSz) if totSz.isdigit() else 0
14653:      curSz = 0
14654:      sz = FFXhoc(path)
14655:      if sz > -1:
14656:       curSz = sz
14657:      if totSz:
14658:       perc = (float(curSz) / float(totSz) * 100.0)
14659:       avPerc.append(perc)
14660:     elif logF:
14661:      perc = CCHRcZ.VVlzpX(logF)
14662:      if perc > -1:
14663:       avPerc.append(perc)
14664:    if lst:
14665:     txt = "Files=%d" % len(lst)
14666:     if avPerc:
14667:      perc = sum(avPerc) / len(avPerc)
14668:      if perc: txt += "   %.2f %%" % perc
14669:   if txt:
14670:    if not self.VVJA3Z : self.VVJA3Z = CChMGW.VVNLfa(self.VVeO1i, txt, 30)
14671:    else    : CChMGW.VVr9Gs(self.VVJA3Z, txt)
14672:   elif self.VVJA3Z:
14673:    self.VVQoPc()
14674:  def VVQoPc(self):
14675:   if self.VVJA3Z:
14676:    self.VVeO1i.deleteDialog(self.VVJA3Z)
14677:    self.VVJA3Z = None
14678:  def VV4MOb(self):
14679:   self.VVTufo(CCo1b7.VVYCbB)
14680:  def VVs2rG(self):
14681:   self.VVTufo(CCo1b7.VVaGf1)
14682:   VVPxk5, VVZcRP, VVfaDB, VVX8pK = self.VVAwKT()
14683:   self.VVazTO = VVX8pK
14684:   self.VVlDEX()
14685:  def VVUHQ4(self):
14686:   self.VVTufo(CCo1b7.VVEOlk)
14687:   self.VVazTO = ""
14688:   FFOKt0(self, 1000, self.VV2VGZ)
14689:   self.VVB1ug()
14690:  def VVqGXQ(self):
14691:   self.VVTufo(CCo1b7.VV26Iy)
14692:   durVal, posVal = CCzUSd.VVaNW3(self.VVeO1i)
14693:   if durVal and posVal and (((durVal - posVal) // 90000.0) < 5):
14694:    return
14695:   if CFG.autoResetFrozenIptvChan.getValue() == "off":
14696:    return
14697:   VVPxk5, VVZcRP, VVfaDB, VVX8pK = self.VVAwKT()
14698:   if not VVfaDB or "file?file" in VVfaDB or ":ftp%3a//" in VVfaDB:
14699:    return
14700:   if iMatch(r"http.+(?:[A-Za-f0-9]+(%3a|:)){10}", VVZcRP):
14701:    return
14702:   if self.VVr4qo == VVX8pK and self.VV7LKE > 0 and (iTime()- self.VV7LKE) < 10:
14703:    return
14704:   if self.VVazTO == VVX8pK:
14705:    if CFG.autoResetFrozenIptvChan.getValue() == "on+":
14706:     CChMGW(self.VVeO1i, "Refreshing")
14707:    CCYrUm.VV0iSP(self.VVeO1i)
14708:   elif "&end=:" in VVfaDB:
14709:    VV1wIO = VVfaDB[VVfaDB.index("&end=:") + 6:]
14710:    pr = CChyfE()
14711:    if pr.VVgBJL(VVPxk5, VV1wIO, VVZcRP, VVfaDB):
14712:     shown = InfoBar.instance.shown
14713:     pr.VVIguo(self.VVeO1i)
14714:     if not shown: InfoBar.instance.hide()
14715:   self.VVr4qo = VVX8pK
14716:   self.VV7LKE = iTime()
14717:  def VV2VGZ(self):
14718:   VVPxk5, VVZcRP, VVfaDB, VVX8pK = self.VVAwKT()
14719:   if VVPxk5.startswith("4097:") and self.lastSimulatedEOF != VVX8pK:
14720:    FFOKt0(self, 1000, BF(self.VVMC2i, VVX8pK))
14721:  def VVMC2i(self, ref):
14722:   VVPxk5, VVZcRP, VVfaDB, VVX8pK = self.VVAwKT()
14723:   if ref == VVX8pK and self.VVedk0 in (CCo1b7.VVYCbB, CCo1b7.VVEOlk):
14724:    self.lastSimulatedEOF = VVX8pK
14725:    self.VVqGXQ()
14726:  def VVAwKT(self):
14727:   s = CC3rDi(self.VVeO1i)
14728:   return s.VVPxk5, s.VVZcRP, s.VVfaDB, s.myPhp or s.VVZcRP
14729:  def VVTufo(self, state):
14730:   self.VVedk0 = state
14731:   global VVfaPN_VAL
14732:   VVfaPN_VAL = state
14733: class CCdt86():
14734:  def __init__(self, SELF):
14735:   self.SELF  = SELF
14736:   self.Title  = "Update Current Bouquet EPG/PIcons"
14737:   self.pPath  = CCafIt.VVjkKT()
14738:   self.updErr  = ""
14739:   self.isFfmpeg = FFayeZ("ffmpeg")
14740:   self.totCh  = 0
14741:   self.totIptv = 0
14742:   self.totNotIptv = 0
14743:   self.totEpgDnl = 0
14744:   self.totPic  = 0
14745:   self.totPicOK = 0
14746:   self.epgLst  = []
14747:   self.bName  = ""
14748:   CCh3tv.VV7Nf4(SELF
14749:       , VVixvy  = self.VVrwj0
14750:       , VVbYwR = self.VV6fLO)
14751:  def VVrwj0(self, VVXyP6):
14752:   VVXyP6.VVaks5("Reading Services ...")
14753:   self.bName = CCMvE7.VVCWrE()
14754:   services = CCMvE7.VVqZTI()
14755:   if not services:
14756:    self.updErr = 'Cannot read service from: \n\n"%s"' % self.bName
14757:    return
14758:   elif len(services) == 0:
14759:    self.updErr = 'No services in: \n\n"%s"' % self.bName
14760:    return
14761:   else:
14762:    self.totCh = len(services)
14763:   if not VVXyP6 or VVXyP6.isCancelled: return
14764:   VVXyP6.VVq8NF(self.totCh)
14765:   VVXyP6.VVaks5("Downloading ...")
14766:   for ndx, (VVu06s, VV1wIO) in enumerate(services):
14767:    if not VVXyP6 or VVXyP6.isCancelled: return
14768:    if FFUPnc(VVu06s):
14769:     self.totIptv += 1
14770:     VVPxk5, VVZcRP, VV57TX, VVfaDB = CC3rDi.VVGg6H(VVu06s)
14771:     if not VVXyP6 or VVXyP6.isCancelled: return
14772:     evLst = []
14773:     epg = VVfbmn = ""
14774:     if VVZcRP:
14775:      epg, evLst, VVfbmn, err = CCvjVs.VVPhf6(VVZcRP)
14776:      if VVfbmn: self.totPic += 1
14777:     else:
14778:      continue
14779:     if not VVXyP6 or VVXyP6.isCancelled: return
14780:     VVXyP6.VV6j41(self.totEpgDnl, self.totPic)
14781:     if not epg:
14782:      epg, evLst, err = CCkEI5.VV67It(VVZcRP)
14783:     if evLst:
14784:      self.epgLst.append((VVPxk5, evLst))
14785:      self.totEpgDnl += len(evLst)
14786:     if not VVXyP6 or VVXyP6.isCancelled: return
14787:     VVXyP6.VV6j41(self.totEpgDnl, self.totPic)
14788:     self.totPicOK += self.VVRHhq(VVu06s, VVfbmn)
14789:     if not VVXyP6 or VVXyP6.isCancelled: return
14790:     VVXyP6.VV6j41(self.totEpgDnl, self.totPic)
14791:    else:
14792:     self.totNotIptv += 1
14793:    if not VVXyP6 or VVXyP6.isCancelled: return
14794:    VVXyP6.VVxtQs(1)
14795:  def VV6fLO(self, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
14796:   if self.updErr:
14797:    FFdw58(self.SELF, self.updErr, title=self.Title)
14798:    return
14799:   totEpgOK = 0
14800:   for VVPxk5, evLst in self.epgLst:
14801:    if evLst:
14802:     totEv, totOK = CC5TsO.VV8M7K(VVPxk5, evLst)
14803:     totEpgOK += totOK
14804:   if totEpgOK > 0:
14805:    CC5TsO.VVYLja()
14806:   tab = lambda x, y: "%s\t: %s\n" % (x, y)
14807:   txt = ""
14808:   txt += tab("Bouquet"  , self.bName)
14809:   txt += "\n"
14810:   txt += tab("Services"  , self.totCh)
14811:   txt += tab("Processed"  , self.totIptv)
14812:   txt += tab("Non-IPTV"  , self.totNotIptv)
14813:   txt += "\n"
14814:   txt += tab("Events Found" , self.totEpgDnl)
14815:   txt += tab("Events Added" , totEpgOK)
14816:   txt += "\n"
14817:   txt += tab("PIcons Found" , self.totPic)
14818:   txt += tab("PIcons Added" , self.totPicOK)
14819:   if not VVRI6P:
14820:    self.Title += "  (stopped)"
14821:   FF4lCP(self.SELF, txt, title=self.Title)
14822:  def VVRHhq(self, VVu06s, url):
14823:   if not all((url, self.isFfmpeg, VVmJwX(self.pPath))):
14824:    return 0
14825:   path, err = FFx9uM(url, "ajp_tmp.png", timeout=2, VVzHui=True)
14826:   if not FFCyVu(path) or not VVmJwX(self.pPath):
14827:    return 0
14828:   VVPxk5 = CCvjVs.VVHamE(VVu06s)
14829:   picon = VVPxk5.replace(":", "_") + ".png"
14830:   cmd = CCvjVs.VVQ9GP(path)
14831:   cmd += FFb2oQ("mv -f '%s' '%s%s'" % (path, self.pPath, picon))
14832:   ok = FFpwZS(cmd)
14833:   return 1 if ok else 0
14834: class CCa36K():
14835:  def __init__(self, VVCk9g=False):
14836:   self.VVX6Ut  = CFG.hideIptvServerChannPrefix.getValue()
14837:   self.VVWmRw  = VVCk9g or CFG.hideIptvServerAdultWords.getValue()
14838:   self.VVDx9q = r"(b[-]*e[-]*I[-]*N)"
14839:   self.VVcAqm  = r"beIN"
14840:   self.VVcGaa = iCompile( r"\s*^[A-Za-z]{2,4}\d*\s*(?:[|:-]|[^\x00-\x7F])+\s*(.+)"
14841:           r"|^\[.{2}\]\s*(.+\[.{2}\]\s*\[.{2,}\])"
14842:           r"|^(?!\[)*\s*[\[(|:][ A-Za-z0-9\/\-._:|\]\[]+[\])|:](.+)"
14843:           r"|^[A-Za-z]{,3}[^\x21-\x7E]\s(.+)")
14844:   self.VVustK = self.VVAJyh(self.VVX6Ut, "ajpanel_iptv_prefix", False, ())
14845:   self.VV2YHg = self.VVAJyh(self.VVWmRw, "ajpanel_iptv_blacklist", True, ("+18","18 rated","18+","aduld","adult","adulte","adulto","aikuinen","blue film","blue movie","dirty film","dirty movie","dorosly","erotic","erwachsene","porn","r-17 film","r-17 movie","r-18 film","r-18 movie","r18 film","r18 movie","sex","skin flick","voksen","volwassen","vuxen","x-rated","xrated","xxi","xx","xvideo","xyz"))
14846:  def VVAJyh(self, cond, fName, isLower, tSet):
14847:   tSet = set(tSet)
14848:   if cond:
14849:    for path in (VVIp2p, FF0cqc()):
14850:     path += fName
14851:     if FFCyVu(path):
14852:      for line in FFL19l(path):
14853:       line = line.strip()
14854:       if len(line) >= 3:
14855:        tSet.add(line.lower() if isLower else line)
14856:   return tuple(sorted(tSet, key=lambda x: x.lower()))
14857:  def VVcBrZ(self, name,  censored=""):
14858:   if self.VVWmRw and (censored == "1" or any(x in name.lower() for x in self.VV2YHg)):
14859:    return ""
14860:   name = iSub(self.VVDx9q, self.VVcAqm, name, flags=IGNORECASE).strip()
14861:   if CCkEI5.VVAP76(name):
14862:    return CCkEI5.VVBmSe(name)
14863:   return self.VVZNMg(name)
14864:  def VVZNMg(self, name):
14865:   newName = ""
14866:   if self.VVX6Ut:
14867:    span = iSearch(self.VVcGaa, name)
14868:    if span:
14869:     tName = span.group(1) or span.group(2) or span.group(3) or span.group(4)
14870:     if not tName.startswith(("HD", "[HD]", "SD", "[SD]")):
14871:      newName = tName
14872:    for t in self.VVustK:
14873:     if name.startswith(t):
14874:      newName = name[len(t):]
14875:      break
14876:   return newName.strip() or name
14877:  def VVBgSG(self, name):
14878:   name = iSub(self.VVDx9q, self.VVcAqm, name, flags=IGNORECASE).strip()
14879:   name = self.VVZNMg(name)
14880:   return name.lower().replace(" hd", "").replace(" fm", "").replace(" 4k", "").replace(" tv", "").replace(" sd", "").strip()
14881:  def VV1vXv(self, name):
14882:   if self.VVWmRw and any(x in name.lower() for x in self.VV2YHg):
14883:    return ""
14884:   return name.strip()
14885:  def VVZI1i(self, wordsList):
14886:   lst = list(map(str.lower, wordsList))
14887:   return any(x in self.VV2YHg for x in lst)
14888:  def VVmBMi(self):
14889:   return 'Cannot continue with adults words !\n\n"Skip Adults Channels" is activated in settings.'
14890:  @staticmethod
14891:  def VVD1PA():
14892:   badW1 = CCwklK.VVO6rU()
14893:   badW2 = CCwklK.VVu30K()
14894:   nameCl = CCa36K()
14895:   def VVZwiy(txt):
14896:    txt = nameCl.VVZNMg(txt)
14897:    txt = txt.replace("24/7", "")
14898:    for ch in ":|_-+.[](){}#!@$%^*": txt = txt.replace(ch, " ")
14899:    if len(txt) > 4: txt = iSub(r"\d{4,}", "", txt, flags=IGNORECASE)
14900:    while "  " in txt: txt = txt.replace("  ", " ")
14901:    words = []
14902:    for word in txt.split():
14903:     if not word.lower() in badW1 and not badW2.match(word):
14904:      words.append(word)
14905:    txt = " ".join(words)
14906:    return txt.strip()
14907:   return VVZwiy
14908: class CCWz9v(CCa36K):
14909:  def __init__(self, SELF, VVs2Wm, VVKWLJ="", VVdgZS="", cbFnc=None, chkExt=False):
14910:   self.SELF  = SELF
14911:   self.VVs2Wm = VVs2Wm
14912:   self.VVKWLJ  = VVKWLJ
14913:   self.outD  = "%s%s/" % (CCjZbZ.VVz4Ig(), VVdgZS or os.path.basename(VVs2Wm)[:-4])
14914:   self.cbFnc  = cbFnc
14915:   self.chkExt  = chkExt
14916:   self.Title  = "Create Local Server"
14917:   self.err  = ""
14918:   self.totGrp  = 0
14919:   self.totCh  = 0
14920:   self.totL  = self.totLh = 0
14921:   self.totV  = self.totVh = 0
14922:   self.totS  = self.totSh = 0
14923:   self.totK  = self.totKh = 0
14924:   self.totM  = self.totMh = 0
14925:   self.totR  = self.totRh = 0
14926:   self.totD  = self.totDh = 0
14927:   self.totF  = self.totFh = 0
14928:   self.totAll  = 0
14929:   self.lineNum = 0
14930:   CCa36K.__init__(self, VVCk9g=True)
14931:   CCh3tv.VV7Nf4(self.SELF, VVLL7M="Checking File ...", titleBg="#22220022", bodyBg="#22220022"
14932:       , VVixvy  = self.VVaAJo
14933:       , VVbYwR = self.VVUown)
14934:  def VVaAJo(self, VVXyP6):
14935:   if VVmJwX(self.outD):
14936:    for f in iGlob(FFoWxR(self.outD) + "*"):
14937:     FFwgGB(f)
14938:   elif not FFpwZS("mkdir -p '%s'" % self.outD):
14939:    self.err = "Cannot make directory."
14940:    return
14941:   par = grp = url = marker = ""
14942:   bDict = {}
14943:   enc, totLines = CC7ocD.VVm9FZ(self.VVs2Wm)
14944:   if not VVXyP6 or VVXyP6.isCancelled: return
14945:   VVXyP6.VVq8NF(totLines)
14946:   with ioOpen(self.VVs2Wm, "r", encoding=enc) as f:
14947:    for line in f:
14948:     self.lineNum += 1
14949:     if not VVXyP6 or VVXyP6.isCancelled: return
14950:     VVXyP6.VVxtQs(1)
14951:     line = str(line.strip())
14952:     if line.startswith("#EXTINF:"):
14953:      par = line
14954:      continue
14955:     elif line.startswith("#EXTGRP:"):
14956:      grp = line.partition("#EXTGRP:")[2].strip()
14957:      continue
14958:     elif not line.startswith("#"):
14959:      url = line
14960:     elif line.startswith("#EXTM3U"):
14961:      continue
14962:     if not (par and url):
14963:      continue
14964:     par = par.replace('""', '" "')
14965:     span = iSearch(r'(?:tvg-name="(.+?)")*.+,(.+)', par, IGNORECASE)
14966:     VV1wIO = (((span.group(1) or span.group(2))).replace(":", "|").replace("||", "|").strip() if span else "") or "No-name"
14967:     chBlk = 0 if self.VVcBrZ(VV1wIO) else 1
14968:     span = iSearch(r'tvg-logo="(.+?)"', par, IGNORECASE)
14969:     icn = ((span.group(1)).replace("\t", "").strip() if span else "") or "-"
14970:     span = iSearch(r'group-title="(.+?)"', par, IGNORECASE)
14971:     cat = (grp or (span.group(1) if span else "")).replace("\t", "").strip()
14972:     catBlk = 1 if cat and not self.VV1vXv(cat) else 0
14973:     val1 = catBlk or chBlk
14974:     typ = CCjZbZ.VVZXSg(url, self.chkExt)
14975:     if   typ == "Live"  : self.totL, self.totLh = self.totL + 1, self.totLh + 1 * val1
14976:     elif typ == "VOD"  : self.totV, self.totVh = self.totV + 1, self.totVh + 1 * val1
14977:     elif typ == "Series" : self.totS, self.totSh = self.totS + 1, self.totSh + 1 * val1
14978:     elif typ == "Marker" : self.totK, self.totKh = self.totK + 1, self.totKh + 1 * val1
14979:     elif typ == "Movie"  : self.totM, self.totMh = self.totM + 1, self.totMh + 1 * val1
14980:     elif typ == "S.Relay" : self.totR, self.totRh = self.totR + 1, self.totRh + 1 * val1
14981:     elif typ == "DVB"  : self.totD, self.totDh = self.totD + 1, self.totDh + 1 * val1
14982:     elif typ == "FTP"  : self.totF, self.totFh = self.totF + 1, self.totFh + 1 * val1
14983:     cat = cat or "* Uncategorized %s Channels *" % typ
14984:     VVXyP6.VVaks5("Ch=%s  ( L=%s  V=%s  S=%s )" % (self.totCh, self.totL, self.totV, self.totS))
14985:     if typ == "Marker":
14986:      marker = "%s\t%s\t%s\n" % (url, VV1wIO, "-")
14987:      continue
14988:     fileId = typ + cat
14989:     fName = FFbhOc(fileId)
14990:     totCh = (bDict[fileId][3] + 1) if fileId in bDict else 1
14991:     bDict[fileId] = (typ, catBlk, fName, totCh, cat)
14992:     with open(self.outD + fName, "a") as f:
14993:      if marker:
14994:       f.write(marker)
14995:       marker = ""
14996:       self.totAll += 1
14997:      f.write("%s\t%s\t%s\t%s\n" % (chBlk or catBlk, url, VV1wIO, icn))
14998:      self.totCh += 1
14999:      self.totAll += 1
15000:     par = grp = url = ""
15001:   self.totGrp = len(bDict)
15002:   if bDict:
15003:    bLst = ["\t".join((typ, str(catBlk), fName, str(totCh), cat)) for ttl, (typ, catBlk, fName, totCh, cat) in bDict.items()]
15004:    if bLst:
15005:     try: fmTime = int(os.path.getmtime(self.VVs2Wm))
15006:     except: fmTime = ""
15007:     tab = lambda x, y: "#" + " %s: %s\n" % (x, y)
15008:     with open(os.path.join(self.outD, "_main"), "w") as f:
15009:      f.write(tab("File"  , self.VVs2Wm))
15010:      f.write(tab("Modified" , fmTime))
15011:      f.write(tab("URL"  , self.VVKWLJ.partition("&type")[0]))
15012:      f.write(tab("Saved"  , FFIPdt()))
15013:      f.write(tab("Entries" , self.totAll))
15014:      f.write(tab("Services" , self.totCh))
15015:      f.write(tab("Live"  , self.totL))
15016:      f.write(tab("VOD"  , self.totV))
15017:      f.write(tab("Series" , self.totS))
15018:      if self.totK: f.write(tab("Marker" , self.totK))
15019:      if self.totM: f.write(tab("Movie" , self.totM))
15020:      if self.totR: f.write(tab("S.Relay" , self.totR))
15021:      if self.totD: f.write(tab("DVB"  , self.totD))
15022:      if self.totF: f.write(tab("FTP"  , self.totF))
15023:      if self.totLh: f.write(tab("Blk_Live" , self.totLh))
15024:      if self.totVh: f.write(tab("Blk_VOD" , self.totVh))
15025:      if self.totSh: f.write(tab("Blk_Series" , self.totSh))
15026:      if self.totKh: f.write(tab("Blk_Marker" , self.totKh))
15027:      if self.totMh: f.write(tab("Blk_Movie" , self.totMh))
15028:      if self.totRh: f.write(tab("Blk_S.Relay", self.totRh))
15029:      if self.totDh: f.write(tab("Blk_DVB" , self.totDh))
15030:      if self.totFh: f.write(tab("Blk_FTP" , self.totFh))
15031:      f.write("\n".join(bLst))
15032:  def VVUown(self, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
15033:   mainOk = FFCyVu(os.path.join(self.outD, "_main"))
15034:   if not VVRI6P or not mainOk:
15035:    FFVyW4(self.outD)
15036:   ln = "\n\nLine Number : %s" % self.lineNum
15037:   if   not VVRI6P     : pass
15038:   elif self.err      : FFdw58(self.SELF, self.err, self.Title)
15039:   elif threadCounter != threadTotal : FFdw58(self.SELF, "Error in conversion process %s" % ln, self.Title)
15040:   elif not mainOk      : FFdw58(self.SELF, "Cannot extract channels", self.Title)
15041:   elif self.cbFnc      : self.cbFnc(self.VVs2Wm, self.outD)
15042:   else:
15043:    tab = lambda x, y: "%s\t: %s\n" % (x, y)
15044:    txt  = tab("Groups", self.totGrp)
15045:    txt += tab("Services", self.totCh)
15046:    txt += tab("\nEntries" , self.totAll)
15047:    txt += tab("  Live"  , self.totL)
15048:    txt += tab("  VOD"  , self.totV)
15049:    txt += tab("  Series" , self.totS)
15050:    txt += tab("  Movie" , self.totM)
15051:    txt += tab("  DVB"  , self.totD)
15052:    txt += tab("  S.Relay" , self.totR)
15053:    txt += tab("  FTP"  , self.totF)
15054:    txt += tab("  Marker" , self.totK)
15055:    txt += "\n%s\n%s" % (FFjt5L("Output File:", VVJEMb), self.outD)
15056:    FF4lCP(self.SELF, txt, self.Title)
15057: class CCjZbZ(CCa36K):
15058:  VVbu5l   = 0
15059:  VVCAqE  = 1
15060:  VVWcXC = 2
15061:  VVCKX0 = 3
15062:  VV4Vv0  = 4
15063:  VVry11   = 5
15064:  def __init__(self, SELF, mode, url="", m3uF="", VVMye8=None):
15065:   self.SELF   = SELF
15066:   self.mode   = mode
15067:   self.VVMye8= VVMye8
15068:   self.Title   = "Local Servers & M3U Cache"
15069:   self.VVjS9t  = ""
15070:   self.url   = ""
15071:   self.hst   = ""
15072:   self.usr   = ""
15073:   self.pas   = ""
15074:   self.VVGWyE  = ""
15075:   self.VVLLPC   = ""
15076:   CCa36K.__init__(self)
15077:   if not iZip:
15078:    SELF.VVQ5VQ('"zipfile" Module not found !')
15079:    return
15080:   if   mode == CCjZbZ.VVbu5l   : self.VVVrOO()
15081:   elif mode == CCjZbZ.VVCAqE  : self.VVLdPO(self.SELF, m3uF)
15082:   elif mode == CCjZbZ.VVWcXC : self.VVt4iC(m3uF)
15083:   elif mode == CCjZbZ.VVCKX0: self.VVV72a(url)
15084:   elif mode == CCjZbZ.VV4Vv0 : self.VVV72a(url)
15085:   elif mode == CCjZbZ.VVry11   : self.VVLdPO(self.SELF, m3uF)
15086:  def VVV72a(self, url):
15087:   self.url = url
15088:   self.hst, self.usr, self.pas, self.VVGWyE = CCjZbZ.VVir5C(self.url)
15089:   if not all((self.hst, self.usr, self.pas, self.VVGWyE)):
15090:    self.VVQ5VQ("Cannot process URL")
15091:    return
15092:   c1, c2, c3 = VVJEMb, VVFuwR, VVZtfx
15093:   VV3wat = []
15094:   zipFile = "%s%s.zip" % (CCjZbZ.VVz4Ig(), self.VVGWyE)
15095:   if FFCyVu(zipFile):
15096:    VV3wat.append((c1 + "Browse Local Server", "brwLS"))
15097:    VV3wat.append((c1 + "Update Local Server", "updLS"))
15098:   else:
15099:    VV3wat.append((c1 + "Download Resources and Browse Locally", "newLS"))
15100:   VV3wat.append(VVAL3j)
15101:   VV3wat.append((c2 + "Save to M3U (Live/VOD)"   , "toM3U1"))
15102:   VV3wat.append((c2 + "Save to M3U (Live/VOD/Series)" , "toM3U2"))
15103:   VV3wat.append(VVAL3j)
15104:   VV3wat.append((c3 + "Download M3U  (Live=ts)"     , "ful" ))
15105:   VV3wat.append((c3 + "Download M3U  (Live=m3u8)"    , "ful8"))
15106:   VV3wat.append((c3 + "Download M3U  (Uncategorized Channels)" , "low" ))
15107:   VV3wat.append(VVAL3j)
15108:   VV3wat.append(("Download EPG (XML-TV File)", "epg"))
15109:   FFLFTC(self.SELF, BF(self.VVMDHX, zipFile), title="Server Resources", VV3wat=VV3wat, width=1000, VVU8mZ=True, VVwltY="#22002233", VVkxBG="#22001122")
15110:  def VVMDHX(self, zipFile, item=""):
15111:   if item:
15112:    title, ref, ndx = item
15113:    if   ref == "brwLS" : self.VVF0tW(zipFile)
15114:    elif ref == "updLS" : FFRMYv(self.SELF, BF(self.VVFVJ5, title, "newLS"), 'Update Local Cache ?\n\n"%s"' % self.VVGWyE, title=self.Title)
15115:    elif ref == "toM3U1": self.SELF.VVLk4s(0, self.hst, self.usr, self.pas, title)
15116:    elif ref == "toM3U2": self.SELF.VVLk4s(1, self.hst, self.usr, self.pas, title)
15117:    else    : self.VVFVJ5(title, ref)
15118:  def VVFVJ5(self, title, ref):
15119:   if ref == "epg" : ext, php, fNm, typ = "xml", "xmltv", "epg"  , ""
15120:   else   : ext, php, fNm, typ = "m3u", "get"  , "channels_" , "&type=m3u"
15121:   if ref in ("newLS", "ful", "ful8"): typ += "_plus"
15122:   if ref == "ful8": typ += "&output=m3u8"
15123:   url = "%s/%s.php?username=%s&password=%s%s" % (self.hst, php, self.usr, self.pas, typ)
15124:   if   ref == "epg": pass
15125:   elif ref == "low": fNm += "uncat"
15126:   else    : fNm += "grouped_" + ("m3u8" if ref == "ful8" else "ts")
15127:   fName = "%s_%s_%s.%s" % (iUrlparse(self.hst).hostname, fNm, FFjTQe(), ext)
15128:   cbFnc = self.VVgIYM if ref == "newLS" else None
15129:   timeout = 90
15130:   CCzCDl(self.SELF, url, os.path.join(FF0cqc(), fName), title=self.Title, pbTxt="Preparing file in server ...", cbFnc=cbFnc, timeout=timeout)
15131:  def VVgIYM(self, ok, url, webFile, path):
15132:   if ok:
15133:    VVuPkC = iUrlparse(url).hostname
15134:    cbFnc = BF(self.VVquSl, True)
15135:    CCWz9v(self.SELF, VVs2Wm=path, VVKWLJ=url, VVdgZS=VVuPkC, cbFnc=cbFnc)
15136:   else:
15137:    FFwgGB(path)
15138:  def VVt4iC(self, path):
15139:   m3File, m3Dir, VVcwFG, zPath, zFound = CCjZbZ.VVuYvs(path)
15140:   cbFnc = BF(self.VVquSl, False)
15141:   CCWz9v(self.SELF, VVs2Wm=path, VVdgZS=VVcwFG, cbFnc=cbFnc)
15142:  def VVquSl(self, delSrc, path, outD):
15143:   if VVmJwX(outD):
15144:    if delSrc : FFwgGB(path)
15145:    VVTiJ2 = outD.rstrip("/") + ".zip"
15146:    CCjZbZ.VVICcD(self.SELF, outD, VVTiJ2, cbFnc=BF(self.VVPlwE, outD))
15147:  def VVPlwE(self, outD, VVTiJ2, tot, err):
15148:   FFVyW4(outD)
15149:   if   tot: self.VVF0tW(VVTiJ2)
15150:   elif err: self.VVQ5VQ(err)
15151:   else : self.VVQ5VQ("No files to compress !")
15152:  @FFOAKH("Checking File Encoding ...", par=1)
15153:  def VVLdPO(self, SELF, path):
15154:   if not self.VVdT8C(path):
15155:    m3File, m3Dir, VVcwFG, zPath, zFound = CCjZbZ.VVuYvs(path)
15156:    if zFound: self.VVF0tW(zPath)
15157:    else  : self.VVt4iC(path)
15158:  def VVdT8C(self, path):
15159:   if FFXhoc(path) > pow(10, 4):
15160:    return False
15161:   m3u8 = False
15162:   lst = []
15163:   par = url = ""
15164:   try:
15165:    enc = CC7ocD.VV51oT(path)
15166:    with ioOpen(path, "r", encoding=enc) as f:
15167:     c = 0
15168:     for line in f:
15169:      c += 1
15170:      line = str(line).strip()
15171:      if   c > 30          : break
15172:      elif line.startswith("#EXTM3U")     : continue
15173:      elif line.startswith("#EXTINF:")    : par = line
15174:      elif line.startswith("#EXT-X-MEDIA-SEQUENCE:") : m3u8 = True
15175:      elif par and not line.startswith("#")   : url = line
15176:      if par and url:
15177:       lst.append((par, url))
15178:   except:
15179:    self.VVQ5VQ("Cannot read file.\n\n%s" % path)
15180:    return True
15181:   if m3u8:
15182:    VV1wIO = os.path.splitext(os.path.basename(path))[0]
15183:    VVPxk5, chUrl, VVZcRP = CCjZbZ.VVYrGK(1, path, VV1wIO)
15184:    CCqWM2.VVHc02(self.SELF.session, VVaHNe=chUrl)
15185:    return True
15186:   if len(lst) == 1: par, url = lst[0]
15187:   else   : return False
15188:   if iMatch(r"^(?:[A-Za-z0-9]+:){10}$", url):
15189:    CCqWM2.VVHc02(self.SELF.session, VVaHNe=url)
15190:    return True
15191:   span = iSearch(r"^http.+((?:[A-Za-z0-9]+:){10})$", url)
15192:   if span:
15193:    CCqWM2.VVHc02(self.SELF.session, VVaHNe=span.group(1))
15194:    return True
15195:   span = iSearch(r"^http.+\/((?:[A-Za-z0-9]+:){10}\/.+)", url)
15196:   if span:
15197:    CCqWM2.VVHc02(self.SELF.session, VVaHNe=span.group(1))
15198:    return True
15199:   span = iSearch(r'(?:tvg-name="(.+?)")*.+,(.+)', par, IGNORECASE)
15200:   VV1wIO = ((span.group(1) or span.group(2))).replace(":", "|").replace("||", "|").strip() if span else ""
15201:   VV1wIO = VV1wIO or os.path.splitext(os.path.basename(path))[0]
15202:   span = iSearch(r"^((?:[A-Za-z0-9]+:){10})(http.+(?:[A-Za-z0-9]+:){10})$", url)
15203:   if span:
15204:    chUrl = "%s%s:%s" % (span.group(1), FFSiPR(span.group(2)), VV1wIO)
15205:    CCqWM2.VVHc02(self.SELF.session, VVaHNe=chUrl)
15206:    return True
15207:   return False
15208:  def VVVrOO(self):
15209:   lst = [(os.path.splitext(os.path.basename(f))[0], f) for f in iGlob("%s/*.zip" % CCjZbZ.VVz4Ig()) if os.path.isfile(f)]
15210:   if lst:
15211:    lst.sort(key=lambda x: x[0].lower())
15212:    VVOa1G  = self.VVCvez
15213:    VVJbOd  = self.VVQlNq
15214:    VVHGnw  = ("Home Menu" , FF8lJ1)
15215:    VVaTeF  = ("Rename" , self.VVhYc1)
15216:    FFLFTC(self.SELF, None, title=self.Title, VV3wat=lst, width=1200, VVyRCy=3, VVtboQ="", VVOa1G=VVOa1G, VVJbOd=VVJbOd, VVHGnw=VVHGnw, VVaTeF=VVaTeF
15217:      , VVwltY="#08000011", VVkxBG="#08111122", VVoCB2="#08333344")
15218:   else:
15219:    self.VVQ5VQ('No Local Servers.\n\nYou can add local server form %s.' % FFjt5L("Server Resources", VVFuwR))
15220:  def VVCvez(self, item):
15221:   self.VVF0tW(item[2])
15222:  def VVQlNq(self, VV7tND, txt, ref, ndx):
15223:   self.VVcsah(ref)
15224:  def VVhYc1(self, VV7tND, path):
15225:   oName = os.path.basename(path)[:-4]
15226:   FF4z45(self.SELF, BF(self.VVq4FS, VV7tND, path, oName), defaultText=oName, title="Rename", message="New name")
15227:  def VVq4FS(self, VV7tND, path, oName, nName):
15228:   if not nName or not nName.strip(): return
15229:   title = "Rename : %s" % oName
15230:   nName = nName.strip()
15231:   nPath = os.path.join(os.path.dirname(path), "%s.zip" % nName)
15232:   if   path == nPath  : FF28n1(VV7tND, "No change", 800)
15233:   elif FFCyVu(nPath) : FFdw58(self.SELF, "Name already exists:\n\n%s" % nName, title=title)
15234:   else     : FFRMYv(self.SELF, BF(self.VV8Z0k, VV7tND, title, path, nPath, nName), "Rename to:\n\n%s" % nName, title=title)
15235:  def VV8Z0k(self, VV7tND, title, path, nPath, nName):
15236:   try:
15237:    os.rename(path, nPath)
15238:    VV7tND.VVKjBW((nName, nPath))
15239:    FF1mVE(VV7tND, "Renamed", 800)
15240:   except Exception as e:
15241:    FFdw58(self.SELF, str(e), title=title)
15242:  def VVF0tW(self, path):
15243:   if path:
15244:    self.VVLLPC = path
15245:    title = os.path.splitext(FFxtW5(path))[0]
15246:    if len(title) > 40: title = "%s .." % title[:40]
15247:    cl = CCjZbZ.VVs0Rm(path)
15248:    if cl.err or not cl.valid or not cl.totAll:
15249:     self.VVQ5VQ("Invalid file:\n\n%s" % os.path.basename(path))
15250:     return
15251:    lst = []
15252:    lst.append(("Live" , cl.totL, cl.totChL))
15253:    lst.append(("VOD" , cl.totV, cl.totChV))
15254:    lst.append(("Series", cl.totS, cl.totChS))
15255:    if cl.totM or cl.totChM: lst.append(("Movie" , cl.totM, cl.totChM))
15256:    if cl.totD or cl.totChD: lst.append(("DVB"  , cl.totD, cl.totChD))
15257:    if cl.totR or cl.totChR: lst.append(("S.Relay" , cl.totR, cl.totChR))
15258:    if cl.totF or cl.totChF: lst.append(("FTP"  , cl.totF, cl.totChF))
15259:    lst = [(s, str(g), str(ch))for s, g, ch in lst]
15260:    yelBtn = self.mode != CCjZbZ.VVbu5l
15261:    VVu1YM  = (""    , BF(self.VVImuI, path)   , [])
15262:    VV2ytr = (""    , BF(self.VV7sbT, path) , [])
15263:    VVwWmA = ("Home Menu"  , FF8lJ1             , [])
15264:    VVScQz = ("Delete Cache" , BF(self.VVhhAb, path) , []) if yelBtn else None
15265:    header  = ("Type" , "Groups" , "Channels")
15266:    widths  = (50  , 25  , 25  )
15267:    VVLIqP = (LEFT  , CENTER , CENTER )
15268:    FFUQ0v(self.SELF, self.VVMye8, title=title, header=header, VVGape=lst, VVLIqP=VVLIqP, VV3cHe=widths
15269:      , VVllEU=30, VViIEz=20, width=1000, VVwdmN=28, VVu1YM=VVu1YM, VV2ytr=VV2ytr, VVwWmA=VVwWmA, VVScQz=VVScQz, VVKDPJ=2
15270:      , VVwltY="#08222233", VVkxBG="#08222233", VVemyB="#08222233", VVJKqd="#083a4a4a", VVbcr0="#08222233", VVX9AA="#08333355")
15271:  def VV7sbT(self, path, VV6A99, txt, ref, ndx):
15272:   self.VVcsah(path)
15273:  def VVhhAb(self, path, VV6A99, txt, ref, ndx):
15274:   FFRMYv(self.SELF, BF(self.VVTGie, VV6A99, path), "Delete ?\n\n%s" % path, title="Delete Local Cache")
15275:  def VVTGie(self, VV6A99, path):
15276:   FFwgGB(path)
15277:   if FFCyVu(path) : FF28n1(VV6A99, "No deleted", 1000)
15278:   else    : VV6A99.close()
15279:  @FFOAKH(par=2)
15280:  def VVImuI(self, path, VV6A99, title, txt, colList):
15281:   self.VVjS9t = colList[0]
15282:   lines, err = CCjZbZ.VV2LK6(path, "_main", mode=1)
15283:   if err:
15284:    self.VVQ5VQ(err)
15285:    return
15286:   lst = []
15287:   srcFil = VVKWLJ = srcTm = ""
15288:   for line in lines:
15289:    if line.startswith("#"):
15290:     subj, _, val = line.partition(":")
15291:     subj, val = subj[1:].strip().lower(), val.strip()
15292:     if   subj == "file"  : srcFil = val
15293:     elif subj == "url"   : VVKWLJ = val
15294:     elif subj == "created" : srcTm  = val
15295:    else:
15296:     parts = line.split("\t")
15297:     if len(parts) == 5:
15298:      typ, catBlk, fName, totCh, cat = parts
15299:      cat = self.VV1vXv(cat)
15300:      if cat and typ == self.VVjS9t:
15301:       lst.append((cat, totCh, fName))
15302:   if len(lst) == 1 and iMatch(r"\* Uncategorized.+Channels \*", lst[0][0]):
15303:    self.VVv1KP(VV6A99, path, lst[0][0], lst[0][2])
15304:   elif lst:
15305:    mode = {"l": CCkEI5.VVgkvV, "v": CCkEI5.VVgL8R, "s": CCkEI5.VV6cbr}.get(self.VVjS9t[:1].lower())
15306:    VVwltY, VVkxBG, VVemyB, VVJKqd = CCkEI5.VVxV5D(mode)
15307:    lst.sort(key=lambda x: x[0].lower())
15308:    VVu1YM  = ("Channels" , BF(self.VVZIbs, path), [])
15309:    VVwWmA = ("Home Menu" , FF8lJ1         , [])
15310:    VVScQz = ("Find in %s" % self.VVjS9t, BF(self.VVdWVr, path) , [])
15311:    header  = ("Category" , "Channels", "fName")
15312:    widths  = (84   , 16  , 0   )
15313:    VVLIqP = (LEFT   , CENTER , CENTER )
15314:    FFUQ0v(self.SELF, None, title=self.VVjS9t, header=header, VVGape=lst, VVLIqP=VVLIqP, VV3cHe=widths, width=1200, height=960, VVwdmN=30, VVu1YM=VVu1YM, VVwWmA=VVwWmA, VVScQz=VVScQz, VVwltY=VVwltY, VVkxBG=VVkxBG, VVemyB=VVemyB, VVJKqd=VVJKqd)
15315:   else:
15316:    FFjADj(VV6A99, "No Groups/Channels", 1000)
15317:  def VVdWVr(self, path, VV6A99, title, txt, colList):
15318:   VV3wat = []
15319:   VV3wat.append(("Keyboard"  , "manualEntry"))
15320:   VV3wat.append(("From Filter" , "fromFilter"))
15321:   FFLFTC(self.SELF, BF(self.VVwY9a, VV6A99, path), title="Input Type", VV3wat=VV3wat, width=400)
15322:  def VVwY9a(self, VV6A99, path, item=None):
15323:   if item == "manualEntry":
15324:    FF4z45(self.SELF, BF(self.VVpIvt, VV6A99, path), defaultText=CFG.lastFindIptv.getValue(), title="Find", message="Enter Name (or names separated by a comma)")
15325:   elif item == "fromFilter":
15326:    filterObj = CCoErY(self.SELF)
15327:    filterObj.VVVPGN(BF(self.VVpIvt, VV6A99, path))
15328:  def VVpIvt(self, VV6A99, path, item):
15329:   if not item is None:
15330:    title = "Find in %s" % self.VVjS9t
15331:    words = None
15332:    toFind = item.strip()
15333:    FFjt1c(CFG.lastFindIptv, toFind)
15334:    if toFind:
15335:     words, asPrefix = CCoErY.VVPBNm(toFind)
15336:     if words:
15337:      if len(words) == 1 and len(words[0]) < 3:
15338:       self.VVQ5VQ("Enter at least 3 characters.", title=title)
15339:       return
15340:      else:
15341:       for word in words:
15342:        if len(word) < 3:
15343:         self.VVQ5VQ("All words must be at least 3 characters !", title=title)
15344:         return
15345:      if CFG.hideIptvServerAdultWords.getValue() and self.VVZI1i(words):
15346:       self.VVQ5VQ(self.VVmBMi(), title="Find: %s" % " , ".join(words))
15347:       return
15348:      else:
15349:       CCh3tv.VV7Nf4(self.SELF, VVLL7M="Searching for:%s" % toFind[:15], totBars=2
15350:           , VVixvy  = BF(self.VVQ6ks, VV6A99, path, title, words, toFind, asPrefix)
15351:           , VVbYwR = BF(self.VVjprO, VV6A99, title))
15352:    if not words:
15353:     FF28n1(VV6A99, "Nothing to find !", 1500)
15354:  def VVQ6ks(self, VV6A99, path, title, words, toFind, asPrefix, VVXyP6):
15355:   VVXyP6.VVNc18 = []
15356:   VVXyP6.VVq8NF(VV6A99.VVn1uo())
15357:   c = 0
15358:   for ndx, (cat, totCh, fName) in enumerate(VV6A99.VVrrm9()):
15359:    lines, err = CCjZbZ.VV2LK6(path, fName, mode=1)
15360:    if not VVXyP6 or VVXyP6.isCancelled: return
15361:    VVXyP6.VVxtQs(1)
15362:    VVXyP6.VVUIH1(len(lines))
15363:    VVXyP6.VVV3RA(0)
15364:    VVXyP6.VVSW9b(cat)
15365:    for line in lines:
15366:     if not VVXyP6 or VVXyP6.isCancelled: return
15367:     VVXyP6.VVg2Dw(1)
15368:     parts = line.split("\t")
15369:     if len(parts) == 4:
15370:      chBlk, url, name, icn = parts
15371:      name = self.VVcBrZ(name)
15372:      if name:
15373:       nm = name.lower()
15374:       if asPrefix and not nm.startswith(words): continue
15375:       elif any(x in nm for x in words)  : pass
15376:       else         : continue
15377:       if CCkEI5.VVAP76(name):
15378:        name = CCkEI5.VVBmSe(name)
15379:       if icn == "-": icn =""
15380:       c += 1
15381:       if not VVXyP6 or VVXyP6.isCancelled: return
15382:       VVXyP6.VVNc18.append((str(c), name, "Yes" if icn else "", url, icn))
15383:  def VVjprO(self, winObj, cat, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
15384:   if VVNc18 : self.VVtKxj(cat, VVNc18)
15385:   elif VVRI6P : FFjADj(winObj, "Not found", 1500)
15386:  def VVZIbs(self, path, VV6A99, title, txt, colList):
15387:   cat, totCh, fName = colList
15388:   self.VVv1KP(VV6A99, path, cat, fName)
15389:  def VVv1KP(self, winObj, path, cat, fName):
15390:   CCh3tv.VV7Nf4(self.SELF, VVLL7M="Reading Channels ...", VVIZBP=CCh3tv.VVgJkc
15391:       , VVixvy  = BF(self.VVWSvQ, path, fName)
15392:       , VVbYwR = BF(self.VV2e9Q, winObj, cat))
15393:  def VVWSvQ(self, path, fName, VVXyP6):
15394:   VVXyP6.VVNc18 = []
15395:   lines, err = CCjZbZ.VV2LK6(path, fName, mode=1)
15396:   if err:
15397:    self.VVQ5VQ(err)
15398:    return
15399:   if not VVXyP6 or VVXyP6.isCancelled: return
15400:   VVXyP6.VVq8NF(len(lines))
15401:   c = 0
15402:   for line in lines:
15403:    if not VVXyP6 or VVXyP6.isCancelled: return
15404:    VVXyP6.VVxtQs(1)
15405:    parts = line.split("\t")
15406:    if len(parts) == 4:
15407:     chBlk, url, name, icn = parts
15408:     name = self.VVcBrZ(name)
15409:     if name:
15410:      if CCkEI5.VVAP76(name):
15411:       name = CCkEI5.VVBmSe(name)
15412:      if icn == "-": icn =""
15413:      c += 1
15414:      if not VVXyP6 or VVXyP6.isCancelled: return
15415:      VVXyP6.VVNc18.append((str(c), name, "Yes" if icn else "", url, icn))
15416:  def VV2e9Q(self, winObj, cat, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
15417:   if VVNc18 : self.VVtKxj(cat, VVNc18)
15418:   else   : FFjADj(winObj, "No channels", 1000)
15419:  def VVtKxj(self, cat, lst):
15420:   showGrn = self.VVIcUn() != "m3u"
15421:   VVwltY, VVkxBG, VVemyB, VVJKqd = CCkEI5.VVxV5D(CCkEI5.VVXewY)
15422:   VVu1YM  = ("Play"   , self.VVcz9s   , [])
15423:   VV2ytr = (""    , self.VVPzom, [])
15424:   VVwWmA = ("Home Menu"  , FF8lJ1      , [])
15425:   VVwSzI = ("Download Options", self.VVC0sq,[]) if showGrn else None
15426:   VVScQz = ("Options"  , BF(self.VV8t6b, cat), [])
15427:   VV4QTJ = ("Posters Mode" , self.VVelOl , [])
15428:   header  = ("Num" , "Name", "Logo", "url" , "icn" )
15429:   widths  = (8  , 84 , 8  , 0  , 0  )
15430:   VVLIqP = (CENTER , LEFT , CENTER, CENTER, CENTER)
15431:   FFUQ0v(self.SELF, None, title=cat, header=header, VVGape=lst, VVLIqP=VVLIqP, VV3cHe=widths, VVu1YM=VVu1YM, VV2ytr=VV2ytr, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVwltY=VVwltY, VVkxBG=VVkxBG, VVemyB=VVemyB, VVJKqd=VVJKqd, VVHPI7=True, VVMfsO=1)
15432:  def VV8t6b(self, VVIu85, VV6A99, title, txt, colList):
15433:   isMulti = VV6A99.VVXWPu
15434:   itemsOK = True
15435:   totTxt = "ALL"
15436:   if isMulti:
15437:    tot = VV6A99.VVc5NH()
15438:    totTxt = "%d Service%s" % (tot, FFcacr(tot))
15439:    if tot < 1:
15440:     itemsOK = False
15441:   totTxt = FFjt5L(totTxt, VVFuwR)
15442:   cl = CCjZbZ.VVs0Rm(self.VVLLPC)
15443:   hst, usr, pas, VVGWyE = CCjZbZ.VVir5C(cl.VVKWLJ)
15444:   if not VVGWyE:
15445:    num, name, logo, url, VVfbmn = colList
15446:    hst, usr, pas, VVGWyE = CCjZbZ.VVir5C(url)
15447:   VVIu852 = ("%s (%s)" % (VVIu85, VVGWyE)) if VVGWyE else ""
15448:   mSel = CCzSCo(self.SELF, VV6A99, addSep=False, setsOk=True, setsBlue=True)
15449:   VV3wat, cbFncDict = [], None
15450:   VV3wat.append(VVAL3j)
15451:   if itemsOK:
15452:    VV3wat.append(("Add %s to New Bouquet : %s"    % (totTxt, FFjt5L(VVIu85 , VVSGsk)), "addToCur1"))
15453:    if VVIu852: VV3wat.append(("Add %s to New Bouquet : %s" % (totTxt, FFjt5L(VVIu852, VVGCYL)) , "addToCur2"))
15454:    VV3wat.append(("Add %s to Existing/New Bouquet ..."  % (totTxt)            , "addToNew" ))
15455:    title = "Add to Bouquet"
15456:    cbFncDict = { "addToCur1": BF(self.VVb9G5 , VVIu85 , VV6A99, title)
15457:       , "addToCur2": BF(self.VVb9G5 , VVIu852, VV6A99, title)
15458:       , "addToNew" : BF(self.VVGjBm, VVIu85, VV6A99, title)
15459:       }
15460:   else:
15461:    VV3wat.append(("Add to Bouquet (nothing selected)", ))
15462:   mSel.VV9VR2(VV3wat, cbFncDict, width=1400)
15463:  @FFOAKH("Adding Services ...", par=2)
15464:  def VVb9G5(self, VVIu85, VV6A99, Title):
15465:   chUrlLst = self.VV1tr7(VV6A99)
15466:   CCMvE7.VVPJK0(self.SELF, Title, VVIu85, "", chUrlLst)
15467:  def VVGjBm(self, VVIu85, VV6A99, Title):
15468:   picker = CCMvE7(self.SELF, VV6A99, Title, BF(self.VV1tr7, VV6A99), VVFjhV=VVIu85)
15469:  def VV1tr7(self, VV6A99):
15470:   isMulti = VV6A99.VVXWPu
15471:   chUrlLst = []
15472:   rowNum = 0
15473:   for ndx, (num, name, logo, url, VVfbmn) in enumerate(VV6A99.VVrrm9()):
15474:    if not isMulti or VV6A99.VVvlf4(ndx):
15475:     chUrl = self.VVBIA4(rowNum, url, name)
15476:     rowNum += 1
15477:     if chUrl and name:
15478:      chUrlLst.append(chUrl)
15479:   return chUrlLst
15480:  def VVC0sq(self, VV6A99, title, txt, colList):
15481:   isMulti = VV6A99.VVXWPu
15482:   tot  = VV6A99.VVc5NH()
15483:   if isMulti:
15484:    if tot < 1:
15485:     FF28n1(VV6A99, "Select rows first.", 1000)
15486:     return
15487:    else:
15488:     name = "%d Selected" % tot
15489:    plural = FFcacr(tot)
15490:   else:
15491:    name = "ALL"
15492:    plural = "s"
15493:   VV3wat = []
15494:   VV3wat.append(("Download %s %s%s" % (name, "PIcon" if self.VVjS9t == "Live" else "Poster", plural), "dnldPicons" ))
15495:   if self.VVjS9t in ("VOD", "Series"):
15496:    VV3wat.append(VVAL3j)
15497:    tName = "Movie" if self.VVjS9t == "VOD" else "Episode"
15498:    VV3wat.append(("Download Current %s" % tName    , "dnldSel"  ))
15499:    VV3wat.append(("Add Current %s to Download List" % tName , "addSel"  ))
15500:    if not CCHRcZ.VVAbZK():
15501:     VV3wat.append(VVAL3j)
15502:     VV3wat.append(("Download Manager"      , "dload_stat" ))
15503:   FFLFTC(self.SELF, BF(self.VVn1PO, VV6A99, colList), title="Download Options", VV3wat=VV3wat)
15504:  def VVn1PO(self, VV6A99, colList, item=None):
15505:   if item:
15506:    if   item == "dnldPicons" : CCkEI5.VVE5LS(self.SELF, VV6A99, "m3u")
15507:    elif item == "dnldSel"  : self.VVKXOQ(VV6A99, colList, True)
15508:    elif item == "addSel"  : self.VVKXOQ(VV6A99, colList, False)
15509:    elif item == "dload_stat" : CCHRcZ.VVSZMa(self.SELF, VV6A99)
15510:  def VVKXOQ(self, VV6A99, colList, startDnld):
15511:   VVPxk5, VV1wIO, chUrl, VVfbmn, VVZcRP, isMark = self.VVDnYt(colList)
15512:   if startDnld:
15513:    CCHRcZ.VVXNDk(self.SELF, VVZcRP)
15514:   else:
15515:    self.VVtE9u(VV6A99, "Add to Download list", VV1wIO, [VVZcRP], startDnld)
15516:  def VVtE9u(self, VV6A99, title, VV1wIO, VVC9AM, startDnld):
15517:   FFRMYv(self.SELF, BF(self.VVDOiu, VV6A99, VVC9AM, startDnld), VV1wIO, title=title)
15518:  def VVDOiu(self, VV6A99, VVC9AM, startDnld):
15519:   added, skipped = CCHRcZ.VVNrGg(VVC9AM)
15520:   FF28n1(VV6A99, "Added", 1000)
15521:  def VVcz9s(self, VV6A99, title, txt, colList):
15522:   VVPxk5, VV1wIO, chUrl, VVfbmn, VVZcRP, isMark = self.VVDnYt(colList)
15523:   if isMark:
15524:    FF28n1(VV6A99, "Cannot play markers", 500)
15525:   else:
15526:    chUrl = CCwhE4.VVtjAF(self.SELF, chUrl)
15527:    VVAfO9 = self.VV0w88(VVfbmn)
15528:    CCqWM2.VVHc02(self.SELF.session, VVwqHQ=(self, VV6A99, "localServer"), VVaHNe=chUrl, VVAfO9=VVAfO9)
15529:  def VVDnYt(self, colList):
15530:   return CCjZbZ.VVOteG(self.SELF, colList)
15531:  def VVJlyo(self, VV6A99, colList, isUp):
15532:   VVPxk5, VV1wIO, chUrl, VVfbmn, VVZcRP, isMark = self.VVDnYt(colList)
15533:   if isMark:
15534:    for i in range(VV6A99.VVn1uo()):
15535:     if isUp : VV6A99.VVIRjv()
15536:     else : VV6A99.VVgexy()
15537:     VVPxk5, VV1wIO, chUrl, VVfbmn, VVZcRP, isMark = self.VVDnYt(VV6A99.VV5crm())
15538:     if not isMark:
15539:      break
15540:   VVAfO9 = self.VV0w88(VVfbmn)
15541:   return VV1wIO, chUrl, VVAfO9
15542:  def VVPzom(self, VV6A99, title, txt, colList):
15543:   VVPxk5, VV1wIO, chUrl, VVfbmn, VVZcRP, isMark = self.VVDnYt(colList)
15544:   CCvjVs.VV0Xds(self.SELF, VV7VUc=CCvjVs.VV1YsH, params=(VVPxk5, VV1wIO, txt, chUrl, VVfbmn))
15545:  def VVelOl(self, VV6A99, title, txt, colList):
15546:   FFimQ3(VV6A99, BF(self.SELF.session.open, CCUYzx, VV6A99, self.VVvlpm(), 1, 4, 0, "Num"))
15547:  def VVIcUn(self):
15548:   return self.VVjS9t.lower() if self.VVjS9t in ("Live", "VOD", "Series") else "m3u"
15549:  def VVvlpm(self):
15550:   return CCkEI5.VVYrUH(self.VVIcUn())
15551:  def VV0w88(self, VVfbmn):
15552:   return os.path.join(self.VVvlpm(), os.path.basename(VVfbmn)) if VVfbmn else ""
15553:  def VVcsah(self, path):
15554:   cl = CCjZbZ.VVs0Rm(path)
15555:   srcFil = cl.srcFil or path
15556:   if any((srcFil, cl.srv, cl.VVKWLJ, cl.srcTm, cl.totAll)):
15557:    c1 = VVFuwR
15558:    tab = lambda x, y: ("   %s\t: %s\n" % (x, y))
15559:    tab1 = lambda x, y: ("   %s\t: %s\n" % (x, y)) if y else ""
15560:    ttl = lambda x, y: "%s:\n%s\n\n" % (FFjt5L(x, c1), str(y)) if y else ""
15561:    txt  = ttl("Name"  , cl.srv)
15562:    txt += ttl("Saved"  , cl.srcTm)
15563:    if FFCyVu(srcFil):
15564:     t = srcFil + FFjt5L("\nNote : Original file was modified.", VVyFI2) if cl.toUpd else ""
15565:     txt += ttl("Source File", t)
15566:    txt += ttl("Source URL"  , cl.VVKWLJ)
15567:    txt += FFjt5L("Total:\n", c1)
15568:    txt += tab("Groups"  , cl.totGrp)
15569:    txt += tab("Services" , cl.totSrv)
15570:    if cl.totEnt:
15571:     txt += FFjt5L("\nEntries (%s):\n" % cl.totEnt, c1)
15572:     txt += tab1("  Live" , cl.totChL)
15573:     txt += tab1("  VOD"  , cl.totChV)
15574:     txt += tab1("  Series" , cl.totChS)
15575:     txt += tab1("  Movie" , cl.totChM)
15576:     txt += tab1("  DVB"  , cl.totChD)
15577:     txt += tab1("  S.Relay" , cl.totChR)
15578:     txt += tab1("  FTP"  , cl.totChF)
15579:     txt += tab1("  Marker" , cl.totChK)
15580:    FF4lCP(self.SELF, txt, "Services")
15581:   else:
15582:    FF28n1(VV7tND, "No info", 500)
15583:  @staticmethod
15584:  def VVs0Rm(path):
15585:   class CCDNtC():
15586:    def __init__(self):
15587:     self.srv = os.path.splitext(FFxtW5(path))[0]
15588:     self.srcFil = self.srcMod = self.VVKWLJ = self.srcTm = ""
15589:     self.totL = self.totV = self.totS = self.totM = self.totD = self.totR = self.totF = 0
15590:     self.totChL = self.totChV = self.totChS = self.totChM = self.totChD = self.totChR = self.totChF = self.totChK = 0
15591:     self.totEnt = self.totSrv = self.totAll = 0
15592:     self.valid = False
15593:     self.toUpd = False
15594:     self.err = ""
15595:     lines, self.err = CCjZbZ.VV2LK6(path, "_main", mode=1)
15596:     if self.err:
15597:      return
15598:     skip = CFG.hideIptvServerAdultWords.getValue()
15599:     tab1 = lambda s, v, t: int(v) if s == t and v.isdigit() else 0
15600:     tab2 = lambda s, v, t: int(v) if s == "blk_" + t and v.isdigit() else 0
15601:     tab3 = lambda x, catBlk: 1 if (line.startswith(x) and not (skip and catBlk)) else 0
15602:     for line in lines:
15603:      if line.startswith("#"):
15604:       subj, _, val = line.partition(":")
15605:       subj, val = subj[1:].strip().lower(), val.strip()
15606:       if   subj == "file"  : self.srcFil = val
15607:       elif subj == "modified" : self.srcMod = val
15608:       elif subj == "url"  : self.VVKWLJ = val
15609:       elif subj == "saved" : self.srcTm  = val
15610:       elif subj == "entries" : self.totEnt = val
15611:       elif subj == "services" : self.totSrv = val
15612:       self.totChL += tab1(subj, val, "live" )
15613:       self.totChV += tab1(subj, val, "vod" )
15614:       self.totChS += tab1(subj, val, "series" )
15615:       self.totChM += tab1(subj, val, "movie" )
15616:       self.totChD += tab1(subj, val, "dvb" )
15617:       self.totChR += tab1(subj, val, "s.relay")
15618:       self.totChF += tab1(subj, val, "ftp" )
15619:       self.totChK += tab1(subj, val, "marker" )
15620:       if skip:
15621:        self.totChL -= tab2(subj, val, "live" )
15622:        self.totChV -= tab2(subj, val, "vod" )
15623:        self.totChS -= tab2(subj, val, "series" )
15624:        self.totChM -= tab2(subj, val, "movie" )
15625:        self.totChD -= tab2(subj, val, "dvb" )
15626:        self.totChR -= tab2(subj, val, "s.relay")
15627:        self.totChF -= tab2(subj, val, "ftp" )
15628:        self.totChK -= tab2(subj, val, "marker" )
15629:      else:
15630:       parts = line.split("\t")
15631:       if len(parts) == 5:
15632:        typ, catBlk, fName, totCh, cat = line.split("\t")
15633:        catBlk = catBlk == "1"
15634:        self.totL += tab3("Live" , catBlk)
15635:        self.totV += tab3("VOD"  , catBlk)
15636:        self.totS += tab3("Series" , catBlk)
15637:        self.totM += tab3("Movie" , catBlk)
15638:        self.totD += tab3("DVB"  , catBlk)
15639:        self.totR += tab3("S.Relay" , catBlk)
15640:        self.totF += tab3("FTP"  , catBlk)
15641:     self.totGrp = self.totL + self.totV + self.totS + self.totM + self.totD + self.totR + self.totF
15642:     self.totCh = self.totChL + self.totChV + self.totChS + self.totChM + self.totChD + self.totChR + self.totChF
15643:     self.totAll = self.totGrp + self.totCh
15644:     self.valid = any((self.srv, self.srcFil, self.VVKWLJ, self.srcTm, self.totAll))
15645:     if self.srcMod and FFCyVu(self.srcFil):
15646:      try:
15647:       old = int(self.srcMod)
15648:       cur = int(os.path.getmtime(self.srcFil))
15649:       self.toUpd = old != cur
15650:      except:
15651:       pass
15652:   return CCDNtC()
15653:  def VVQ5VQ(self, err, title=""):
15654:   FFdw58(self.SELF, err, title=title or self.Title)
15655:  def VVBIA4(self, rowNum, url, VV1wIO):
15656:   VVPxk5 = CCjZbZ.VVeaoE(rowNum + 1, url)
15657:   span1 = iSearch(r"((?:[a-z0-9]+:){10})(.+)(:.+)", url, IGNORECASE)
15658:   span2 = iSearch(r"((?:[a-z0-9]+:){10})(.+)"  , url, IGNORECASE)
15659:   span3 = iSearch(r"((?:[a-z0-9]+:){10})$"  , url, IGNORECASE)
15660:   span4 = iSearch(r"(.+)([&?]mode=.+&chCm=)(.*)(&end.+)", url, IGNORECASE)
15661:   if   span1 : return "%s%s%s"  % (span1.group(1), FFSiPR(span1.group(2)), span1.group(3))
15662:   elif span2 : return "%s%s:%s" % (span2.group(1), FFSiPR(span2.group(2)), VV1wIO)
15663:   elif span3 : return span3.group(1)
15664:   elif span4 : return "%s%s:%s" % (VVPxk5, FFSiPR(span4.group(1)) + span4.group(2) + FFSiPR(span4.group(3)) + span4.group(4), VV1wIO)
15665:   else  : return "%s%s:%s" % (VVPxk5, FFSiPR(url), VV1wIO)
15666:  @staticmethod
15667:  def VVeaoE(rowNum, url):
15668:   span = iSearch(r".+\/(\d+)\.?", url)
15669:   num = span.group(1) if span else "444"
15670:   catID = "333"
15671:   chNum = str(rowNum)
15672:   stID = num if int(num) < 0xeeee0000 else "444"
15673:   VVPxk5 = CCkEI5.VVpX1r(catID, stID, chNum)
15674:   return VVPxk5
15675:  @staticmethod
15676:  def VVuYvs(path):
15677:   m3Dir = FFoWxR(os.path.dirname(path))
15678:   m3File = os.path.basename(path)
15679:   VVcwFG = os.path.splitext(m3File)[0]
15680:   zPath = "%s%s.zip" % (CCjZbZ.VVz4Ig(), VVcwFG)
15681:   zFound = FFCyVu(zPath)
15682:   return m3File, m3Dir, VVcwFG, zPath, zFound
15683:  @staticmethod
15684:  def VVz4Ig():
15685:   return FF0cqc() + "ajpanel_local_servers/"
15686:  @staticmethod
15687:  def VVOteG(SELF, colList):
15688:   num, name, logo, url, VVfbmn = colList
15689:   VV1wIO = FFzBfi(name)
15690:   isMark = FFhPtm(url)
15691:   if iMatch(r"^([A-Fa-f0-9]+[:]){10}", url):
15692:    VVPxk5 = chUrl = url
15693:    VVZcRP = ""
15694:   else:
15695:    VVPxk5, chUrl, VVZcRP = CCjZbZ.VVYrGK(int(num) + 1, url, VV1wIO)
15696:   return VVPxk5, VV1wIO, chUrl, VVfbmn, VVZcRP, isMark
15697:  @staticmethod
15698:  def VVYrGK(num, url, VV1wIO):
15699:   VVZcRP = FFXarh(url)
15700:   VVPxk5 = CCjZbZ.VVeaoE(num, VVZcRP)
15701:   span = iSearch(r"(.+)([&?]mode=.+&chCm=)(.*)(&end.+)", VVZcRP, IGNORECASE)
15702:   if span : encUrl = FFSiPR(span.group(1)) + span.group(2) + FFSiPR(span.group(3)) + span.group(4)
15703:   else : encUrl = FFSiPR(VVZcRP)
15704:   chUrl = "%s%s:%s" % (VVPxk5, encUrl, VV1wIO)
15705:   VVZcRP = "%s:%s" % (VVZcRP, VV1wIO)
15706:   return VVPxk5, chUrl, VVZcRP
15707:  @staticmethod
15708:  def VVICcD(SELF, Dir, VVTiJ2, cbFnc=None):
15709:   CCh3tv.VV7Nf4(SELF, VVLL7M="Counting Files ...", titleBg="#22220022", bodyBg="#22002211", barBg="#0a226622"
15710:       , VVixvy  = BF(CCjZbZ.VVviSu, Dir, VVTiJ2)
15711:       , VVbYwR = BF(CCjZbZ.VV1g3w, SELF, VVTiJ2, cbFnc))
15712:  @staticmethod
15713:  def VVviSu(Dir, VVTiJ2, VVXyP6):
15714:   tot = 0
15715:   for root, dirs, files in os.walk(Dir):
15716:    tot += len(files)
15717:   if not VVXyP6 or VVXyP6.isCancelled: return
15718:   VVXyP6.VVq8NF(tot)
15719:   VVXyP6.VVNc18 = (0, "")
15720:   tot, err = 0, ""
15721:   try:
15722:    with iZip.ZipFile(VVTiJ2, 'w', iZip.ZIP_DEFLATED) as zipF:
15723:     for root, dirs, files in os.walk(Dir):
15724:      for file in files:
15725:       zipF.write(os.path.join(root, file), os.path.relpath(os.path.join(root, file), os.path.join(Dir, '..')))
15726:       tot += 1
15727:       if not VVXyP6 or VVXyP6.isCancelled: return
15728:       VVXyP6.VVxtQs(1)
15729:       VVXyP6.VVaks5("Archiving Files : %s" % tot)
15730:       VVXyP6.VVNc18 = (tot, "")
15731:   except Exception as e:
15732:    VVXyP6.VVNc18 = (tot, str(e))
15733:  @staticmethod
15734:  def VV1g3w(SELF, VVTiJ2, cbFnc, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
15735:   tot, err = VVNc18
15736:   if err: FFwgGB(VVTiJ2)
15737:   if cbFnc: cbFnc(VVTiJ2, tot, err)
15738:  @staticmethod
15739:  def VV8fEW(Dir, VVTiJ2):
15740:   tot, err = 0, ""
15741:   try:
15742:    with iZip.ZipFile(VVTiJ2, 'w', iZip.ZIP_DEFLATED) as zipF:
15743:     for root, dirs, files in os.walk(Dir):
15744:      for file in files:
15745:       zipF.write(os.path.join(root, file), os.path.relpath(os.path.join(root, file), os.path.join(Dir, '..')))
15746:       tot += 1
15747:   except Exception as e:
15748:    err = str(e)
15749:   return tot, err
15750:  @staticmethod
15751:  def VV2LK6(VVTiJ2, fil, mode=0):
15752:   try:
15753:    with iZip.ZipFile(VVTiJ2) as zipF:
15754:     zInfLst = zipF.infolist()
15755:     for zipInfo in zInfLst:
15756:      fName = os.path.basename(zipInfo.filename)
15757:      if fName == fil:
15758:       with zipF.open(zipInfo.filename) as f:
15759:        txt = f.read().decode()
15760:        if mode == 0: return str(txt), ""
15761:        else  : return [str(x.strip()) for x in txt.splitlines()], ""
15762:   except Exception as e:
15763:    return "", str(e)
15764:   return "", "Missing file"
15765:  @staticmethod
15766:  def VVir5C(url):
15767:   try: res = iUrlparse(url)
15768:   except: return [""] * 4
15769:   scheme = res.scheme
15770:   netloc = res.netloc
15771:   query = res.query
15772:   VVGWyE = res.hostname or ""
15773:   hst  = "%s://%s" % ((scheme or "http"), netloc)
15774:   d = iUrlparse_qs(query)
15775:   usr = d.get("username")[0] if "username" in d else ""
15776:   pas = d.get("password")[0] if "password" in d else ""
15777:   return hst, usr, pas, VVGWyE
15778:  @staticmethod
15779:  def VVZXSg(url, chkExt=False):
15780:   if any(x in url for x in ("/series/", "mode=series")):
15781:    return "Series"
15782:   if any(x in url for x in ("/movie/", "/movie.php", "/media/vod", "mode=vod", "/vod/", "/video/", "/timeshift/")):
15783:    return "VOD"
15784:   if any(x in url for x in ("/live/", "/live2/", "/live.php", "mode=itv", "?ext=.ts", "/index.m3u8")):
15785:    return "Live"
15786:   if url.startswith("1:64:")       : return "Marker"
15787:   if url.startswith("/")        : return "Movie"
15788:   if FFHgaY(url)        : return "S.Relay"
15789:   if iMatch(r"^(?:[A-Fa-f0-9]+:){10}", url)   : return "DVB"
15790:   if iMatch(r"^http.+(?:[A-Fa-f0-9]+:){10}", url)  : return "DVB"
15791:   if any(x in url for x in ("file?file", ":ftp%3a//")): return "FTP"
15792:   if chkExt and any(x in url for x in (".mp4", ".mkv", ".avi")):
15793:    return "VOD"
15794:   return "Live"
15795: class CCwhE4(CC96QG):
15796:  def __init__(self):
15797:   self.curPortalCatId = ""
15798:   CC96QG.__init__(self)
15799:  def VV0z9x(self):
15800:   if CCwhE4.VVOJRa(self):
15801:    self.VV0muG(2)
15802:  def VVAw1p(self, winSession, url, mac):
15803:   self.VV2rlK = url
15804:   if CCwhE4.VVOJRa(self):
15805:    if self.VVNf1R(url, mac):
15806:     FFimQ3(winSession, self.VVG6wB, title="Checking Server ...")
15807:    else:
15808:     FFdw58(self, "Incorrect URL or MAC format !", title="Starting Portal Browser")
15809:  def VVDtP0(self, item=None):
15810:   if item:
15811:    VV7tND, txt, path, ndx = item
15812:    enc = CC7ocD.VV51oT(path, self)
15813:    if enc == -1:
15814:     return
15815:    CCh3tv.VV7Nf4(self, VVLL7M="Processing file lines"
15816:        , VVixvy  = BF(self.VVW8Um, path, enc)
15817:        , VVbYwR = BF(self.VVzcIH, VV7tND, path))
15818:  def VVW8Um(self, path, enc, VVXyP6):
15819:   urlMacPatt  = r"(.*)(https?:\/\/.+(?::[0-9]+)*)(?:.+)((?:[A-Fa-f0-9]{2}\s*:\s*){5}[A-Fa-f0-9]{2})(.*)"
15820:   urlOnlyPatt = r"\s*(https?:\/\/.+(?::[0-9]+)*)"
15821:   macOnlyPatt = r"((?:(?:.*mac\s*)[^A-Fa-f0-9]\s*)*)((?:(?:(?:[A-Fa-f0-9]{2})\s*:\s*){5})\s*(?:[A-Fa-f0-9]{2}))(.*)"
15822:   tableRows, url = [], ""
15823:   lineNum = 0
15824:   totLines = 0
15825:   with ioOpen(path, "r", encoding=enc) as f:
15826:    for line in f:
15827:     totLines += 1
15828:   VVXyP6.VVq8NF(totLines)
15829:   VVXyP6.VVNc18 = []
15830:   def VVZwiy(subj, host, mac, info):
15831:    if host and mac and VVXyP6:
15832:     if not [1 for _, _, _, host1, mac1, _ in VVXyP6.VVNc18 if (host1, mac1) == (host, mac)]:
15833:      VVXyP6.VVNc18.append((str(len(VVXyP6.VVNc18) + 1), str(lineNum), subj, host, mac, info))
15834:   with ioOpen(path, "r", encoding=enc) as f:
15835:    for line in f:
15836:     lineNum += 1
15837:     if not VVXyP6 or VVXyP6.isCancelled:
15838:      return
15839:     VVXyP6.VVxtQs(1, True)
15840:     line = str(line).strip()
15841:     if not line or len(line) > 500 or "password" in line:
15842:      continue
15843:     span = iSearch(urlMacPatt, line, IGNORECASE)
15844:     if span:
15845:      subj = span.group(1).strip().strip(',"') or "-"
15846:      url  = span.group(2).strip().split(" ")[0].split("\t")[0].strip()
15847:      mac  = span.group(3).strip().replace(" ", "").upper()
15848:      info = span.group(4).strip().strip(',;"\t') or "-"
15849:      host = self.VVY27l(url).replace('"mac', "").strip(',"')
15850:      mac  = self.VV1r6n(mac)
15851:      VVZwiy(subj, host, mac, info)
15852:      url = ""
15853:      continue
15854:     if not url:
15855:      span = iSearch(urlMacPatt, line, IGNORECASE)
15856:      if not span:
15857:       span = iSearch(urlOnlyPatt, line, IGNORECASE)
15858:       if span:
15859:        url = span.group(1).split(" ")[0]
15860:     else:
15861:      span = iSearch(macOnlyPatt, line.replace("\t", " "), IGNORECASE)
15862:      if span:
15863:       subj = span.group(1).strip().strip(',"') or "-"
15864:       mac  = span.group(2).strip().replace(" ", "").upper()
15865:       info = span.group(3).strip().strip(',;"') or "-"
15866:       host = self.VVY27l(url).strip(',;"\t')
15867:       mac  = self.VV1r6n(mac)
15868:       VVZwiy("", host, mac, info)
15869:      else:
15870:       span = iSearch(urlOnlyPatt, line, IGNORECASE)
15871:       if span:
15872:        url = span.group(1).split(" ")[0]
15873:  def VVzcIH(self, VVr7eD, path, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
15874:   if VVNc18:
15875:    VVu1YM  = ("Select"   , self.VVCfle , [])
15876:    VVGuQE  = BF(self.VVEo3E, VVr7eD)
15877:    VVwWmA  = ("Home Menu"  , FF8lJ1            , [])
15878:    VVwSzI = ("Browse as M3U" , self.VVFMSv        , [])
15879:    VVScQz = ("Edit File"  , BF(self.VVStbP, path)       , [])
15880:    VV4QTJ = ("Options"  , BF(self.VVpKUL, VVr7eD, path) , [])
15881:    header   = ("Num" , "LineNum" , "Title" , "Host", "MAC-Address" , "Comments")
15882:    widths   = (7  , 0   , 12  , 36 , 20   , 25  )
15883:    VVLIqP  = (CENTER , CENTER , LEFT  , LEFT , CENTER  , LEFT  )
15884:    VV6A99 = FFUQ0v(self, None, title=os.path.basename(path), header=header, VVGape=VVNc18, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVu1YM=VVu1YM, VVGuQE=VVGuQE, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVwltY="#0a001122", VVkxBG="#0a001122", VVemyB="#0a001122", VVJKqd="#00004455", VVbcr0="#0a333333", VVX9AA="#11331100", VVHPI7=True, VVMfsO=3, VVSLOq=CFG.lastFindServers)
15885:    if not VVRI6P:
15886:     FF28n1(VV6A99, "Stopped at line %s" % threadCounter, 1000)
15887:   else:
15888:    if VVRI6P:
15889:     FFdw58(self, "No valid portal data (or incorrect file format) in:\n\n%s" % path, title="Get Portal Data")
15890:  @FFOAKH("Checking Access ...", par=1, clearMsg=False)
15891:  def VVFMSv(self, VV6A99, title, txt, colList):
15892:   host, mac = colList[3], colList[4]
15893:   p, pUrl, pUrlAcc, pUrlDnld, pHost, pUser, pPass, err = CC96QG.VV1SNn(host=host, mac=mac)
15894:   VV6A99.VVrmMb()
15895:   if pUrlAcc and pUrlDnld : self.VVgCCs(VV6A99, title, pUrlAcc)
15896:   else     : FFdw58(self, err or "No response from Server !", title="Playlist for : %s" % host)
15897:  def VVCfle(self, VV6A99, title, txt, colList):
15898:   self.VVAw1p(VV6A99, colList[3], colList[4])
15899:  def VVStbP(self, path, VV6A99, title, txt, colList):
15900:   rowNum = int(colList[1].strip()) - 1
15901:   if FFCyVu(path) : CCyMCP(self, path, VVbYwR=BF(self.VVzm4T, VV6A99), VVPhQC=rowNum)
15902:   else    : FF8Wsn(self, path)
15903:  def VVpKUL(self, VVr7eD, path, VV6A99, title, txt, colList):
15904:   VV3wat =[]
15905:   VV3wat.append(("Filter Responsive Servers"  , "tok"))
15906:   VV3wat.append(("Find Servers with Playlist Access", "plst"))
15907:   FFLFTC(self, BF(self.VVEaMp, VVr7eD, VV6A99, path), title="Portal Options", VV3wat=VV3wat, width=700)
15908:  def VVEaMp(self, VVr7eD, VV6A99, path, item):
15909:   if not item: return
15910:   isToken = item == "tok"
15911:   nm, ext = os.path.splitext(os.path.basename(path))
15912:   for s in ("TOKEN_", "PLAYLIST_", "OK_"): nm = nm.replace(s, "")
15913:   nm = iSub(r"(_\d{8})", "", nm)
15914:   nm = iSub(r"(_\d{6})", "", nm)
15915:   nm, _ = os.path.splitext(nm)
15916:   txt = "TOKEN" if item == "tok" else "PLAYLIST"
15917:   nm = "%s_%s_%s.txt" % (nm, "TOKEN" if isToken else "PLAYLIST", FFjTQe())
15918:   outF = os.path.join(os.path.dirname(path), nm)
15919:   self.VVspUi(VVr7eD, VV6A99, outF, isToken, VV6A99.VVrrm9(), VV6A99.VVn1uo())
15920:  def VVspUi(self, VVr7eD, VV6A99, outF, isToken, lst, tot):
15921:   CCh3tv.VV7Nf4(self, VVLL7M="Checking Portals"
15922:       , VVixvy  = BF(self.VV7QJ2, outF, isToken, lst, tot)
15923:       , VVbYwR = BF(self.VVPd3Z, VVr7eD, VV6A99, outF, isToken))
15924:  def VV7QJ2(self, outF, isToken, lst, tot, VVXyP6):
15925:   totOk = totNotOK = totHstErr = totSkip = 0
15926:   VVXyP6.VVNc18 = (totOk, totNotOK, totHstErr, totSkip, "")
15927:   VVXyP6.VVq8NF(tot)
15928:   skipHosts = set()
15929:   for row in lst:
15930:    if not VVXyP6 or VVXyP6.isCancelled: return
15931:    VVXyP6.VVEpLv(0, totOk)
15932:    num, lNum, titl, host, mac, cmnt = row
15933:    valid = False
15934:    if host in skipHosts        : totSkip += 1
15935:    elif self.VVNf1R(host, mac, VVwb7n=False) : valid = True
15936:    else            : totHstErr += 1
15937:    if valid:
15938:     fLine = token = pUrlAcc = ""
15939:     if isToken:
15940:      t1 = iTime()
15941:      token, profile, tErr = self.VVTATM(VVwb7n=False)
15942:      took = "%.3f" % (iTime() - t1)
15943:      if token:
15944:       fLine = "%s\t%s\t%s\t(Token: %s sec) %s" % (titl, host, mac, took, "" if cmnt == "-" else cmnt)
15945:     else:
15946:      p, pUrl, pUrlAcc, pUrlDnld, pHost, pUser, pPass, err = CC96QG.VV1SNn(host=host, mac=mac)
15947:      if pUrlAcc:
15948:       fLine = "%s\t%s\n%s\n" % (host, mac, pUrlAcc)
15949:     if not VVXyP6 or VVXyP6.isCancelled: return
15950:     if isToken and token or not isToken and pUrlAcc:
15951:      try:
15952:       with open(outF, "a") as f:
15953:        f.write("%s\n" % fLine)
15954:       totOk += 1
15955:       if not VVXyP6 or VVXyP6.isCancelled: return
15956:       VVXyP6.VVNc18 = (totOk, totNotOK, totHstErr, totSkip, "")
15957:      except Exception as e:
15958:       if not VVXyP6 or VVXyP6.isCancelled: return
15959:       VVXyP6.VVNc18 = (totOk, totNotOK, totHstErr, totSkip, str(e))
15960:       return
15961:     else:
15962:      if self.portal_latestResponse.get("resCritical", ""):
15963:       skipHosts.add(host)
15964:       totSkip += 1
15965:      else:
15966:       totNotOK += 1
15967:    if not VVXyP6 or VVXyP6.isCancelled: return
15968:    VVXyP6.VVNc18 = (totOk, totNotOK, totHstErr, totSkip, "")
15969:    VVXyP6.VVEpLv(1, totOk)
15970:  def VVPd3Z(self, VVr7eD, VV6A99, outF, isToken, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
15971:   totOk, totNotOK, totHstErr, totSkip, err = VVNc18
15972:   c1, c2 = VVSGsk, VVz22H
15973:   tab = lambda a, b: "%s\t: %s\n" % (a, b)
15974:   txt  = tab("Servers" ,  threadTotal)
15975:   txt += tab("Checked" ,  threadCounter)
15976:   txt += tab("Accessible" ,  FFjt5L(totOk, c1 if totOk else c2))
15977:   if totNotOK   : txt += tab("No Token" if isToken else "Not found", totNotOK)
15978:   if totSkip   : txt += tab("Skipped"  , "%d (host access error)" % totSkip)
15979:   if totHstErr  : txt += tab("Host Error" , totHstErr)
15980:   if err    : txt += tab("\nError" , FFjt5L(err, c2))
15981:   if not VVRI6P : txt += tab("\nProcess", FFjt5L("Stopped", c2))
15982:   if totOk   : txt += "\n%s\n%s\n" % (FFjt5L("Output File:", c1), outF)
15983:   FF4lCP(self, txt, title="Portal Servers Filtering")
15984:   if totOk:
15985:    if VVr7eD: VVr7eD.VV5HD3((outF, outF), isSort=True)
15986:    if VV6A99: VV6A99.close()
15987:  def VVG6wB(self):
15988:   token, profile, tErr = self.VVTATM()
15989:   if token:
15990:    dots = "." * self.VVdDpE
15991:    dots += {"s":"", "p":"+", "q":"++"}.get(self.VVaM9P(), "")
15992:    dots += "*" if not self.VVncdQ == self.VV2rlK else ""
15993:    if dots:
15994:     dots = FFjt5L(dots, VVo7S9)
15995:    if CFG.simplePortal.getValue() : VVwltY, VVkxBG = "
15996:    else       : VVwltY, VVkxBG = "#22003344", "#22002233"
15997:    VV3wat  = self.VVafii()
15998:    VVOa1G = self.VV9X9b
15999:    VVJbOd = BF(self.VV49j5, 1)
16000:    VVHGnw = ("Home Menu", FF8lJ1)
16001:    VVB4pu= ("Add to Menu", BF(CCkEI5.VVoyt7, self, True, self.VVncdQ + "\t" + self.VVvRlC))
16002:    VVaTeF = ("Bookmark", BF(CCkEI5.VVwOWK, self, True, self.VVncdQ + "\t" + self.VVvRlC))
16003:    VV7tND = FFLFTC(self, None, title="Portal Resources (MAC=%s) %s" % (self.VVvRlC, dots), VV3wat=VV3wat, VVOa1G=VVOa1G, VVJbOd=VVJbOd, VVHGnw=VVHGnw, VVB4pu=VVB4pu, VVaTeF=VVaTeF, VVwltY=VVwltY, VVkxBG=VVkxBG)
16004:    self.VVANDc(VV7tND)
16005:  def VV9X9b(self, item=None):
16006:   if item:
16007:    VV7tND, title, ref, ndx = item
16008:    if   ref == "live"   : mode = "itv"
16009:    elif ref == "vod"   : mode = "vod"
16010:    elif ref == "series"  : mode = "series"
16011:    elif ref == "accountInfo" : mode = ""
16012:    if mode : self.VV5K0A(VV7tND, mode)
16013:    else : self.VVkOTh(VV7tND, title)
16014:  @FFOAKH("Reading Account ...", par=1)
16015:  def VVkOTh(self, VV7tND, title, forceMoreInfo=False):
16016:   rows, totCols = self.VVIr7V(forceMoreInfo)
16017:   title = "%s (MAC=%s)" % (title, self.VVvRlC)
16018:   VVwWmA  = ("Home Menu" , FF8lJ1           , [])
16019:   VVwSzI  = None
16020:   if VVBvqf:
16021:    VVwSzI = ("Get JS"  , BF(self.VV7Vtg, self.VVTr19()) , [])
16022:   if totCols == 2:
16023:    VV4QTJ = None
16024:    header   = ("Subject" , "Value" )
16025:    widths   = (43   , 57  )
16026:    VVMfsO  = 0
16027:   else:
16028:    VV4QTJ = ("More Info.", BF(self.VVNkUI, VV7tND)    , [])
16029:    header   = ("Num", "User/Server" , "Subject" , "Value" )
16030:    widths   = (0 , 15   , 35  , 50  )
16031:    VVMfsO  = 2
16032:   FFUQ0v(self, None, title=title, width=1200, header=header, VVGape=rows, VV3cHe=widths, VVwdmN=26, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VV4QTJ=VV4QTJ, VVwltY="#0a00292B", VVkxBG="#0a002126", VVemyB="#0a002126", VVJKqd="#00000000", VVMfsO=VVMfsO)
16033:  @FFOAKH("Getting JS ...", par=2)
16034:  def VV7Vtg(self, url, VV6A99, title, txt, colList):
16035:   txt  = "// Host\t: %s\t%s\n" % (url, self.VVvRlC)
16036:   ver, err = self.VVI5kn(url)
16037:   txt += "// Version\t: %s\n\n" % (ver or err)
16038:   js , err = self.VVI5kn(url, isJsFile=True)
16039:   if err: txt += "Error : %s" % err
16040:   else  : txt += js
16041:   FF4lCP(self, txt, title="JS Info", VVRhqH="Server_xpcom.common.js")
16042:  def VVNkUI(self, VV7tND, VV6A99, title, txt, colList):
16043:   VV6A99.cancel()
16044:   self.VVkOTh(VV7tND, "Account Info.", forceMoreInfo=True)
16045:  @FFOAKH("Reading Categories ...", par=1)
16046:  def VV5K0A(self, VV7tND, mode):
16047:   token, profile, tErr = self.VVTATM()
16048:   if not token:
16049:    return
16050:   res, err = self.VVnjdQ(self.VVryIa(mode))
16051:   list = []
16052:   if not err:
16053:    try:
16054:     tDict = jLoads(res.text)
16055:     if tDict:
16056:      chList = tDict["js"]
16057:      for item in chList:
16058:       Id   = FFYjVd(item, "id"       )
16059:       Title  = FFYjVd(item, "title"      )
16060:       censored = FFYjVd(item, "censored"      )
16061:       Title = self.VV1vXv(Title)
16062:       if Title:
16063:        isAll = Title.strip().lower() in ("all", "all channels")
16064:        if not isAll or isAll and VVWe5f:
16065:         list.append((Title.strip(), Id))
16066:    except:
16067:     pass
16068:   title = self.VVdGiv(mode)
16069:   if list:
16070:    list.sort(key=lambda x: x[0].lower())
16071:    self.VVLp7F = dict([(x[1], x[0]) for x in list])
16072:    VVwltY, VVkxBG, VVemyB, VVJKqd = self.VVxV5D(mode)
16073:    mName = self.VVdGiv(mode)
16074:    VVCOpO  = (""     , BF(self.VVqVx2, mode), [])
16075:    VVu1YM   = ("Show List"   , BF(self.VVDIxp, mode)   , [])
16076:    VVwWmA  = ("Home Menu"   , FF8lJ1        , [])
16077:    if mode in ("vod", "series"):
16078:     VVScQz = ("Find in %s" % mName , BF(self.VVa107, mode, False), [])
16079:     VV4QTJ = ("Find in Selected" , BF(self.VVa107, mode, True) , [])
16080:    else:
16081:     VVScQz = None
16082:     VV4QTJ = None
16083:    header   = None
16084:    widths   = (100   , 0  )
16085:    FFUQ0v(self, None, title=title, width=1200, header=header, VVGape=list, VV3cHe=widths, VVwdmN=30, VVwWmA=VVwWmA, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVCOpO=VVCOpO, VVu1YM=VVu1YM, VVwltY=VVwltY, VVkxBG=VVkxBG, VVemyB=VVemyB, VVJKqd=VVJKqd, VVSLOq=CFG.lastFindIptv)
16086:   else:
16087:    s = "Authorization failed"
16088:    if err:
16089:     txt = err
16090:    elif s in res.text:
16091:     txt = s
16092:     if self.VVnsdh:
16093:      txt += "\n\n( %s )" % self.VVnsdh
16094:    else:
16095:     txt = "Could not get Categories from server!"
16096:    FFdw58(self, txt, title=title)
16097:  @FFOAKH("Downloading ...", par=2)
16098:  def VVuCrJ(self, mode, VV6A99, title, txt, colList):
16099:   token, profile, tErr = self.VVTATM()
16100:   if not token:
16101:    return
16102:   VVetid = colList[1]
16103:   catID  = colList[2]
16104:   res, err = self.VVnjdQ(self.VVhjC5(catID))
16105:   list = []
16106:   if not err:
16107:    try:
16108:     tDict = jLoads(res.text)
16109:     if tDict:
16110:      chList = tDict["js"]['data']
16111:      for item in chList:
16112:       Id    = FFYjVd(item, "id"    )
16113:       actors   = FFYjVd(item, "actors"   )
16114:       added   = FFYjVd(item, "added"   )
16115:       age    = FFYjVd(item, "age"    )
16116:       category_id  = FFYjVd(item, "category_id"  )
16117:       description  = FFYjVd(item, "description"  )
16118:       director  = FFYjVd(item, "director"   )
16119:       genres_str  = FFYjVd(item, "genres_str"  )
16120:       name   = FFYjVd(item, "name"    )
16121:       path   = FFYjVd(item, "path"    )
16122:       screenshot_uri = FFYjVd(item, "screenshot_uri" )
16123:       series   = FFYjVd(item, "series"   )
16124:       cmd    = FFYjVd(item, "cmd"    )
16125:       cmd    = cmd.replace("ffmpeg ", "")
16126:       for episode in eval(series):
16127:        list.append((VVetid, name, str(episode), category_id, Id, added, age, cmd, director, genres_str, actors, description, screenshot_uri, path))
16128:    except:
16129:     pass
16130:   if list:
16131:    list.sort(key=lambda x: (x[1], int(x[2])))
16132:    VVwltY, VVkxBG, VVemyB, VVJKqd = CCkEI5.VVxV5D("")
16133:    VVCOpO = (""     , BF(self.VVFT0S, mode, True)  , [])
16134:    VVu1YM  = ("Play"    , BF(self.VVzqdS, mode)       , [])
16135:    VV2ytr = (""     , BF(self.VVzUBN, mode)     , [])
16136:    VVwWmA = ("Home Menu"   , FF8lJ1            , [])
16137:    VVwSzI = ("Download Options" , BF(self.VVnHDd, mode, "sp", VVetid) , [])
16138:    VVScQz = ("Options"   , BF(self.VVCbC2, "pEp", mode, VVetid) , [])
16139:    VV4QTJ = ("Posters Mode"  , BF(self.VVTdR5, mode, True)      , [])
16140:    header   = ("Name" , "Season" , "Episode" , "catID" , "ID" , "Added" , "Age" , "cmd" , "Director", "Genre" , "Actors" , "Description" , "Screenshot" , "Path")
16141:    widths   = (65  , 20  , 15  , 0   , 0   , 0.01 , 0.01 , 0  , 0.01  , 0.01  , 0   , 0    , 0    , 0  )
16142:    VVLIqP  = (LEFT  , LEFT  , CENTER , LEFT  , LEFT  , LEFT , LEFT , LEFT , LEFT  , LEFT  , LEFT  , LEFT   , LEFT   , LEFT )
16143:    FFUQ0v(self, None, title=VVetid, width=1200, header=header, VVGape=list, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVCOpO=VVCOpO, VVu1YM=VVu1YM, VV2ytr=VV2ytr, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVSLOq=CFG.lastFindIptv, VVwltY=VVwltY, VVkxBG=VVkxBG, VVemyB=VVemyB, VVJKqd=VVJKqd)
16144:   else:
16145:    FFdw58(self, "Could not get Episodes from server!", title=VVetid)
16146:  def VVa107(self, mode, searchInCat, VV6A99, title, txt, colList):
16147:   searchCatId = colList[1].strip() if searchInCat else ""
16148:   VV3wat = []
16149:   VV3wat.append(("Keyboard"  , "manualEntry"))
16150:   VV3wat.append(("From Filter" , "fromFilter"))
16151:   FFLFTC(self, BF(self.VVCmc8, VV6A99, mode, searchCatId), title="Input Type", VV3wat=VV3wat, width=400)
16152:  def VVCmc8(self, VV6A99, mode, searchCatId, item=None):
16153:   if item == "manualEntry":
16154:    FF4z45(self, BF(self.VVyUAG, VV6A99, mode, searchCatId), defaultText=CFG.lastFindIptv.getValue(), title="Find", message="Enter Name (or names separated by a comma)")
16155:   elif item == "fromFilter":
16156:    filterObj = CCoErY(self)
16157:    filterObj.VVVPGN(BF(self.VVyUAG, VV6A99, mode, searchCatId))
16158:  def VVyUAG(self, VV6A99, mode, searchCatId, item):
16159:   if not item is None:
16160:    searVV1wIO = item.strip()
16161:    FFjt1c(CFG.lastFindIptv, searVV1wIO)
16162:    title = self.VVvwJ7(mode, searVV1wIO)
16163:    if "," in searVV1wIO : FFdw58(self, "Use only one word to search in Portal Servers !\n\nRemove the comma.", title=title)
16164:    elif len(searVV1wIO) < 3: FFdw58(self, "Enter at least 3 characters.", title=title)
16165:    else     :
16166:     if CFG.hideIptvServerAdultWords.getValue() and self.VVZI1i([searVV1wIO]):
16167:      FFdw58(self, self.VVmBMi(), title=title)
16168:     else:
16169:      self.VVQqfr(mode, searVV1wIO, "", searVV1wIO, searchCatId)
16170:  def VVDIxp(self, mode, VV6A99, title, txt, colList):
16171:   bName = colList[0].strip()
16172:   catID = colList[1].strip()
16173:   self.curPortalCatId = catID
16174:   self.VVQqfr(mode, bName, catID, "", "")
16175:  def VVQqfr(self, mode, bName, catID, searVV1wIO, searchCatId):
16176:   CCh3tv.VV7Nf4(self, VVLL7M="Reading from server"
16177:       , VVixvy  = BF(self.VVxrxQ, mode, bName, catID, searVV1wIO, searchCatId)
16178:       , VVbYwR = BF(self.VV9ldE, mode, bName, catID, searVV1wIO, searchCatId))
16179:  def VV9ldE(self, mode, bName, catID, searVV1wIO, searchCatId, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
16180:   if searVV1wIO : title = self.VVvwJ7(mode, searVV1wIO)
16181:   else   : title = "%s : %s" % (self.VVdGiv(mode), bName)
16182:   if VVNc18:
16183:    VVwSzI = None
16184:    VVScQz = None
16185:    if mode == "series":
16186:     VVwltY, VVkxBG, VVemyB, VVJKqd = self.VVxV5D("series2")
16187:     VVu1YM  = ("Episodes"   , BF(self.VVuCrJ, mode)           , [])
16188:    else:
16189:     VVwltY, VVkxBG, VVemyB, VVJKqd = self.VVxV5D("")
16190:     VVu1YM  = ("Play"    , BF(self.VVzqdS, mode)           , [])
16191:     VVwSzI = ("Download Options" , BF(self.VVnHDd, mode, "vp" if mode == "vod" else "", "") , [])
16192:     VVScQz = ("Options"   , BF(self.VVCbC2, "pCh", mode, bName)      , [])
16193:    VVCOpO = (""      , BF(self.VVFT0S, mode, False)      , [])
16194:    VV2ytr = (""      , BF(self.VVbf1q, mode)         , [])
16195:    VVwWmA = ("Home Menu"    , FF8lJ1                , [])
16196:    VV4QTJ = ("Posters Mode"   , BF(self.VVTdR5, mode, False)         , [])
16197:    header   = ("Num" , "Name", "catID", "genreID" , "Icon", "cmd" , "Cat./Genre" , "Logo", "play", "actors" , "descr" , "director", "Catch-up")
16198:    widths   = (9  , 50  , 0   , 0     , 0  , 0  , 25   , 6  , 0  , 0   , 0   , 0   , 10  )
16199:    VVLIqP  = (CENTER, LEFT  , CENTER , CENTER  , LEFT , LEFT , LEFT   , CENTER, LEFT , LEFT  , LEFT  , LEFT  , CENTER )
16200:    VV6A99 = FFUQ0v(self, None, title=title, header=header, VVGape=VVNc18, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVSLOq=CFG.lastFindIptv, VVu1YM=VVu1YM, VVCOpO=VVCOpO, VV2ytr=VV2ytr, VVwltY=VVwltY, VVkxBG=VVkxBG, VVemyB=VVemyB, VVJKqd=VVJKqd, VVHPI7=True, VVMfsO=1)
16201:    if not VVRI6P:
16202:     if not threadCounter == threadTotal:
16203:      tot = " (Stopped at %d of %d) " % (threadCounter, threadTotal)
16204:      VV6A99.VV0ZtI(VV6A99.VVpVUj() + tot)
16205:     if threadErr: FF28n1(VV6A99, "Error while reading !", 2000)
16206:     else  : FF28n1(VV6A99, "Stopped at channel %s" % threadCounter, 1000)
16207:   else:
16208:    if searVV1wIO : FFdw58(self, "Could not find names with:\n\n%s" % searVV1wIO, title=title)
16209:    else   : FFdw58(self, "Could not get list from server !", title=title)
16210:  def VVbf1q(self, mode, VV6A99, title, txt, colList):
16211:   ttl = lambda x, y: "%s:\n%s\n\n" % (FFjt5L(x, VVFuwR), str(y)) if y.strip() and not "N/A" in y else ""
16212:   tab = lambda x, y: "%s\t: %s\n" % (x, y) if y.strip() and not "N/A" in y else ""
16213:   Num, Name, catID, genreID, Icon, cmd, Cat_Genre, Logo, play, actors, descr, director, arch = colList
16214:   txt  = tab("Number"  , Num)
16215:   txt += tab("Name"  , Name)
16216:   txt += tab("Category" , self.VVLp7F.get(genreID, ""))
16217:   txt += tab("Cat./Genre" , Cat_Genre)
16218:   txt += tab("Director" , director)
16219:   txt += "\n"
16220:   txt += ttl("Actors"  , actors)
16221:   txt += ttl("Description", descr)
16222:   play = play.strip()
16223:   if play and not play.startswith("[No "):
16224:    txt += ttl("Cur. Playing", play)
16225:   if mode == "series":
16226:    VV1wIO = colList[1]
16227:    VVfbmn = colList[4]
16228:    txt  = "%s\n\n%s" % (title, txt)
16229:    CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVC2DO, params=(VV1wIO, txt, VVfbmn))
16230:   else:
16231:    self.VVbND6(mode, VV6A99, title, txt, colList)
16232:  def VVzUBN(self, mode, VV6A99, title, txt, colList):
16233:   txt += "\n"
16234:   txt += "Actors:\n%s\n\n" % FFjt5L(colList[10], VVA4XU)
16235:   txt += "Description:\n%s" % FFjt5L(colList[11], VVA4XU)
16236:   self.VVbND6(mode, VV6A99, title, txt, colList)
16237:  def VVbND6(self, mode, VV6A99, title, txt, colList):
16238:   VV1wIO, catID, stID, chNum, chCm, serCode, serId, VVfbmn = self.VVcP3g(mode, colList)
16239:   VVPxk5, chUrl = self.VVfi1S(self.VVncdQ, self.VVvRlC, mode, VV1wIO, catID, stID, chNum, chCm, serCode, serId)
16240:   txt = "%s\n\n%s" % (title, txt)
16241:   CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVFka3, params=(VVPxk5, chUrl, VV1wIO, txt, VVfbmn))
16242:  def VVxrxQ(self, mode, bName, catID, searVV1wIO, searchCatId, VVXyP6):
16243:   try:
16244:    token, profile, tErr = self.VVTATM()
16245:    if not token:
16246:     return
16247:    if VVXyP6.isCancelled:
16248:     return
16249:    VVXyP6.VVNc18, total_items, max_page_items, err = self.VVyTNm(mode, catID, 1, 1, searVV1wIO, searchCatId)
16250:    if VVXyP6.isCancelled:
16251:     return
16252:    if VVXyP6.VVNc18 and total_items > -1 and max_page_items > -1:
16253:     VVXyP6.VVq8NF(total_items)
16254:     VVXyP6.VVxtQs(max_page_items, True)
16255:     pages = int(iCeil(float(total_items) / float(max_page_items)))
16256:     total_items = pages
16257:     for i in range(pages - 1):
16258:      if VVXyP6.isCancelled:
16259:       return
16260:      page = i + 2
16261:      counter = (i + 1) * max_page_items + 1
16262:      list, total_items, max_page_items, err = self.VVyTNm(mode, catID, page, counter, searVV1wIO, searchCatId)
16263:      if err:
16264:       VVXyP6.VVlmol()
16265:      if VVXyP6.isCancelled:
16266:       return
16267:      if list:
16268:       VVXyP6.VVNc18 += list
16269:       VVXyP6.VVxtQs(len(list), True)
16270:   except:
16271:    pass
16272:  def VVyTNm(self, mode, catID, page, counter, searVV1wIO, searchCatId):
16273:   list = []
16274:   total_items = max_page_items = -1
16275:   if searVV1wIO : url = self.VVLfbI(mode, searVV1wIO, searchCatId, page)
16276:   else   : url = self.VV7Kcq(mode, catID, page)
16277:   res, err = self.VVnjdQ(url)
16278:   if not err:
16279:    try:
16280:     tDict = jLoads(res.text)
16281:     if tDict:
16282:      item = tDict["js"]
16283:      total_items  = self.VVgyFk(FFYjVd(item, "total_items"  ))
16284:      max_page_items = self.VVgyFk(FFYjVd(item, "max_page_items" ))
16285:      chList = tDict["js"]['data']
16286:      cmdStr = "http://localhost/ch/"
16287:      for item in chList:
16288:       Id    = FFYjVd(item, "id"     )
16289:       name   = FFYjVd(item, "name"     )
16290:       o_name   = FFYjVd(item, "o_name"    )
16291:       category_id  = FFYjVd(item, "category_id"   )
16292:       tv_genre_id  = FFYjVd(item, "tv_genre_id"   )
16293:       number   = FFYjVd(item, "number"    ) or str(counter)
16294:       logo   = FFYjVd(item, "logo"     )
16295:       screenshot_uri = FFYjVd(item, "screenshot_uri"  )
16296:       pic    = FFYjVd(item, "pic"     )
16297:       cmd    = FFYjVd(item, "cmd"     )
16298:       censored  = FFYjVd(item, "censored"    )
16299:       genres_str  = FFYjVd(item, "genres_str"   )
16300:       curPlay   = FFYjVd(item, "cur_playing"   )
16301:       actors   = FFYjVd(item, "actors"    )
16302:       descr   = FFYjVd(item, "description"   )
16303:       director  = FFYjVd(item, "director"    )
16304:       archive   = FFYjVd(item, "archive"    )
16305:       archDur   = FFYjVd(item, "tv_archive_duration" )
16306:       catID   = category_id or tv_genre_id
16307:       arch = "Yes" if archive == "1" else ""
16308:       if archDur:
16309:        if archDur.isdigit():
16310:         tot = int(archDur)
16311:         if tot > 0: arch = "%s hour%s" % (tot, FFcacr(tot))
16312:        else:
16313:         arch = archDur
16314:       name = o_name or name
16315:       if " " in cmd :
16316:        cmd = cmd.split(" ")[1].strip()
16317:       if mode == "itv" and not cmdStr in cmd and not cmd.endswith(".m3u8") and not "ffrt" in cmd:
16318:        if ("token=" in cmd and "d=Mag" in cmd) or "AuthToken=" in cmd or "play_token=" in cmd:
16319:         cmd = "Zz1" + FFiPNn(cmd)
16320:        else:
16321:         span = iSearch(r"stream=(.+)&", cmd)
16322:         if span:
16323:          cmd = "%s%s_" % (cmdStr, span.group(1))
16324:         else:
16325:          span = iSearch(r".+\/.+\/.+\/(.+)", cmd)
16326:          if span:
16327:           cmd = "%s%s_" % (cmdStr, span.group(1))
16328:       if   logo.startswith("http")   : picon = logo
16329:       elif pic.startswith("http")    : picon = pic
16330:       elif screenshot_uri.startswith("http") : picon = screenshot_uri
16331:       else         : picon = logo or screenshot_uri or pic
16332:       sp = "/stalker_portal"
16333:       if picon.startswith(sp):
16334:        picon = (self.VVncdQ + picon).replace(sp * 2, sp)
16335:       isIcon = "Yes" if picon.startswith("http") else ""
16336:       counter += 1
16337:       name = self.VVcBrZ(name, censored=censored)
16338:       if name:
16339:        list.append((number, name, Id, catID, picon, cmd, genres_str, isIcon, curPlay, actors, descr, director, arch))
16340:    except:
16341:     err = "Channel Parse Error !"
16342:   return list, total_items, max_page_items, err
16343:  def VVgyFk(self, valStr):
16344:   try:
16345:    return int(valStr)
16346:   except:
16347:    return -1
16348:  def VVzqdS(self, mode, VV6A99, title, txt, colList):
16349:   VV1wIO, catID, stID, chNum, chCm, serCode, serId, VVfbmn = self.VVcP3g(mode, colList)
16350:   VVPxk5, chUrl = self.VVfi1S(self.VVncdQ, self.VVvRlC, mode, VV1wIO, catID, stID, chNum, chCm, serCode, serId)
16351:   if self.VVAP76(VV1wIO):
16352:    FF28n1(VV6A99, "This is a marker!", 300)
16353:   else:
16354:    chUrl = CCwhE4.VVtjAF(self, chUrl)
16355:    VVAfO9 = os.path.join(self.VVYrUH(mode), os.path.basename(VVfbmn)) if VVfbmn else ""
16356:    CCqWM2.VVHc02(self.session, VVwqHQ=(self, VV6A99, mode), VVaHNe=chUrl, VVAfO9=VVAfO9)
16357:  def VVsQmE(self, mode, VV6A99, colList):
16358:   VV1wIO, catID, stID, chNum, chCm, serCode, serId, VVfbmn = self.VVcP3g(mode, colList)
16359:   VVPxk5, chUrl = self.VVfi1S(self.VVncdQ, self.VVvRlC, mode, VV1wIO, catID, stID, chNum, chCm, serCode, serId)
16360:   VVAfO9 = os.path.join(self.VVYrUH(mode), os.path.basename(VVfbmn)) if VVfbmn else ""
16361:   return VV1wIO, chUrl, VVAfO9
16362:  def VVcP3g(self, mode, colList):
16363:   if mode == "series":
16364:    VV1wIO = colList[0]
16365:    season = colList[1]
16366:    serCode = colList[2]
16367:    catID = colList[3]
16368:    serId = colList[4]
16369:    chCm = colList[7]
16370:    VVfbmn = colList[12]
16371:    VV1wIO = "%s (%s - %s)" % (VV1wIO, season, serCode)
16372:    chNum = serCode
16373:    stID = serId.replace(":", "_")
16374:   else:
16375:    chNum = colList[0]
16376:    VV1wIO = colList[1]
16377:    stID = colList[2]
16378:    catID = colList[3]
16379:    VVfbmn = colList[4]
16380:    chCm = colList[5]
16381:    serCode = ""
16382:    serId = ""
16383:   return VV1wIO.strip(), catID.strip(), stID.strip(), chNum.strip(), chCm.strip(), serCode.strip(), serId.strip(), VVfbmn.strip()
16384:  @staticmethod
16385:  def VVOJRa(SELF, install=True, cbFnc=None):
16386:   try:
16387:    import requests
16388:    return True
16389:   except:
16390:    if install:
16391:     title = 'Install "Requests"'
16392:     VV3wat = []
16393:     VV3wat.append((title        , "inst" ))
16394:     VV3wat.append(("Update Packages then %s" % title , "updInst" ))
16395:     FFLFTC(SELF, BF(CCwhE4.VVWBq0, SELF, cbFnc=cbFnc), title='This requires Python "Requests" library', VV3wat=VV3wat)
16396:    return False
16397:  @staticmethod
16398:  def VVWBq0(SELF, item=None, cbFnc=None):
16399:   if item:
16400:    cmdUpd = FFoY7E(VVaNvq)
16401:    if cmdUpd:
16402:     cmdInst = FF5sZa(VVwFAi, "python-requests")
16403:     if pyVersion[0] >= 3:
16404:      cmdInst = cmdInst.replace("python-", "python3-")
16405:     if   item == "inst"  : cmd = cmdInst
16406:     elif item == "updInst" : cmd = cmdUpd + " && " + cmdInst
16407:     FFbi5l(SELF, cmd, VV62hm=True, title='Installing "Requests" Library', VVoasw=cbFnc)
16408:    else:
16409:     FFfone(SELF)
16410:  def VVkX5P(self):
16411:   valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = self.VVGNGo(CC3rDi(self.session).VVZcRP)
16412:   return mode, host, catID, stID, epNum.replace("%3a", ":"), epId.replace("%3a", ":")
16413:  def VVANDc(self, VV7tND):
16414:   curMode, curHost, curCat, curStID, curEpNum, curEpId = self.VVkX5P()
16415:   if all((curMode, curHost, curCat)) and curHost == self.VVncdQ:
16416:    VV7tND.VVx2yy({"itv": 0, "vod": 1, "series": 2}.get(curMode, 0))
16417:  def VVqVx2(self, mode, VV6A99, title, txt, colList):
16418:   curMode, curHost, curCat, curStID, curEpNum, curEpId = self.VVkX5P()
16419:   if all((curMode, curHost, curCat)) and curMode == mode and curHost == self.VVncdQ:
16420:    VV6A99.VVPkdw({1:curCat})
16421:  def VVFT0S(self, mode, isEp, VV6A99, title, txt, colList):
16422:   curMode, curHost, curCat, curStID, curEpNum, curEpId = self.VVkX5P()
16423:   if all((curMode, curHost, curCat)) and curCat == self.curPortalCatId and curMode == mode and curHost == self.VVncdQ:
16424:    if mode in ("itv", "vod"):
16425:     VV6A99.VVPkdw({2:curStID})
16426:    else:
16427:     if isEp:
16428:      VV6A99.VVPkdw({2:curEpNum, 4:curEpId})
16429:     elif mode == "series":
16430:      ser1 = curEpId.split(":")[0]
16431:      ser2 = "%s:%s" % (ser1, ser1)
16432:      ok = VV6A99.VVPkdw({2:ser2})
16433:      if not ok: VV6A99.VVPkdw({2:ser1})
16434:  @staticmethod
16435:  def VVFP1K(VVZcRP):
16436:   span = iSearch(r"(mode=.+)&chCm=.+&end=:(.+)", VVZcRP, IGNORECASE)
16437:   if span : return span.group(1), span.group(2)
16438:   else : return "", ""
16439:  @staticmethod
16440:  def VVtjAF(SELF, chUrl):
16441:   VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(SELF)
16442:   phpPart1, VV1wIO1 = CCwhE4.VVFP1K(VVZcRP)
16443:   phpPart2, VV1wIO2 = CCwhE4.VVFP1K(FFXarh(chUrl))
16444:   return None if phpPart1 and (phpPart1, VV1wIO1) == (phpPart2, VV1wIO2) else chUrl
16445: class CCkEI5(Screen, CCwhE4, CCa36K, CCwnHL):
16446:  VVwTwt    = 0
16447:  VVH6Pi    = 1
16448:  VVvCuq    = 2
16449:  VV17gf    = 3
16450:  VVqJ6d     = 4
16451:  VVa4UD     = 5
16452:  VVYSwZ     = 6
16453:  VVdQtp     = 7
16454:  VV5dgQ     = 8
16455:  VVKkG6     = 9
16456:  VVL3RT      = 10
16457:  VVQVpf     = 11
16458:  VV08wu     = 12
16459:  VVvTCX     = 13
16460:  VVMDMz     = 14
16461:  VV1MxY      = 15
16462:  VVQaZg      = 16
16463:  VVCz9o      = 17
16464:  VV5aRM      = 18
16465:  VVDxcx      = 19
16466:  VVJbaD    = 0
16467:  VVgkvV   = 1
16468:  VVgL8R   = 2
16469:  VV6cbr   = 3
16470:  VVspif  = 4
16471:  VVhkSg  = 5
16472:  VVXewY   = 6
16473:  VVw3vg   = 7
16474:  VVtP50  = 8
16475:  VV4kmD  = 9
16476:  VVZUri  = 10
16477:  def __init__(self, session):
16478:   self.skin, self.VVfOli = FFiNEe(VVWp3I, 970, 1050, 50, 40, 30, "
16479:   self.session     = session
16480:   self.VV6A99    = None
16481:   self.VVXTPg     = "Local IPTV Services"
16482:   self.VVfymn    = {}
16483:   self.VVV9Jd = False
16484:   self.VVvnTo   = CCkEI5.VVjMS6(atLeastOne=True)
16485:   self.VVpQCY    = True
16486:   self.VV2rlK      = ""
16487:   self.VVBk7J    = None
16488:   self.VVLp7F     = {}
16489:   CCwhE4.__init__(self)
16490:   CCa36K.__init__(self)
16491:   VV3wat = self.VVLywV()
16492:   FFZMxC(self, title="IPTV", VV3wat=VV3wat)
16493:   FFBep1(self, {"menu" : self.VV7Oxs})
16494:   self.onShown.append(self.VV7OzD)
16495:   self.onClose.append(self.onExit)
16496:   self["myMenu"].onSelectionChanged.append(self.VV0wwP)
16497:   global VVyXy5
16498:   VVyXy5 = True
16499:  def VV7OzD(self):
16500:   self["myMenu"].setList(self.VVLywV())
16501:   FF2GM8(self)
16502:   FF6W0I(self)
16503:   if self.VVpQCY:
16504:    self.VVpQCY = False
16505:    FF4IPF(self["myMenu"])
16506:    self.VVctp3()
16507:    FFf6kX()
16508:  def VVctp3(self):
16509:   qUrl, VVZcRP, VVfaDB = CCkEI5.VVs0fr(self)
16510:   if qUrl or "chCode" in VVfaDB:
16511:    for ndx, item in enumerate(self["myMenu"].list):
16512:     if item[0] == "IPTV Server Browser (from Current Channel)" and len(item) > 1:
16513:      self["myMenu"].moveToIndex(ndx)
16514:      break
16515:  def onExit(self):
16516:   self["myMenu"].onSelectionChanged = []
16517:   FFYDZ6("VVyXy5")
16518:  def VV0wwP(self):
16519:   if self["myMenu"].getCurrent()[1] in ("VVgmdJ", "VVmoT7Portal") : self["keyMenu"].show()
16520:   else                      : self["keyMenu"].hide()
16521:  def VV7Oxs(self):
16522:   if self["myMenu"].getVisible():
16523:    title, item = self["myMenu"].getCurrent()
16524:    if   item == "VVgmdJ" : confItem = CFG.favServerPlaylist
16525:    elif item == "VVmoT7Portal" : confItem = CFG.favServerPortal
16526:    else         : return
16527:    url = confItem.getValue().strip().split()[0]
16528:    title += (" : %s" % FFjt5L(CCkEI5.VVRLKG(url)[1], VVyFI2)) if url else ""
16529:    FFRMYv(self, BF(self.VVJNv0, confItem), "Remove from menu ?", title=title)
16530:  def VVJNv0(self, confItem):
16531:   FFjt1c(confItem, "")
16532:   self.VV7OzD()
16533:  def VVLywV(self):
16534:   fav1, fav2 = CFG.favServerPlaylist.getValue(), CFG.favServerPortal.getValue()
16535:   c1 = VVIH76
16536:   VV3wat = []
16537:   if fav1: VV3wat.append((c1 +  "Favourite Playlist Server"    , "VVgmdJ" ))
16538:   if fav2: VV3wat.append((c1 +  "Favourite Portal Server"    , "VVmoT7Portal" ))
16539:   VV3wat.append(("IPTV Server Browser (from Playlists)"     , "VVrIJU_fromPlayList" ))
16540:   VV3wat.append(("IPTV Server Browser (from Portal List)"    , "VVrIJU_fromMac"  ))
16541:   qUrl, VVZcRP, VVfaDB = CCkEI5.VVs0fr(self)
16542:   fromCurCond = qUrl or "chCode" in VVfaDB
16543:   VV3wat.append(FFsLU5("IPTV Server Browser (from Current Channel)", "VVrIJU_fromCurrChan", fromCurCond))
16544:   VV3wat.append(VVAL3j)
16545:   VV3wat.append(("Local Servers & M3U Cache"       , "browser_localServ"  ))
16546:   VV3wat.append(("M3U/M3U8 File Browser"        , "VV9w3Z"   ))
16547:   if self.VVvnTo:
16548:    VV3wat.append(("IPTV Services (from Local Bouquets)"    , "iptvTable_all"   ))
16549:   VV3wat.append(VVAL3j)
16550:   VV3wat.append(FFsLU5("Update Current Bouquet EPG/PIcons (from IPTV Server)", "VVFT2F", fromCurCond))
16551:   if self.VVvnTo:
16552:    VV3wat.append(VVAL3j)
16553:    c1, c2 = VVZtfx, VVFuwR
16554:    t1 = FFjt5L("auto-match names", VVIH76)
16555:    t2 = FFjt5L("from xml file"  , VVIH76)
16556:    VV3wat.append((c1 + "Count Available IPTV Channels"    , "VVXKGz"    ))
16557:    VV3wat.append((c1 + "Copy EPG/PIcons between Channels (%s)" % t2 , "copyEpgPicons"   ))
16558:    VV3wat.append(VVAL3j)
16559:    VV3wat.append((c2 + "Share Reference with DVB Channels (%s)" % t2 , "renumIptvRef_fromFile" ))
16560:    VV3wat.append((c2 + "Share Reference with DVB Channels (%s)" % t1 , "VVkIRr" ))
16561:    VV3wat.append((VVyFI2 + "More Reference Tools ..."  , "VVDcKO"   ))
16562:   VV3wat.append(VVAL3j)
16563:   VV3wat.append(("Reload Channels and Bouquets"       , "VV8d5Y"   ))
16564:   VV3wat.append(VVAL3j)
16565:   if not CCHRcZ.VVAbZK():
16566:    VV3wat.append(("Download Manager"         , "dload_stat"    ))
16567:   else:
16568:    VV3wat.append(("Download Manager ... No downloads"    ,       ))
16569:   return VV3wat
16570:  def VVeDfm(self, item):
16571:   self.VV2rlK = ""
16572:   tTitle = "Share Reference with DVB Service"
16573:   if item is not None:
16574:    if   item == "VVPgSR"   : self.VVPgSR()
16575:    elif item == "VVL3AS" : self.VVL3AS()
16576:    elif item == "VVWnDr" : FFRMYv(self, self.VVWnDr, "Change Current List References to Unique Codes ?")
16577:    elif item == "VVthI4_rows" : FFRMYv(self, BF(FFimQ3, self.VV6A99, self.VVthI4), "Change Current List References to Identical Codes ?")
16578:    elif item == "VVdBzQ"   : self.VVdBzQ(tTitle)
16579:    elif item == "VVOPJS"   : self.VVOPJS(tTitle)
16580:    elif item == "VVgmdJ" : self.VVmoT7(False)
16581:    elif item == "VVmoT7Portal" : self.VVmoT7(True)
16582:    elif item == "VVrIJU_fromPlayList" : self.VV0muG(1)
16583:    elif item == "VVrIJU_fromMac"  : self.VV0z9x()
16584:    elif item == "VVrIJU_fromCurrChan" : self.VVsUXV()
16585:    elif item == "browser_localServ"  : CCjZbZ(self, CCjZbZ.VVbu5l)
16586:    elif item == "VV9w3Z"   : self.VV9w3Z()
16587:    elif item == "iptvTable_all"   : self.VVr1GE(self.VVwTwt)
16588:    elif item == "VVFT2F" : CCkEI5.VVFT2F(self)
16589:    elif item == "VVXKGz"    : self.VVXKGz()
16590:    elif item == "copyEpgPicons"   : self.VVNXsZ(False)
16591:    elif item == "renumIptvRef_fromFile" : self.VVNXsZ(True)
16592:    elif item == "VVkIRr" : FFRMYv(self, self.VVkIRr, VVsWSA="Continue ?")
16593:    elif item == "VVDcKO"    : self.VVDcKO()
16594:    elif item == "VV8d5Y"   : CCYrUm.VV8d5Y(self)
16595:    elif item == "dload_stat"    : CCHRcZ.VVSZMa(self)
16596:  def VVPr1F(self):
16597:   item = FFTmHZ(self)
16598:   self.VVeDfm(item)
16599:  @FFOAKH("Loading Channels ...")
16600:  def VVr1GE(self, mode):
16601:   VVAkuK = self.VVoN6g(mode)
16602:   if VVAkuK:
16603:    bg = "#1b001121"
16604:    VVwSzI = ("Current Service", self.VVEzbx , [])
16605:    VVScQz = ("Options"  , self.VV6N3C   , [])
16606:    VV4QTJ = ("Filter"   , self.VVI81R   , [])
16607:    VVu1YM  = ("Play"   , BF(self.VVG1o1)  , [])
16608:    VV2ytr = (""    , self.VVen0D    , [])
16609:    VVCOpO = (""    , self.VVMBc4     , [])
16610:    header   = ("Num" , "Name", "Bouquet" , "Type", "Ref.", "URL" )
16611:    widths   = (8  , 30 , 30  , 6  , 26 , 0  )
16612:    VVLIqP  = (CENTER , LEFT , LEFT  , CENTER, LEFT , LEFT )
16613:    FFUQ0v(self, None, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, width=1750, height=1000, VVwdmN=25
16614:      , VVu1YM=VVu1YM, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VV2ytr=VV2ytr, VVCOpO=VVCOpO
16615:      , VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#11004a55", VVHPI7=True, VVMfsO=1)
16616:   else:
16617:    if mode == self.VVKkG6: err = "No Live IPTV channels !"
16618:    else       : err = "No IPTV channels !"
16619:    FFdw58(self, err)
16620:  def VVMBc4(self, VV6A99, title, txt, colList):
16621:   self.VV6A99 = VV6A99
16622:  def VV6N3C(self, VV6A99, title, txt, colList):
16623:   VV3wat = []
16624:   VV3wat.append(("Add Current List to a New Bouquet"     , "VVPgSR"  ))
16625:   VV3wat.append(VVAL3j)
16626:   VV3wat.append(FFsLU5("Delete Current List (from all Bouquets)" , "VVL3AS" , VV6A99.VVpVUj().startswith("Filter:"), VVz22H))
16627:   VV3wat.append(VVAL3j)
16628:   VV3wat.append(("Change Current List References to Unique Codes" , "VVWnDr"))
16629:   VV3wat.append(("Change Current List References to Identical Codes", "VVthI4_rows" ))
16630:   VV3wat.append(VVAL3j)
16631:   VV3wat.append(("Share Reference with DVB Service (manual entry)" , "VVdBzQ"   ))
16632:   VV3wat.append(("Share Reference with DVB Service (auto-find)"  , "VVOPJS"   ))
16633:   FFLFTC(self, self.VVeDfm, title="IPTV Tools", VV3wat=VV3wat)
16634:  @FFOAKH(par=1)
16635:  def VVI81R(self, VV6A99, title, txt, colList):
16636:   VV3wat = []
16637:   VV3wat.append(("All"         , "all"   ))
16638:   VV3wat.append(VVAL3j)
16639:   VV3wat.append(("Prefix of Selected Channel"   , "sameName" ))
16640:   VV3wat.append(("Suggest Words from Selected Channel" , "partName" ))
16641:   VV3wat.append(("Names with Non-English Characters" , "nonEnglish" ))
16642:   VV3wat.append(("Duplicate References"     , "depRef"  ))
16643:   VV3wat.append(("Reference x:x:x:x:0:0:0:0:0:0:"  , "ref00"  ))
16644:   VV3wat.append(("Stream Relay"       , "SRelay"  ))
16645:   VV3wat.append(FF0bQE("Category"))
16646:   VV3wat.append(("Live"         , "live"  ))
16647:   VV3wat.append(("VOD"         , "vod"   ))
16648:   VV3wat.append(("Series"        , "series"  ))
16649:   VV3wat.append(("Uncategorized"      , "uncat"  ))
16650:   VV3wat.append(FF0bQE("Media"))
16651:   VV3wat.append(("Video"        , "video"  ))
16652:   VV3wat.append(("Audio"        , "audio"  ))
16653:   VV3wat.append(FF0bQE("File Type"))
16654:   VV3wat.append(("MKV"         , "MKV"   ))
16655:   VV3wat.append(("MP4"         , "MP4"   ))
16656:   VV3wat.append(("MP3"         , "MP3"   ))
16657:   VV3wat.append(("AVI"         , "AVI"   ))
16658:   VV3wat.append(("FLV"         , "FLV"   ))
16659:   VV3wat.extend(CCMvE7.VVlHzq(prefix="__b__", onlyIptv=True))
16660:   inFilterFnc = BF(self.VVMQBC, VV6A99) if VV6A99.VVpVUj().startswith("Filter:") else None
16661:   filterObj = CCoErY(self)
16662:   filterObj.VVywN2(VV3wat, VV3wat, BF(self.VVPKOr, VV6A99, False), inFilterFnc=inFilterFnc)
16663:  def VVMQBC(self, VV6A99, VV7tND, item):
16664:   self.VVPKOr(VV6A99, True, item)
16665:  def VVPKOr(self, VV6A99, inFilter, item=None):
16666:   self.VVV9Jd = inFilter
16667:   prefix = VV6A99.VVeE40(1).split(" ")[0]
16668:   if item is not None:
16669:    if   item == "all"    : mode, words, title = self.VVwTwt , ""  , self.VVXTPg
16670:    elif item == "sameName"   : mode, words, title = self.VVH6Pi , prefix , prefix + " ..."
16671:    elif item == "partName"   : mode, words, title = self.VVvCuq , ""  , ""
16672:    elif item == "nonEnglish"  : mode, words, title = self.VV17gf , ""  , "Names with Non-English Characters"
16673:    elif item == "depRef"   : mode, words, title = self.VVYSwZ  , ""  , "Duplicate References"
16674:    elif item == "ref00"   : mode, words, title = self.VVdQtp  , ""  , "Reference x:x:x:x:0:0:0:0:0:0:"
16675:    elif item == "SRelay"   : mode, words, title = self.VV5dgQ  , ""  , "Stream Relay"
16676:    elif item == "live"    : mode, words, title = self.VVKkG6  , ""  , "Live"
16677:    elif item == "vod"    : mode, words, title = self.VVL3RT   , ""  , "VOD"
16678:    elif item == "series"   : mode, words, title = self.VVQVpf  , ""  , "Series"
16679:    elif item == "uncat"   : mode, words, title = self.VV08wu  , ""  , "Uncategorized"
16680:    elif item == "video"   : mode, words, title = self.VVvTCX  , ""  , "Video"
16681:    elif item == "audio"   : mode, words, title = self.VVMDMz  , ""  , "Audio"
16682:    elif item == "MKV"    : mode, words, title = self.VV1MxY   , ""  , "MKV"
16683:    elif item == "MP4"    : mode, words, title = self.VVQaZg   , ""  , "MP4"
16684:    elif item == "MP3"    : mode, words, title = self.VVCz9o   , ""  , "MP3"
16685:    elif item == "AVI"    : mode, words, title = self.VV5aRM   , ""  , "AVI"
16686:    elif item == "FLV"    : mode, words, title = self.VVDxcx   , ""  , "FLV"
16687:    elif item.startswith("__b__") : mode, words, title = self.VVqJ6d  , item[5:] , item[5:]
16688:    elif item.startswith("__w__") : mode, words, title = self.VVa4UD  , item[5:] , item[5:]
16689:    else       : return
16690:   if mode != self.VVwTwt:
16691:    tTitle = "Filter: "
16692:    if mode == self.VVqJ6d:
16693:     tTitle += " Bouquet = "
16694:    title = tTitle + FFjt5L(title, VVJEMb)
16695:   if len(title) > 85:
16696:    title = title[:85] + ".."
16697:   if mode == self.VVvCuq:
16698:    VV3wat = []
16699:    VV1wIO = VV6A99.VVeE40(1)
16700:    if VV1wIO:
16701:     list = set()
16702:     for match in iFinditer(r"((?:[^\x00-\x7F]+\s*)+)", VV1wIO, IGNORECASE):
16703:      list.add(match.group(1).strip())
16704:     if list:
16705:      for match in iFinditer(r"(\w+)", VV1wIO, IGNORECASE):
16706:       list.add(match.group(1).strip())
16707:     words = VV1wIO.split(" ")
16708:     tWord = ""
16709:     for word in words:
16710:      tWord += " " + word
16711:      list.add(word.strip())
16712:      list.add(tWord.strip())
16713:     for item in sorted(list):
16714:      if item:
16715:       VV3wat.append((item, item))
16716:     if not VV3wat and VV1wIO:
16717:      VV3wat.append((VV1wIO, VV1wIO))
16718:     FFLFTC(self, self.VVF5KS, VV3wat=VV3wat)
16719:    else:
16720:     VV6A99.VV6fGE("Invalid Channel Name")
16721:   else:
16722:    words, asPrefix = CCoErY.VVPBNm(words)
16723:    if not words and mode in (self.VVqJ6d, self.VVa4UD):
16724:     FF28n1(self.VV6A99, "Incorrect filter", 2000)
16725:    else:
16726:     self.VVBk7J = BF(FFimQ3, self.VV6A99, BF(self.VVKAPw, mode, words, asPrefix, title), clearMsg=False, title="Filtering ...")
16727:     self.VVBk7J()
16728:  def VVF5KS(self, word=None):
16729:   if word:
16730:    title = "Filter: %s" % FFjt5L(word, VVJEMb)
16731:    self.VVBk7J = BF(FFimQ3, self.VV6A99, BF(self.VVKAPw, self.VVvCuq, [word.lower()], False, title), clearMsg=False, title="Filtering ...")
16732:    self.VVBk7J()
16733:  @staticmethod
16734:  def VVBmSe(txt):
16735:   return "#f#11ffff00#" + txt
16736:  def VVKAPw(self, mode, words, asPrefix, title):
16737:   if self.VVV9Jd : VVAkuK = self.VV1l8Y(mode=mode, words=words, asPrefix=asPrefix)
16738:   else       : VVAkuK = self.VVoN6g(mode=mode, words=words, asPrefix=asPrefix)
16739:   if VVAkuK:
16740:    self.VV6A99.VVMqQ9(VVAkuK, title)
16741:    return True
16742:   else:
16743:    self.VV6A99.VV6fGE("Not found")
16744:    return False
16745:  def VV1l8Y(self, mode=0, words=None, asPrefix=False):
16746:   VVAkuK = []
16747:   for row in self.VV6A99.VVrrm9():
16748:    row = list(map(str.strip, row))
16749:    chNum, VV1wIO, VVY5Mx, chType, VVPxk5, url = row
16750:    if self.VVDWbD(mode, VVPxk5, FFXarh(url).lower(), VV1wIO, words, VVY5Mx.lower(), asPrefix):
16751:     VVAkuK.append(row)
16752:   VVAkuK = self.VVEhJo(mode, VVAkuK)
16753:   return VVAkuK
16754:  def VVoN6g(self, mode=0, words=None, asPrefix=False, isStripChan=False):
16755:   patt = r"
16756:   if isStripChan: patt += r"[^\x00-\x7F]*(.+)[^\x00-\x7F]*"
16757:   else    : patt += r"(.+)"
16758:   VVAkuK = []
16759:   files = CCkEI5.VVjMS6()
16760:   if files:
16761:    chNum = 1
16762:    for path in files:
16763:     if path.endswith("radio"): chType = "Radio"
16764:     else      : chType = "TV"
16765:     txt = FFYVq0(path)
16766:     span = iSearch(r"
16767:     if span : VVY5Mx = span.group(1)
16768:     else : VVY5Mx = ""
16769:     VVY5Mx_lCase = VVY5Mx.lower()
16770:     for match in iFinditer(patt, txt, IGNORECASE):
16771:      VVPxk5 = match.group(1).upper()
16772:      url  = match.group(2).strip()
16773:      VV1wIO = match.group(3).strip()
16774:      if self.VVAP76(VV1wIO): VViido = self.VVBmSe(VV1wIO)
16775:      else        : VViido = VV1wIO
16776:      row = (str(chNum), VViido, VVY5Mx, chType + (" SRel" if FFHgaY(url) else ""), VVPxk5, url)
16777:      if self.VVDWbD(mode, VVPxk5, FFXarh(url).lower(), VV1wIO, words, VVY5Mx_lCase, asPrefix):
16778:       VVAkuK.append(row)
16779:       chNum += 1
16780:   VVAkuK = self.VVEhJo(mode, VVAkuK)
16781:   return VVAkuK
16782:  def VVEhJo(self, mode, VVAkuK):
16783:   newRows = []
16784:   if VVAkuK and mode == self.VVYSwZ:
16785:    counted  = iCounter(elem[4] for elem in VVAkuK)
16786:    for item in VVAkuK:
16787:     tot = counted.get(item[4], 0)
16788:     if tot > 1:
16789:      newRows.append(item)
16790:    return newRows
16791:   else:
16792:    return VVAkuK
16793:  def VVDWbD(self, mode, VVPxk5, tUrl, VV1wIO, words, VVY5Mx_lCase, asPrefix):
16794:   if   mode == self.VVwTwt : return True
16795:   elif mode == self.VVYSwZ : return True
16796:   elif mode == self.VVdQtp  : return ":0:0:0:0:0:0:" in VVPxk5
16797:   elif mode == self.VV5dgQ : return FFHgaY(tUrl)
16798:   elif mode == self.VVvTCX  : return CCkEI5.VVNeuG(tUrl, getAudVid=True) == "vid"
16799:   elif mode == self.VVMDMz  : return CCkEI5.VVNeuG(tUrl, getAudVid=True) == "aud"
16800:   elif mode == self.VVKkG6  : return CCkEI5.VVNeuG(tUrl, compareType="live")
16801:   elif mode == self.VVL3RT  : return CCkEI5.VVNeuG(tUrl, compareType="vod")
16802:   elif mode == self.VVQVpf : return CCkEI5.VVNeuG(tUrl, compareType="series")
16803:   elif mode == self.VV08wu  : return CCkEI5.VVNeuG(tUrl, compareType="")
16804:   elif mode == self.VV1MxY  : return CCkEI5.VVNeuG(tUrl, compareExt="mkv")
16805:   elif mode == self.VVQaZg  : return CCkEI5.VVNeuG(tUrl, compareExt="mp4")
16806:   elif mode == self.VVCz9o  : return CCkEI5.VVNeuG(tUrl, compareExt="mp3")
16807:   elif mode == self.VV5aRM  : return CCkEI5.VVNeuG(tUrl, compareExt="avi")
16808:   elif mode == self.VVDxcx  : return CCkEI5.VVNeuG(tUrl, compareExt="flv")
16809:   elif mode == self.VVH6Pi: return VV1wIO.lower().startswith(words[0])
16810:   elif mode == self.VVvCuq: return words[0] in VV1wIO.lower()
16811:   elif mode == self.VV17gf: return bool(iSearch(r"[^\x00-\x7F]", VV1wIO))
16812:   elif mode == self.VVqJ6d : return words[0] == VVY5Mx_lCase
16813:   elif mode == self.VVa4UD :
16814:    name = VV1wIO.lower()
16815:    for word in words:
16816:     if asPrefix:
16817:      if name.startswith(word) : return True
16818:     elif word in name    : return True
16819:   return False
16820:  def VVPgSR(self):
16821:   picker = CCMvE7(self, self.VV6A99, "Add to Bouquet", self.VVmOKe)
16822:  def VVmOKe(self):
16823:   chUrlLst = []
16824:   for row in self.VV6A99.VVrrm9():
16825:    chUrlLst.append(row[4] + row[5])
16826:   return chUrlLst
16827:  def VVL3AS(self):
16828:   tot = self.VV6A99.VVn1uo()
16829:   FFRMYv(self, self.VV7cGE, "Delete %s IPTV Channel%s ?" % (tot, FFcacr(tot)))
16830:  def VV7cGE(self):
16831:   bFiles = CCkEI5.VVjMS6()
16832:   if not bFiles:
16833:    FF28n1(self.VV6A99, "No bouquets files !", 1500)
16834:    return
16835:   totRows = self.VV6A99.VVn1uo()
16836:   if not totRows:
16837:    FF28n1(self.VV6A99, "Cannot read list", 1500)
16838:    return
16839:   CCh3tv.VV7Nf4(self, VVLL7M="Renumbering References", VVIZBP=CCh3tv.VVgJkc, totBars=2
16840:       , VVixvy  = BF(self.VVp9DE, totRows, bFiles)
16841:       , VVbYwR = self.VVtXN6 )
16842:  def VVp9DE(self, totRows, bFiles, VVXyP6):
16843:   totDel = totBouq = 0
16844:   VVXyP6.VVq8NF(len(bFiles))
16845:   VVXyP6.VVUIH1(totRows)
16846:   VVXyP6.VVNc18 = (totRows, totDel, totBouq)
16847:   for path in bFiles:
16848:    if not VVXyP6 or VVXyP6.isCancelled:
16849:     return
16850:    if FFCyVu(path):
16851:     toSave = False
16852:     txt  = FFYVq0(path)
16853:     span = iSearch(r"
16854:     if span : bName = span.group(1)
16855:     else : bName = os.path.splitext(os.path.basename(path))[0]
16856:     VVXyP6.VVaks5("%s   %s" % (totDel, bName))
16857:     VVXyP6.VVxtQs(1)
16858:     VVXyP6.VVV3RA(0)
16859:     for row in self.VV6A99.VVrrm9():
16860:      if not VVXyP6 or VVXyP6.isCancelled:
16861:       return
16862:      VVXyP6.VVg2Dw(1)
16863:      ref = row[4] + row[5]
16864:      if ref in txt:
16865:       txt, tot = iSubn(r"(
16866:       if tot > 0:
16867:        totDel += tot
16868:        VVXyP6.VVNc18 = (totRows, totDel, totBouq)
16869:        toSave = True
16870:     if toSave:
16871:      totBouq += 1
16872:      VVXyP6.VVNc18 = (totRows, totDel, totBouq)
16873:      with open(path, "w") as f:
16874:       f.write(txt)
16875:  def VVtXN6(self, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
16876:   totRows, totDel, totBouq = VVNc18
16877:   if totBouq:
16878:    FFfpyJ()
16879:    txt  = "Channels\t: %s\n" % totRows
16880:    txt += "Deleted\t: %s   (from %s bouquet%s)" % (totDel, totBouq, FFcacr(totBouq))
16881:    FF4lCP(self, txt, VVbYwR=BF(FFimQ3, self.VV6A99 or self, self.VVZ00Q, clearMsg=False))
16882:   else:
16883:    FFipXT(self, "No changes.")
16884:  def VVZ00Q(self):
16885:   if self.VV6A99:
16886:    if not self.VVBk7J():
16887:     if not self.VVKAPw(self.VVwTwt, "", False, "Local IPTV Services"):
16888:      self.VV6A99.cancel()
16889:  def VVDcKO(self):
16890:   t1 = FFjt5L("Bouquet" , VVFuwR)
16891:   t2 = FFjt5L("ALL"  , VVyFI2)
16892:   t3 = FFjt5L("Unique"  , VVZtfx)
16893:   t4 = FFjt5L("Identical" , VVIH76)
16894:   VV3wat = []
16895:   VV3wat.append((VVJEMb + "Check System Acceptable Reference Types", "VVhMoT"))
16896:   VV3wat.append(FFsLU5("Check Reference Codes Format", "VVWgKX", self.VVvnTo, VVJEMb))
16897:   VV3wat.append(VVAL3j)
16898:   txt = "Change %s Ref. Types to (1/4097/5001/5002/8192/8193/8793) .."
16899:   VV3wat.append((txt % t1, "VVOO3I" ))
16900:   VV3wat.append((txt % t2, "VVcMWv_all"  ))
16901:   VV3wat.append(VVAL3j)
16902:   txt = "Change %s References to %s Codes .."
16903:   VV3wat.append((txt % (t1, t3), "VV5I9P" ))
16904:   VV3wat.append((txt % (t2, t3), "VVFTpS"  ))
16905:   VV3wat.append(VVAL3j)
16906:   VV3wat.append(("Change %s References to %s Codes" % (t2, t4) , "VVthI4_all"))
16907:   VVOa1G = self.VVK6T4
16908:   FFLFTC(self, None, width=1220, title="IPTV Reference Tools", VV3wat=VV3wat, VVOa1G=VVOa1G, VVwltY="#22002233", VVkxBG="#22001122")
16909:  def VVK6T4(self, item=None):
16910:   if item:
16911:    ques = "Continue ?"
16912:    VV7tND, txt, item, ndx = item
16913:    if   item == "VVhMoT"    : FFimQ3(VV7tND, self.VVhMoT)
16914:    elif item == "VVWgKX"     : FFimQ3(VV7tND, self.VVWgKX)
16915:    elif item == "VVOO3I" : self.VVHp9J(VV7tND, self.VVEOTS)
16916:    elif item == "VVcMWv_all"  : self.VVEOTS(VV7tND, None, None)
16917:    elif item == "VV5I9P" : self.VV5I9P(VV7tND, txt)
16918:    elif item == "VVFTpS"  : FFRMYv(self, BF(self.VVFTpS , VV7tND, txt), title=txt, VVsWSA=ques)
16919:    elif item == "VVthI4_all"  : FFRMYv(self, BF(FFimQ3, VV7tND, self.VVthI4), title=txt, VVsWSA=ques)
16920:  def VVEOTS(self, VV7tND, bName, bPath):
16921:   VV3wat = []
16922:   for rt in CCkEI5.VV5LSJ():
16923:    VV3wat.append(("%s\t ... %s" % (rt, CCkEI5.VVDWCB(rt)), rt))
16924:   FFLFTC(self, BF(self.VV9RIk, VV7tND, bName, bPath), VV3wat=VV3wat, width=800, title="Change Reference Types to:")
16925:  def VV9RIk(self, VV7tND, bName, bPath, rType=None):
16926:   if rType:
16927:    self.VVte9c(VV7tND, bName, bPath, rType)
16928:  def VVHp9J(self, VV7tND, fnc):
16929:   VV3wat = CCMvE7.VVlHzq()
16930:   if VV3wat:
16931:    FFLFTC(self, BF(self.VVNL6A, VV7tND, fnc), VV3wat=VV3wat, title="IPTV Bouquets", VVU8mZ=True)
16932:   else:
16933:    FF28n1(VV7tND, "No bouquets Found !", 1500)
16934:  def VVNL6A(self, VV7tND, fnc, item=None):
16935:   if item:
16936:    bName, bRef, ndx = item
16937:    span = iSearch(r'BOUQUET "(.+)" ORDER', bRef, IGNORECASE)
16938:    if span:
16939:     bPath = VVQe79 + span.group(1)
16940:     if FFCyVu(bPath): fnc(VV7tND, bName, bPath)
16941:     else    : FF28n1(VV7tND, "Bouquet file not found!", 2000)
16942:    else:
16943:     FF28n1(VV7tND, "Cannot process bouquet !", 2000)
16944:  def VVte9c(self, VV7tND, bName, bPath, rType):
16945:   if bPath: title = "Change for Bouquet : %s" % FFjt5L(bName, VV1fx4)
16946:   else : title = "Change for %s" % FFjt5L("All IPTV Services", VV1fx4)
16947:   FFRMYv(self, BF(self.VVoQBH, VV7tND, bName, bPath, rType), "Change to : %s ?" % FFjt5L(rType, VV1fx4), title=title)
16948:  @FFOAKH("Changing Type ...", par=1)
16949:  def VVoQBH(self, VV7tND, bName, bPath, rType):
16950:   totChange = 0
16951:   if bPath: files = [bPath]
16952:   else : files = CCkEI5.VVjMS6()
16953:   if files:
16954:    newRType = rType + ":"
16955:    piconPath = CCafIt.VVjkKT()
16956:    for path in files:
16957:     if   not FFCyVu(path)      : err = "Cannot read the file:\n\n%s" % path
16958:     elif not CClYaF.VVSOog(self, path) : err = "File is not in 'UTF-8' Encoding:\n\n%s" % path
16959:     else           : err = ""
16960:     if err:
16961:      FFdw58(self, err)
16962:      return
16963:     newpFile = path + ".tmp"
16964:     totMod = 0
16965:     with open(newpFile, "w") as tFile:
16966:      with ioOpen(path, "r", encoding="utf-8") as f:
16967:       for line in f:
16968:        span = iSearch(r"
16969:        if span:
16970:         oldRType = span.group(1)
16971:         if not oldRType == newRType:
16972:          totMod += 1
16973:          totChange += 1
16974:          span = iSearch(r"((?:[A-Fa-f0-9]+[:]){10})", line)
16975:          if span : oldPicon = piconPath + span.group(1).strip(":").replace(":", "_") + ".png"
16976:          else : oldPicon = ""
16977:          line = iSub(r"(
16978:          if FFCyVu(oldPicon):
16979:           span = iSearch(r"((?:[A-Fa-f0-9]+[:]){10})", line)
16980:           if span:
16981:            FFpwZS("mv -f '%s' '%s'" % (oldPicon, piconPath + span.group(1).strip(":").replace(":", "_") + ".png"))
16982:        tFile.write(line)
16983:     if totMod: cmd = "mv -f '%s' '%s'" % (newpFile, path)
16984:     else  : cmd = "rm -f '%s'" % newpFile
16985:     FFpwZS(cmd)
16986:   self.VVkNdH(totChange > 0, 'Change Ref. Codes to "%s"' % rType, "Changes = %d" % totChange)
16987:  @FFOAKH()
16988:  def VVXKGz(self):
16989:   totFiles = 0
16990:   files  = CCkEI5.VVjMS6()
16991:   if files:
16992:    totFiles = len(files)
16993:   totChans = 0
16994:   VVAkuK = self.VVoN6g()
16995:   if VVAkuK:
16996:    totChans = len(VVAkuK)
16997:   FF4lCP(self, "Total Files\t: %d\nTotal Channels\t: %d" % (totFiles, totChans))
16998:  def VVWgKX(self):
16999:   files = CCkEI5.VVjMS6()
17000:   if files:
17001:    totInvalid = 0
17002:    invTxt  = ""
17003:    for path in files:
17004:     txt = FFYVq0(path)
17005:     for match in iFinditer(r"
17006:      totInvalid += 1
17007:      invTxt += "%s\t: %s\n" % (os.path.basename(path), match.group(1))
17008:    if totInvalid == 0 : color = VVSGsk
17009:    else    : color = VVz22H
17010:    totInvalid = FFjt5L(totInvalid, color)
17011:    txt  = "Processed Files\t\t: %d\n" % len(files)
17012:    txt += "Invalid References\t: %s\n" % totInvalid
17013:    if invTxt:
17014:     txt += FFjt5L("\nInvalid Refrences (File & Chan. Name):\n", color)
17015:     txt += invTxt
17016:   else:
17017:    txt = "No IPTV Files processed."
17018:   FF4lCP(self, txt, title="Check IPTV References")
17019:  def VVhMoT(self):
17020:   bName  = "%s_IPTV_TMP_BOUQUET_DEL" % VVh9hj
17021:   userBName = "userbouquet.%s.tv"  % bName
17022:   chPrefix = "Testing RType "
17023:   rTypeList = CCkEI5.VV5LSJ()
17024:   chUrlLst = []
17025:   for rType in (rTypeList):
17026:    ref = "%s:0:1:DDD:DDD:DDD:DDD:0:0:0:http%%3a//testUrl.com/aa/bb.m3u8:Testing RType %s" % (rType, rType)
17027:    chUrlLst.append(ref)
17028:   CCMvE7.VVPJK0(self, "", bName, "", chUrlLst, showRes=False)
17029:   acceptedList = []
17030:   VVKETx = eServiceReference('1:7:1:0:0:0:0:0:0:0:FROM BOUQUET "%s" ORDER BY bouquet' % userBName)
17031:   if VVKETx:
17032:    VVlGGv = FFZcDI(VVKETx)
17033:    if VVlGGv:
17034:     for service in VVlGGv:
17035:      VV1wIO = service[1]
17036:      acceptedList.append(VV1wIO.replace(chPrefix, ""))
17037:   path = VVQe79 + userBName
17038:   bFile = VVQe79 + "bouquets.tv"
17039:   tmpF = bFile + ".tmp"
17040:   cmd = FFb2oQ("grep -v '%s' '%s' > '%s'; mv '%s' '%s'" % (userBName, bFile, tmpF, tmpF, bFile))
17041:   cmd += FFb2oQ("rm -f '%s'" % path)
17042:   FFpwZS(cmd)
17043:   FFfpyJ()
17044:   title = "System Acceptable Reference Types"
17045:   if acceptedList:
17046:    txt = ""
17047:    for item in rTypeList:
17048:     if item in acceptedList : res, color = "Yes", VVSGsk
17049:     else     : res, color = "No" , VVz22H
17050:     pl = CCkEI5.VVDWCB(item)
17051:     txt += "    %s\t: %s%s\n" % (item, FFjt5L(res, color), FFjt5L("\t... %s" % pl, VVA4XU) if pl else "")
17052:    FF4lCP(self, txt, title=title)
17053:   else:
17054:    txt = FFdw58(self, "Could not complete the test on your system!", title=title)
17055:  @FFOAKH()
17056:  def VVkIRr(self):
17057:   VVHj48, err = CCYrUm.VVJud0(self, CCYrUm.VVmjC7)
17058:   if VVHj48:
17059:    totChannels = 0
17060:    totChange = 0
17061:    for path in CCkEI5.VVjMS6():
17062:     toSave = False
17063:     txt = FFYVq0(path)
17064:     for match in iFinditer(r"(
17065:      totChannels += 1
17066:      VV1wIO = match.group(3).strip(" !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~")
17067:      VVPxk5 = VVHj48.get(VV1wIO, "")
17068:      if VVPxk5:
17069:       VVPxk5  = VVPxk5[VVPxk5.index(":") + 1:]
17070:       toSave  = True
17071:       totChange += 1
17072:       txt = txt.replace(match.group(0), match.group(1) + VVPxk5 + ":" + match.group(2))
17073:     if toSave:
17074:      with open(path, "w") as f:
17075:       f.write(txt)
17076:    txt  = "Channels\t: %d\n" % totChannels
17077:    txt += "Changed\t: %d\n" % totChange
17078:    self.VVkNdH(totChange > 0, "Copy Ref. from existing Channels", txt)
17079:   else:
17080:    FFdw58(self, 'No channels in "lamedb" !')
17081:  def VVFTpS(self, VV7tND, title):
17082:   bFiles = CCkEI5.VVjMS6()
17083:   if bFiles: self.VV0cc4(bFiles, title)
17084:   else  : FF28n1(VV7tND, "No bouquets files !", 1500)
17085:  def VV5I9P(self, VV7tND, title):
17086:   self.VVHp9J(VV7tND, BF(self.VV9ynJ, title))
17087:  def VV9ynJ(self, title, VV7tND, bName, bPath):
17088:   self.VV0cc4([bPath], title)
17089:  def VV0cc4(self, bFiles, title):
17090:   CCh3tv.VV7Nf4(self, VVLL7M="Renumbering References"
17091:       , VVixvy  = BF(self.VVXz3o, bFiles)
17092:       , VVbYwR = BF(self.VVKsbI, title))
17093:  def VVXz3o(self, bFiles, VVXyP6):
17094:   VVXyP6.VVNc18 = ""
17095:   VVXyP6.VVaks5("Calculating Reference ...")
17096:   totLines = 0
17097:   patt = r"
17098:   for path in bFiles:
17099:    if FFCyVu(path):
17100:     lines = FFL19l(path)
17101:     for line in lines:
17102:      span = iSearch(patt, line)
17103:      if span:
17104:       totLines += 1
17105:   if not VVXyP6 or VVXyP6.isCancelled:
17106:    return
17107:   elif not totLines:
17108:    VVXyP6.VVNc18 = "No IPTV Services !"
17109:    return
17110:   else:
17111:    VVXyP6.VVq8NF(totLines)
17112:   rType = CFG.iptvAddToBouquetRefType.getValue()
17113:   startId = startNS = 0
17114:   for path in bFiles:
17115:    if not VVXyP6 or VVXyP6.isCancelled:
17116:     return
17117:    if FFCyVu(path):
17118:     toSave = False
17119:     bName  = os.path.basename(path)
17120:     lines  = FFL19l(path)
17121:     for ndx, line in enumerate(lines):
17122:      if not VVXyP6 or VVXyP6.isCancelled:
17123:       return
17124:      if ndx == 0:
17125:       span = iSearch(r"
17126:       if span:
17127:        bName = span.group(1)
17128:       if VVXyP6:
17129:        VVXyP6.VVaks5("Processing : %s " % bName)
17130:      span = iSearch(patt, line)
17131:      if span:
17132:       if VVXyP6:
17133:        VVXyP6.VVxtQs(1)
17134:       VVPxk5, startId, startNS = CCMvE7.VVIGWw(rType, CCMvE7.VVZ6bs, [], startId, startNS)
17135:       if VVPxk5:
17136:        lines[ndx] = "#SERVICE %s" % (VVPxk5 + span.group(1))
17137:        toSave = True
17138:       else:
17139:        if VVXyP6:
17140:         VVXyP6.VVNc18 = "Out of Free References while processing the file:\n%s" % path
17141:        return
17142:     if toSave:
17143:      with open(path, "w") as f:
17144:       f.write("\n".join(lines) + "\n")
17145:  def VVKsbI(self, title, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
17146:   txt  = "Found\t: %d\n"  % threadTotal
17147:   txt += "Changed\t: %d\n" % threadCounter
17148:   if VVNc18:
17149:    txt += "\n\n%s\n%s" % (FFjt5L("Ended with Error:", VVz22H), VVNc18)
17150:   self.VVkNdH(True, title, txt)
17151:  def VVWnDr(self):
17152:   bFiles = CCkEI5.VVjMS6()
17153:   if not bFiles:
17154:    FF28n1(self.VV6A99, "No bouquets files !", 1500)
17155:    return
17156:   tableRefList = []
17157:   for row in self.VV6A99.VVrrm9():
17158:    tableRefList.append((row[4], row[5]))
17159:   if not tableRefList:
17160:    FF28n1(self.VV6A99, "Cannot read list", 1500)
17161:    return
17162:   CCh3tv.VV7Nf4(self, VVLL7M="Renumbering References"
17163:       , VVixvy  = BF(self.VV61QR, bFiles, tableRefList)
17164:       , VVbYwR = BF(self.VVKsbI, "Change Current List References to Unique Codes"))
17165:  def VV61QR(self, bFiles, tableRefList, VVXyP6):
17166:   VVXyP6.VVNc18 = ""
17167:   VVXyP6.VVaks5("Reading System References ...")
17168:   refLst = CCMvE7.VVc8iI(CCMvE7.VVZ6bs, stripRType=True)
17169:   if not VVXyP6 or VVXyP6.isCancelled:
17170:    return
17171:   VVXyP6.VVq8NF(len(tableRefList))
17172:   rType = CFG.iptvAddToBouquetRefType.getValue()
17173:   startId = startNS = 0
17174:   for path in bFiles:
17175:    if not VVXyP6 or VVXyP6.isCancelled:
17176:     return
17177:    if FFCyVu(path):
17178:     toSave = False
17179:     bName = os.path.basename(path)
17180:     txt  = FFYVq0(path)
17181:     span = iSearch(r"
17182:     if span:
17183:      bName = span.group(1)
17184:     if not VVXyP6 or VVXyP6.isCancelled:
17185:      return
17186:     VVXyP6.VVaks5("Processing : %s " % bName)
17187:     for ref, url in tableRefList:
17188:      if not VVXyP6 or VVXyP6.isCancelled:
17189:       return
17190:      VVu06s = ref + url
17191:      if VVu06s in txt:
17192:       VVXyP6.VVxtQs(1)
17193:       VVPxk5, startId, startNS = CCMvE7.VVIGWw(rType, CCMvE7.VVZ6bs, refLst, startId, startNS)
17194:       if VVPxk5:
17195:        tot = txt.count(VVu06s)
17196:        if tot > 0:
17197:         txt = txt.replace(VVu06s, VVPxk5 + url)
17198:         toSave = True
17199:       else:
17200:        if VVXyP6:
17201:         VVXyP6.VVNc18 = "Out of Free References while processing the file:\n%s" % path
17202:        return
17203:     if toSave:
17204:      with open(path, "w") as f:
17205:       f.write(txt)
17206:  def VVthI4(self):
17207:   list = None
17208:   if self.VV6A99:
17209:    list = []
17210:    for row in self.VV6A99.VVrrm9():
17211:     list.append(row[4] + row[5])
17212:   files = CCkEI5.VVjMS6()
17213:   totChange = 0
17214:   if files:
17215:    for path in files:
17216:     lines = FFL19l(path)
17217:     toSave = False
17218:     for ndx, line in enumerate(lines):
17219:      span = iSearch(r"
17220:      if span:
17221:       if not list or span.group(1) in list:
17222:        txt, tot = iSubn(r"(
17223:        if tot > 0:
17224:         lines[ndx] = txt
17225:         toSave  = True
17226:         totChange += 1
17227:     if toSave:
17228:      with open(path, "w") as f:
17229:       f.write("\n".join(lines) + "\n")
17230:   self.VVkNdH(totChange > 0, "Change to Identical Ref. Codes", "Changes = %d" % totChange)
17231:  def VVkNdH(self, isChanged, title, txt, refreshTable=True):
17232:   if isChanged:
17233:    FFfpyJ()
17234:    if refreshTable and self.VV6A99:
17235:     VVAkuK = self.VVoN6g()
17236:     if VVAkuK and self.VV6A99:
17237:      self.VV6A99.VVMqQ9(VVAkuK, self.VVXTPg)
17238:      self.VV6A99.VV6fGE(txt)
17239:    FF4lCP(self, txt, title=title)
17240:   else:
17241:    FFipXT(self, "No changes.")
17242:  @staticmethod
17243:  def VVjMS6(atLeastOne=False, onlyFileName=False):
17244:   types = ('*.tv', '*.radio')
17245:   files = []
17246:   for f in types:
17247:    files.extend(iGlob(VVQe79 + f))
17248:   if files:
17249:    iptvFiles = []
17250:    for path in files:
17251:     if FFCyVu(path):
17252:      txt = FFYVq0(path)
17253:      span = iSearch(r"
17254:      if span:
17255:       iptvFiles.append(os.path.basename(path) if onlyFileName else path)
17256:       if atLeastOne:
17257:        return iptvFiles
17258:    return iptvFiles
17259:   else:
17260:    return None
17261:  def VVen0D(self, VV6A99, title, txt, colList):
17262:   Num, Name, Bouquet, Type, Ref, URL = VV6A99.VV5crm()
17263:   VVZcRP = FFXarh(URL)
17264:   VVfaDB = "%s:%s" % (Ref.rstrip(":"), URL.rstrip(":"))
17265:   if not VVfaDB.endswith(":" + Name):
17266:    VVfaDB += ":" + Name
17267:   txt  = "%s\n\n" % title
17268:   txt += "Name\t: %s\n" % FFjt5L(Name, VVFuwR)
17269:   txt += "Bouquet\t: %s\n" % Bouquet
17270:   txt += CCvjVs.VVjB93(FFXarh(VVfaDB), showUrl=False)
17271:   CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVXwW0, params=(Ref, Name, txt, VVZcRP, VVfaDB))
17272:  def VVIHV3(self, VV6A99, colList):
17273:   VV1wIO = colList[1]
17274:   VVPxk5 = colList[4]
17275:   url  = colList[5]
17276:   chUrl = VVPxk5 + url
17277:   return VV1wIO, chUrl
17278:  def VVG1o1(self, VV6A99, title, txt, colList):
17279:   VV1wIO, chUrl = self.VVIHV3(VV6A99, colList)
17280:   self.VVMp7d(VV6A99, VV1wIO, chUrl, "localIptv")
17281:  def VVYAch(self, mode, VV6A99, colList):
17282:   VV1wIO, chUrl, VVfbmn, VVPxk5 = self.VVK5K0(mode, colList)
17283:   VVAfO9 = os.path.join(self.VVYrUH(mode), os.path.basename(VVfbmn)) if VVfbmn else ""
17284:   return VV1wIO, chUrl, VVAfO9
17285:  def VVF9cb(self, mode, VV6A99, title, txt, colList):
17286:   VV1wIO, chUrl, VVfbmn, VVPxk5 = self.VVK5K0(mode, colList)
17287:   VVAfO9 = os.path.join(self.VVYrUH(mode), os.path.basename(VVfbmn)) if VVfbmn else ""
17288:   self.VVMp7d(VV6A99, VV1wIO, chUrl, mode, VVAfO9)
17289:  def VVMp7d(self, VV6A99, VV1wIO, chUrl, mode, VVAfO9=""):
17290:   VV1wIO = FFzBfi(VV1wIO)
17291:   if self.VVAP76(VV1wIO):
17292:    FF28n1(VV6A99, "This is a marker!", 300)
17293:   else:
17294:    CCqWM2.VVHc02(self.session, VVwqHQ=(self, VV6A99, mode), VVaHNe=chUrl, VVAfO9=VVAfO9, VVV4a7=mode == self.VV4kmD)
17295:  @staticmethod
17296:  def VVAP76(VV1wIO):
17297:   mark = ("--", "__", "==", "##",  "**", "_*", "*_", str(u"\u2605" * 2))
17298:   if VV1wIO.startswith(mark) and VV1wIO.endswith(mark):
17299:    return True
17300:   return False
17301:  def VVEzbx(self, VV6A99, title, txt, colList):
17302:   VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(self)
17303:   if VVPxk5:
17304:    url1 = FFXarh(VV57TX.strip())
17305:    for ndx, row in enumerate(VV6A99.VVrrm9()):
17306:     if VVPxk5 in row[4]:
17307:      tableRow = FFXarh(row[5].strip())
17308:      if url1 in tableRow or tableRow in url1:
17309:       VV6A99.VVrqBw(ndx)
17310:       break
17311:    else:
17312:     FF28n1(VV6A99, "Not found", 1000)
17313:  def VV9w3Z(self):
17314:   if CCwhE4.VVOJRa(self):
17315:    self.VVj5lb()
17316:  @FFOAKH("Searching ...")
17317:  def VVj5lb(self):
17318:   lines = self.VVKEO0(3)
17319:   if lines:
17320:    lst = []
17321:    for f in lines:
17322:     if os.path.isfile(f):
17323:      m3File, m3Dir, VVcwFG, zPath, zFound = CCjZbZ.VVuYvs(f)
17324:      sz = FFXhoc(f)
17325:      (m3SzT, m3Sz) = (CClYaF.VV99gM(sz, mode=4), str(sz)) if sz > -1 else ("", "")
17326:      m3Tm = zSz = ""
17327:      if zFound:
17328:       sz = FFXhoc(zPath)
17329:       zSz = CClYaF.VV99gM(sz, mode=4) if sz > -1 else ""
17330:       if zSz: m3SzT = "
17331:       m3Tm = CCjZbZ.VVs0Rm(zPath).srcMod
17332:      lst.append((m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm))
17333:    title = "M3U/M3U8 File Browser"
17334:    if lst:
17335:     lst.sort(key=lambda x: x[0].lower())
17336:     bTitle = "Playlist Options"
17337:     bg = "#11221122"
17338:     VVb5gJ  = {3:2}
17339:     VVu1YM  = ("Select"    , self.VVSTF4       , [])
17340:     VVwSzI = ("Refresh File Cache" , self.VVisGJ    , [])
17341:     VVScQz = ("File Options"  , self.VVoEEw       , [])
17342:     VV4QTJ = (bTitle    , BF(self.VVRhAi, bTitle) , [])
17343:     header   = ("File" , "Path", "Size","Size" , "zPath" , "Cached Size" , "m3Tm" )
17344:     widths   = (50  , 38 , 0.02 , 12 , 0   , 0.01   , 0   )
17345:     VVLIqP  = (LEFT  , LEFT , CENTER, CENTER, CENTER , CENTER  , CENTER )
17346:     tbl = FFUQ0v(self, None, title=title, header=header, VVGape=lst, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVb5gJ=VVb5gJ, VVu1YM=VVu1YM, VV4QTJ=VV4QTJ, VVwSzI=VVwSzI, VVScQz=VVScQz, VVwltY="#11221122", VVkxBG=bg, VVemyB=bg, VVJKqd="#11004a55", VVbcr0="#0a333333", VVX9AA="#06333333")
17347:     tbl.VVIOX6(BF(self.VVJ5wF, tbl))
17348:    else:
17349:     FFdw58(self,"No files found." , title=title)
17350:  def VVSTF4(self, VV6A99, title, txt, colList):
17351:   m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm = colList
17352:   CCjZbZ(VV6A99, CCjZbZ.VVCAqE, m3uF=m3Dir+m3File, VVMye8=BF(self.VVMaF7, VV6A99))
17353:  def VVisGJ(self, VV6A99, title, txt, colList):
17354:   m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm = colList
17355:   if VV6A99["keyGreen"].getVisible():
17356:    CCjZbZ(self, CCjZbZ.VVWcXC, m3uF=m3Dir+m3File, VVMye8=BF(self.VVMaF7, VV6A99))
17357:  def VVoEEw(self, VV6A99, title, txt, colList):
17358:   m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm = colList
17359:   VV3wat = []
17360:   VV3wat.append(("Delete Selected File"   , "delm3u"))
17361:   if zSz: VV3wat.append(("Delete Local Cache" , "delZip"))
17362:   FFLFTC(self, BF(self.VVHXsl, VV6A99, colList), title="File Options", VV3wat=VV3wat, width=700, VVU8mZ=True)
17363:  def VVHXsl(self, VV6A99, colList, item):
17364:   if item:
17365:    title, ref, ndx = item
17366:    m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm = colList
17367:    if  ref == "delm3u": path = m3Dir + m3File
17368:    elif ref == "delZip": path = zPath
17369:    FFRMYv(self, BF(self.VVav84, VV6A99, path, ref), "Delete ?\n\n%s" % path, title=title)
17370:  def VVav84(self, VV6A99, path, ref):
17371:   FFwgGB(path)
17372:   if ref == "delm3u":
17373:    if FFCyVu(path) : FF28n1(VV6A99, "No deleted", 1000)
17374:    else    : VV6A99.VVtM2v()
17375:   elif ref == "delZip":
17376:    self.VVMaF7(VV6A99)
17377:  def VVRhAi(self, Title, VV6A99, title, txt, colList):
17378:   m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm = colList
17379:   VV3wat = []
17380:   VV3wat.append(("Browse Selected Server Online"  , "br"))
17381:   VV3wat.append(("Filter Playlist URLs (from all Files)", "fl"))
17382:   FFLFTC(self, BF(self.VVBhfH, VV6A99, m3Dir+m3File), title=Title, VV3wat=VV3wat, width=700, VVU8mZ=True)
17383:  def VVBhfH(self, VV6A99, path, item):
17384:   if item:
17385:    title, ref, ndx = item
17386:    if  ref == "br": self.VV57zg(VV6A99, title, path)
17387:    elif ref == "fl": self.VVDcLv(VV6A99)
17388:  def VVMaF7(self, VV6A99, *arg):
17389:   m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm = VV6A99.VV5crm()
17390:   sz = FFXhoc(zPath)
17391:   zSz = CClYaF.VV99gM(sz, mode=4) if sz > -1 else ""
17392:   try: m3Tm = str(int(os.path.getmtime(m3Dir + m3File)))
17393:   except: m3Tm = ""
17394:   VV6A99.VViSLW((m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm))
17395:   if zSz:
17396:    fg = FFRUST("
17397:    ndx = VV6A99.VVGTqU()
17398:    VV6A99.VVmMYI(ndx, 3, 8, fg)
17399:    VV6A99.VVmMYI(ndx, 3, 9, fg)
17400:   self.VVJ5wF(VV6A99)
17401:  def VVJ5wF(self, VV6A99):
17402:   m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm = VV6A99.VV5crm()
17403:   VV6A99["keyGreen"].hide()
17404:   if zSz and m3Tm:
17405:    try: curTm = int(os.path.getmtime(m3Dir + m3File))
17406:    except: curTm = ""
17407:    if curTm and m3Tm != str(curTm):
17408:     VV6A99["keyGreen"].show()
17409:  def VVDcLv(self, VV6A99):
17410:   CCh3tv.VV7Nf4(self, titleBg="#22003344", bodyBg="#22001122"
17411:       , VVixvy  = BF(self.VVCGdA, VV6A99)
17412:       , VVbYwR = self.VVVcMx)
17413:  def VVCGdA(self, VV6A99, VVXyP6):
17414:   lst = []
17415:   dupl = 0
17416:   totF = VV6A99.VVn1uo()
17417:   VVXyP6.VVq8NF(totF)
17418:   VVXyP6.VVNc18 = (totF, dupl, lst)
17419:   for ndx, (m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm) in enumerate(VV6A99.VVrrm9()):
17420:    path = m3Dir + m3File
17421:    if not VVXyP6 or VVXyP6.isCancelled: return
17422:    VVXyP6.VVaks5(os.path.basename(path))
17423:    VVXyP6.VVxtQs(1)
17424:    if FFCyVu(path):
17425:     enc = CC7ocD.VV51oT(path)
17426:     if not enc == -1:
17427:      with ioOpen(path, "r", encoding=enc) as f:
17428:       for line in f:
17429:        if not VVXyP6 or VVXyP6.isCancelled: return
17430:        line = str(line).strip()
17431:        line, _, _ = line.partition("?")
17432:        line, _, _ = line.partition("&")
17433:        if len(line) < 500:
17434:         url = CCkEI5.VVyZOO(line)
17435:         if url:
17436:          if not url in lst: lst.append(url)
17437:          else    : dupl += 1
17438:          VVXyP6.VVNc18 = (totF, dupl, lst)
17439:          break
17440:  def VVVcMx(self, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
17441:   title = "Create Playlist from m3u Files"
17442:   totF, dupl, lst = VVNc18
17443:   if not lst:
17444:    FFdw58(self, "Could not obtain URLs from this file list !", title=title)
17445:    return
17446:   lst.sort()
17447:   pListF = "%sPlaylist_%s.txt" % (FF7BT0(), FFjTQe())
17448:   with open(pListF, "w") as f:
17449:    for url in lst:
17450:     f.write(url + "\n")
17451:   txt = ""
17452:   txt += "Total Files\t: %d\n" % totF
17453:   txt += "Prcessed Files\t: %d\n" % threadCounter
17454:   if dupl > 0: txt += "Duplicates\t: %d  (removed)\n" % dupl
17455:   txt += "Created Lines\t: %d\n" % len(lst)
17456:   txt += "Playlist File\t: %s" % pListF
17457:   FF4lCP(self, txt, title=title)
17458:  @FFOAKH("Searching ...")
17459:  def VV0muG(self, mode):
17460:   if   mode == 1: title, okFnc = "Select Playlist File", self.VVtDsx
17461:   elif mode == 2: title, okFnc = "Select Portal File"  , self.VVDtP0
17462:   lines = self.VVKEO0(mode)
17463:   if lines:
17464:    lines.sort()
17465:    VV3wat = []
17466:    for line in lines:
17467:     VV3wat.append((FFjt5L(line, VVFuwR) if "Bookmarks" in line else line, line))
17468:    t = CC6u6z.VVZxjK(901 if mode==1 else 902) if mode in (1, 2) and VVBvqf else None
17469:    VVJbOd = self.VVNhTV
17470:    VVwJOl = (VVFuwR + t, BF(self.VVHgVh, mode, t)) if t else None
17471:    VVaTeF = ("Merge All Files", BF(self.VVYmtc, mode)) if len(VV3wat) > 1 else None
17472:    FFLFTC(self, None, title=title, VV3wat=VV3wat, width=1700, height=900, VVOa1G=okFnc, VVJbOd=VVJbOd, VVwJOl=VVwJOl, VVaTeF=VVaTeF, VVtboQ="")
17473:  def VVKEO0(self, mode):
17474:   err = excl = ""
17475:   dirs = []
17476:   path = "/"
17477:   if CFG.iptvHostsMode.getValue() == VVSBbs:
17478:    excl = FF5W9s(1)
17479:   else:
17480:    lst = list(set(list(map(str.strip, CFG.iptvHostsDirs.getValue().split(",")))))
17481:    tList = []
17482:    for Dir in lst:
17483:     if VVmJwX(Dir):
17484:      tList.append(Dir)
17485:    lst = sorted(tList, key=len)
17486:    for Dir in lst:
17487:     for dir1 in dirs:
17488:      if len(Dir) > len(dir1) and Dir.startswith(dir1):
17489:       break
17490:     else:
17491:      dirs.append(Dir)
17492:    if   len(dirs) == 1 : path = dirs[0]
17493:    elif len(dirs) > 1 : path = "{%s}" % ",".join(dirs)
17494:    if not dirs:
17495:     FFdw58(self, 'Directory not found !\n\nCheck your settings option:\n\n"IPTV Hosts Files Path (Playlist, Portal, M3U)"')
17496:     return []
17497:   if   mode == 1: par = r'\( -iname "*playlist*" -o -iname "*stalker*" -o -iname "*urlscan.io*" \) | grep -i "\.txt\|\.json"'
17498:   elif mode == 2: par = r'\( -iname "*portal*" -o -iname "*stalker*" -o -iname "*urlscan.io*"  \) | grep -i "\.txt\|\.conf\|\.json"'
17499:   elif mode == 3: par = r'-iname "*.m3u" -o -iname "*.m3u8" | grep -i "\.m3u\|\.m3u8"'
17500:   files = FF3xOt("find %s %s %s 2> /dev/null" % (path, excl, par))
17501:   if files:
17502:    err = CClYaF.VV8isu(files)
17503:    if err : FFdw58(self, err + FFjt5L('\n\n( Change "IPTV Hosts Files Path" to "Custom" and try again )', VVFuwR))
17504:    else : return files
17505:   else:
17506:    if   path == "/": txt = "!"
17507:    elif dirs  : txt = "in directories listed in settings !"
17508:    else   : txt = "in :\n%s" % path
17509:    if   mode == 1: err = 'No Playlist files found %s\n\n Expecting ".txt" files\n(names must include the word "playlist")' % txt
17510:    elif mode == 2: err = 'No portal files found %s\n\n Expecting ".txt" or ".conf" files\n(name must include the word "portal" or "stalker")' % txt
17511:    elif mode == 3: err = 'No ".m3u" files found %s' % txt
17512:    t = CC6u6z.VVZxjK(901 if mode==1 else 902) if mode in (1, 2) and VVBvqf else None
17513:    if t: FFRMYv(self, BF(self.VVHgVh, mode, t), "%s ?" % t)
17514:    else: FFdw58(self, err)
17515:   return []
17516:  def VVYmtc(self, mode, VV7tND, item):
17517:   lst = VV7tND.VV35XX()
17518:   title = "Merge %s files" % len(lst)
17519:   w1 = w2 = ""
17520:   for nm in lst:
17521:    nm = nm.lower()
17522:    if "playlist" in nm: w1 = "Playlist_"
17523:    if "portal" in nm or "stalker" in nm: w2 = "Portal_"
17524:   path = "%sMerged_%s%s%s.txt" % (FF7BT0(), w1, w2, FFjTQe())
17525:   err = ""
17526:   with open(path, "w") as outF:
17527:    sep = "=" * 100
17528:    c = 0
17529:    try:
17530:     for fil in lst:
17531:      c += 1
17532:      outF.write("#%s\nFile-%s: %s\n#%s\n" % (sep, c, fil, sep))
17533:      outF.write("%s\n\n" % FFYVq0(fil).strip())
17534:    except Exception as e:
17535:     err = str(e)
17536:   if err:
17537:    FFwgGB(path)
17538:    FFdw58(self, "Error in:\n%s\n\n%s" % (fil, err), title=title)
17539:   else:
17540:    FFipXT(self, "Saved to:\n\n%s" % path, title=title)
17541:    VV7tND.VV5HD3((path, path), isSort=True)
17542:  def VVHgVh(self, mode, t, VV7tND=None, item=None):
17543:   if   mode == 1: fnc = self.VVu7ic(t, VV7tND)
17544:   elif mode == 2: fnc = self.VVrYB9(t, VV7tND)
17545:  @FFOAKH(par=2)
17546:  def VVu7ic(self, title, VV7tND):
17547:   lst = []
17548:   for i in range(100, 118): lst.append(CC6u6z.VVZxjK(i))
17549:   try: l1, l2, l3, r, t, u, p, U, P, H, J, L, x1, x2, x3, x4, x5, x6 = lst
17550:   except: return
17551:   if not all(lst): return
17552:   exp = iCompile(r".*(%s.+)\/.*%s=(.+)&%s=([^&]+)" % (H, U, P), IGNORECASE)
17553:   lst, eLst, mT = set(), [], ""
17554:   fTm = FFjTQe()
17555:   dstPath = FF7BT0()
17556:   for ndx, l in enumerate((l1, l2, l3), start=1):
17557:    resp, txt, err = CC96QG.VVKe8x(l, verify=True)
17558:    if err:
17559:     eLst.append(err)
17560:    else:
17561:     try: d = jLoads(txt)[r]
17562:     except: d = {}
17563:     for par in d:
17564:      span = exp.search(str(par[t][u]))
17565:      if span and all(span.groups()):
17566:       lst.add(L % tuple([FFXarh(x).strip() for x in span.groups()]))
17567:    if VVBvqf > 1:
17568:     mT += ("%s\n%s\n%s\n\n" % (l, resp.headers, "\n".join([("%s\t: %s" % (x.ljust(30), resp.headers.get(x, ""))) for x in (x1, x2, x3, x4, x5, x6)]))) if resp else ""
17569:     with open("%s%s_%s_%s.%s" % (dstPath, p, fTm, ndx, J), "w") as f: f.write(txt)
17570:   if VVBvqf > 1:
17571:    with open("%s%s_%s_0" % (dstPath, p, fTm), "w") as f: f.write(mT)
17572:   if lst  : self.VVCnnM(VV7tND, None, "%s%s_%s.txt" % (dstPath, p, fTm), [(u, "") for u in lst], False)
17573:   elif eLst: FFdw58(self, "\n\n".join(eLst), title=title)
17574:   else  : FFdw58(self, "Not found", title=title)
17575:  @FFOAKH(par=2)
17576:  def VVrYB9(self, title, VV7tND):
17577:   u, p = CC6u6z.VVZxjK(200), CC6u6z.VVZxjK(201)
17578:   if not all(u and p): return
17579:   resp, txt, err = CC96QG.VVKe8x(u, verify=True)
17580:   U = iFindall(r'"@id": "(.+\.html)"', txt, IGNORECASE) if resp else None
17581:   lst = set()
17582:   for u in U:
17583:    resp, txt, err = CC96QG.VVKe8x(u, verify=True)
17584:    if not txt: continue
17585:    txt = txt.replace("http", "\nhttp")
17586:    for line in txt.split("\n"):
17587:     span = iSearch(r"(http[^< ]+).+(?:[a-fA-F0-9]{2}:){5}[a-fA-F0-9]{2}", line)
17588:     if span:
17589:      u = span.group(1).partition("&")[0].partition("#")[0]
17590:      for m in iFindall(r"((?:[a-fA-F0-9]{2}:){5}[a-fA-F0-9]{2})", line):
17591:       lst.add(("0", "0", "-", u, m.upper(), "-"))
17592:   if lst:
17593:    lst = sorted(lst)
17594:    outF = "%s%s_%s.txt" % (FF7BT0(), p, FFjTQe())
17595:    if VVBvqf > 1:
17596:     self.VVspUi(None, None, outF, True, lst, len(lst))
17597:    else:
17598:     with open(outF, "w") as f:
17599:      for _, _, _, h, m, _ in lst: f.write("%s\t%s\n" % (h, m))
17600:     VV7tND.VV5HD3((outF, outF), isSort=True)
17601:   else:
17602:    FFdw58(self, "Not found")
17603:  def VVNhTV(self, VV7tND, txt, ref, ndx):
17604:   txt = ref
17605:   sz = FFXhoc(ref)
17606:   if sz > 0:
17607:    txt += "\n\nSize: %s" % CClYaF.VV99gM(sz)
17608:   FF4lCP(self, txt, title="File Path")
17609:  def VVtDsx(self, item=None):
17610:   if item:
17611:    VV7tND, txt, path, ndx = item
17612:    self.VVCTSY(VV7tND, path)
17613:  @FFOAKH(par=1)
17614:  def VVCTSY(self, VV7tND, path):
17615:   enc = CC7ocD.VV51oT(path, self)
17616:   if enc == -1:
17617:    return
17618:   num, lineNum, VVAkuK = 1, 0, []
17619:   datePatt = iCompile(r"(?:(?:ends?|exp)(?:[\w]+))[: ]*(\d{4})[-_](\d{2})[-_](\d{2})(?:\s+(\d{2}):(\d{2}):(\d{2}))?", IGNORECASE)
17620:   def VV0Kuq(url, rem=""):
17621:    if url:
17622:     modified, uURL, uProtoc, uHost, uPort, uQuery, uUser, uPass, uQueryParam = CCkEI5.VVRLKG(url)
17623:     uURL = uURL.rstrip("/")
17624:     for item in VVAkuK:
17625:      if item[2] == uURL and item[3] == uUser and item[4] == uPass:
17626:       return 0
17627:     span = datePatt.search(rem)
17628:     c1 = ""
17629:     if span:
17630:      y, m, d, H, M, S = span.groups()
17631:      H = int(H) if str(H).isdigit() else 0
17632:      M = int(M) if str(M).isdigit() else 0
17633:      S = int(S) if str(S).isdigit() else 0
17634:      try:
17635:       end = mktime(datetime(int(y), int(m), int(d), H, M, S).timetuple())
17636:       c1 = "#f#00ff5555#" if iTime() > end else "#f#0055ff55#"
17637:      except:
17638:       c1 = "#f#00888888#"
17639:     VVAkuK.append((str(len(VVAkuK)+1), str(lineNum), str(uURL), str(uUser), str(uPass), c1 + rem, url))
17640:     return 1
17641:    return 0
17642:   title = "Get Playlist URLs"
17643:   with ioOpen(path, "r", encoding=enc) as f:
17644:    if path.endswith(".json"):
17645:     fTxt = f.read()
17646:     try:
17647:      data = jLoads(fTxt)
17648:      for d in data:
17649:       uURL, uUser, uPass, end = d.get("host", ""), d.get("username", ""), d.get("password", ""), d.get("end_date", "")
17650:       rem = ("Ends: %s" % FFTS4w(float(end))) if str(end).isdigit() else ""
17651:       url = "%s/get.php?username=%s&password=%s&type=m3u" % (uURL, uUser, uPass) if all((uURL, uUser, uPass)) else ""
17652:       num += VV0Kuq(url, rem)
17653:     except:
17654:      try:
17655:       exp = iCompile(r".*(http.+)\/.*username=(.+)&password=([^&]+)", IGNORECASE)
17656:       for d in jLoads(fTxt)["results"]:
17657:        span = exp.search(str(d["task"]["url"]))
17658:        if span and all(span.groups()):
17659:         uURL, uUser, uPass = [FFXarh(x.strip()) for x in span.groups()]
17660:         url = "%s/get.php?username=%s&password=%s&type=m3u" % (uURL, uUser, uPass) if all((uURL, uUser, uPass)) else ""
17661:         num += VV0Kuq(url)
17662:      except Exception as e:
17663:       FFdw58(self, str(e), title=title)
17664:       return
17665:    else:
17666:     l3 = []
17667:     hstPatt = iCompile(r"(http?:\/\/[^\/]+)[^\s]+(?:\s+#(.+))?", IGNORECASE)
17668:     usrPatt = iCompile(r"username\s*[=:]\s*(\S+)", IGNORECASE)
17669:     pasPatt = iCompile(r"password\s*[=:]\s*(\S+)", IGNORECASE)
17670:     for line in f:
17671:      lineNum += 1
17672:      line = str(line).strip()
17673:      if not line or len(line) > 500:
17674:       continue
17675:      span = iSearch(r"(?:http.+)?(http.+php.+username=.+password=[^\s<]+)(?:\s+#(.+))?", line, IGNORECASE)
17676:      url = rem = ""
17677:      if span:
17678:       url = span.group(1)
17679:       rem = span.group(2).strip() if span.group(2) else ""
17680:      else:
17681:       span = iSearch(r"(http.+)\s+username(.+)\s+password\s+([^\s]+)(?:\s+#(.+))?", line, IGNORECASE)
17682:       if span:
17683:        host = FFoWxR(span.group(1).strip())
17684:        user1 = span.group(2).strip()
17685:        pass1 = span.group(3).strip()
17686:        rem  = span.group(4).strip() if span.group(4) else ""
17687:        url  = "%sget.php?username=%s&password=%s&type=m3u" % (host, user1, pass1)
17688:      if url:
17689:       l3 = []
17690:      else:
17691:       l3.append(line)
17692:       if len(l3) > 3: l3.pop(0)
17693:       if len(l3) == 3:
17694:        spanH = hstPatt.search(l3[0])
17695:        spanU = usrPatt.search(l3[1]) or usrPatt.search(l3[2])
17696:        spanP = pasPatt.search(l3[2]) or pasPatt.search(l3[1])
17697:        if spanH and spanU and spanP:
17698:         host, user1, pass1 = spanH.group(1), spanU.group(1), spanP.group(1)
17699:         rem = spanH.group(2).strip() if spanH.group(2) else ""
17700:         if all((host, user1, pass1)): url = "%s/get.php?username=%s&password=%s&type=m3u" % (host, user1, pass1)
17701:         l3 = []
17702:      num += VV0Kuq(url, rem)
17703:   if VVAkuK:
17704:    VVu1YM  = ("Start"    , BF(self.VVVpkf, "Playlist File")      , [])
17705:    VVGuQE  = BF(self.VVEo3E, VV7tND)
17706:    VVwWmA = ("Home Menu"   , FF8lJ1             , [])
17707:    VVwSzI = ("Server Resources" , self.VVFuB7     , [])
17708:    VVScQz = ("Edit File"   , BF(self.VVk4dv, path)        , [])
17709:    VV4QTJ = ("Check & Filter"  , BF(self.VVPu1w, VV7tND, path) , [])
17710:    header   = ("Num" , "LineNum" , "Address" , "User" , "Password" , "Remarks" , "URL" )
17711:    widths   = (7  , 0   , 33  , 17  , 17   , 26  , 0.03 )
17712:    VVLIqP  = (CENTER , CENTER , LEFT  , LEFT   , LEFT   , LEFT  , LEFT  )
17713:    FFUQ0v(self, None, title=os.path.basename(path), header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, width=1800, height=1000, VVwdmN=26, VVu1YM=VVu1YM, VVGuQE=VVGuQE, VVwWmA=VVwWmA, VV4QTJ=VV4QTJ, VVwSzI=VVwSzI, VVScQz=VVScQz, VVwltY="#11001116", VVkxBG="#11001116", VVemyB="#11001116", VVJKqd="#00003635", VVbcr0="#0a333333", VVX9AA="#11331100", VVHPI7=True, VVMfsO=2, VVSLOq=CFG.lastFindServers)
17714:   else:
17715:    FFdw58(self, "No valid URLs line in this file:\n\n%s" % path, title=title)
17716:  def VVEo3E(self, VV7tND, VV6A99, path):
17717:   if VV7tND and path.endswith(".txt"):
17718:    VV7tND.VV5HD3((path, path), isSort=True)
17719:  def VVFuB7(self, VV6A99, title, txt, colList):
17720:   CCjZbZ(self, CCjZbZ.VV4Vv0, url=colList[6])
17721:  def VV2jvq(self, VV7tND, item):
17722:   CCjZbZ(self, CCjZbZ.VVCKX0, url=self.VVfymn["playListURL"])
17723:  def VVVpkf(self, Title, VV6A99, title, txt, colList):
17724:   url = colList[6]
17725:   self.VVgCCs(VV6A99, Title, url)
17726:  def VVk4dv(self, path, VV6A99, title, txt, colList):
17727:   rowNum = int(colList[1].strip()) - 1
17728:   if FFCyVu(path) : CCyMCP(self, path, VVbYwR=BF(self.VVzm4T, VV6A99), VVPhQC=rowNum)
17729:   else    : FF8Wsn(self, path)
17730:  def VVzm4T(self, VV6A99, fileChanged):
17731:   if fileChanged:
17732:    VV6A99.cancel()
17733:  def VVdBzQ(self, title):
17734:   curChName = self.VV6A99.VVeE40(1)
17735:   FF4z45(self, BF(self.VVIOKi, self.VV6A99, title), defaultText=curChName, title=title, message="Enter Name:")
17736:  @FFOAKH(par=1)
17737:  def VVIOKi(self, VV6A99, title, name):
17738:   if name:
17739:    VVHj48, err = CCYrUm.VVJud0(self, CCYrUm.VVp2Ed, VVXwzE=False, VV49Lf=False)
17740:    list = []
17741:    if VVHj48:
17742:     name = self.VVBgSG(name)
17743:     ratio = "1"
17744:     for item in VVHj48:
17745:      if name in item[0].lower():
17746:       list.append((item[0], FFR9yH(item[2]), item[3], ratio))
17747:    if list : self.VVuprI(list, title)
17748:    else : FFdw58(self, "Not found:\n\n%s" % name, title=title)
17749:  def VVOPJS(self, title):
17750:   curChName = self.VV6A99.VVeE40(1)
17751:   CCh3tv.VV7Nf4(self, VVLL7M="Find similar names"
17752:       , VVixvy  = self.VVIzGB
17753:       , VVbYwR = BF(self.VVYeFR, title, curChName))
17754:  def VVIzGB(self, VVXyP6):
17755:   curChName = self.VV6A99.VVeE40(1)
17756:   VVHj48, err = CCYrUm.VVJud0(self, CCYrUm.VVXNWJ, VVXwzE=False, VV49Lf=False)
17757:   if not VVHj48 or not VVXyP6 or VVXyP6.isCancelled:
17758:    return
17759:   VVXyP6.VVNc18 = []
17760:   VVXyP6.VVq8NF(len(VVHj48))
17761:   curCh = self.VVBgSG(curChName)
17762:   for VVPxk5 in VVHj48:
17763:    VV1wIO, sat, inDB = VVHj48.get(VVPxk5, ("", "", 0))
17764:    ratio = CCafIt.VV8e0X(VV1wIO.lower(), curCh)
17765:    if not VVXyP6 or VVXyP6.isCancelled:
17766:     return
17767:    VVXyP6.VVxtQs(1, True)
17768:    if VVXyP6 and ratio > 50:
17769:     VVXyP6.VVNc18.append((VV1wIO, FFR9yH(sat), VVPxk5.replace("_", ":"), str(ratio)))
17770:  def VVYeFR(self, title, curChName, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
17771:   if VVNc18: self.VVuprI(VVNc18, title)
17772:   elif VVRI6P: FFdw58(self, "No similar names found for:\n\n%s" % curChName, title)
17773:  def VVuprI(self, VVAkuK, title):
17774:   FFimQ3(self.VV6A99, BF(self.VVlMA3, VVAkuK, title))
17775:  def VVlMA3(self, VVAkuK, title):
17776:   curChName = self.VV6A99.VVeE40(1)
17777:   VVVvc0 = self.VV6A99.VVeE40(4)
17778:   VV2rlK  = self.VV6A99.VVeE40(5)
17779:   VVAkuK.sort(key=lambda x: (100-int(x[3]), x[0].lower()))
17780:   VVu1YM  = ("Share Sat/C/T Ref.", BF(self.VV0BPS, title, curChName, VVVvc0, VV2rlK), [])
17781:   header   = ("Name" , "Sat"  , "Reference" , "Ratio" )
17782:   widths   = (34  , 33  , 33   , 0   )
17783:   FFUQ0v(self, None, title=title, header=header, VVGape=VVAkuK, VV3cHe=widths, VVwdmN=26, VVu1YM=VVu1YM, VVwltY="#0a00112B", VVkxBG="#0a001126", VVemyB="#0a001126", VVJKqd="#00000000")
17784:  def VV0BPS(self, newtitle, curChName, VVVvc0, VV2rlK, VV6A99, title, txt, colList):
17785:   newChName = colList[0]
17786:   newRefCode = colList[2]
17787:   data  = newtitle, curChName, VVVvc0, VV2rlK, newChName, newRefCode
17788:   ques  = "IPTV Channel\t: %s\n\nSat/C/T Chan. \t: %s\n" % (curChName, newChName)
17789:   FFRMYv(self.VV6A99, BF(self.VVgToo, VV6A99, data), ques, title=newtitle, VVAgUy=True)
17790:  @FFOAKH(par=1)
17791:  def VVgToo(self, VV6A99, data):
17792:   VV6A99.cancel()
17793:   title, curChName, VVVvc0, VV2rlK, newChName, newRefCode = data
17794:   VV2rlK  = VV2rlK.strip()
17795:   VVVvc0 = VVVvc0.strip()
17796:   newRefCode = newRefCode.strip()
17797:   if not VVVvc0.endswith(":") : VVVvc0 += ":"
17798:   if not newRefCode.endswith(":") : newRefCode += ":"
17799:   curFullUrl = newFullUrl = ""
17800:   span = iSearch(r"([A-Fa-f0-9]+:).+", VVVvc0, IGNORECASE)
17801:   if span:
17802:    curRType = span.group(1)
17803:    span = iSearch(r"[A-Fa-f0-9]+:(.+)", newRefCode, IGNORECASE)
17804:    if span:
17805:     newRefCode = curRType + span.group(1)
17806:     curFullUrl = VVVvc0 + VV2rlK
17807:     newFullUrl = newRefCode + VV2rlK
17808:   totChanges = 0
17809:   resTxt = resErr = ""
17810:   if curFullUrl and newFullUrl:
17811:    for path in CCkEI5.VVjMS6():
17812:     txt = FFYVq0(path)
17813:     if curFullUrl in txt:
17814:      totChanges += 1
17815:      txt = txt.replace(curFullUrl, newFullUrl)
17816:      with open(path, "w") as f:
17817:       f.write(txt)
17818:    if totChanges > 0:
17819:     FFfpyJ()
17820:     newRow = []
17821:     for i in range(6):
17822:      newRow.append(self.VV6A99.VVeE40(i))
17823:     newRow[4] = newRefCode
17824:     done = self.VV6A99.VViSLW(newRow)
17825:     resTxt = "Done"
17826:    else:
17827:     resErr = "Not found in IPTV files"
17828:   else:
17829:    resErr = "Cannot read Chan. Info."
17830:   if   resTxt: FFIElK(BF(FFipXT , self, resTxt, title=title))
17831:   elif resErr: FFIElK(BF(FFdw58, self, resErr, title=title))
17832:  def VVPu1w(self, VVr7eD, path, VV6A99, title, txt, colList):
17833:   outF = "%s_OK_%s.txt" % (path, FFjTQe())
17834:   lst = [(url, remarks) for num, lineNum, hst, usr, pas, remarks, url in VV6A99.VVrrm9()]
17835:   self.VVCnnM(VVr7eD, VV6A99, outF, lst, True)
17836:  def VVCnnM(self, VVr7eD, VV6A99, outF, lst, hasFile):
17837:   CCh3tv.VV7Nf4(self, VVLL7M="Checking Authorized Servers"
17838:       , VVixvy  = BF(self.VVrXIm, VV6A99, lst)
17839:       , VVbYwR = BF(self.VVTtko, VVr7eD, VV6A99, outF, len(lst), hasFile))
17840:  def VVrXIm(self, VV6A99, lst, VVXyP6):
17841:   VVXyP6.VVq8NF(len(lst))
17842:   VVXyP6.VVNc18 = []
17843:   datePatt = iCompile(r"(?:ends?|exp)[\w]+[: ]*\d{4}[-_]\d{2}[-_]\d{2}(?:\s+\d{2}:\d{2}:\d{2})?(.*)", IGNORECASE)
17844:   for url, remarks in lst:
17845:    if not VVXyP6 or VVXyP6.isCancelled: return
17846:    VVXyP6.VVxtQs(1, True)
17847:    qUrl = self.VVGaR8(self.VVJbaD, url)
17848:    txt, err = self.VVzVZL(qUrl, timeout=1)
17849:    if not err:
17850:     try:
17851:      tDict = jLoads(txt)
17852:      if tDict and not err and "server_info" in tDict:
17853:       item = tDict["user_info"]
17854:       if not FFYjVd(item, "auth") == "0":
17855:        end = item.get("exp_date", "")
17856:        rem = ("Ends: %s" % FFTS4w(float(end))) if str(end).isdigit() else ""
17857:        if remarks:
17858:         span = datePatt.search(remarks)
17859:         if span : rem += (" ... %s" % span.group(1)) if span.group(1) else ""
17860:         else : rem += " ... %s" % remarks
17861:        if not VVXyP6 or VVXyP6.isCancelled: return
17862:        VVXyP6.VVNc18.append("%s%s" % (qUrl, ("\t#" + " " + rem) if rem else ""))
17863:     except:
17864:      pass
17865:  def VVTtko(self, VVr7eD, VV6A99, outF, totChk, hasFile, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
17866:   title = "Authorized Servers"
17867:   if VVNc18:
17868:    totAuth = len(VVNc18)
17869:    if hasFile and totAuth == totChk:
17870:     FFipXT(self, "All URLs are authorized.", title=title)
17871:    else:
17872:     with open(outF, "w") as f:
17873:      for item in VVNc18:
17874:       f.write("%s\n" % item)
17875:     if VVr7eD : VVr7eD.VV5HD3((outF, outF), isSort=True)
17876:     else   : self.VV0muG(1)
17877:     txt = FFjt5L("Process Stopped\n\n", VVYjI5) if not VVRI6P else ""
17878:     txt += "Checked\t: %d/%d\n"  %  (threadCounter, totChk)
17879:     txt += "Authorized\t: %s\n\n" %  FFjt5L(totAuth, VVSGsk)
17880:     txt += "%s\n%s"    %  (FFjt5L("Result File:", VVFuwR), outF)
17881:     FF4lCP(self, txt, title=title)
17882:     if VV6A99: VV6A99.close()
17883:   else:
17884:    FFdw58(self, "No authorized URL found !", title=title)
17885:  @staticmethod
17886:  def VVzVZL(url, timeout=3, allowDocType=False):
17887:   if not iRequest:
17888:    return "" , "Cannot import URLLIB/URLLIB2 !"
17889:   try:
17890:    req = iRequest(url)
17891:    req.add_header("User-Agent", CCkEI5.VVQNEW())
17892:    res = iUrlopen(req, timeout=timeout)
17893:    resCode = res.code
17894:    if resCode == 200 :
17895:     cont = res.headers.get("Content-Type")
17896:     if cont:
17897:      if not any(x in cont for x in ("/json", "/ld+json", "text/html", "text/plain")):
17898:       return "", "Unexpected server data type ( %s )" % cont
17899:      res = res.read().decode("UTF-8", "replace")
17900:      if res:
17901:       if not allowDocType and ("<!DOCTYPE html" in res or "<html" in res):
17902:        sErr = "Username or password is invalid."
17903:        if sErr in res : return "", sErr
17904:        else   : return "", "Incorrect data format from server (html)."
17905:       else:
17906:        return res, ""
17907:      else:
17908:       return "", "No data from server."
17909:     else:
17910:      return "", "No data received from server"
17911:    elif resCode == 401 : err = "Unauthorized"
17912:    elif resCode == 402 : err = "Payment Required"
17913:    elif resCode == 408 : err = "Request Timeout"
17914:    else    : err = "err=%d" % resCode
17915:    return "", err
17916:   except Exception as e:
17917:    return "", str(e)
17918:  @staticmethod
17919:  def VVRLKG(url):
17920:   uURL = uProtoc = uHost = uPort = uQuery = uUser = uPass = ""
17921:   modified = False
17922:   uQueryParam = {}
17923:   span  = iSearch(r"\s*(?:(.+):\/\/)*([^:^\/]*)(?::(\d*)\/)*\/*([^\?]*)\?*(.+)", url, IGNORECASE)
17924:   if span:
17925:    modified = True
17926:    uProtoc = span.group(1) or ""
17927:    uHost = span.group(2) or ""
17928:    uPort = span.group(3) or ""
17929:    uQuery = span.group(4) or ""
17930:    param = span.group(5) or ""
17931:    for part in param.split("&"):
17932:     if "=" in part:
17933:      if   part.lower().startswith("username"): uUser = part.split("=")[1]
17934:      elif part.lower().startswith("password"): uPass = part.split("=")[1]
17935:      parts = part.split("=")
17936:      key = parts[0]
17937:      val = parts[1]
17938:      uQueryParam[key] = val
17939:   if uProtoc : uProtoc += "://"
17940:   if uPort : uPort = ":" + uPort
17941:   uURL = "%s%s%s/" % (uProtoc, uHost, uPort)
17942:   return modified, uURL, uProtoc, uHost, uPort, uQuery, uUser, uPass, uQueryParam
17943:  @staticmethod
17944:  def VVNeuG(url, justValidate=False, getAudVid=False, compareType=None, compareExt=None, justRetDotExt=False):
17945:   res = scheme = netloc = path = params = query = fragment = username = password = hostname = port = ""
17946:   try:
17947:    if not iUrlparse(url).scheme:
17948:     url = url.lstrip("/")
17949:     url = "http://" + url
17950:    res   = iUrlparse(url)
17951:    scheme  = res.scheme
17952:    netloc  = res.netloc
17953:    path  = res.path
17954:    params  = res.params
17955:    query  = res.query
17956:    fragment = res.fragment
17957:    username = res.username or ""
17958:    password = res.password or ""
17959:    hostname = res.hostname or ""
17960:    port  = res.port  or ""
17961:   except:
17962:    pass
17963:   if justValidate:
17964:    return all([scheme, netloc, path])
17965:   tmpPath = path.strip("/")
17966:   if   path.startswith("/live/") : chType, tmpPath = "live" , path[6:]
17967:   elif path.startswith("/movie/") : chType, tmpPath = "vod" , path[7:]
17968:   elif path.startswith("/series/"): chType, tmpPath = "series", path[8:]
17969:   elif any(x in url for x in ("mode=itv", "/stream.", "/live."))     : chType = "live"
17970:   elif any(x in url for x in ("mode=vod", "/movie/", "/vod/", "/video/", ".m3u8")): chType = "vod"
17971:   elif "mode=series" in url  : chType = "series"
17972:   else       : chType = ""
17973:   parts = tmpPath.split("/")
17974:   if len(parts) >= 2:
17975:    username = parts[0]
17976:    password = parts[1]
17977:    if len(parts) > 2:
17978:     tmpPath  = "/".join(parts[2:])
17979:   parts  = tmpPath.split(":")
17980:   fileName = parts[0]
17981:   if len(parts) > 1: VV1wIO = ":".join(parts[1:])
17982:   elif ":" in query: VV1wIO = query.split(":")[1]
17983:   else    : VV1wIO = ""
17984:   streamId, dotExt = os.path.splitext(fileName)
17985:   ext = dotExt[1:]
17986:   if justRetDotExt:
17987:    return dotExt
17988:   if compareExt:
17989:    if compareExt == ext: return True
17990:    else    : return False
17991:   if getAudVid:
17992:    if ext:
17993:     tDict = CCHmnm.VViatp()
17994:     if   ext in list(tDict["mov"]): return "vid"
17995:     elif ext in list(tDict["mus"]): return "aud"
17996:    return ""
17997:   if streamId.isdigit():
17998:    if not chType :
17999:     if not ext              : chType = "live"
18000:     elif iSearch(r"(s\d\d.*e\d\d|e\d\d.*s\d\d)", VV1wIO, IGNORECASE): chType = "series"
18001:     else               : chType = "movie:"
18002:   else:
18003:    streamId = ""
18004:   if compareType is not None:
18005:    if compareType == chType: return True
18006:    else     : return False
18007:   else:
18008:    if scheme:
18009:     scheme += "://"
18010:    host = scheme + netloc
18011:    return chType, host, username, password, streamId, VV1wIO
18012:  @staticmethod
18013:  def VVZniM(VVZcRP):
18014:   return CCkEI5.VVNeuG(VVZcRP, justRetDotExt=True)
18015:  def VVGaR8(self, mode, url, Id="0"):
18016:   Id = str(Id).strip()
18017:   modified, uURL, uProtoc, uHost, uPort, uQuery, uUser, uPass, uQueryParam = self.VVRLKG(url)
18018:   url = "%splayer_api.php?username=%s&password=%s" % (uURL, uUser, uPass)
18019:   if   mode == self.VVJbaD   : return "%s"            % url
18020:   elif mode == self.VVgkvV   : return "%s&action=get_live_categories"     % url
18021:   elif mode == self.VVgL8R   : return "%s&action=get_vod_categories"      % url
18022:   elif mode == self.VV6cbr  : return "%s&action=get_series_categories"     % url
18023:   elif mode == self.VVspif  : return "%s&action=get_live_categories"     % url
18024:   elif mode == self.VVhkSg : return "%s&action=get_series_info&series_id=%s"   % (url, Id)
18025:   elif mode == self.VVXewY   : return "%s&action=get_live_streams&category_id=%s"  % (url, Id)
18026:   elif mode == self.VVw3vg    : return "%s&action=get_vod_streams&category_id=%s"   % (url, Id)
18027:   elif mode == self.VVtP50  : return "%s&action=get_series&category_id=%s"    % (url, Id)
18028:   elif mode == self.VVZUri : return "%s&action=get_live_streams"      % url
18029:   elif mode == self.VV4kmD  : return "%s&action=get_live_streams&category_id=%s"  % (url, Id)
18030:  @FFOAKH(par=1, clearMsg=False)
18031:  def VV57zg(self, VV6A99, title, path):
18032:   if FFCyVu(path):
18033:    enc = CC7ocD.VV51oT(path, self)
18034:    if enc == -1: return
18035:    qUrl = ""
18036:    with ioOpen(path, "r", encoding=enc) as f:
18037:     for line in f:
18038:      line = str(line).strip()
18039:      if not line or len(line) > 500: continue
18040:      qUrl = CCkEI5.VVyZOO(line)
18041:      if qUrl:
18042:       break
18043:    VV6A99.VVrmMb()
18044:    if qUrl : self.VVgCCs(VV6A99, title, qUrl)
18045:    else : FFdw58(self, "Invalid M3U line format in:\n\n%s" % path, title=title)
18046:   else:
18047:    FFdw58(self, "Cannot open file :\n\n%s" % path, title=title)
18048:  def VVsUXV(self):
18049:   title = "Current Channel Server"
18050:   qUrl, VVZcRP, VVfaDB = CCkEI5.VVs0fr(self)
18051:   if qUrl or "chCode" in VVfaDB:
18052:    p = CC96QG()
18053:    valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVGNGo(VVZcRP)
18054:    if valid:
18055:     self.VVAw1p(self, host, mac)
18056:     return
18057:    elif qUrl:
18058:     self.VVgCCs(self, title, qUrl)
18059:     return
18060:   FFdw58(self, "Error in current channel URL !", title=title)
18061:  @staticmethod
18062:  def VVs0fr(SELF):
18063:   VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(SELF)
18064:   qUrl = CCkEI5.VVyZOO(VVZcRP)
18065:   return qUrl, VVZcRP, VVfaDB
18066:  @staticmethod
18067:  def VVyZOO(url):
18068:   if url.startswith("#"):
18069:    return ""
18070:   url = url.strip(" /")
18071:   try: res = iUrlparse(url)
18072:   except: return ""
18073:   scheme = res.scheme
18074:   netloc = res.netloc
18075:   if not scheme or not netloc:
18076:    return ""
18077:   host = scheme + "://" +  netloc
18078:   path = res.path.strip("/")
18079:   if   path.startswith("live/") : path = path[5:]
18080:   elif path.startswith("movie/") : path = path[6:]
18081:   elif path.startswith("series/") : path = path[7:]
18082:   parts = path.split("/")
18083:   part = "%s/get.php?username=%s&password=%s&type=m3u"
18084:   if len(parts) == 3 and len(parts[0]) > 1:
18085:    return part % (host, parts[0], parts[1])
18086:   else:
18087:    data = CCkEI5.VV9F1k(url)
18088:    if data : return part % (data[0], data[1], data[2])
18089:    else : return ""
18090:  @FFOAKH("Checking Server ...", par=1)
18091:  def VVgCCs(self, SELF, title, url):
18092:   self.VV2rlK = url
18093:   self.VVfymn = {}
18094:   qUrl = self.VVGaR8(self.VVJbaD, url)
18095:   txt, err = self.VVzVZL(qUrl)
18096:   if err:
18097:    err = "Server Error:\n\n%s" % err
18098:   tDict = {}
18099:   if not err:
18100:    try: tDict = jLoads(txt)
18101:    except: pass
18102:    if not tDict:
18103:     err = "Could not parse server data !"
18104:   if tDict and not err:
18105:    self.VVfymn = {"playListURL": url}
18106:    if "user_info" in tDict and "server_info" in tDict:
18107:     item = tDict["user_info"]
18108:     self.VVfymn["username"    ] = FFYjVd(item, "username" )
18109:     self.VVfymn["password"    ] = FFYjVd(item, "password" )
18110:     self.VVfymn["message"    ] = FFYjVd(item, "message" )
18111:     self.VVfymn["auth"     ] = FFYjVd(item, "auth"  )
18112:     self.VVfymn["status"    ] = FFYjVd(item, "status"  )
18113:     self.VVfymn["exp_date"    ] = FFYjVd(item, "exp_date" , isDate=True)
18114:     self.VVfymn["is_trial"    ] = FFYjVd(item, "is_trial" )
18115:     self.VVfymn["active_cons"   ] = FFYjVd(item, "active_cons")
18116:     self.VVfymn["created_at"   ] = FFYjVd(item, "created_at" , isDate=True)
18117:     self.VVfymn["max_connections"  ] = FFYjVd(item, "max_connections")
18118:     self.VVfymn["allowed_output_formats"] = FFYjVd(item, "allowed_output_formats")
18119:     key = "allowed_output_formats"
18120:     val = item.get(key, None)
18121:     if isinstance(val, list):
18122:      self.VVfymn[key] = " , ".join(val)
18123:     item = tDict["server_info"]
18124:     self.VVfymn["url"    ] = FFYjVd(item, "url"   )
18125:     self.VVfymn["port"    ] = FFYjVd(item, "port"   )
18126:     self.VVfymn["https_port"  ] = FFYjVd(item, "https_port"  )
18127:     self.VVfymn["server_protocol" ] = FFYjVd(item, "server_protocol")
18128:     self.VVfymn["rtmp_port"   ] = FFYjVd(item, "rtmp_port"  )
18129:     self.VVfymn["timezone"   ] = FFYjVd(item, "timezone"  )
18130:     self.VVfymn["timestamp_now"  ] = FFYjVd(item, "timestamp_now" , isDate=True)
18131:     self.VVfymn["time_now"   ] = FFYjVd(item, "time_now"  )
18132:     VV3wat  = self.VVafii(True)
18133:     VVOa1G = self.VVegLh
18134:     VVJbOd = BF(self.VV49j5, 0)
18135:     VVHGnw = ("Home Menu" , FF8lJ1)
18136:     VVwJOl = ("Resources" , self.VV2jvq)
18137:     VVB4pu= ("Add to Menu", BF(CCkEI5.VVoyt7, self, False, self.VVfymn["playListURL"]))
18138:     VVaTeF = ("Bookmark" , BF(CCkEI5.VVwOWK, self, False, self.VVfymn["playListURL"]))
18139:     VV7tND = FFLFTC(self, None, title="IPTV Server Resources", VV3wat=VV3wat, VVOa1G=VVOa1G, VVJbOd=VVJbOd, VVHGnw=VVHGnw, VVwJOl=VVwJOl, VVB4pu=VVB4pu, VVaTeF=VVaTeF)
18140:     self.VVX4OZ(VV7tND)
18141:    else:
18142:     err = "Cannot get User-Data from server !"
18143:   if err:
18144:    FFdw58(self, err, title=title)
18145:   FF28n1(self)
18146:  def VVegLh(self, item=None):
18147:   if item:
18148:    VV7tND, title, ref, ndx = item
18149:    if   ref == "live"   : self.VVQ18M(VV7tND, self.VVgkvV , title=title)
18150:    elif ref == "vod"   : self.VVQ18M(VV7tND, self.VVgL8R , title=title)
18151:    elif ref == "series"  : self.VVQ18M(VV7tND, self.VV6cbr , title=title)
18152:    elif ref == "catchup"  : self.VVQ18M(VV7tND, self.VVspif, title=title)
18153:    elif ref == "accountInfo" : FFimQ3(VV7tND, BF(self.VVfi5g, title=title))
18154:  def VVX4OZ(self, VV7tND):
18155:   dUrl = CC3rDi(self.session).VVZcRP
18156:   if   FF1BEt(dUrl): VV7tND.VVx2yy(2)
18157:   elif FFKxIH(dUrl) : VV7tND.VVx2yy(1)
18158:  @FFOAKH(par=2)
18159:  def VV49j5(self, isPortal, VV7tND, txt, ref, ndx):
18160:   txt  = "%s\n\n" % self.VV2rlK
18161:   if isPortal:
18162:    tab  = lambda x, y: "%s\t: %s\n" % (x, y)
18163:    wServ = self.VViTWL()
18164:    if wServ:
18165:     txt += tab("Web Server", wServ)
18166:    if VVBvqf:
18167:     ver, err = self.VVI5kn(self.VVTr19())
18168:     txt += tab("Original", self.VV2rlK)
18169:     txt += tab("Modified", self.VVncdQ)
18170:     txt += tab("PHP"  , self.VVxRkD)
18171:     txt += tab("Extra"  , {2:"Big", 3:"Sml"}.get(self.VVdDpE, "-"))
18172:     txt += tab("Version" , (ver or err))
18173:     txt += "\n%s\n..\tBig\n...\tSml\nBlank\t/s/l.p\n+\t/p.p\n++\t/p1.p\n*\tModed" % SEP
18174:   FF4lCP(self, txt, title="Current Server")
18175:  def VVfi5g(self, title):
18176:   rows = []
18177:   for key, val in self.VVfymn.items():
18178:    if isinstance(val, list): val = str(" , ".join(val))
18179:    else     : val = str(val)
18180:    if any(x in key for x in ("url", "port", "https_port", "server_protocol", "rtmp_port", "timezone", "timestamp_now", "time_now")):
18181:     num, part = "2", self.VVIrBX
18182:    else:
18183:     num, part = "1", self.VVnS6i
18184:    rows.append((num, part, str(key).replace("_", " ").title(), str(val)))
18185:   rows.sort(key=lambda x: (x[0], x[2]))
18186:   VVwWmA  = ("Home Menu", FF8lJ1, [])
18187:   VVwSzI  = None
18188:   if VVBvqf:
18189:    VVwSzI = ("Get JS" , BF(self.VV7Vtg, "/".join(self.VVfymn["playListURL"].split("/")[:-1])), [])
18190:   header    = ("Num", "User/Server" , "Subject" , "Value" )
18191:   widths    = (0 , 15   , 35  , 50  )
18192:   FFUQ0v(self, None, title=title, width=1200, header=header, VVGape=rows, VV3cHe=widths, VVwdmN=26, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVwltY="#0a00292B", VVkxBG="#0a002126", VVemyB="#0a002126", VVJKqd="#00000000", VVMfsO=2)
18193:  def VVmYeb(self, mode, jData):
18194:   list = []
18195:   err  = ""
18196:   try:
18197:    tDict = jLoads(jData)
18198:    if tDict:
18199:     if mode in (self.VVXewY, self.VV4kmD):
18200:      for ndx, item in enumerate(tDict, start=1):
18201:       num      = FFYjVd(item, "num"     )
18202:       name     = FFYjVd(item, "name"     )
18203:       stream_id    = FFYjVd(item, "stream_id"   )
18204:       stream_icon    = FFYjVd(item, "stream_icon"   )
18205:       epg_channel_id   = FFYjVd(item, "epg_channel_id"  )
18206:       added     = FFYjVd(item, "added"    , isDate=True)
18207:       is_adult    = FFYjVd(item, "is_adult"    )
18208:       category_id    = FFYjVd(item, "category_id"   )
18209:       tv_archive    = FFYjVd(item, "tv_archive"   )
18210:       direct_source   = FFYjVd(item, "direct_source"  )
18211:       archDur     = FFYjVd(item, "tv_archive_duration" )
18212:       name = self.VVcBrZ(name, censored=is_adult)
18213:       if name:
18214:        if mode == self.VVXewY or mode == self.VV4kmD and tv_archive == "1":
18215:         hasPicon = "Yes" if stream_icon else ""
18216:         VVArDB = "Yes" if tv_archive == "1" else ""
18217:         if archDur:
18218:          if archDur.isdigit():
18219:           tot = int(archDur)
18220:           if tot > 0: VVArDB = "%s day%s" % (tot, FFcacr(tot))
18221:          else:
18222:           VVArDB = archDur
18223:         list.append((num, name, category_id, stream_id, stream_icon, added, epg_channel_id, is_adult, hasPicon, VVArDB, direct_source))
18224:     elif mode == self.VVw3vg:
18225:      for ndx, item in enumerate(tDict, start=1):
18226:       num     = FFYjVd(item, "num"     )
18227:       name    = FFYjVd(item, "name"     )
18228:       stream_id   = FFYjVd(item, "stream_id"   )
18229:       stream_icon   = FFYjVd(item, "stream_icon"   )
18230:       added    = FFYjVd(item, "added"    , isDate=True)
18231:       is_adult   = FFYjVd(item, "is_adult"    )
18232:       category_id   = FFYjVd(item, "category_id"   )
18233:       container_extension = FFYjVd(item, "container_extension" ) or "mp4"
18234:       name = self.VVcBrZ(name, censored=is_adult)
18235:       if name:
18236:        isPicon = "Yes" if stream_icon else ""
18237:        list.append((num, name, category_id, stream_id, stream_icon, added, is_adult, container_extension, isPicon))
18238:     elif mode == self.VVtP50:
18239:      for ndx, item in enumerate(tDict, start=1):
18240:       num     = FFYjVd(item, "num"     )
18241:       name    = FFYjVd(item, "name"     )
18242:       series_id   = FFYjVd(item, "series_id"   )
18243:       cover    = FFYjVd(item, "cover"    )
18244:       genre    = FFYjVd(item, "genre"    )
18245:       episode_run_time = FFYjVd(item, "episode_run_time"  )
18246:       category_id   = FFYjVd(item, "category_id"   )
18247:       container_extension = FFYjVd(item, "container_extension" ) or "mp4"
18248:       name = self.VVcBrZ(name)
18249:       if name:
18250:        isPicon = "Yes" if cover else ""
18251:        list.append((num, name, category_id, series_id, genre, episode_run_time, container_extension, cover, isPicon))
18252:   except:
18253:    err = "Cannot parse received data !"
18254:   return list, err
18255:  @FFOAKH("Downloading ...", par=1)
18256:  def VVQ18M(self, VV7tND, mode, title):
18257:   cList, err = self.VVzrt7(mode)
18258:   if cList and mode == self.VVspif:
18259:    cList = self.VVGTjd(cList)
18260:   if err:
18261:    FFdw58(self, err, title=title)
18262:   elif cList:
18263:    cList.sort(key=lambda x: x[0].lower())
18264:    self.VVLp7F = dict([(x[1], x[0]) for x in cList])
18265:    VVwltY, VVkxBG, VVemyB, VVJKqd = self.VVxV5D(mode)
18266:    mName = self.VVdGiv(mode)
18267:    if   mode == self.VVgkvV  : fMode = self.VVXewY
18268:    elif mode == self.VVgL8R  : fMode = self.VVw3vg
18269:    elif mode == self.VV6cbr : fMode = self.VVtP50
18270:    elif mode == self.VVspif : fMode = self.VV4kmD
18271:    if mode == self.VVspif:
18272:     VVScQz = None
18273:     VV4QTJ = None
18274:    else:
18275:     VVScQz = ("Find in %s" % mName , BF(self.VVjRkU, fMode, True) , [])
18276:     VV4QTJ = ("Find in Selected" , BF(self.VVjRkU, fMode, False) , [])
18277:    VVu1YM   = ("Show List"   , BF(self.VVbiGO, mode)  , [])
18278:    VVwWmA  = ("Home Menu"   , FF8lJ1         , [])
18279:    header   = ("Category Name", "catID","Parent ID", "Server Default Sorting" )
18280:    widths   = (100, 0, 0, 0.02)
18281:    FFUQ0v(self, None, title=title, width=1200, header=header, VVGape=cList, VV3cHe=widths, VVwdmN=30, VV8LLn=True, VVwWmA=VVwWmA, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVu1YM=VVu1YM, VVwltY=VVwltY, VVkxBG=VVkxBG, VVemyB=VVemyB, VVJKqd=VVJKqd, VVSLOq=CFG.lastFindIptv)
18282:   else:
18283:    FFdw58(self, "No list from server !", title=title)
18284:   FF28n1(self)
18285:  def VVzrt7(self, mode, url=None, chkAdult=True):
18286:   qUrl  = self.VVGaR8(mode, url or self.VVfymn["playListURL"])
18287:   timeout = 20 if mode in (self.VVgkvV, self.VVspif) else 3
18288:   txt, err = self.VVzVZL(qUrl, timeout=timeout)
18289:   if err:
18290:    return [], "Server Error:\n\n" + err
18291:   list = []
18292:   try:
18293:    tDict = jLoads(txt)
18294:    if tDict:
18295:     c = 0
18296:     for item in tDict:
18297:      category_id  = FFYjVd(item, "category_id" )
18298:      category_name = FFYjVd(item, "category_name")
18299:      parent_id  = FFYjVd(item, "parent_id" )
18300:      if chkAdult: category_name = self.VV1vXv(category_name)
18301:      if category_name:
18302:       c += 1
18303:       list.append((category_name, category_id, parent_id, str(c)))
18304:   except:
18305:    return "", "Cannot parse received data !"
18306:   return list, ""
18307:  def VVGTjd(self, catList):
18308:   mode = self.VV4kmD
18309:   qUrl = self.VVGaR8(mode, self.VVfymn["playListURL"])
18310:   txt, err= self.VVzVZL(qUrl)
18311:   chanList= []
18312:   if err:
18313:    return []
18314:   chanList, err = self.VVmYeb(mode, txt)
18315:   newCatList = []
18316:   for cat in catList:
18317:    for ch in chanList:
18318:     if cat[1] == ch[2] and not cat in newCatList:
18319:      newCatList.append(cat)
18320:   return newCatList
18321:  @FFOAKH("Downloading ...", par=2)
18322:  def VVbiGO(self, mode, VV6A99, title, txt, colList):
18323:   bName  = colList[0]
18324:   catID  = colList[1]
18325:   parentID = colList[2]
18326:   title = self.VVdGiv(mode) + " : "+ bName
18327:   if   mode == self.VVgkvV  : mode = self.VVXewY
18328:   elif mode == self.VVgL8R  : mode = self.VVw3vg
18329:   elif mode == self.VV6cbr : mode = self.VVtP50
18330:   elif mode == self.VVspif : mode = self.VV4kmD
18331:   qUrl  = self.VVGaR8(mode, self.VVfymn["playListURL"], catID)
18332:   txt, err = self.VVzVZL(qUrl, timeout=20)
18333:   list  = []
18334:   if not err and mode in (self.VVXewY, self.VVw3vg, self.VVtP50, self.VV4kmD):
18335:    list, err = self.VVmYeb(mode, txt)
18336:   if err:
18337:    FFdw58(self, err, title=title)
18338:   elif list:
18339:    VVwWmA  = ("Home Menu"   , FF8lJ1            , [])
18340:    if mode in (self.VVXewY, self.VV4kmD):
18341:     VVwltY, VVkxBG, VVemyB, VVJKqd = self.VVxV5D(mode)
18342:     VV2ytr = (""     , BF(self.VVMxey, mode)      , [])
18343:     VVwSzI = ("Download Options" , BF(self.VVnHDd, mode, "", "")   , [])
18344:     VVScQz = ("Options"   , BF(self.VVCbC2, "lv", mode, bName)   , [])
18345:     VV4QTJ = ("Posters Mode"  , BF(self.VVTdR5, mode, False)     , [])
18346:     VVu1YM  = ("Play"    , BF(self.VVF9cb, mode)       , [])
18347:    elif mode == self.VVw3vg:
18348:     VVwltY, VVkxBG, VVemyB, VVJKqd = self.VVxV5D(mode)
18349:     VVu1YM  = ("Play"    , BF(self.VVF9cb, mode)       , [])
18350:     VV2ytr = (""     , BF(self.VVMxey, mode)      , [])
18351:     VVwSzI = ("Download Options" , BF(self.VVnHDd, mode, "v", "")   , [])
18352:     VVScQz = ("Options"   , BF(self.VVCbC2, "v", mode, bName)   , [])
18353:     VV4QTJ = ("Posters Mode"  , BF(self.VVTdR5, mode, False)     , [])
18354:    elif mode == self.VVtP50:
18355:     VVwltY, VVkxBG, VVemyB, VVJKqd = self.VVxV5D("series2")
18356:     VVu1YM  = ("Show Seasons"  , BF(self.VVhnCl, mode)       , [])
18357:     VV2ytr = (""     , BF(self.VVotEo, mode)     , [])
18358:     VVwSzI = None
18359:     VVScQz = None
18360:     VV4QTJ = ("Posters Mode"  , BF(self.VVTdR5, mode, True)      , [])
18361:    header, widths, VVLIqP = self.VVlJdN(mode)
18362:    FFUQ0v(self, None, title=title, header=header, VVGape=list, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVu1YM=VVu1YM, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVSLOq=CFG.lastFindIptv, VV2ytr=VV2ytr, VVwltY=VVwltY, VVkxBG=VVkxBG, VVemyB=VVemyB, VVJKqd=VVJKqd, VVHPI7=True, VVMfsO=1)
18363:   else:
18364:    FFdw58(self, "No Channels found !", title=title)
18365:   FF28n1(self)
18366:  def VVlJdN(self, mode):
18367:   if mode in (self.VVXewY, self.VV4kmD):
18368:    header   = ("Num" , "Name", "catID", "ID"  , "Icon" , "Added" , "epgID" , "Is Adult", "Logo", "Catch-up", "Link")
18369:    widths   = (8  , 55  , 0   , 0   , 0  , 22  , 0   , 0   , 6  , 9   , 0.03 )
18370:    VVLIqP  = (CENTER, LEFT  , CENTER , CENTER, LEFT , CENTER , CENTER , CENTER , CENTER, CENTER , CENTER)
18371:   elif mode == self.VVw3vg:
18372:    header   = ("Num" , "Name", "catID", "ID"  , "Icon" , "Added" , "isAdult" , "Ext" , "Logo")
18373:    widths   = (8  , 62  , 0   , 0   , 0  , 24  , 0   , 0  , 6  )
18374:    VVLIqP  = (CENTER, LEFT  , CENTER , CENTER, LEFT , CENTER , CENTER , CENTER, CENTER)
18375:   elif mode == self.VVtP50:
18376:    header   = ("Num" , "Name", "catID", "ID"  , "Genre" , "Dur.", "Ext" , "Cover" , "Logo" )
18377:    widths   = (8  , 56  , 0   , 0   , 30  , 0  , 0  , 0   , 6   )
18378:    VVLIqP  = (CENTER, LEFT  , LEFT   , CENTER , LEFT , CENTER, CENTER, LEFT  , CENTER )
18379:   return header, widths, VVLIqP
18380:  @FFOAKH("Downloading ...", par=2)
18381:  def VVhnCl(self, mode, VV6A99, title, txt, colList):
18382:   title = colList[1]
18383:   list, err = self.VVdLhN(colList[3])
18384:   if err:
18385:    FFdw58(self, err, title=title)
18386:   elif list:
18387:    VVwltY, VVkxBG, VVemyB, VVJKqd = CCkEI5.VVxV5D("")
18388:    VVwWmA = ("Home Menu"   , FF8lJ1          , [])
18389:    VVwSzI = ("Download Options" , BF(self.VVnHDd, mode, "s", title), [])
18390:    VVScQz = ("Options"   , BF(self.VVCbC2, "s", mode, title) , [])
18391:    VV4QTJ = ("Posters Mode"  , BF(self.VVTdR5, mode, False)   , [])
18392:    VV2ytr = (""     , BF(self.VVMxey, mode)    , [])
18393:    VVu1YM  = ("Play"    , BF(self.VVF9cb, mode)     , [])
18394:    header   = ("Season" , "Episode" , "Title" , "catID" , "stID", "Icon", "Ext" )
18395:    widths   = (10  , 10  , 80  , 0   , 0  , 0  , 0  )
18396:    VVLIqP  = (CENTER , CENTER , LEFT  , CENTER , CENTER, LEFT , CENTER)
18397:    FFUQ0v(self, None, title=title, header=header, VVGape=list, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVu1YM=VVu1YM, VV2ytr=VV2ytr, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVSLOq=CFG.lastFindIptv, VVwltY=VVwltY, VVkxBG=VVkxBG, VVemyB=VVemyB, VVJKqd=VVJKqd)
18398:   else:
18399:    FFdw58(self, "No Channels found !", title=title)
18400:   FF28n1(self)
18401:  def VVdLhN(self, series_id, url=None):
18402:   qUrl  = self.VVGaR8(self.VVhkSg, url or self.VVfymn["playListURL"], series_id)
18403:   txt, err = self.VVzVZL(qUrl)
18404:   list  = []
18405:   if not err:
18406:    list = []
18407:    err  = ""
18408:    try:
18409:     tDict = jLoads(txt)
18410:     if tDict:
18411:      title  = "Seasons"
18412:      category_id = "222"
18413:      icon  = ""
18414:      if "info" in tDict:
18415:       sName  = FFYjVd(tDict["info"], "name"  )
18416:       category_id = FFYjVd(tDict["info"], "category_id" )
18417:       icon  = FFYjVd(tDict["info"], "cover"  )
18418:      if "episodes" in tDict:
18419:       seasons = tDict["episodes"]
18420:       for season in seasons:
18421:        item = seasons[season]
18422:        for EP in item:
18423:         stream_id   = FFYjVd(EP, "id"     )
18424:         episode_num   = FFYjVd(EP, "episode_num"  )
18425:         epTitle    = FFYjVd(EP, "title"    )
18426:         container_extension = FFYjVd(EP, "container_extension")
18427:         seasonNum   = FFYjVd(EP, "season"    )
18428:         sName = self.VVcBrZ(sName)
18429:         epTitle = self.VVcBrZ(epTitle)
18430:         epTitle = self.VVAcpQ(series_id, sName, epTitle, seasonNum, episode_num)
18431:         list.append((seasonNum, episode_num, epTitle, category_id, stream_id, icon, container_extension))
18432:    except:
18433:     err = "Cannot parse received data !"
18434:   return list, err
18435:  def VVAcpQ(self, catID, sName, eName, sNum, eNum):
18436:   SeEp = ( "S%.2dE%.2d (%s)" % (int(sNum), int(eNum), catID) ) if sNum.isdigit() and eNum.isdigit() else ""
18437:   prefix = sName + " " + SeEp
18438:   patt = r"(S\d{1,3}\W*E\d{1,3})|(E\d{1,3}\W*S\d{1,3})"
18439:   if eName.lower().startswith(sName.lower()):
18440:    eName = sName + eName[len(sName):]
18441:   if iMatch(r"^%s" % patt, eName, IGNORECASE):
18442:    return iSub(patt, prefix, eName, flags=IGNORECASE)
18443:   elif not eName.startswith(sName):
18444:    return prefix + " " + eName
18445:   elif eName.startswith(sName):
18446:    eName, tot = iSubn(patt, SeEp, eName, flags=IGNORECASE)
18447:    if tot : return eName
18448:    else : return prefix + " " + eName[len(sName):].strip()
18449:   return eName
18450:  def VVLk4s(self, ser, hst, usr, pas, title):
18451:   typ = "LVS" if ser else "LV"
18452:   outF = "%s%s_%s_%s.m3u" % (FF7BT0(), FFOu5Y(iUrlparse(hst).hostname), typ, FFjTQe())
18453:   CCh3tv.VV7Nf4(self, VVLL7M="Reading Categories ...", totBars=2
18454:       , VVixvy  = BF(self.VVOuIu, ser, hst, usr, pas, outF, title)
18455:       , VVbYwR = BF(self.VVLKJF, ser, outF, title))
18456:  def VVOuIu(self, ser, hst, usr, pas, outF, title, VVXyP6):
18457:   VVXyP6.VVq8NF(7)
18458:   self._tDic = {"totL": 0, "totV": 0, "totS": 0, "addL": 0, "addV": 0, "addS": 0, "addEp": 0, "err": ""}
18459:   lCat, vCat, sCat = {}, {}, {}
18460:   srcs = ("Live", "VOD", "Series")
18461:   catMode = [self.VVgkvV, self.VVgL8R, self.VV6cbr]
18462:   modes = [self.VVXewY, self.VVw3vg, self.VVtP50]
18463:   acts = ["get_live_streams", "get_vod_streams", "get_series"]
18464:   if not ser: catMode, modes, acts = catMode[:2], modes[:2], acts[:2]
18465:   url  = "%s/player_api.php?username=%s&password=%s" % (hst, usr, pas)
18466:   catErr = ""
18467:   for mode in catMode:
18468:    if not VVXyP6 or VVXyP6.isCancelled: return
18469:    VVXyP6.VVxtQs(1)
18470:    lst, err = self.VVzrt7(mode, url=url, chkAdult=False)
18471:    catErr = err or catErr
18472:    if not lst: continue
18473:    dic = {Id: nm for nm, Id, pId, num in lst}
18474:    if dic:
18475:     if  mode == self.VVgkvV  : lCat = dic
18476:     elif mode == self.VVgL8R  : vCat = dic
18477:     elif mode == self.VV6cbr: sCat = dic
18478:   cats = [lCat, vCat, sCat]
18479:   if not ser: cats = cats[:2]
18480:   if not any((lCat, vCat, sCat)):
18481:    self._tDic["err"] = catErr or "Cannot read categories."
18482:    return
18483:   with open(outF, "w") as f:
18484:    f.write("#EXTM3U\n")
18485:    for mode, src, catLst, act in tuple(zip(modes, srcs, cats, acts)):
18486:     if not VVXyP6 or VVXyP6.isCancelled: return
18487:     VVXyP6.VVaks5("Reading %s ..." % src)
18488:     VVXyP6.VVxtQs(1)
18489:     VVXyP6.VVV3RA(0)
18490:     txt, err = self.VVzVZL("%s&action=%s" % (url, act), timeout=20)
18491:     if txt:
18492:      lst, err = self.VVmYeb(mode, txt)
18493:      if not lst: continue
18494:     else:
18495:      continue
18496:     tot = len(lst)
18497:     if  mode == self.VVXewY : self._tDic["totL"] = tot
18498:     elif mode == self.VVw3vg  : self._tDic["totV"] = tot
18499:     elif mode == self.VVtP50 : self._tDic["totS"] = tot
18500:     if not VVXyP6 or VVXyP6.isCancelled: return
18501:     VVXyP6.VVaks5("Saving %s ..." % src)
18502:     VVXyP6.VVUIH1(len(lst))
18503:     VVXyP6.VVV3RA(0)
18504:     for row in lst:
18505:      if not VVXyP6 or VVXyP6.isCancelled: return
18506:      VVXyP6.VVg2Dw(1)
18507:      colList = list(map(str.strip, row))
18508:      if mode in (self.VVXewY, self.VVw3vg):
18509:       if mode == self.VVXewY:
18510:        num, name, category_id, stream_id, stream_icon, added, epg_channel_id, is_adult, hasPicon, VVArDB, direct_source = colList
18511:        VVfbmn, ext, uCat = stream_icon, "", ""
18512:       elif mode == self.VVw3vg:
18513:        num, name, category_id, stream_id, stream_icon, added, is_adult, container_extension, isPicon = colList
18514:        VVfbmn, ext, uCat = stream_icon, "." + container_extension, "movie/"
18515:       catNm = catLst.get(category_id, "")
18516:       catNm = (' group-title="%s"' % catLst[category_id]) if category_id in catLst else ""
18517:       pUrl  = (' tvg-logo="%s"' % VVfbmn) if VVfbmn else ""
18518:       chUrl = "%s/%s%s/%s/%s%s" % (hst, uCat, usr, pas, stream_id, ext)
18519:       f.write('
18520:       f.write("%s\n" % chUrl)
18521:       if mode == self.VVXewY : self._tDic["addL"] += 1
18522:       elif mode == self.VVw3vg : self._tDic["addV"] += 1
18523:      else:
18524:       num, name, category_id, series_id, genre, episode_run_time, container_extension, cover, isPicon = row
18525:       seLst, err = self.VVdLhN(series_id, url=url)
18526:       if not seLst: continue
18527:       addSer = 0
18528:       for ep in seLst:
18529:        if not VVXyP6 or VVXyP6.isCancelled: return
18530:        seasonNum, episode_num, epTitle, category_id, stream_id, icon, container_extension = list(map(str.strip, ep))
18531:        pUrl = (' tvg-logo="%s"' % cover) if cover else ""
18532:        chUrl= "%s/series/%s/%s/%s.%s" % (hst, usr, pas, stream_id, container_extension)
18533:        f.write('#EXTINF:-1 group-title="%s"%s,%s (SE%s:EP%s)\n' % (name, pUrl, name, seasonNum, episode_num))
18534:        f.write("%s\n" % chUrl)
18535:        if not VVXyP6 or VVXyP6.isCancelled: return
18536:        self._tDic["addEp"] += 1
18537:        addSer = 1
18538:       self._tDic["addS"] += addSer
18539:  def VVLKJF(self, ser, outF, title, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
18540:   d = self._tDic
18541:   totL, totV, totS, addL, addV, addS, addEp = d["totL"], d["totV"], d["totS"], d["addL"], d["addV"], d["addS"], d["addEp"]
18542:   if VVRI6P: txt = ""
18543:   else   : txt = "%s\n\n" % FFjt5L("Process stopped.", VVIH76)
18544:   if (addL + addV + addS + addEp) > 0:
18545:    txt += "Added Live\t: %s%s\n" % (addL, (" of %s" % totL) if (addL != totL) else "")
18546:    txt += "Added VOD\t: %s%s\n"  % (addV, (" of %s" % totV) if (addV != totV) else "")
18547:    if ser: txt += "Added Series\t: %s%s  ( Episodes : %s )\n" % (addS, (" of %s" % totS) if (addS != totS) else "", addEp)
18548:    if FFCyVu(outF): txt += "\n%s\n%s" % (FFjt5L("Saved to:", VVJEMb), outF)
18549:    FF4lCP(self, txt, title)
18550:   elif d["err"]:
18551:    FFdw58(self, d["err"], title)
18552:    FFwgGB(outF)
18553:   else:
18554:    FFwgGB(outF)
18555:  def VVjRkU(self, mode, isAll, VV6A99, title, txt, colList):
18556:   onlyCatID = None if isAll else colList[1]
18557:   VV3wat = []
18558:   VV3wat.append(("Keyboard"  , "manualEntry"))
18559:   VV3wat.append(("From Filter" , "fromFilter"))
18560:   FFLFTC(self, BF(self.VVliHG, VV6A99, mode, onlyCatID), title="Input Type", VV3wat=VV3wat, width=400)
18561:  def VVliHG(self, VV6A99, mode, onlyCatID, item=None):
18562:   if item == "manualEntry":
18563:    FF4z45(self, BF(self.VV9OZ2, VV6A99, mode, onlyCatID), defaultText=CFG.lastFindIptv.getValue(), title="Find", message="Enter Name (or names separated by a comma)")
18564:   elif item == "fromFilter":
18565:    filterObj = CCoErY(self)
18566:    filterObj.VVVPGN(BF(self.VV9OZ2, VV6A99, mode, onlyCatID))
18567:  def VV9OZ2(self, VV6A99, mode, onlyCatID, item):
18568:   if not item is None:
18569:    title = "Find in names"
18570:    words = None
18571:    toFind = item.strip()
18572:    FFjt1c(CFG.lastFindIptv, toFind)
18573:    if toFind:
18574:     words, asPrefix = CCoErY.VVPBNm(toFind)
18575:     if words:
18576:      if len(words) == 1 and len(words[0]) < 3:
18577:       FFdw58(self, "Enter at least 3 characters.", title=title)
18578:       return
18579:      else:
18580:       for word in words:
18581:        if len(word) < 3:
18582:         FFdw58(self, "All words must be at least 3 characters !", title=title)
18583:         return
18584:      if CFG.hideIptvServerAdultWords.getValue() and self.VVZI1i(words):
18585:       FFdw58(self, self.VVmBMi(), title="Find: %s" % " , ".join(words))
18586:       return
18587:      else:
18588:       CCh3tv.VV7Nf4(self, VVLL7M="Searching for:%s" % toFind[:15], totBars=2
18589:           , VVixvy  = BF(self.VVP3Pw, VV6A99, mode, onlyCatID, title, words, toFind, asPrefix)
18590:           , VVbYwR = BF(self.VViBDc, mode, toFind, title))
18591:    if not words:
18592:     FF28n1(VV6A99, "Nothing to find !", 1500)
18593:  def VVP3Pw(self, VV6A99, mode, onlyCatID, title, words, toFind, asPrefix, VVXyP6):
18594:   VVXyP6.VVq8NF(VV6A99.VVn1uo() if onlyCatID is None else 1)
18595:   VVXyP6.VVNc18 = []
18596:   for row in VV6A99.VVrrm9():
18597:    catName = row[0]
18598:    catID = row[1]
18599:    if not onlyCatID is None and not catID == onlyCatID:
18600:     continue
18601:    if not VVXyP6 or VVXyP6.isCancelled: return
18602:    VVXyP6.VVxtQs(1)
18603:    VVXyP6.VVV3RA(0)
18604:    VVXyP6.VVSW9b(catName)
18605:    qUrl = self.VVGaR8(mode, self.VVfymn["playListURL"], catID)
18606:    txt, err= self.VVzVZL(qUrl, timeout=20)
18607:    if not err:
18608:     tList, err = self.VVmYeb(mode, txt)
18609:     if tList:
18610:      if not VVXyP6 or VVXyP6.isCancelled: return
18611:      VVXyP6.VVUIH1(len(tList))
18612:      for item in tList:
18613:       if not VVXyP6 or VVXyP6.isCancelled: return
18614:       VVXyP6.VVg2Dw(1)
18615:       name = item[1].strip().lower()
18616:       name = self.VVcBrZ(name)
18617:       if name:
18618:        if asPrefix and not name.startswith(words) : continue
18619:        elif any(x in name for x in words)   : pass
18620:        else          : continue
18621:        if not VVXyP6 or VVXyP6.isCancelled:
18622:         return
18623:        VVXyP6.VVNc18.append(item)
18624:        VVXyP6.VVSW9b(catName)
18625:  def VViBDc(self, mode, toFind, title, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
18626:   if VVNc18:
18627:    title = self.VVvwJ7(mode, toFind)
18628:    VVwltY, VVkxBG, VVemyB, VVJKqd = self.VVxV5D(mode)
18629:    if mode == self.VVXewY or mode == self.VVw3vg:
18630:     if mode == self.VVw3vg : typ = "v"
18631:     else          : typ = ""
18632:     bName   = CCkEI5.VVPjQO(toFind)
18633:     VVu1YM  = ("Play"     , BF(self.VVF9cb, mode)     , [])
18634:     VVwSzI = ("Download Options" , BF(self.VVnHDd, mode, typ, "") , [])
18635:     VVScQz = ("Options"   , BF(self.VVCbC2, "fnd", mode, bName), [])
18636:     VV4QTJ = ("Posters Mode"  , BF(self.VVTdR5, mode, False)   , [])
18637:     VV2ytr = (""     , BF(self.VVMxey, mode)    , [])
18638:    elif mode == self.VVtP50:
18639:     VVwltY, VVkxBG, VVemyB, VVJKqd = self.VVxV5D("series2")
18640:     VVu1YM  = ("Show Seasons"  , BF(self.VVhnCl, mode)     , [])
18641:     VVScQz = None
18642:     VVwSzI = None
18643:     VV4QTJ = ("Posters Mode"  , BF(self.VVTdR5, mode, True)    , [])
18644:     VV2ytr = (""     , BF(self.VVotEo, mode)   , [])
18645:    VVwWmA  = ("Home Menu"   , FF8lJ1          , [])
18646:    header, widths, VVLIqP = self.VVlJdN(mode)
18647:    VV6A99 = FFUQ0v(self, None, title=title, header=header, VVGape=VVNc18, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVu1YM=VVu1YM, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VV2ytr=VV2ytr, VVwltY=VVwltY, VVkxBG=VVkxBG, VVemyB=VVemyB, VVJKqd=VVJKqd, VVHPI7=True, VVMfsO=1)
18648:    if not VVRI6P:
18649:     FF28n1(VV6A99, "Stopped" , 1000)
18650:   else:
18651:    if VVRI6P:
18652:     FFdw58(self, "Not found in names !\n\n( %s )" % toFind, title=title)
18653:  def VVK5K0(self, mode, colList):
18654:   colList = list(map(str.strip, colList))
18655:   if mode in (self.VVXewY, self.VV4kmD):
18656:    num, name, category_id, stream_id, stream_icon, added, epg_channel_id, is_adult, hasPicon, VVArDB, direct_source = colList
18657:    chNum, VV1wIO, catID, stID, VVfbmn, ext, uCat = num, name, category_id, stream_id, stream_icon, "", ""
18658:   elif mode == self.VVw3vg:
18659:    num, name, category_id, stream_id, stream_icon, added, is_adult, container_extension, isPicon = colList
18660:    chNum, VV1wIO, catID, stID, VVfbmn, ext, uCat = num, name, category_id, stream_id, stream_icon, "." + container_extension, "movie/"
18661:   else:
18662:    seasonNum, episode_num, epTitle, category_id, stream_id, icon, container_extension = colList
18663:    chNum, VV1wIO, catID, stID, VVfbmn, ext, uCat = "222", epTitle, category_id, stream_id, icon, "." + container_extension, "series/"
18664:   VV1wIO = FFd1WZ(VV1wIO)
18665:   url = self.VVfymn["playListURL"]
18666:   modified, uURL, uProtoc, uHost, uPort, uQuery, uUser, uPass, uQueryParam = self.VVRLKG(url)
18667:   VVPxk5 = self.VVpX1r(catID, stID, chNum)
18668:   chUrl = "%s%s%s/%s/%s%s"  % (uURL, uCat, uUser, uPass, stID, ext)
18669:   chUrl = chUrl.replace(":", "%3a")
18670:   chUrl = VVPxk5 + chUrl + ":" + VV1wIO
18671:   return VV1wIO, chUrl, VVfbmn, VVPxk5
18672:  def VVMxey(self, mode, VV6A99, title, txt, colList):
18673:   if mode in (self.VVXewY, self.VV4kmD): catID = colList[2]
18674:   elif mode == self.VVw3vg          : catID = colList[2]
18675:   else                   : catID = colList[3]
18676:   catName = self.VVLp7F.get(catID, "")
18677:   if catName:
18678:    txt = txt.strip() + "\nCategory\t: %s" % catName
18679:   self.VV19VQ(mode, VV6A99, title, txt, colList)
18680:  @FFOAKH(par=2)
18681:  def VV19VQ(self, mode, VV6A99, title, txt, colList):
18682:   VV1wIO, chUrl, VVfbmn, VVPxk5 = self.VVK5K0(mode, colList)
18683:   txt = "%s\n\n%s" % (title, txt)
18684:   CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VV1YsH, params=(VVPxk5, VV1wIO, txt, chUrl, VVfbmn))
18685:  @FFOAKH(par=2)
18686:  def VVotEo(self, mode, VV6A99, title, txt, colList):
18687:   name = colList[1]
18688:   Dur  = colList[5]
18689:   Cover = colList[7]
18690:   txt  = "%s\n\n%s" % (title, txt)
18691:   txt  += "Duration\t: %s" % Dur
18692:   CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVUWdA, params=(name, txt, Cover))
18693:  def VVTdR5(self, mode, isSerNames, VV6A99, title, txt, colList):
18694:   if mode == "m3u":
18695:    nameCol, picCol, descCol, descTxt = 1, 4, 2, "Group"
18696:   elif mode in ("itv", "vod", "series"):
18697:    if isSerNames: nameCol, picCol, descCol, descTxt = 0, 12, 9, "Genre"
18698:    else   : nameCol, picCol, descCol, descTxt = 1, 4 , 6, "Category/Genre"
18699:   else:
18700:    nameCol = 1
18701:    if isSerNames         : picCol, descCol, descTxt = 7, 4, "Genre"
18702:    elif mode == self.VVXewY : picCol, descCol, descTxt = 4, 5, "Added"
18703:    elif mode == self.VV4kmD : picCol, descCol, descTxt = 4, 5, "Added"
18704:    elif mode == self.VVw3vg  : picCol, descCol, descTxt = 4, 5, "Added"
18705:    elif mode == self.VVtP50 : picCol, descCol, descTxt = 5, 0, "Season"
18706:   FFimQ3(VV6A99, BF(self.session.open, CCUYzx, VV6A99, self.VVYrUH(mode), nameCol, picCol, descCol, descTxt))
18707:  @staticmethod
18708:  def VVYrUH(mode):
18709:   if   mode in ("itv", "live" , CCkEI5.VVXewY, CCkEI5.VV4kmD): subD = "Live"
18710:   elif mode in ("vod"   , CCkEI5.VVw3vg )          : subD = "VOD"
18711:   elif mode in ("series"  , CCkEI5.VVtP50)          : subD = "Series"
18712:   elif mode == "m3u"                       : subD = "M3U"
18713:   else                          : subD = ""
18714:   return FFoWxR(os.path.join(FF0cqc(), "Posters", subD))
18715:  def VVnHDd(self, mode, typ, VVetid, VV6A99, title, txt, colList):
18716:   VV3wat = []
18717:   isMulti = VV6A99.VVXWPu
18718:   tot  = VV6A99.VVc5NH()
18719:   if isMulti:
18720:    if tot < 1:
18721:     FF28n1(VV6A99, "Select rows first.", 1000)
18722:     return
18723:    else:
18724:     name = "%d Selected" % tot
18725:    plural = FFcacr(tot)
18726:   else:
18727:    name = "ALL"
18728:    plural = "s"
18729:   txt = "PIcon" if mode in ("itv", CCkEI5.VVXewY, CCkEI5.VV4kmD) else "Poster"
18730:   VV3wat.append(("Download %s %s%s" % (name, txt, plural)  , "dnldPicons" ))
18731:   if typ:
18732:    VV3wat.append(VVAL3j)
18733:    tName = "Movie" if typ.startswith("v") else "Episode"
18734:    VV3wat.append(("Download Current %s" % tName    , "dnldSel"  ))
18735:    VV3wat.append(("Add Current %s to Download List" % tName , "addSel"  ))
18736:    if typ.startswith("s"):
18737:     VV3wat.append(("Add All Episodes to Download List" , "addAllEp" ))
18738:    if not CCHRcZ.VVAbZK():
18739:     VV3wat.append(VVAL3j)
18740:     VV3wat.append(("Download Manager"      , "dload_stat" ))
18741:   FFLFTC(self, BF(self.VVmUow, VV6A99, mode, typ, VVetid, colList), title="Download Options", VV3wat=VV3wat)
18742:  def VVmUow(self, VV6A99, mode, typ, VVetid, colList, item=None):
18743:   if item:
18744:    if   item == "dnldPicons" : self.VVE5LS(self, VV6A99, mode)
18745:    elif item == "dnldSel"  : self.VVGjeL(VV6A99, mode, typ, colList, True)
18746:    elif item == "addSel"  : self.VVGjeL(VV6A99, mode, typ, colList, False)
18747:    elif item == "addAllEp"  : self.VVLLey(VV6A99, mode, typ, VVetid)
18748:    elif item == "dload_stat" : CCHRcZ.VVSZMa(self, VV6A99)
18749:  @FFOAKH(par=1)
18750:  def VVGjeL(self, VV6A99, mode, typ, colList, startDnld):
18751:   VV1wIO, VVZcRP = self.VVOkm6(mode, typ, colList)
18752:   if startDnld:
18753:    CCHRcZ.VVXNDk(self, VVZcRP)
18754:   else:
18755:    self.VV1lS7(VV6A99, "Add to Download list", VV1wIO, [VVZcRP], startDnld)
18756:  def VVLLey(self, VV6A99, mode, typ, VVetid):
18757:   VVC9AM = []
18758:   for row in VV6A99.VVrrm9():
18759:    VV1wIO, VVZcRP = self.VVOkm6(mode, typ, row)
18760:    VVC9AM.append(VVZcRP)
18761:   self.VV1lS7(VV6A99, "Add to Download list", "%s\n\n( %d Episodes )" % (VVetid, len(VVC9AM)), VVC9AM, False)
18762:  def VV1lS7(self, VV6A99, title, VV1wIO, VVC9AM, startDnld):
18763:   FFRMYv(self, BF(self.VVvUrN, VV6A99, VVC9AM, startDnld), VV1wIO, title=title)
18764:  def VVvUrN(self, VV6A99, VVC9AM, startDnld):
18765:   added, skipped = CCHRcZ.VVNrGg(VVC9AM)
18766:   FF28n1(VV6A99, "Added", 1000)
18767:  def VVOkm6(self, mode, typ, colList):
18768:   if typ in ("v", "s"):
18769:    VV1wIO, chUrl, VVfbmn, VVPxk5 = self.VVK5K0(mode, colList)
18770:   elif typ in ("vp", "sp"):
18771:    VV1wIO, catID, stID, chNum, chCm, serCode, serId, VVfbmn = self.VVcP3g(mode, colList)
18772:    VVPxk5, chUrl = self.VVfi1S(self.VVncdQ, self.VVvRlC, mode, VV1wIO, catID, stID, chNum, chCm, serCode, serId)
18773:   VVPxk5, VVZcRP, VV57TX, VVfaDB = CC3rDi.VVGg6H(chUrl)
18774:   return VV1wIO, VVZcRP
18775:  @staticmethod
18776:  def VVE5LS(SELF, VV6A99, mode):
18777:   if FFayeZ("ffmpeg"):
18778:    CCh3tv.VV7Nf4(SELF, VVLL7M="Downloading PIcons"
18779:        , VVixvy  = BF(CCkEI5.VVC4jj, SELF, VV6A99, mode)
18780:        , VVbYwR = BF(CCkEI5.VV7Oqv, SELF))
18781:   else:
18782:    FFRMYv(SELF, BF(CCkEI5.VVGS56, SELF), '"FFmpeg" is required to resize the PIcons.\n\nInstall FFmpeg ?', title="Download all PIcons")
18783:  @staticmethod
18784:  def VVC4jj(SELF, VV6A99, mode, VVXyP6):
18785:   VVXyP6.VVNc18 = {"total": 0, "threads": 0, "proces": 0, "badUrl": 0, "exist": 0, "attempt": 0, "ok": 0, "size0": 0, "fail": 0, "err": ""}
18786:   VV1tA1 = set()
18787:   pPath = CCafIt.VVjkKT()
18788:   VVXyP6.VVaks5("Collecting list ...")
18789:   ndxLst = []
18790:   for ndx, row in enumerate(VV6A99.VVrrm9()):
18791:    if not VV6A99.VVXWPu or VV6A99.VVvlf4(ndx):
18792:     ndxLst.append(ndx)
18793:   if not VVXyP6 or VVXyP6.isCancelled: return
18794:   if ndxLst:
18795:    VVXyP6.VVNc18["total"] = len(ndxLst)
18796:    VVXyP6.VVq8NF(len(ndxLst))
18797:    VVXyP6.VV0ddK(0)
18798:   else:
18799:    VVXyP6.VVNc18["err"] = "No valid URLs"
18800:    return
18801:   def VVBIzy(VVfbmn, picon):
18802:    VVXyP6.VVNc18["threads"] += 1
18803:    VVXyP6.VVNc18["attempt"] += 1
18804:    path, err = FFx9uM(VVfbmn, picon, timeout=2, VVzHui=True)
18805:    if not VVXyP6 or VVXyP6.isCancelled:
18806:     FFwgGB(path)
18807:    elif err:
18808:     VVXyP6.VVNc18["fail"] += 1
18809:     if any(x in err.lower() for x in ("time-out", "unauthorized")):
18810:      VVXyP6.VVNc18["err"] = err.title()
18811:    elif not path:
18812:     pass
18813:    elif FFXhoc(path) == 0:
18814:     VVXyP6.VVNc18["size0"] += 1
18815:     FFwgGB(path)
18816:    else:
18817:     VVXyP6.VVNc18["ok"] += 1
18818:     totOk = VVXyP6.VVNc18["ok"]
18819:     VVXyP6.VV0ddK(totOk)
18820:     cmd = CCvjVs.VVQ9GP(path)
18821:     cmd += FFb2oQ("mv -f '%s' '%s'" % (path, pPath))
18822:     FFpwZS(cmd)
18823:    if VVXyP6 and not VVXyP6.isCancelled:
18824:     VVXyP6.VVNc18["threads"] -= 1
18825:   while ndxLst or VVXyP6.VVNc18["threads"] > 0:
18826:    try:
18827:     if not VVXyP6 or VVXyP6.isCancelled : return
18828:     elif VVXyP6.VVNc18["err"]   : return
18829:     elif VVXyP6.VVNc18["threads"] >= 8: continue
18830:     elif not ndxLst        : continue
18831:    except:
18832:     return
18833:    row = VV6A99.VVMADj(ndxLst[0])
18834:    ndxLst.pop(0)
18835:    VVXyP6.VVxtQs(1)
18836:    VVXyP6.VVNc18["proces"] += 1
18837:    if mode in ("itv", "vod", "series"):
18838:     VV1wIO, catID, stID, chNum, chCm, serCode, serId, VVfbmn = SELF.VVcP3g(mode, row)
18839:     VVPxk5 = CCkEI5.VVpX1r(catID, stID, chNum)
18840:    elif mode == "m3u":
18841:     VVPxk5, VV1wIO, chUrl, VVfbmn, VVZcRP, isMark = CCjZbZ.VVOteG(SELF, row)
18842:    else:
18843:     VV1wIO, chUrl, VVfbmn, VVPxk5 = SELF.VVK5K0(mode, row)
18844:    if not VVfbmn:
18845:     VVXyP6.VVNc18["badUrl"] += 1
18846:     continue
18847:    picon = VVPxk5.replace(":", "_").rstrip("_") + ".png"
18848:    if not VVXyP6 or VVXyP6.isCancelled:
18849:     return
18850:    if FFCyVu(pPath + picon):
18851:     VVXyP6.VVNc18["exist"] += 1
18852:    elif not picon in VV1tA1:
18853:     VV1tA1.add(picon)
18854:     iThread(name="ajp_DnldPic", target=BF(VVBIzy, VVfbmn, picon)).start()
18855:  @staticmethod
18856:  def VV7Oqv(SELF, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
18857:   tDict = VVNc18
18858:   txt  = ""
18859:   txt += "Total Processed\t\t: %d of %d\n" % (tDict["proces"], tDict["total"])
18860:   txt += "Download Success\t: %d of %s\n"  % (tDict["ok"], tDict["attempt"])
18861:   txt += "Skipped (PIcon exist)\t: %d\n"  % tDict["exist"]
18862:   txt += "Skipped (Size = 0)\t: %d\n"   % tDict["size0"]
18863:   txt += "Incorrect PIcon URL\t: %d\n"  % tDict["badUrl"]
18864:   txt += "Download Failure\t: %d\n"   % tDict["fail"]
18865:   txt += "PIcons Path\t\t: %s\n"    % CCafIt.VVjkKT()
18866:   if not VVRI6P: color = "#11402000"
18867:   elif tDict["err"]: color = "#11201000"
18868:   else    : color = "#22001122"
18869:   if tDict["err"]:
18870:    txt = "Critical Error\t\t: %s\n\n%s"  % (tDict["err"], txt)
18871:   title = "PIcons Download Result"
18872:   if not VVRI6P:
18873:    title += "  (cancelled)"
18874:   FF4lCP(SELF, txt, title=title, VVemyB=color)
18875:  @staticmethod
18876:  def VVGS56(SELF):
18877:   cmd = FF5sZa(VVwFAi, "ffmpeg")
18878:   if cmd : FFbi5l(SELF, cmd, title="Installing FFmpeg")
18879:   else : FFfone(SELF)
18880:  @staticmethod
18881:  def VVFT2F(SELF):
18882:   CCdt86(SELF)
18883:  @staticmethod
18884:  def VVigje(chUrl, streamId, mode):
18885:   modified, uURL, uProtoc, uHost, uPort, uQuery, uUser, uPass, uQueryParam = CCkEI5.VVRLKG(chUrl)
18886:   qUrl = "%splayer_api.php?username=%s&password=%s&action=get_simple_data_table&stream_id=%s" % (uURL, uUser, uPass, streamId)
18887:   txt, err = CCkEI5.VVzVZL(qUrl)
18888:   if err : return "", err
18889:   else : return CCkEI5.VV1q43(txt, mode=mode)
18890:  @staticmethod
18891:  def VV1q43(txt, mode):
18892:   lst = []
18893:   evLst = []
18894:   try:
18895:    tDict = jLoads(txt)
18896:    for item in tDict["epg_listings"]:
18897:     description = FFYjVd(item, "description"  , is_base64=True).replace("\n", " .. ")
18898:     has_archive = FFYjVd(item, "has_archive"      )
18899:     lang  = FFYjVd(item, "lang"        ).upper()
18900:     now_playing = FFYjVd(item, "now_playing"      )
18901:     tTitle  = FFYjVd(item, "title"   , is_base64=True)
18902:     startServ = FFYjVd(item, "start"       )
18903:     startT  = FFYjVd(item, "start_timestamp" , isDate=True )
18904:     startTs  = FFYjVd(item, "start_timestamp"     )
18905:     stopT  = FFYjVd(item, "stop_timestamp" , isDate=True )
18906:     stopTs  = FFYjVd(item, "stop_timestamp"     )
18907:     if mode == 0:
18908:      if has_archive == "1":
18909:       return True, ""
18910:     elif mode == 1:
18911:      try:
18912:       startTs, stopTs = int(startTs), int(stopTs)
18913:       if has_archive == "1" or (startTs < iTime() and stopTs > iTime()):
18914:        durMin = str((stopTs - startTs) // 60)
18915:        durTm = FFFHEC(stopTs - startTs)
18916:        row = (startT[:-3], stopT[:-3], durTm, lang, tTitle, description, startServ, now_playing, durMin)
18917:        if not row in lst:
18918:         lst.append(row)
18919:      except:
18920:       pass
18921:     elif mode == 2:
18922:      try:
18923:       startTs, stopTs = int(startTs), int(stopTs)
18924:       if stopTs > iTime():
18925:        dur = stopTs - startTs
18926:        shortDesc = ("Language : %s" % lang) if lang else ""
18927:        lst.append((startTs, dur, tTitle, shortDesc, description, 1))
18928:      except:
18929:       pass
18930:     elif mode == 3:
18931:      try:
18932:       startTs, stopTs = int(startTs), int(stopTs)
18933:       if stopTs > iTime():
18934:        dur = stopTs - startTs
18935:        row = (description, has_archive, lang, now_playing, tTitle, startT, startTs, stopT, stopTs)
18936:        if not row in lst:
18937:         lst.append(row)
18938:         shortDesc = ("Language : %s" % lang) if lang else ""
18939:         evLst.append((startTs, dur, tTitle, shortDesc, description, 1))
18940:      except:
18941:       pass
18942:   except:
18943:    return "", "Cannot parse received data !"
18944:   if   mode == 0: return False, ""
18945:   elif mode == 1: return lst, ""
18946:   elif mode == 2: return lst, ""
18947:   elif mode == 3:
18948:    sep = FFjt5L("_" * 32 + "\n", VVo7S9)
18949:    fg1, fg2, curTxt = VVwdUw, VVz22H, "    (CURRENT EVENT)"
18950:    epg = ""
18951:    for evNum, (description, has_archive, lang, now_playing, tTitle, startT, startTs, stopT, stopTs) in enumerate(lst, start=1):
18952:     if now_playing == "0": color, txt = fg1, ""
18953:     else     : color, txt = fg2, curTxt
18954:     epg += sep
18955:     epg += FFjt5L("Event\t: %d%s\n" % (evNum, txt), color)
18956:     epg += "Title\t: %s\n"    % FFjt5L(tTitle, VVFuwR)
18957:     epg += "Start\t: %s\n"    % startT
18958:     epg += "End\t: %s\n"    % stopT
18959:     if lang   : epg += "Language\t: %s\n"  % lang
18960:     if description : epg += "Description:\n%s\n" % FFjt5L(description, VVA4XU)
18961:    return epg, evLst, ""
18962:   else:
18963:    return lst, ""
18964:  @staticmethod
18965:  def VV67It(VVZcRP):
18966:   epg, evLst, err = "", [], ""
18967:   if "mode=itv" in VVZcRP:
18968:    p, err = CC96QG.VV9eVr(VVZcRP)
18969:    if p:
18970:     valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVGNGo(VVZcRP)
18971:     if valid and stID:
18972:      res, err = p.VVnjdQ(p.VVc7nF(stID))
18973:      if res:
18974:       epg, err = CCkEI5.VVhcmB(res.text, retLst=False)
18975:       evLst, err = CCkEI5.VVhcmB(res.text, retLst=True)
18976:       return epg, evLst, err
18977:   else:
18978:    data = CCkEI5.VV9F1k(VVZcRP)
18979:    if data:
18980:     uHost, uUser, uPass, uId, VV1wIO = data
18981:     if all((uHost, uUser, uPass, uId)):
18982:      qUrl = "%s/player_api.php?username=%s&password=%s&action=get_short_epg&stream_id=%s" % (uHost, uUser, uPass, uId)
18983:      txt, err = CCkEI5.VVzVZL(qUrl, timeout=3)
18984:      if txt:
18985:       epg, evLst, err = CCkEI5.VV1q43(txt, mode=3)
18986:   return epg, evLst, err
18987:  @staticmethod
18988:  def VVhcmB(txt, retLst=False):
18989:   epg = ""
18990:   lst = []
18991:   now = iTime()
18992:   try:
18993:    tDict = jLoads(txt)
18994:    for item in tDict["js"]:
18995:     actor = FFYjVd(item, "actor"       )
18996:     cat  = FFYjVd(item, "category"       )
18997:     descr = FFYjVd(item, "descr"   , is_base64=True).replace("\n", " .. ")
18998:     director= FFYjVd(item, "director"       )
18999:     name = FFYjVd(item, "name"    , is_base64=True)
19000:     startT = FFYjVd(item, "start_timestamp" , isDate=True )
19001:     startTs = FFYjVd(item, "start_timestamp"     )
19002:     stopT = FFYjVd(item, "stop_timestamp" , isDate=True )
19003:     stopTs = FFYjVd(item, "stop_timestamp"     )
19004:     try:
19005:      startTs, stopTs = int(startTs), int(stopTs)
19006:      if stopTs > now:
19007:       dur = stopTs - startTs
19008:       row = (actor, cat, descr, director, name, startT, stopT, startTs, stopTs, dur)
19009:       if not row in lst:
19010:        lst.append(row)
19011:     except:
19012:      pass
19013:   except:
19014:    return "", "Cannot parse received data !"
19015:   if retLst:
19016:    lst = [(startTs, dur, name, "", descr, 1) for (actor, cat, descr, director, name, startT, stopT, startTs, stopTs, dur) in lst]
19017:    return lst, ""
19018:   else:
19019:    sep  = FFjt5L("_" * 32 + "\n", VVo7S9)
19020:    curTxt = FFjt5L("    (CURRENT EVENT)", VVJEMb)
19021:    evNum = 1
19022:    for actor, cat, descr, director, name, startT, stopT, startTs, stopTs, dur in lst:
19023:     curEv = curTxt if (startTs < now and stopTs > now) else ""
19024:     epg += sep
19025:     epg += "Event\t: %d%s\n" % (evNum, curEv)
19026:     epg += "Title\t: %s\n"  % FFjt5L(name, VVFuwR)
19027:     epg += "Start\t: %s\n"  % startT
19028:     epg += "End\t: %s\n"  % stopT
19029:     epg += "Description:\n%s\n" % FFjt5L(descr , VVA4XU) if descr else "Description\t: - \n"
19030:     epg += "Genre:\n%s\n"  % FFjt5L(cat  , VVA4XU) if cat else ""
19031:     epg += "Actors:\n%s\n"  % FFjt5L(actor , VVA4XU) if actor else ""
19032:     epg += "Director:\n%s\n" % FFjt5L(director, VVA4XU) if director else ""
19033:     evNum += 1
19034:    return epg, ""
19035:  @staticmethod
19036:  def VVfN18(txt):
19037:   epg = movie_image = err = ""
19038:   try:
19039:    tDict = jLoads(txt)
19040:    item = tDict["info"]
19041:    movie_image = FFYjVd(item, "movie_image" )
19042:    genre  = FFYjVd(item, "genre"  )
19043:    plot  = FFYjVd(item, "plot"   )
19044:    country  = FFYjVd(item, "country"  )
19045:    actors  = FFYjVd(item, "actors"  )
19046:    cast  = FFYjVd(item, "cast"   )
19047:    rating  = FFYjVd(item, "rating"  )
19048:    director = FFYjVd(item, "director"  )
19049:    releasedate = FFYjVd(item, "releasedate" )
19050:    duration = FFYjVd(item, "duration"  )
19051:    tab = lambda x, y: ("%s\t: %s\n" % (x, y)) if y and y != "-" else ""
19052:    try:
19053:     lang = FFYjVd(tDict["info"]["audio"]["tags"], "language")
19054:     if lang:
19055:      epg += tab("Language", lang.capitalize())
19056:    except:
19057:     pass
19058:    epg += tab("Genre"  , genre)
19059:    epg += tab("Released" , releasedate)
19060:    epg += tab("Country" , country)
19061:    epg += tab("Duration" , duration)
19062:    epg += tab("Director" , director)
19063:    epg += tab("Rating"  , rating)
19064:    if cast or actors : epg += "Cast:\n%s\n\n" % FFjt5L(cast or actors, VVA4XU)
19065:    if plot    : epg += "Plot:\n%s"  % FFjt5L(plot, VVA4XU)
19066:   except Exception as e:
19067:    err = str(e)
19068:   return epg, movie_image, err
19069:  @staticmethod
19070:  def VVYkyo(txt, VVZcRP):
19071:   span = iSearch(r".+\/series\/.+\/.+\/(\d+)", VVZcRP)
19072:   epId = span.group(1) if span else ""
19073:   epg = epSeason = epTitle = cover = err = ""
19074:   try:
19075:    tDict = jLoads(txt)
19076:    item = tDict["info"]
19077:    cast  = FFYjVd(item, "cast"    )
19078:    cover  = FFYjVd(item, "cover"   )
19079:    director = FFYjVd(item, "director"   )
19080:    genre  = FFYjVd(item, "genre"   )
19081:    name  = FFYjVd(item, "name"    )
19082:    plot  = FFYjVd(item, "plot"    )
19083:    if epId:
19084:     for sName, ep in tDict["episodes"].items():
19085:      for item in ep:
19086:       Id   = FFYjVd(item, "id"     )
19087:       season  = FFYjVd(item, "season"    )
19088:       Title  = FFYjVd(item, "title"    )
19089:       if Id  == epId:
19090:        epSeason, epTitle = season, Title
19091:        break
19092:      if epSeason or epTitle:
19093:       break
19094:    ttl = lambda x, y: "\n%s:\n%s\n\n" % (FFjt5L(x, VVFuwR), str(y)) if y else ""
19095:    tab = lambda x, y: ("%s\t: %s\n" % (x, y)) if y else ""
19096:    epg =  tab("Season"  , epSeason)
19097:    epg += tab("Title"  , epTitle)
19098:    epg += tab("Name"  , name)
19099:    epg += tab("Genre"  , genre)
19100:    epg += tab("Director" , director)
19101:    epg += ttl("Cast"  , cast)
19102:    epg += ttl("Plot"  , plot)
19103:   except Exception as e:
19104:    err = str(e)
19105:   return epg, cover, err
19106:  @staticmethod
19107:  def VVpX1r(catID, stID, chNum):
19108:   MAX_4b = 65535
19109:   MAX_8b = 4294967295
19110:   SID  = CCkEI5.VVHz2c(catID, MAX_4b)
19111:   TSID = CCkEI5.VVHz2c(chNum, MAX_4b)
19112:   ONID = CCkEI5.VVHz2c(chNum, MAX_4b)
19113:   NS  = CCkEI5.VVHz2c(stID, MAX_8b)
19114:   if len(NS) == 4:
19115:    NS = "1" + NS
19116:   rType = CFG.iptvAddToBouquetRefType.getValue()
19117:   return "%s:0:1:%s:%s:%s:%s:0:0:0:" % (rType, SID, TSID, ONID, NS)
19118:  @staticmethod
19119:  def VVHz2c(numStr, limit):
19120:   if numStr.isdigit():
19121:    i = int(numStr)
19122:    if i > limit:
19123:     i = limit
19124:    return (hex(i))[2:].upper()
19125:   else:
19126:    return "222"
19127:  @staticmethod
19128:  def VVPjQO(txt):
19129:   txt = iSub(iCompile(r'\W'), "_", txt)
19130:   txt = FFMYNg(txt, "_")
19131:   return "Bouquet" if txt == "_" else txt
19132:  @staticmethod
19133:  def VVxV5D(mode):
19134:   if   mode in ("itv"  , CCkEI5.VVgkvV)  : return "#0a21303C", "#0a21303C", "#0a21303C", "#00005566"
19135:   elif mode in ("vod"  , CCkEI5.VVgL8R)  : return "#1a260518", "#1a260518", "#1a260518", "#04224040"
19136:   elif mode in ("series" , CCkEI5.VV6cbr) : return "#1a36013F", "#1a26012F", "#1a26012F", "#04224040"
19137:   elif mode in ("catchup" , CCkEI5.VVspif) : return "#0a213044", "#0a213044", "#0a21303C", "#04224040"
19138:   elif mode == CCkEI5.VV4kmD    : return "#0a202020", "#0a202020", "#0a202020", "#04663366"
19139:   elif mode == "catchupEv"           : return "#0a00191B", "#0a001116", "#0a001116", "#00553344"
19140:   elif mode == "series2"            : return "#0a462538", "#0a462538", "#0a462538", "#04224040"
19141:   else                : return "#0a00292B", "#0a002126", "#0a002126", "#00005566"
19142:  @staticmethod
19143:  @FFOAKH("Reading ...")
19144:  def VVvSue(SELF, hostUrl, VV1wIO, streamId, ok_fnc, rst_fnc=None):
19145:   pList, err = CCkEI5.VVigje(hostUrl, streamId, mode=1)
19146:   title = "Catch-up TV Programs"
19147:   if err:
19148:    FFdw58(SELF, "Server Error:\n\n%s" % err, title=title)
19149:    return
19150:   elif not pList:
19151:    FFdw58(SELF, "No Programs from server", title=title)
19152:    return
19153:   pList.sort(key=lambda x: x[0], reverse=True)
19154:   grnSTime = ""
19155:   VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(SELF)
19156:   span = iSearch(r"(\d{4}-\d{2}-\d{2}):(\d{2})-(\d{2})", VVZcRP)
19157:   if span : sTime = span.group(1) + " " + span.group(2) + ":" + span.group(3)
19158:   else : sTime = ""
19159:   grn = False
19160:   for ndx, row in enumerate(pList):
19161:    if sTime in row[6] and row[4] in VV1wIO:
19162:     pList[ndx] = tuple(["
19163:     grnSTime = row[6]
19164:    elif row[7] == "1":
19165:     pList[ndx] = tuple(["#f#00ffff00#" + x for x in row])
19166:     grnSTime = row[6]
19167:   span = iSearch(r"(.+)\/timeshift(\/.+\/.+)\/.+\/.+(\/.+)\.ts(.+)\s>>", VVPxk5 + ":" + VV57TX, IGNORECASE)
19168:   chUrl = "".join(span.groups()) if span else ""
19169:   def VVL1aK(VV6A99, title, txt, colList):
19170:    FFnfiC(SELF.session, chUrl)
19171:    VV6A99.cancel()
19172:    if rst_fnc: rst_fnc()
19173:   def VV8YHC(VV6A99, title, txt, colList):
19174:    VV6A99.VVn5CC(6, grnSTime, VVwb7n=True)
19175:   title = "Programs for : " + FFjt5L(VV1wIO, VVJEMb)
19176:   VVwltY, VVkxBG, VVemyB, VVJKqd = CCkEI5.VVxV5D("catchupEv")
19177:   VVwSzI = ("Current Event" , VV8YHC , []) if grnSTime else None
19178:   VVScQz = ("Play Latest" , VVL1aK , []) if chUrl else None
19179:   VVu1YM  = ("Play"  , ok_fnc  , [])
19180:   header   = ("Start" , "End" , "Duration", "Lang", "Title" , "Description" , "sTime" , "Playing" , "DurMin" )
19181:   widths   = (16  , 16 , 9   , 6  , 30  , 23   , 0   , 0   , 0   )
19182:   VVLIqP  = (CENTER , CENTER, CENTER , CENTER, LEFT  , LEFT   , CENTER , CENTER , CENTER )
19183:   FFUQ0v(SELF, None, title=title, header=header, VVGape=pList, VVLIqP=VVLIqP, VV3cHe=widths, width=1800, height=950, VVwdmN=24, VVu1YM=VVu1YM, VVwSzI=VVwSzI, VVScQz=VVScQz, VVwltY=VVwltY, VVkxBG=VVkxBG, VVemyB=VVemyB, VVJKqd=VVJKqd)
19184:  @staticmethod
19185:  def VVyjSu(rUrl, fPath):
19186:   fPath = fPath.strip()
19187:   if fPath.startswith("http://"):
19188:    return fPath
19189:   elif fPath.startswith("/"):
19190:    try:
19191:     res = iUrlparse(rUrl)
19192:     scheme = res.scheme
19193:     netloc = res.netloc
19194:     if scheme and netloc:
19195:      host = "%s://%s" % (scheme, netloc)
19196:      return os.path.join(host, fPath.lstrip("/"))
19197:    except:
19198:     pass
19199:    return ""
19200:   else:
19201:    baseUrl = os.path.dirname(rUrl).strip()
19202:    fName = os.path.basename(rUrl).strip()
19203:    return os.path.join(baseUrl, fPath)
19204:  def VVoyt7(self, isPortal, line, selectionObj, item):
19205:   title = "Add server to IPTV Menu (for easy access)"
19206:   if isPortal : typ, confItem = "Portal" , CFG.favServerPortal
19207:   else  : typ, confItem = "Playlist", CFG.favServerPlaylist
19208:   rmTxt = "Removed from IPTV Menu."
19209:   svTxt = 'Added to IPTV Menu.\n\nWill be shown as "%s"' % FFjt5L("Favourite %s Server" % typ, VVSGsk)
19210:   cur = confItem.getValue().strip().replace("\t", "\n")
19211:   if cur == line.strip():
19212:    FFRMYv(self, BF(self.VVvDHm, title, rmTxt, typ, confItem, ""), "Already in IPTV Menu !\n\nRemove ?", title=title)
19213:   elif cur:
19214:    FFRMYv(self, BF(self.VVvDHm, title, svTxt, typ, confItem, line), "Replace current favourite item ?\n\n%s" % ((cur[:60] + "..") if len(cur) > 60 else cur), title=title)
19215:   else:
19216:    self.VVvDHm(title, svTxt, typ, confItem, line)
19217:  def VVvDHm(self, title, txt, typ, confItem, line):
19218:   FFjt1c(confItem, line)
19219:   FFipXT(self, txt, title=title)
19220:  def VVmoT7(self, isPortal):
19221:   if isPortal:
19222:    span = iSearch(r"(.+)\s((?:[A-Fa-f0-9]+:){5}.+[A-Fa-f0-9]+)", CFG.favServerPortal.getValue(), IGNORECASE)
19223:    if span:
19224:     self.VVAw1p(self, span.group(1), span.group(2))
19225:     return
19226:   else:
19227:    span = iSearch(r"(http.+\/\/.+\/.+username=.+&password=.+)", CFG.favServerPlaylist.getValue(), IGNORECASE)
19228:    if span:
19229:     self.VVgCCs(self, "Favourite Playlist Server", span.group(1))
19230:     return
19231:   FFdw58(self, "Incorrect server data !")
19232:  @staticmethod
19233:  def VVwOWK(SELF, isPortal, line, selectionObj, item):
19234:   path = FF7BT0()
19235:   if isPortal : path += "Portal_Bookmarks.txt"
19236:   else  : path += "Playlist_Bookmarks.txt"
19237:   title = "Bookmark Current Server"
19238:   try:
19239:    if FFCyVu(path):
19240:     with ioOpen(path, "r", encoding="utf-8") as f:
19241:      for fLine in f:
19242:       if str(line) in str(fLine):
19243:        FFdw58(SELF, "Already added to file:\n\n%s" % path, title=title)
19244:        return
19245:    with open(path, "a") as f:
19246:     f.write(line + "\n")
19247:    FFipXT(SELF, "Added to file:\n\n%s" % path, title=title)
19248:   except Exception as e:
19249:    FFdw58(SELF, "Error:\n\n%s" % str(e), title=title)
19250:  def VVCbC2(self, source, mode, VVIu85, VV6A99, title, txt, colList):
19251:   isMulti = VV6A99.VVXWPu
19252:   itemsOK = True
19253:   totTxt = "ALL"
19254:   if isMulti:
19255:    tot = VV6A99.VVc5NH()
19256:    totTxt = "%d Service%s" % (tot, FFcacr(tot))
19257:    if tot < 1:
19258:     itemsOK = False
19259:   totTxt = FFjt5L(totTxt, VVFuwR)
19260:   VVIu852 = ""
19261:   if self.VV2rlK:
19262:    name = iUrlparse(self.VV2rlK).netloc
19263:    if name:
19264:     VVIu852 = "%s (%s)" % (VVIu85, name.split(":")[0])
19265:   mSel = CCzSCo(self, VV6A99, addSep=False, setsOk=True, setsBlue=True)
19266:   VV3wat, cbFncDict = [], None
19267:   VV3wat.append(VVAL3j)
19268:   if itemsOK:
19269:    title = "Add to Bouquet"
19270:    thTxt = "Adding Services ..."
19271:    VV3wat.append(("Add %s to New Bouquet : %s"    % (totTxt, FFjt5L(VVIu85 , VVSGsk)), "addToCur1"))
19272:    if VVIu852: VV3wat.append(("Add %s to New Bouquet : %s" % (totTxt, FFjt5L(VVIu852, VVGCYL)) , "addToCur2"))
19273:    VV3wat.append(("Add %s to Existing/New Bouquet ..."  % (totTxt)            , "addToNew" ))
19274:    VV3wat.append(VVAL3j)
19275:    VV3wat.append(("Save %s to M3U File" % (totTxt), "toM3u" ))
19276:    cbFncDict = { "addToCur1": BF(self.VVDDgR, source, mode, VVIu85 , VV6A99, title)
19277:       , "addToCur2": BF(self.VVDDgR, source, mode, VVIu852, VV6A99, title)
19278:       , "toM3u"  : BF(self.VVwVFk   , source, mode, VVIu852, VV6A99, "Save to M3U File")
19279:       , "addToNew" : BF(self.VVSXwS, source, mode, VVIu85, VV6A99, title)
19280:       }
19281:   else:
19282:    VV3wat.append(("Add to Bouquet (nothing selected)", ))
19283:   mSel.VV9VR2(VV3wat, cbFncDict, width=1400)
19284:  @FFOAKH("Adding Services ...", par=4)
19285:  def VVDDgR(self, source, mode, VVIu85, VV6A99, Title):
19286:   chUrlLst = self.VVznPA(source, mode, VV6A99)
19287:   CCMvE7.VVPJK0(self, Title, VVIu85, "", chUrlLst)
19288:  def VVSXwS(self, source, mode, VVIu85, VV6A99, Title):
19289:   picker = CCMvE7(self, VV6A99, Title, BF(self.VVznPA, source, mode, VV6A99), VVFjhV=VVIu85)
19290:  def VVznPA(self, source, mode, VV6A99):
19291:   isMulti = VV6A99.VVXWPu
19292:   chUrlLst = []
19293:   rowNum = 0
19294:   for ndx, row in enumerate(VV6A99.VVrrm9()):
19295:    if not isMulti or VV6A99.VVvlf4(ndx):
19296:     chUrl = VV1wIO = ""
19297:     if source in ("pEp", "pCh"):
19298:      VV1wIO, catID, stID, chNum, chCm, serCode, serId, VVfbmn = self.VVcP3g(mode, row)
19299:      VVPxk5, chUrl = self.VVfi1S(self.VVncdQ, self.VVvRlC, mode, VV1wIO, catID, stID, chNum, chCm, serCode, serId)
19300:     elif source in ("lv", "v", "s", "fnd"):
19301:      VV1wIO, chUrl, VVfbmn, VVPxk5 = self.VVK5K0(mode, row)
19302:     if chUrl and VV1wIO:
19303:      chUrlLst.append(chUrl)
19304:   return chUrlLst
19305:  @FFOAKH("Adding Services ...", par=4)
19306:  def VVwVFk(self, source, mode, VVIu85, VV6A99, Title):
19307:   chUrlLst = []
19308:   outF = "%s%s_%s.m3u" % (FF7BT0(), FFOu5Y(VVIu85), FFjTQe())
19309:   totCh = toB = 0
19310:   with open(outF, "w") as f:
19311:    f.write("#EXTM3U\n")
19312:    for ndx, row in enumerate(VV6A99.VVrrm9()):
19313:     if not VV6A99.VVXWPu or VV6A99.VVvlf4(ndx):
19314:      chUrl = VV1wIO = ""
19315:      if source in ("pEp", "pCh"):
19316:       VV1wIO, catID, stID, chNum, chCm, serCode, serId, VVfbmn = self.VVcP3g(mode, row)
19317:       VVPxk5, chUrl = self.VVfi1S(self.VVncdQ, self.VVvRlC, mode, VV1wIO, catID, stID, chNum, chCm, serCode, serId)
19318:      elif source in ("lv", "v", "s", "fnd"):
19319:       VV1wIO, chUrl, VVfbmn, VVPxk5 = self.VVK5K0(mode, row)
19320:      if VV1wIO and chUrl:
19321:       chR = chUrl.replace(":" + VV1wIO, "").strip()
19322:       span = iSearch(r'^(?:[A-Fa-f0-9]+:){10}(.*)', chR, IGNORECASE)
19323:       if span:
19324:        totCh += 1
19325:        pUrl = (' tvg-logo="%s"' % VVfbmn) if VVfbmn else ""
19326:        f.write('
19327:        f.write("%s\n" % FFXarh(span.group(1)))
19328:   if totCh:
19329:    FFipXT(self, "Exported %s Channel%s to:\n\n%s" % (totCh, FFcacr(totCh), outF), title=Title)
19330:   else:
19331:    FFdw58(self, "Nothing to save.", title=Title)
19332:    FFwgGB(outF)
19333:  @staticmethod
19334:  def VVnmMH():
19335:   return {"1": "DVB Stream", "4097": "ServiceMp3", "5001": "GST Player", "5002": "ExtEPlayer3", "8192": "HDMI input", "8193": "eServiceUri", "8793": "ServiceUrl"}
19336:  @staticmethod
19337:  def VV5LSJ():
19338:   return sorted(tuple(CCkEI5.VVnmMH()))
19339:  @staticmethod
19340:  def VVDWCB(rt):
19341:   return CCkEI5.VVnmMH().get(str(rt), "")
19342:  @staticmethod
19343:  def VVBbrv(VVPxk5):
19344:   span = iSearch(r"(?:([A-Fa-f0-9]+):){1}(?:[A-Fa-f0-9]+:){8}", VVPxk5)
19345:   return span.group(1) if span else ""
19346:  @staticmethod
19347:  def VV4IKy(VVPxk5):
19348:   return CCkEI5.VVDWCB(CCkEI5.VVBbrv(VVPxk5))
19349:  @staticmethod
19350:  def VVUDPe(rt):
19351:   if   rt == "1"  : return True
19352:   elif rt == "4097": return True
19353:   elif rt == "5001": return FFCyVu("/usr/bin/gstplayer") or FFCyVu("/usr/bin/gstplayer_gst-1.0")
19354:   elif rt == "5002": return FFCyVu("/usr/bin/exteplayer3")
19355:   elif rt == "8192": return False
19356:   elif rt == "8193": return FFCyVu("/usr/bin/apt-get")
19357:   elif rt == "8793": return FFCyVu("/usr/bin/apt-get")
19358:   else    : return False
19359:  @staticmethod
19360:  def VVMYQY(SELF, cbFnc):
19361:   def VVTWCX(rt, selectionObj, item):
19362:    FFRMYv(SELF, BF(VVRdGX, rt, selectionObj), "Save as Default Player ?", title="Current Player : %s (%s)" % (rt, CCkEI5.VVDWCB(rt)))
19363:   def VVRdGX(rt, selectionObj):
19364:    FFjt1c(CFG.iptvAddToBouquetRefType, rt)
19365:    selectionObj.cancel()
19366:    FF1mVE(SELF, "Saved", 800)
19367:   curRt = CC3rDi(SELF.session).refType
19368:   defRt = CFG.iptvAddToBouquetRefType.getValue()
19369:   VV3wat = []
19370:   for ndx, rt in enumerate(CCkEI5.VV5LSJ()):
19371:    if   rt == curRt: color, txt = VVFuwR, "(Current)"
19372:    elif rt == defRt: color, txt = VVZtfx, "(Default)"
19373:    else   : color = txt = ""
19374:    VV3wat.append(FFsLU5("%s\t%s %s" % (CCkEI5.VVDWCB(rt), rt, txt), rt, CCkEI5.VVUDPe(rt), color))
19375:    if ndx < 4 and ndx % 2: VV3wat.append(VVAL3j)
19376:   VVB4pu = ("Save", BF(VVTWCX, curRt)) if curRt != defRt else None
19377:   FFLFTC(SELF, cbFnc, VV3wat=VV3wat, width=700, title="Select Player", VVB4pu=VVB4pu, VVwltY="#11220000", VVkxBG="#11220000")
19378:  @staticmethod
19379:  def VVYuoh(VVZcRP):
19380:   if not FFHgaY(VVZcRP) and iMatch(r"(.+)(?:(?:\/live)*|\/movie|\/series)\/(.+)\/(.+)\/(.+):(.+)", VVZcRP):
19381:    return True
19382:   else:
19383:    return bool(CCkEI5.VV9F1k(VVZcRP))
19384:  @staticmethod
19385:  def VV9F1k(VVZcRP):
19386:   if "/timeshift/" in VVZcRP:
19387:    span = iSearch(r"(.+)\/timeshift\/(.+)\/(.+)\/.+\/.+\/(.+)\.ts:(.+)(?:\s>>)?", VVZcRP)
19388:    if span and all(span.groups()): return span.groups()
19389:   else:
19390:    span = iSearch(r"(.+)\/(.+)\/(.+)\/(\d+):(.+)", VVZcRP)
19391:    if span and all(span.groups()):
19392:     return span.groups()
19393:    elif "chCode" in VVZcRP:
19394:     span = iSearch(r"(http.+)\/(.+)\/(.+)\/(\d+)\?play_token.+&end=:(.+)", VVZcRP)
19395:     if span and all(span.groups()):
19396:      return span.groups()
19397:   return None
19398:  @staticmethod
19399:  def VVQNEW():
19400:   return "Mozilla/5.0 (U; Linux; C; Emulator/1.2.12) AppleWebKit/533.3 (KHTML, like Gecko) Safari/533.3"
19401:  @staticmethod
19402:  def VVgoVw():
19403:   return { 'User-Agent': CCkEI5.VVQNEW() }
19404: class CCE4dD(object):
19405:  def __init__(self, SELF):
19406:   SELF["mySbFrm"] = Label()
19407:   SELF["mySbBak"] = Label()
19408:   SELF["mySbSld"] = Label()
19409:   self.frm, self.bak, self.sld = SELF["mySbFrm"], SELF["mySbBak"], SELF["mySbSld"]
19410:   self.frmI = self.bakI = self.sldI = None
19411:   self.sldX = self.sldY = self.sldW = self.sldH = 0
19412:   for obj in (self.frm, self.bak, self.sld): obj.hide()
19413:  def VVdDaQ(self, x, y, w, h, bW=1, frmColor="#11aaaaaa", bakColor="#11003344", sldColor="#11ff8000"):
19414:   x, y, w, h = int(x), int(y), int(w), int(h)
19415:   FFZ0AC(self.frm, frmColor)
19416:   FFZ0AC(self.bak, bakColor)
19417:   FFZ0AC(self.sld, sldColor)
19418:   self.frmI, self.bakI, self.sldI = self.frm.instance, self.bak.instance, self.sld.instance
19419:   self.frmI.move(ePoint(x, y))
19420:   self.frmI.resize(eSize(w, h))
19421:   self.bakI.move(ePoint(x + bW, y + bW))
19422:   self.bakI.resize(eSize(w - bW * 2, h - bW * 2))
19423:   self.sldX = x + bW
19424:   self.sldY = y + bW
19425:   self.sldW = w - bW * 2
19426:   self.sldH = h - bW * 2
19427:   self.sldI.move(ePoint(self.sldX, self.sldY))
19428:   self.sldI.resize(eSize(self.sldW, self.sldH))
19429:  def VVO0oI(self, val, maxN):
19430:   if maxN < 2:
19431:    for obj in (self.frm, self.bak, self.sld): obj.hide()
19432:   else:
19433:    for obj in (self.frm, self.bak, self.sld): obj.show()
19434:    visH = max(self.sldH / maxN, self.sldH * 0.05)
19435:    self.sldI.resize(eSize(self.sldW, int(visH)))
19436:    y = FFjFSv(val, 1, maxN, 0, self.sldH - visH)
19437:    self.sldI.move(ePoint(self.sldX, int(self.sldY + y)))
19438: class CCsyCY(CCE4dD):
19439:  def __init__(self, VV6zIF=""):
19440:   self.VVQ3Dp  = self.VVfOli["VVUuJZ"]["rows"]
19441:   self.VVsHeH  = self.VVfOli["VVUuJZ"]["cols"]
19442:   self.VVg3d5  = self.VVQ3Dp * self.VVsHeH
19443:   self.VV6zIF  = VV6zIF
19444:   self.VVUwNK  = self.VVfOli["VVUuJZ"].get("percBar", 0)
19445:   self.VVbKuB  = 0
19446:   self.VVUeUp  = 0
19447:   self.VVSmMg  = 0
19448:   self.curRow   = 0
19449:   self.curCol   = 0
19450:   self.VVBGsZ  = 0
19451:   self.VV3uAw  = 0
19452:   self.VVcG7K  = 0
19453:   self.VVGCBk  = 0
19454:   self.VV6wbi   = False
19455:   self.VVzIFK   = {}
19456:   self.VVuKJI  = None
19457:   self.VVa0gN  = {}
19458:   self.VVP8y1  = 0
19459:   self.VVIgWJ  = 0
19460:   self.VVC1Tl  = ""
19461:   self.VVQODt = True
19462:   self.VVLEOv = False
19463:   CCE4dD.__init__(self, self)
19464:   self["myCursorLbl"]  = Label()
19465:   self["myCursorPic"]  = Pixmap()
19466:   self["myPiconF"]  = Label()
19467:   self["myPiconBG"]  = Label()
19468:   self["myPiconPic"]  = Pixmap()
19469:   self["myPiconF"].hide()
19470:   self["myPiconBG"].hide()
19471:   self["myPiconPic"].hide()
19472:   for row in range(self.VVQ3Dp):
19473:    for col in range(self.VVsHeH):
19474:     self["myPosterBak%d%d" % (row, col)] = Pixmap()
19475:     self["myPosterRep%d%d" % (row, col)] = Label()
19476:     self["myPosterPic%d%d" % (row, col)] = Pixmap()
19477:     self["myPosterPic%d%d" % (row, col)].hide()
19478:     self["myPosterBak%d%d" % (row, col)].hide()
19479:     self["myPosterLbl%d%d" % (row, col)] = Label()
19480:     self["myPosterLbl%d%d" % (row, col)].hide()
19481:     if self.VVUwNK:
19482:      for nm in ("myPercFr", "myPercBG", "myPercFG"):
19483:       self[nm + "%d%d" % (row, col)] = Label()
19484:       self[nm + "%d%d" % (row, col)].hide()
19485:   self.VVaFRk()
19486:   VVSZWt, boxT, boxW, boxH, infT, infH, totInf, bGap = self.VVfOli["retPar"]
19487:   for i in range(totInf):
19488:    self["myPiconInf%d" % i] = Label()
19489:   FFHlAU(self,
19490:   {
19491:    "up"  : self.VVx0di   ,
19492:    "down"  : self.VVDBsZ  ,
19493:    "left"  : self.VVziFC  ,
19494:    "right"  : self.VVLe1s  ,
19495:    "next"  : self.VVSYHQ ,
19496:    "last"  : self.VVLlE3  ,
19497:    "pageUp" : self.VVLlE3  ,
19498:    "chanUp" : self.VVLlE3  ,
19499:    "pageDown" : self.VVSYHQ ,
19500:    "chanDown" : self.VVSYHQ ,
19501:    "0"   : self.VVkrIc
19502:   })
19503:  def VVCHVq(self, sbDim=None, sbFrmW=1, sbFrmColor="#11aaaaaa", sbBg="#11003344", sbSldBg="#11ff8000", shade="", cursor="
19504:   self.VVGEkC(shade)
19505:   if cursor == "swap" : self.VVLEOv = True
19506:   else    : self.VVrs4x(cursor)
19507:   self.VVGyYL()
19508:   self["myPiconPic"].instance.setScale(1)
19509:   for row in range(self.VVQ3Dp):
19510:    for col in range(self.VVsHeH):
19511:     self["myPosterPic%d%d" % (row, col)].instance.setScale(1)
19512:     sz = self["myPosterPic%d%d" % (row, col)].instance.size()
19513:     pos= self["myPosterPic%d%d" % (row, col)].instance.position()
19514:     self.VVzIFK[(row, col)] = ((pos.x(), pos.y()))
19515:     self.VVuKJI = (sz.width(), sz.height())
19516:   gap = int(self.VVfOli["VVSZWt"] / 1)
19517:   topBox = self["myPosterPic%d%d" % (0, 0)].instance
19518:   sz = topBox.size()
19519:   self.VVP8y1 = sz.width()
19520:   self.VVIgWJ = sz.height()
19521:   boxX, boxY, boxW, boxH, infT, infH, totInf, bGap = self.VVfOli["retPar"]
19522:   if sbDim:
19523:    x, y, w, h = sbDim
19524:   elif self.VVfOli["VVUuJZ"].get("upSBar", False):
19525:    x, y, w, h = self.VVfOli["width"] - 22, self.VVfOli["titleH"] + 8, 15, infH - 12
19526:   else:
19527:    w = 20
19528:    y = infT + infH + 3
19529:    h = self.VVfOli["height"] - self.VVfOli["VVeFSs"] - y - 2
19530:    x = self.VVfOli["width"] - w - 2
19531:   self.VVdDaQ(x, y, w, h, bW=sbFrmW, frmColor=sbFrmColor, bakColor=sbBg, sldColor=sbSldBg)
19532:   for row in range(self.VVQ3Dp):
19533:    for col in range(self.VVsHeH):
19534:     FFK4PQ(self["myPosterLbl%d%d" % (row, col)], "#000000", 2)
19535:   self["myCursorLbl"].hide()
19536:   self["myCursorPic"].hide()
19537:  def VVGEkC(self, val):
19538:   self.VVC1Tl = val
19539:   if val:
19540:    p = CC6u6z.VVQuYE(self["myPosterBak00"], val, toPng=True) or VVIp2p + "frm2.png"
19541:    png = FFmNfu(p)
19542:   else:
19543:    png = None
19544:   for row in range(self.VVQ3Dp):
19545:    for col in range(self.VVsHeH):
19546:     pic = self["myPosterBak%d%d" % (row, col)]
19547:     pic.instance.setPixmap(png)
19548:     pic.instance.invalidate()
19549:     if self.VVC1Tl:
19550:      pic.show()
19551:  def VVrs4x(self, cursor):
19552:   if not cursor or cursor.startswith("/"):
19553:    self["myCursorLbl"].hide()
19554:    self["myCursorPic"].show()
19555:    FFBFPY(self["myCursorPic"], cursor if FFCyVu(cursor) else VVIp2p + "frm1.png")
19556:   else:
19557:    self.VVQODt = False
19558:    self["myCursorPic"].hide()
19559:    self["myCursorLbl"].show()
19560:    if iMatch(r"^
19561:     FFZ0AC(self["myCursorLbl"], cursor)
19562:  def VVTrjr(self):
19563:   if not self.VVuKJI:
19564:    return
19565:   normC, cursC = "#00444444", "#00ffff00"
19566:   for row in range(self.VVQ3Dp):
19567:    for col in range(self.VVsHeH):
19568:     ndx = self.VVvg4K(row, col)
19569:     picInst = self["myPosterPic%d%d" % (row, col)].instance
19570:     cursInst = self["myCursorPic"].instance
19571:     cPos, cSz = cursInst.position(), cursInst.size()
19572:     if (row, col) == (self.curRow, self.curCol):
19573:      x, y, w, h = cPos.x(), cPos.y(), cSz.width(), cSz.height()
19574:      if ndx in self.VVa0gN:
19575:       _, y, w1, h1 = self.VVa0gN[ndx]
19576:       _, _, w, h = self.VVF7W0(w1, h1, w, h)
19577:       x, w = x + 6, w - 12
19578:       self["myCursorPic"].show()
19579:       cursInst.setBorderColor(parseColor(cursC))
19580:       cursInst.setBorderWidth(4)
19581:      else:
19582:       picInst.setBorderColor(parseColor(cursC))
19583:       picInst.setBorderWidth(4)
19584:     elif ndx in self.VVa0gN:
19585:      x, y, w, h = self.VVa0gN[ndx]
19586:     else:
19587:      (x, y), (w, h) = self.VVzIFK[(row, col)], self.VVuKJI
19588:      if self.VV3uAw == self.VVvg4K(row, col):
19589:       picInst.setBorderColor(parseColor(normC))
19590:       picInst.setBorderWidth(1)
19591:     picInst.move(ePoint(x, y))
19592:     picInst.resize(eSize(*(w, h)))
19593:  def VVaJVd(self, ndx, row, col, pic, path, reset=False):
19594:   inst = pic.instance
19595:   if reset:
19596:    if (row, col) == (self.curRow, self.curCol):
19597:     curs = self["myCursorPic"].instance
19598:     cPos, cSz = curs.position(), curs.size()
19599:     boxX, boxY, boxW, boxH = cPos.x(), cPos.y(), cSz.width(), cSz.height()
19600:    else:
19601:     (boxX, boxY), (boxW, boxH) = self.VVzIFK[(row, col)], self.VVuKJI
19602:    if ndx in self.VVa0gN:
19603:     del self.VVa0gN[ndx]
19604:   else:
19605:    boxX, boxY = self.VVzIFK[(row, col)]
19606:    boxW, boxH = self.VVuKJI
19607:   png = FFmNfu(path) or FFmNfu(VVIp2p + "noPic.png")
19608:   if png:
19609:    inst.setBorderWidth(0)
19610:   else:
19611:    inst.setBorderColor(parseColor("#00ff8055"))
19612:    inst.setBorderWidth(2)
19613:    return False
19614:   pngSz = png.size()
19615:   pngW, pngH = pngSz.width(), pngSz.height()
19616:   inst.setPixmap(png)
19617:   if (pngW > pngH and boxH > boxW) or (pngH > pngW and boxW > boxH) or (pngW == pngH and boxW != boxH):
19618:    x, y, w, h = CCsyCY.VVF7W0(pngW, pngH, boxW, boxH)
19619:    x += boxX
19620:    y += boxY
19621:    self.VVa0gN[ndx] = (x, y, w, h)
19622:   else:
19623:    x, y, w, h = boxX, boxY, boxW, boxH
19624:    inst.setBorderColor(parseColor("#00444444"))
19625:    inst.setBorderWidth(1)
19626:   inst.resize(eSize(*(w, h)))
19627:   inst.move(ePoint(x, y))
19628:   return True
19629:  def VVjkVK(self, colors):
19630:   for i, (fg, bg) in enumerate(colors):
19631:    if fg: FFGUI5(self["myPiconInf%d" % i], fg)
19632:    if bg: FFZ0AC(self["myPiconInf%d" % i], bg)
19633:  def VVkhlj(self, inf0, inf1):
19634:   self["myPiconInf0"].setText("  %s  " % inf0 )
19635:   self["myPiconInf1"].setText("   %s   " % inf1)
19636:   self["myPiconInf2"].setText("Num. : %d / %d" % (self.VVBGsZ + 1, self.VVbKuB))
19637:   self["myPiconInf3"].setText("Page: %d / %d"  % (self.VVSmMg  + 1, self.VVUeUp))
19638:  def VVS7BN(self):
19639:   f1 = self.VVSmMg * self.VVg3d5
19640:   f2 = f1 + self.VVg3d5
19641:   if f1 > self.VVbKuB: f1 = self.VVbKuB
19642:   if f2 > self.VVbKuB: f2 = self.VVbKuB
19643:   return f1, f2
19644:  def VVx0di(self):
19645:   if self.VVSmMg == self.curRow == self.curCol == 0:
19646:    self.VVGc2k()
19647:   else:
19648:    if self.VVSmMg == 0 and self.curRow == 0: self.curCol = 0
19649:    else          : self.curRow -= 1
19650:    self.VVLckG()
19651:  def VVDBsZ(self):
19652:   if self.VVSmMg == self.VVUeUp - 1 and self.curRow == self.VVcG7K and self.curCol == self.VVGCBk:
19653:    self.VVPhaY()
19654:   else:
19655:    if self.VVSmMg == self.VVUeUp - 1 and self.curRow == self.VVcG7K:
19656:     self.curCol = self.VVGCBk
19657:    else:
19658:     self.curRow += 1
19659:    self.VVLckG()
19660:  def VVziFC(self):
19661:   if self.VVSmMg == self.curRow == self.curCol == 0:
19662:    self.VVGc2k()
19663:   else:
19664:    self.curCol -= 1
19665:    self.VVLckG()
19666:  def VVLe1s(self):
19667:   if self.VVSmMg == self.VVUeUp - 1 and self.curRow == self.VVcG7K and self.curCol == self.VVGCBk:
19668:    self.VVPhaY()
19669:   else:
19670:    self.curCol += 1
19671:    self.VVLckG()
19672:  def VVLlE3(self):
19673:   oldPage = self.VVSmMg
19674:   if self.VVSmMg == 0:
19675:    self.curRow = 0
19676:    self.curCol = 0
19677:   else:
19678:    self.VVSmMg -= 1
19679:   self.VVLckG(oldPage != self.VVSmMg)
19680:  def VVSYHQ(self):
19681:   oldPage = self.VVSmMg
19682:   if self.VVSmMg == self.VVUeUp - 1:
19683:    self.curRow = self.VVcG7K
19684:    self.curCol = self.VVGCBk
19685:   else:
19686:    self.VVSmMg += 1
19687:   self.VVLckG(oldPage != self.VVSmMg)
19688:  def VVkrIc(self):
19689:   if self.VVBGsZ == 0: self.VVGc2k()
19690:   else     : self.VVPhaY()
19691:  def VVPhaY(self):
19692:   force = self.VVSmMg != 0
19693:   self.curRow  = 0
19694:   self.curCol  = 0
19695:   self.VVSmMg = 0
19696:   self.VVLckG(force)
19697:  def VVGc2k(self):
19698:   force = self.VVSmMg != self.VVUeUp - 1
19699:   self.VVSmMg = self.VVUeUp - 1
19700:   self.curRow  = (self.VVQ3Dp - 1)
19701:   self.curCol  = (self.VVsHeH - 1)
19702:   self.VVLckG(force)
19703:  def VVLckG(self, force=False):
19704:   if self.VV6wbi:
19705:    return
19706:   oldPage = self.VVSmMg
19707:   if self.curCol > self.VVsHeH - 1:
19708:    self.curCol = 0
19709:    self.curRow += 1
19710:   elif self.curCol < 0:
19711:    self.curCol = self.VVsHeH - 1
19712:    self.curRow -= 1
19713:   if self.curRow > self.VVQ3Dp - 1:
19714:    self.curRow = 0
19715:    self.VVSmMg += 1
19716:   elif self.curRow < 0:
19717:    self.curRow = self.VVQ3Dp - 1
19718:    self.VVSmMg -= 1
19719:   VVSI5d = self.VVUeUp -1
19720:   if   self.VVSmMg < 0  : self.VVSmMg = 0
19721:   elif self.VVSmMg > VVSI5d: self.VVSmMg = VVSI5d
19722:   if self.curRow > self.VVQ3Dp - 1: self.curRow = self.VVQ3Dp - 1
19723:   if self.curCol < 0     : self.curCol = 0
19724:   self.VVHvUS()
19725:   self["myCursorLbl"].hide()
19726:   self["myCursorPic"].hide()
19727:   self.VVO0oI(self.VVSmMg + 1, self.VVUeUp)
19728:   FFIElK(BF(self.VVF5e6, force or not oldPage == self.VVSmMg, VVSI5d))
19729:  def VVF5e6(self, force, VVSI5d):
19730:   try:
19731:    if force:
19732:     self.VVa0gN = {}
19733:     self.VVe4Ro()
19734:    if self.VVSmMg == VVSI5d:
19735:     if self.curRow > self.VVcG7K:
19736:      self.curRow = self.VVcG7K
19737:     if self.curRow == self.VVcG7K and self.curCol > self.VVGCBk:
19738:      self.curCol = self.VVGCBk
19739:    self.VV3uAw = self.VVBGsZ
19740:    self.VVBGsZ = self.VVSmMg * self.VVg3d5 + self.curRow * self.VVsHeH + self.curCol
19741:    self.VVHvUS()
19742:    boxX, boxY, boxW, boxH, infT, infH, totInf, bGap = self.VVfOli["retPar"]
19743:    self["myCursorLbl"].instance.move(ePoint(int(boxX + (boxW + bGap) * self.curCol) + 1, int(boxY + (boxH + bGap) * self.curRow) + 1))
19744:    self["myCursorPic"].instance.move(ePoint(int(boxX + (boxW + bGap) * self.curCol) + 1, int(boxY + (boxH + bGap) * self.curRow) + 1))
19745:    if self.VVLEOv:
19746:     self.VVTrjr()
19747:    else:
19748:     if self.VVQODt : self["myCursorPic"].show()
19749:     else    : self["myCursorLbl"].show()
19750:   except:
19751:    pass
19752:  def VVvg4K(self, row, col):
19753:   return self.VVSmMg * self.VVg3d5 + row * self.VVsHeH + col
19754:  def VVdLxd(self, ndx):
19755:   if ndx > -1 and ndx < self.VVbKuB:
19756:    oldPage   = self.VVSmMg
19757:    self.VVSmMg = int(ndx / self.VVg3d5)
19758:    firstInPage  = self.VVSmMg * self.VVg3d5
19759:    diff   = ndx - firstInPage
19760:    self.curRow  = int(diff / self.VVsHeH)
19761:    firstInRow  = self.curRow * self.VVsHeH
19762:    diff   = ndx - firstInPage
19763:    self.curCol  = diff - self.curRow * self.VVsHeH
19764:    self.VVLckG(False if oldPage == self.VVSmMg else True)
19765:   else:
19766:    FF28n1(self, "Not found", 1000)
19767:  def VVozNN(self):
19768:   if self.VV6zIF:
19769:    for row in range(self.VVQ3Dp):
19770:     for col in range(self.VVsHeH):
19771:      self["myPosterRep%d%d" % (row, col)].hide()
19772:  def VVaFRk(self):
19773:   for row in range(self.VVQ3Dp):
19774:    for col in range(self.VVsHeH):
19775:     for nm in ("myPosterBak", "myPosterRep", "myPosterPic", "myPosterLbl"):
19776:      self[nm + "%d%d" % (row, col)].hide()
19777:     if self.VVUwNK:
19778:      for nm in ("myPercFr", "myPercBG", "myPercFG"):
19779:       self[nm + "%d%d" % (row, col)].hide()
19780:  def VVwbpA(self, row, col):
19781:   if self.VVC1Tl:
19782:    self["myPosterBak%d%d" % (row, col)].show()
19783:   if not self.VVLEOv:
19784:    self["myPosterRep%d%d" % (row, col)].show()
19785:   pic = self["myPosterPic%d%d" % (row, col)]
19786:   lbl = self["myPosterLbl%d%d" % (row, col)]
19787:   pic.show()
19788:   lbl.show()
19789:   return pic, lbl
19790:  def VV3wsR(self, row, col, perc):
19791:   if self.VVUwNK and perc > -1:
19792:    if perc > -1:
19793:     bgLbl = self["myPercBG%d%d" % (row, col)]
19794:     fgLbl = self["myPercFG%d%d" % (row, col)]
19795:     sz = bgLbl.instance.size()
19796:     fgLbl.instance.resize(eSize(*(min(perc, 100) * sz.width() // 100, sz.height())))
19797:     for nm in ("myPercFr", "myPercBG", "myPercFG"):
19798:      self[nm + "%d%d" % (row, col)].show()
19799:  def VVA2WD(self):
19800:   if self.VV6zIF:
19801:    fg = bg = self.VV6zIF.getValue()
19802:    self.session.openWithCallback(self.VVnMYE, CC1FS2, defFG=fg, defBG=bg, onlyBG=True)
19803:  def VVnMYE(self, fg, bg):
19804:   if self.VV6zIF and bg:
19805:    FFjt1c(self.VV6zIF, bg)
19806:    self.VVGyYL()
19807:  def VVGyYL(self):
19808:   if self.VV6zIF:
19809:    for row in range(self.VVQ3Dp):
19810:     for col in range(self.VVsHeH):
19811:      FFZ0AC(self["myPosterRep%d%d" % (row, col)], self.VV6zIF.getValue())
19812:  def VVExY8(self, lbl, txt, color=""):
19813:   CCsyCY.VVaiX0(lbl, txt, color)
19814:  @staticmethod
19815:  def VVaiX0(lbl, txt, color=""):
19816:   lbl.show()
19817:   lbl.setText(txt)
19818:   txtW = lbl.instance.calculateSize().width()
19819:   lblW = lbl.instance.size().width() - 15
19820:   if txtW > lblW:
19821:    for i in range(len(txt), 5, -1):
19822:     txt = txt[:-1]
19823:     lbl.setText("%s.." % txt)
19824:     txtW = lbl.instance.calculateSize().width()
19825:     if txtW < lblW:
19826:      break
19827:   if color:
19828:    lbl.setText("%s%s" % (color, txt))
19829:  @staticmethod
19830:  def VVF7W0(pngW, pngH, boxW, boxH):
19831:   r_old = float(pngW) / pngH
19832:   r_new = float(boxW) / boxH
19833:   if (r_old > r_new):
19834:    w = boxW
19835:    h = int(float(w) / r_old)
19836:    x = 0
19837:    y = int((boxH - h) / 2.0) + 4
19838:   else:
19839:    h = boxH
19840:    w = int(h * r_old)
19841:    y = 2
19842:    x = int((boxW - w) / 2.0)
19843:   return x, y, w, h
19844: class CCUYzx(Screen, CCsyCY):
19845:  CANCEL_POSTER_DOWNLOAD = False
19846:  def __init__(self, session, VV6A99, pPath, nameCol, picCol, descCol, descTxt):
19847:   self.skin, self.VVfOli = FFiNEe(VVpLGo, 1870, 1030, 50, 20, 20, "#06112a33", "#06112a33", 50, VV0Ay7=2, VVt3Ak=20, VVUuJZ={"rows":2, "cols":6, "picR":0.90, "lblR":0.10, "w1R":0.85, "w2R":0.15, "gapX":35, "gapY":35})
19848:   self.session   = session
19849:   self.VV6A99  = VV6A99
19850:   self.pPath    = pPath
19851:   self.nameCol   = nameCol
19852:   self.picCol    = picCol
19853:   self.descCol   = descCol
19854:   self.descTxt   = descTxt
19855:   self.Title    = VV6A99.Title or "Server Browser"
19856:   self.timer_updPic  = eTimer()
19857:   self.totThreads   = 0
19858:   self.VV1tA1 = set()
19859:   self.totDownloads  = 0
19860:   self.VVGape    = []
19861:   self.postersNdxLst  = []
19862:   self.totPosterUrls  = 0
19863:   self.VVbKuB   = 0
19864:   self.VVpQCY  = True
19865:   self.isInPlayer   = False
19866:   FFZMxC(self, self.Title)
19867:   CCsyCY.__init__(self)
19868:   if not VVmJwX(self.pPath):
19869:    FFpwZS("mkdir -p '%s'" % self.pPath)
19870:    if not VVmJwX(self.pPath):
19871:     self.pPath = "/tmp/"
19872:   FFBep1(self,
19873:   {
19874:    "ok" : self.VVPr1F    ,
19875:    "cancel": self.close    ,
19876:    "menu" : self.VVFYyH ,
19877:    "info" : self.VVLrXf
19878:   })
19879:   self.onShown.append(self.VV7OzD)
19880:   self.onClose.append(self.onExit)
19881:  def VV7OzD(self):
19882:   if self.VVpQCY:
19883:    self.VVpQCY = False
19884:    FF6W0I(self)
19885:    FFWgBS(self)
19886:    self.VVCHVq(cursor="swap", sbSldBg="#00777777")
19887:    for i in range(4):
19888:     FFZ0AC(self["myPiconInf%s" % i], "#0a001a22")
19889:    self.VV35bc()
19890:   elif self.isInPlayer:
19891:    self.isInPlayer = False
19892:    VVSmMg, curRow, curCol = self.VVSmMg, self.curRow, self.curCol
19893:    self.VVjT0n()
19894:    if (VVSmMg, curRow, curCol) != (self.VVSmMg, self.curRow, self.curCol):
19895:     self.VVLckG(False if VVSmMg == self.VVSmMg else True)
19896:  def VVjT0n(self):
19897:   ndx = self.VV6A99.VVGTqU()
19898:   self.VVSmMg = int(ndx / self.VVg3d5)
19899:   ndx     -= self.VVSmMg * self.VVg3d5
19900:   self.curRow  = int((ndx / self.VVsHeH))
19901:   ndx     -= self.curRow * self.VVsHeH
19902:   self.curCol  = int((ndx % self.VVsHeH))
19903:  def onExit(self):
19904:   CCUYzx.CANCEL_POSTER_DOWNLOAD = True
19905:   self.timer_updPic.stop()
19906:  def VVFYyH(self):
19907:   VV1wIO, subj, desc, fName, VVfbmn = self.VVGape[self.VVBGsZ]
19908:   picOk = FFCyVu(self.pPath + fName)
19909:   VV3wat = []
19910:   VV3wat.append(FFsLU5("Show Selected Picture"        , "VVIENY"  , picOk))
19911:   VV3wat.append(FFsLU5("Export Selected Picture"        , "VV9oi3" , picOk))
19912:   VV3wat.append(FFsLU5("Set Selected Picture as a Poster for a Local Media" , "VVFrce", picOk))
19913:   VV3wat.append(VVAL3j)
19914:   VV3wat.append(("Cache details"       , "VVkieu"  ))
19915:   VV3wat.append(VVAL3j)
19916:   VV3wat.append(("Help (Keys)"        , "help"     ))
19917:   FFLFTC(self, self.VVrAZ5, title=self.Title, VV3wat=VV3wat)
19918:  def VVrAZ5(self, item=None):
19919:   if item is not None:
19920:    if   item == "VVIENY"   : self.VVIENY()
19921:    elif item == "VV9oi3"   : self.VV9oi3()
19922:    elif item == "VVFrce"  : self.VVFrce()
19923:    elif item == "VVkieu"  : self.VVkieu()
19924:    elif item == "help"     : FFw2rR(self, "_help_servBr", "Server Browser (Keys)")
19925:  def VVPr1F(self):
19926:   self.VV6A99.VVrqBw(self.VVBGsZ)
19927:   self.VV6A99.VVDFgE()
19928:   self.isInPlayer = True
19929:  def VVLrXf(self):
19930:   self.VV6A99.VVrqBw(self.VVBGsZ)
19931:   self.VV6A99.VVyogT()
19932:  def VVmIuN(self, url):
19933:   span = iSearch(r".+\.(png|jpg|jpeg)", url, IGNORECASE)
19934:   if span:
19935:    ext = span.group(1)
19936:   else:
19937:    ext = "jpg"
19938:    for ex in (".jpg", ".png", ".jpeg"):
19939:     if ex in url.lower():
19940:      ext = ex[1:]
19941:      break
19942:   ext = ext.lower()
19943:   if ext == "jpeg": ext = "jpg"
19944:   return "%s.%s" % (FFbhOc(url), ext)
19945:  def VV35bc(self):
19946:   for colList in self.VV6A99.VVrrm9():
19947:    VV1wIO = colList[self.nameCol]
19948:    url  = colList[self.picCol]
19949:    desc = colList[self.descCol]
19950:    fName = VVfbmn = ""
19951:    if url:
19952:     tmpFile = self.VVmIuN(url)
19953:     if FFCyVu(self.pPath + tmpFile):
19954:      fName = tmpFile
19955:     else:
19956:      VVfbmn = url
19957:      self.totPosterUrls += 1
19958:    self.VVGape.append((VV1wIO, self.descTxt, desc, fName, VVfbmn))
19959:   self.VVbKuB = len(self.VVGape)
19960:   self.VVUeUp = int(self.VVbKuB / self.VVg3d5) + (self.VVbKuB % self.VVg3d5 > 0)
19961:   self.VVjT0n()
19962:   self.VVLckG(True)
19963:   for ndx, (VV1wIO, subj, desc, fName, VVfbmn) in enumerate(self.VVGape):
19964:    if VVfbmn and not fName:
19965:     self.postersNdxLst.append(ndx)
19966:   CCUYzx.CANCEL_POSTER_DOWNLOAD = False
19967:   try: self.timer_updPic_conn = self.timer_updPic.timeout.connect(self.VVyKPA)
19968:   except: self.timer_updPic.callback.append(self.VVyKPA)
19969:   self.timer_updPic.start(50, False)
19970:  def VVffim(self):
19971:   if self.postersNdxLst and self.totThreads < 8:
19972:    iThread(name="ajp_DnldPic", target=self.VVZvfo).start()
19973:  def VVZvfo(self):
19974:   try:
19975:    if CCUYzx.CANCEL_POSTER_DOWNLOAD: return
19976:    self.totThreads += 1
19977:    ndx = self.postersNdxLst[0]
19978:    self.postersNdxLst.pop(0)
19979:    VV1wIO, subj, desc, fName, VVfbmn = self.VVGape[ndx]
19980:    if VVfbmn and not fName:
19981:     if CCUYzx.CANCEL_POSTER_DOWNLOAD: return
19982:     VV1wIO, subj, desc, fName, VVfbmn = self.VVGape[ndx]
19983:     fName = self.VVmIuN(VVfbmn)
19984:     if not fName in self.VV1tA1:
19985:      self.VV1tA1.add(fName)
19986:      path, err = FFx9uM(VVfbmn, fName, timeout=2, VVzHui=True, VVf6G8=False)
19987:      if path:
19988:       if CCUYzx.CANCEL_POSTER_DOWNLOAD:
19989:        FFwgGB(path)
19990:        return
19991:       cmd = CCvjVs.VVQ9GP(path, 500)
19992:       cmd += FFb2oQ("mv -f '%s' '%s'" % (path, self.pPath + fName))
19993:       FFpwZS(cmd)
19994:     if CCUYzx.CANCEL_POSTER_DOWNLOAD: return
19995:     self.totDownloads += 1
19996:     self.VVGape[ndx] = (VV1wIO, subj, desc, fName, "-")
19997:    self.totThreads -= 1
19998:   except:
19999:    pass
20000:  def VVyKPA(self):
20001:   if self.postersNdxLst:
20002:    if self.totThreads < 8:
20003:     iThread(name="ajp_DnldPic", target=self.VVZvfo).start()
20004:    txt = VVYjI5 + "   >> Downloading %d/%d ..." % (self.totDownloads, self.totPosterUrls)
20005:   else:
20006:    txt = ""
20007:   self["myTitle"].setText("  %s%s" % (self.Title, txt))
20008:   last = self.VVbKuB
20009:   f1 = self.VVSmMg * self.VVg3d5
20010:   f2 = f1 + self.VVg3d5
20011:   if f1 > last: f1 = last
20012:   if f2 > last: f2 = last
20013:   row = col = remain = 0
20014:   for ndx in range(f1, f2):
20015:    VV1wIO, subj, desc, fName, VVfbmn = self.VVGape[ndx]
20016:    if fName and VVfbmn == "-":
20017:     path = self.pPath + fName
20018:     if FFCyVu(path):
20019:      self.VVGape[ndx] = (VV1wIO, subj, desc, fName, "")
20020:      pic, lbl = self.VVwbpA(row, col)
20021:      self.VVaJVd(ndx, row, col, pic, path, reset=True)
20022:      if ndx == self.VVBGsZ and self.VVLEOv:
20023:       self.VVTrjr()
20024:    if VVfbmn and not fName:
20025:     remain += 1
20026:    col += 1
20027:    if col > (self.VVsHeH - 1):
20028:     col = 0
20029:     row += 1
20030:   if not txt:
20031:    self.VV1tA1 = set()
20032:    FFOKt0(self, 2000, self.timer_updPic.stop)
20033:  def VVe4Ro(self):
20034:   self.VVaFRk()
20035:   f1, f2 = self.VVS7BN()
20036:   row = col = 0
20037:   for ndx in range(f1, f2):
20038:    VV1wIO, subj, desc, fName, VVfbmn = self.VVGape[ndx]
20039:    pic, lbl = self.VVwbpA(row, col)
20040:    self.VVExY8(lbl, VV1wIO)
20041:    self.VVaJVd(ndx, row, col, pic, self.pPath + fName)
20042:    self.VVcG7K = row
20043:    self.VVGCBk = col
20044:    col += 1
20045:    if col > (self.VVsHeH - 1):
20046:     col = 0
20047:     row += 1
20048:  def VVHvUS(self):
20049:   VV1wIO, subj, desc, fName, VVfbmn = self.VVGape[self.VVBGsZ]
20050:   self.VVkhlj(VV1wIO, "%s : %s" % (subj, desc) if desc else "")
20051:  def VVIENY(self):
20052:   VV1wIO, subj, desc, fName, VVfbmn = self.VVGape[self.VVBGsZ]
20053:   if fName and FFCyVu(self.pPath + fName) : CCf8zb.VVjnMn(self, self.pPath + fName)
20054:   else          : FF28n1(self, "File not found", 1500)
20055:  def VV9oi3(self):
20056:   title = "Copy Poster/PIcon"
20057:   VV1wIO, subj, desc, fName, VVfbmn = self.VVGape[self.VVBGsZ]
20058:   if fName:
20059:    dstPath = FFriZ7()
20060:    dstF = dstPath + (FFOu5Y(VV1wIO) + os.path.splitext(fName)[1] if VV1wIO else fName)
20061:    if FFpwZS("cp -f '%s' '%s'" % (self.pPath + fName, dstF)):
20062:     FFipXT(self, "File copied to:\n\n%s" % dstF, title=title)
20063:    else:
20064:     FFdw58(self, "Cannot copy the file:\n%s\n\nTo:\n%s" % (fName, dstPath), title=title)
20065:   else:
20066:    FFdw58(self, "No Poster/PIcon found", title=title)
20067:  def VVFrce(self):
20068:   self.session.openWithCallback(self.VV8Nqe, BF(CClYaF, VV1gDA="movies", VV1pbK=CFG.MovieDownloadPath.getValue()))
20069:  def VV8Nqe(self, path):
20070:   if path:
20071:    title = "Set Selected Picture as a Poster for a Local Media"
20072:    VV1wIO, subj, desc, fName, VVfbmn = self.VVGape[self.VVBGsZ]
20073:    if fName:
20074:     srcF = self.pPath + fName
20075:     dstF = "%s%s" % (os.path.splitext(path)[0], os.path.splitext(srcF)[1])
20076:     if FFpwZS("cp -f '%s' '%s'" % (srcF, dstF)):
20077:      FFipXT(self, "File copied to:\n\n%s" % dstF, title=title)
20078:     else:
20079:      FFdw58(self, "Cannot copy the file:\n%s\n\nTo:\n%s" % (fName, dstF), title=title)
20080:     CCG2jh.VVp7lg(dstF)
20081:    else:
20082:     FFdw58(self, "No Poster/PIcon found", title=title)
20083:  @FFOAKH("Calculating ...")
20084:  def VVkieu(self):
20085:   txt = "\n"
20086:   totSize = 0
20087:   for path in ("Live/", "VOD/", "Series/", "M3U/"):
20088:    path = "%sPosters/%s" % (FF0cqc(), path)
20089:    size = "Dir. not found !"
20090:    if VVmJwX(path):
20091:     size = FFTKR0("find '%s' ! -type d -print0 2> /dev/null | xargs -0 ls -lsa 2> /dev/null | awk '{sum+=$6;} END {print sum;}'" % path)
20092:     if size.isdigit():
20093:      size = int(size)
20094:      totSize += size
20095:      size = CClYaF.VV99gM(size)
20096:    txt += "%s\n    %s\n\n" % (FFjt5L(path, VVFuwR), size)
20097:   mainPath = "%sPosters" % FF0cqc()
20098:   totFiles = FFTKR0("find '%s' ! -type d | wc -l" % mainPath)
20099:   totFTxt = " (%s file%s)" % (totFiles, FFcacr(int(totFiles))) if totFiles.isdigit() else ""
20100:   txt += "%s\n    %s\n\n" % (FFjt5L("Total space used by Posters/PIcons%s:" % totFTxt, VV1fx4), CClYaF.VV99gM(totSize))
20101:   mountPath = CClYaF.VVuTcL(mainPath)
20102:   if VVmJwX(mountPath):
20103:    total, used, free, avail, err = CClYaF.VVdlF7(mountPath)
20104:    total, used, free, avail = [CClYaF.VV99gM(x) for x in (total, used, free, avail)]
20105:    txt += "%s\n" % SEP
20106:    txt += FFjt5L("Media Space:\n", VVIH76)
20107:    txt += "    Media Path\t: %s\n" % FFjt5L(mountPath, VVZtfx)
20108:    txt += "    Total Size\t: %s\n" % total
20109:    txt += "    Used Size\t: %s\n" % used
20110:    txt += "    Free Size\t: %s\n" % free
20111:    if free != avail: txt += "    Available\t: %s" % avail
20112:   FF4lCP(self, txt, title="Cache Used Size", height=1000)
20113: class CCG2jh(Screen, CCsyCY):
20114:  def __init__(self, session, title, lst):
20115:   self.skin, self.VVfOli = FFiNEe(VVpLGo, 1870, 1030, 50, 20, 20, "#06112233", "#06112233", 50, VV0Ay7=2, VVt3Ak=20, VVUuJZ={"rows":2, "cols":6, "picR":0.90, "lblR":0.10, "w1R":0.85, "w2R":0.15, "gapX":30, "gapY":30, "percBar":1})
20116:   self.session   = session
20117:   self.Title    = title
20118:   self.VVGape    = lst
20119:   self.VV295u   = -1
20120:   FFZMxC(self, self.Title)
20121:   CCsyCY.__init__(self)
20122:   FFBep1(self,
20123:   {
20124:    "ok" : self.VVfmN9 ,
20125:    "cancel": self.close   ,
20126:    "menu" : self.VV1ER9,
20127:    "info" : self.VVO0RC
20128:   })
20129:   self.onShown.append(self.VV7OzD)
20130:  def VV7OzD(self):
20131:   self.onShown.remove(self.VV7OzD)
20132:   FF6W0I(self)
20133:   FFWgBS(self)
20134:   self.VVCHVq(cursor="swap", sbSldBg="#00777777")
20135:   for i in range(4):
20136:    FFZ0AC(self["myPiconInf%s" % i], "#0a001122")
20137:   self.VVjIcM()
20138:  def VVjIcM(self):
20139:   self.VVbKuB = len(self.VVGape)
20140:   self.VVUeUp = int(self.VVbKuB / self.VVg3d5) + (self.VVbKuB % self.VVg3d5 > 0)
20141:   self.VVLckG(True)
20142:   self.VVMypQ(VVwb7n=False)
20143:  def VVe4Ro(self):
20144:   self.VVaFRk()
20145:   f1, f2 = self.VVS7BN()
20146:   mPath = CFG.MovieDownloadPath.getValue()
20147:   row = col = 0
20148:   for ndx in range(f1, f2):
20149:    path, movie, poster = self.VVGape[ndx]
20150:    movie = os.path.join(mPath, path, movie)
20151:    poster = os.path.join(mPath, path, poster)
20152:    pic, lbl = self.VVwbpA(row, col)
20153:    self.VVExY8(lbl, os.path.splitext(os.path.basename(movie))[0])
20154:    self.VVaJVd(ndx, row, col, pic, poster)
20155:    d = CCzUSd.VV0NUN(CCzUSd.VVc5Po(FFbhOc(movie)))
20156:    if d:
20157:     self.VV3wsR(row, col, int(round(100.0 * d["pos"] / d["dur"])))
20158:    self.VVcG7K = row
20159:    self.VVGCBk = col
20160:    col += 1
20161:    if col > (self.VVsHeH - 1):
20162:     col = 0
20163:     row += 1
20164:  def VVAoNk(self, ndx=-1):
20165:   if ndx == -1:
20166:    ndx = self.VVBGsZ
20167:   path, movie, poster = self.VVGape[ndx]
20168:   path = os.path.join(CFG.MovieDownloadPath.getValue(), path)
20169:   path = os.path.join(path, movie)
20170:   if poster:
20171:    poster = os.path.join(os.path.dirname(path), poster)
20172:   return path, poster
20173:  def VVHvUS(self):
20174:   path, poster = self.VVAoNk()
20175:   self.VVkhlj(os.path.splitext(os.path.basename(path))[0], os.path.dirname(path))
20176:  def VV1ER9(self):
20177:   fPath, fDir, fName = CClYaF.VV4zSS(self)
20178:   cur = False
20179:   if fPath:
20180:    for ndx, (path, movie, poster) in enumerate(self.VVGape):
20181:     if fPath == os.path.join(CFG.MovieDownloadPath.getValue(), path, movie):
20182:      cur = True
20183:      break
20184:   path, poster = self.VVAoNk()
20185:   c1, c2, c3 = VVJEMb, VVZtfx , VVFuwR
20186:   VV3wat = []
20187:   VV3wat.append((c1 + "Find a movie ..."   , "VVIwcG"  ))
20188:   VV3wat.append(FFsLU5("Go to Current Movie" , "VVMypQ", cur, c1 ))
20189:   VV3wat.append(VVAL3j)
20190:   VV3wat.append(("Add Selected Movie to Bouquet", "VV9nO90"))
20191:   VV3wat.append(("Add All Movies to Bouquet" , "VV9nO91"))
20192:   VV3wat.append(VVAL3j)
20193:   VV3wat.append(FFsLU5("Show Poster" , "VVIENY" , poster))
20194:   VV3wat.append(FFsLU5("Export Poster", "VV9oi3", poster))
20195:   VV3wat.append(VVAL3j)
20196:   VV3wat.append((c3 + "Change Poster (locate manually) ..." , "VVTwlc"  ))
20197:   VV3wat.append((c3 + "Change Poster (Download)"   , "VVmM4L" ))
20198:   VV3wat.append(VVAL3j)
20199:   VV3wat.append(("Help (Keys)", "help"))
20200:   FFLFTC(self, self.VVnk8m, width=900, title=self.Title, VV3wat=VV3wat)
20201:  def VVnk8m(self, item=None):
20202:   if item is not None:
20203:    if   item == "VVIwcG"  : self.VVIwcG()
20204:    elif item == "VVMypQ"    : self.VVMypQ()
20205:    elif item == "VV9nO90": self.VV9nO9(False)
20206:    elif item == "VV9nO91": self.VV9nO9(True)
20207:    elif item == "VV9oi3"    : self.VV9oi3()
20208:    elif item == "VVIENY"    : self.VVIENY()
20209:    elif item == "VVTwlc"  : self.VVTwlc()
20210:    elif item == "VVmM4L"  : self.VVmM4L()
20211:    elif item == "help"      : FFw2rR(self, "_help_movBr", "Movies Browser (Keys)")
20212:  def VVIwcG(self):
20213:   VVAkuK = []
20214:   for ndx, (path, movie, poster) in enumerate(self.VVGape):
20215:    path = os.path.join(CFG.MovieDownloadPath.getValue(), path)
20216:    VVAkuK.append((os.path.splitext(movie)[0], path, str(ndx)))
20217:   VVAkuK.sort(key=lambda x: x[0].lower())
20218:   VVu1YM = ("Select" , self.VV4pgN, [])
20219:   header  = ("Name" , "Path", "NDX.")
20220:   widths  = (60  , 40 , 0  )
20221:   FFUQ0v(self, None, title="Select Movie", width=1800, height=1000, header=header, VVGape=VVAkuK, VV3cHe=widths, VVwdmN=26, VVu1YM=VVu1YM, VVSLOq=CFG.lastFindMovie)
20222:  def VV4pgN(self, VV6A99, title, txt, colList):
20223:   self.VVdLxd(int(colList[2].strip()))
20224:   VV6A99.cancel()
20225:  def VVMypQ(self, VVwb7n=True):
20226:   fPath, fDir, fName = CClYaF.VV4zSS(self)
20227:   if fPath:
20228:    for ndx, (path, movie, poster) in enumerate(self.VVGape):
20229:     if fPath == os.path.join(CFG.MovieDownloadPath.getValue(), path, movie):
20230:      self.VVdLxd(ndx)
20231:      return
20232:   if VVwb7n:
20233:    FF28n1(self, "Not found", 1000)
20234:  def VVfmN9(self):
20235:   self.VV295u = self.VVBGsZ
20236:   VVPxk5 = self.VVgxBr()
20237:   CCqWM2.VVHc02(self.session, VVdxwH=False, VVaHNe=VVPxk5, zapFnc=self.VVgxBr, cbFnc=self.VV2Akw)
20238:  def VV2Akw(self):
20239:   Len = len(self.VVGape)
20240:   mPath = CFG.MovieDownloadPath.getValue()
20241:   self.VVGape = [(path, movie, poster) for path, movie, poster in self.VVGape if FFCyVu(os.path.join(mPath, path, movie))]
20242:   if Len != len(self.VVGape):
20243:    self.VVjIcM()
20244:   else:
20245:    self.VVdLxd(self.VV295u)
20246:  def VVgxBr(self, val=0):
20247:   ndx = self.VV295u + val
20248:   if   ndx > self.VVbKuB -1: ndx = 0
20249:   elif ndx < 0     : ndx = self.VVbKuB - 1
20250:   self.VV295u = ndx
20251:   path, poster = self.VVAoNk(ndx)
20252:   VVPxk5 = "%s:%s%s" % (CFG.iptvAddToBouquetRefType.getValue(), "0:" * 9, path)
20253:   return VVPxk5
20254:  def VVO0RC(self):
20255:   lst = []
20256:   path, poster = self.VVAoNk()
20257:   size = FFXhoc(path)
20258:   lst.append(("Media Path", path))
20259:   if size > -1: lst.append(("Media Size", CClYaF.VV99gM(size)))
20260:   lst.append(("Poster Path", poster))
20261:   size = FFXhoc(poster)
20262:   if size > -1: lst.append(("Poster Size", CClYaF.VV99gM(size)))
20263:   d = CCzUSd.VV0NUN(CCzUSd.VVc5Po(FFbhOc(path)))
20264:   if d:
20265:    lst.append(("Duration", FFFHEC(d["dur"] / 90000.0)))
20266:    lst.append(("Watched", FFTS4w(d["w"])))
20267:    lst.append(("Resume Position", FFFHEC(d["pos"] / 90000.0)))
20268:   bg="#11001122"
20269:   FFUQ0v(self, None, title="Media File Information", VVGape=lst, VV3cHe=(20, 80), VVwdmN=30, VVKDPJ=1, VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVLf28=0)
20270:  def VVIENY(self):
20271:   path, poster = self.VVAoNk()
20272:   if FFCyVu(poster): CCf8zb.VVjnMn(self, poster)
20273:   else     : FF28n1(self, "No Poster", 1500)
20274:  def VV9oi3(self):
20275:   title = "Copy Poster"
20276:   path, poster = self.VVAoNk()
20277:   if poster:
20278:    dstPath = FFriZ7()
20279:    dstF = os.path.join(dstPath, os.path.basename(poster))
20280:    if FFpwZS("cp -f '%s' '%s'" % (poster, dstF)):
20281:     FFipXT(self, "File copied to:\n\n%s" % dstF, title=title)
20282:    else:
20283:     FFdw58(self, "Cannot copy the file:\n%s\n\nTo:\n%s" % (poster, dstPath), title=title)
20284:   else:
20285:    FF28n1(self, "No Poster", 1500)
20286:  def VVTwlc(self):
20287:   path, poster = self.VVAoNk()
20288:   sDir = FFoWxR(os.path.dirname(path))
20289:   self.session.openWithCallback(BF(self.VVlrDJ, sDir, path), BF(CClYaF, VV1gDA="poster", VV1pbK=sDir))
20290:  def VVfSsn(self, VV7tND, txt, ref, ndx):
20291:   CCf8zb.VVjnMn(self, VVPq2Z=ref)
20292:  def VVlrDJ(self, sDir, path, pPath=None):
20293:   if pPath:
20294:    newPath = sDir + os.path.splitext(os.path.basename(path))[0] + os.path.splitext(pPath)[1].lower()
20295:    if   pPath == newPath : FF28n1(self, "No change", 1000)
20296:    elif FFCyVu(newPath): FFRMYv(self, BF(self.VV6MfM, pPath, newPath), "Overwrite exiting file ?\n\n%s" % os.path.basename(newPath), title="Change Poster")
20297:    else     : self.VV6MfM(pPath, newPath)
20298:  def VV6MfM(self, pPath, newPath):
20299:   if FFpwZS("cp -f '%s' '%s'" % (pPath, newPath)):
20300:    path, movie, poster = self.VVGape[self.VVBGsZ]
20301:    self.VVGape[self.VVBGsZ] = (path, movie, os.path.basename(newPath))
20302:    FFimQ3(self, BF(self.VVLckG, True))
20303:    CCG2jh.VVp7lg(newPath)
20304:   else:
20305:    FF28n1(self, "Cannot copy file.", 1000)
20306:  def VVmM4L(self):
20307:   path, poster = self.VVAoNk()
20308:   evName = os.path.splitext(os.path.basename(path))[0]
20309:   dstP = os.path.splitext(path)[0] + ".jpg"
20310:   self.session.openWithCallback(BF(self.VVHrM7, dstP), CChtNF, dstP=dstP, evName=evName)
20311:  def VVHrM7(self, dstP, pPath=None):
20312:   if pPath:
20313:    path, movie, poster = self.VVGape[self.VVBGsZ]
20314:    self.VVGape[self.VVBGsZ] = (path, movie, os.path.basename(dstP))
20315:    FFimQ3(self, BF(self.VVLckG, True))
20316:  def VV9nO9(self, isAll):
20317:   pathLst = []
20318:   if isAll:
20319:    for ndx, (path, movie, poster) in enumerate(self.VVGape):
20320:     path = os.path.join(CFG.MovieDownloadPath.getValue(), path, movie)
20321:     pathLst.append(path)
20322:   else:
20323:    path, poster = self.VVAoNk()
20324:    pathLst = [path]
20325:   picker = CCMvE7(self, self, "Add to Bouquet", BF(self.VVZXrb, pathLst))
20326:  def VVZXrb(self, pathLst):
20327:   return CCMvE7.VVvoK9(pathLst)
20328:  @staticmethod
20329:  def VVp7lg(path):
20330:   if path.endswith(".png"):
20331:    fileNoExt = path[:-4]
20332:    jpgF = fileNoExt + ".jpg"
20333:    if FFCyVu(jpgF):
20334:     c = 1
20335:     newF = "%s_%d.jpg" % (fileNoExt, c)
20336:     while FFCyVu(newF):
20337:      c += 1
20338:      newF = "%s_%d.jpg" % (fileNoExt, c)
20339:     FFpwZS("mv -f '%s' '%s'" % (jpgF, newF))
20340:  @staticmethod
20341:  @FFOAKH()
20342:  def VV7hTj(SELF):
20343:   eLst = CCHmnm.VViatp()["mov"]
20344:   mPath = CFG.MovieDownloadPath.getValue()
20345:   lst = []
20346:   for (Dir, dirs, files) in os.walk(mPath):
20347:    for f in files:
20348:     if os.path.splitext(f)[1].lstrip(".").lower() in eLst:
20349:      path = os.path.join(Dir, f)
20350:      poster = ""
20351:      for ext in ("jpg", "png"):
20352:       pic = "%s.%s" % (os.path.splitext(path)[0], ext)
20353:       if FFCyVu(pic):
20354:        poster = os.path.basename(pic)
20355:        break
20356:      lst.append((os.path.dirname(path).replace(mPath, ""), os.path.basename(path), poster))
20357:   title = "Movies Browser"
20358:   lst.sort(key=lambda x: x[1].lower())
20359:   if lst: SELF.session.open(CCG2jh, title, lst)
20360:   else  : FFdw58(SELF, "No movies found in:\n\n%s\n\nYou can change the path from settings." % mPath, title=title)
20361: class CCjThi(Screen, CCsyCY):
20362:  def __init__(self, session, bName, lst):
20363:   self.skin, self.VVfOli = FFiNEe(VVpLGo, 1750, 1040, 50, 3, 3, "#22003344", "#22001122", 45, VVeFSs=40, VV0Ay7=2, VVt3Ak=20, VVUuJZ={"rows":4, "cols":6, "picR":0.75, "lblR":0.25, "w1R":0.80, "w2R":0.20, "gapX":15, "gapY":15})
20364:   self.session   = session
20365:   self.Title    = bName
20366:   self.VVGape    = lst
20367:   self.pPath    = CCafIt.VVjkKT()
20368:   self.VVbKuB   = 0
20369:   self.VVpQCY  = True
20370:   self.VVyzvh  = False
20371:   FFZMxC(self, self.Title)
20372:   FFRLNq(self["keyRed"] , "OK = Zap")
20373:   FFRLNq(self["keyGreen"] , "Current Channel")
20374:   FFRLNq(self["keyBlue"] , "Preview")
20375:   CCsyCY.__init__(self, CFG.transpColorChannels)
20376:   FFBep1(self,
20377:   {
20378:    "ok"  : BF(self.VVGQg3, True),
20379:    "cancel" : self.VVfXzC      ,
20380:    "menu"  : self.VVLbBy   ,
20381:    "info"  : self.VVU4wr    ,
20382:    "red"  : self.VVfXzC      ,
20383:    "green"  : BF(self.VVUesd, True)  ,
20384:    "blue"  : BF(self.VVGQg3, False)
20385:   })
20386:   self.onShown.append(self.VV7OzD)
20387:  def VV7OzD(self):
20388:   if self.VVpQCY:
20389:    force = True
20390:    self.VVpQCY = False
20391:    FF6W0I(self)
20392:    FFWgBS(self)
20393:    FFZ0AC(self["keyRed"], "#0a333333")
20394:    self.VVCHVq()
20395:   elif self.VVyzvh:
20396:    self.VVyzvh = False
20397:    return
20398:   else:
20399:    pName, srvLst = CCjThi.VVdAdw()
20400:    if srvLst and not srvLst == self.VVGape:
20401:     force = True
20402:     self.Title = pName
20403:     self["myTitle"].setText("  %s  " % self.Title)
20404:     self.VVGape = srvLst
20405:    else:
20406:     force = False
20407:   self.VVbKuB = len(self.VVGape)
20408:   self.VVUeUp = int(self.VVbKuB / self.VVg3d5) + (self.VVbKuB % self.VVg3d5 > 0)
20409:   self.VVLckG(force)
20410:   self.VVUesd()
20411:  def VVLbBy(self):
20412:   VV3wat = []
20413:   VV3wat.append(("Find Name (sorted list)" , "findSrt"  ))
20414:   VV3wat.append(("Find Name (as listed)" , "findNoSrt"))
20415:   VV3wat.append(VVAL3j)
20416:   VV3wat.append(("Change Background Color" , "VVA2WD"))
20417:   VV3wat.append(VVAL3j)
20418:   VV3wat.append(("Help (Keys)", "help"))
20419:   FFLFTC(self, self.VV2vBb, title="Options", VV3wat=VV3wat)
20420:  def VV2vBb(self, item=None):
20421:   if item:
20422:    if   item == "findSrt"    : self.VViYJb(True)
20423:    elif item == "findNoSrt"   : self.VViYJb(False)
20424:    elif item == "VVA2WD": self.VVA2WD()
20425:    elif item == "help"     : FFw2rR(self, "_help_srvcBr", "Services Browser (Keys)")
20426:  def VViYJb(self, isSort):
20427:   VV3wat = []
20428:   for ndx, item in enumerate(self.VVGape):
20429:    VV3wat.append((item[1], ndx))
20430:   if isSort:
20431:    VV3wat.sort(key=lambda x: x[0].lower())
20432:   FFLFTC(self, self.VVl51x, title="Find Name", VV3wat=VV3wat, width=1300)
20433:  def VVl51x(self, ndx=None):
20434:   if ndx is not None:
20435:    self.VVdLxd(ndx)
20436:  def VVU4wr(self):
20437:   VVPxk5, VV1wIO = self.VVGape[self.VVBGsZ]
20438:   txt  = "Service Name\t: %s\n" % VV1wIO
20439:   txt += "Referrence\t: %s" % VVPxk5
20440:   CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVvVii, params=(VVPxk5, VV1wIO, txt))
20441:   self.VVyzvh = True
20442:  def VVfXzC(self):
20443:   if self.shown: self.close()
20444:   else   : self.show()
20445:  def VVGQg3(self, isExit):
20446:   try:
20447:    if self.shown:
20448:     chUrl = self.VVGape[self.VVBGsZ][0]
20449:     if isExit:
20450:      self.VV4kOk(chUrl)
20451:     else:
20452:      FFnfiC(self.session, chUrl)
20453:      FFSqRh(self, "Cancel to go back")
20454:    else:
20455:     self.show()
20456:   except:
20457:    pass
20458:  @FFOAKH("Starting ...")
20459:  def VV4kOk(self, chUrl):
20460:   FFnfiC(self.session, chUrl, VV9rup=True)
20461:   self.close()
20462:  def VVUesd(self, VVwb7n=False):
20463:   serv = self.session.nav.getCurrentlyPlayingServiceReference()
20464:   err = ""
20465:   if serv:
20466:    curRef = serv.toString()
20467:    for ndx, item in enumerate(self.VVGape):
20468:     if curRef == item[0]:
20469:      self.VVdLxd(ndx)
20470:      return ndx
20471:    else:
20472:     err = "Not found"
20473:   else:
20474:    err = "No active service"
20475:   if VVwb7n and err:
20476:    FF28n1(self, err, 500)
20477:   return -1
20478:  def VVe4Ro(self):
20479:   self.VVaFRk()
20480:   f1, f2 = self.VVS7BN()
20481:   row = col = 0
20482:   for ndx in range(f1, f2):
20483:    ref, name = self.VVGape[ndx]
20484:    pic, lbl = self.VVwbpA(row, col)
20485:    self.VVExY8(lbl, name)
20486:    path = CCafIt.VVXjFJ(self.pPath, ref, name)
20487:    self.VVaJVd(ndx, row, col, pic, path)
20488:    self.VVcG7K = row
20489:    self.VVGCBk = col
20490:    col += 1
20491:    if col > (self.VVsHeH - 1):
20492:     col = 0
20493:     row += 1
20494:  def VVHvUS(self):
20495:   ref, name = self.VVGape[self.VVBGsZ]
20496:   span = iSearch(r"((?:[A-Fa-f0-9]+:){10})", ref)
20497:   if span: ref = span.group(1)
20498:   self.VVkhlj(name, ref)
20499:  @staticmethod
20500:  def VVZhZh():
20501:   VVPxk5 = refName = rootRef = rootName = ""
20502:   inBouquet = False
20503:   VVCy6c = InfoBar.instance
20504:   if VVCy6c:
20505:    csel = VVCy6c.servicelist
20506:    if csel:
20507:     currSel  = csel.getCurrentSelection()
20508:     rootRef  = csel.getRoot().toString()
20509:     VVPxk5  = currSel.toString()
20510:     rootName = FFCjjv(rootRef)
20511:     refName  = FFCjjv(VVPxk5)
20512:     inBouquet = csel.inBouquet()
20513:     if   inBouquet        : rootSrc = "Favourites"
20514:     elif "(satellitePosition == " in rootRef : rootSrc = "Satellites"
20515:     elif "name:Current transponder" in rootRef : rootSrc = "Transponder"
20516:     elif "(provider == " in rootRef    : rootSrc = "Provider"
20517:     else          : rootSrc = "ALL"
20518:   return VVPxk5, refName, rootRef, rootName, inBouquet, rootSrc
20519:  @staticmethod
20520:  def VVdAdw(VVPxk5="", refName="", rootRef="", rootName="", inBouquet=False):
20521:   VVPxk5, rootRef = VVPxk5.strip(), rootRef.strip()
20522:   if not VVPxk5 and not rootRef:
20523:    VVPxk5, refName, rootRef, rootName, inBouquet, rootSrc = CCjThi.VVZhZh()
20524:    VVPxk5, rootRef = VVPxk5.strip(), rootRef.strip()
20525:   pName, srvLst = "", []
20526:   if VVPxk5 and rootRef:
20527:    if   VVPxk5.startswith("1:7:") : ref, name = VVPxk5, refName
20528:    elif rootRef.startswith("1:7:") : ref, name = rootRef, rootName
20529:    else       : return "", []
20530:    srvLst = FFZcDI(eServiceReference(ref))
20531:    pName = name or "No-Name"
20532:    if not inBouquet: srvLst.sort(key=lambda x: x[1].lower())
20533:   else:
20534:    srvLst = CCMvE7.VVqZTI()
20535:    pName  = CCMvE7.VVCWrE() or "ALL (Group)"
20536:   return pName, srvLst
20537:  @staticmethod
20538:  def VVJNjY(SELF, cbFnc=None):
20539:   pName, srvLst = CCjThi.VVdAdw()
20540:   if srvLst: SELF.session.openWithCallback(cbFnc, CCjThi, pName, srvLst)
20541:   else  : FFdw58(SELF, "No services found in:\n\n%s" % pName, title="Channels Browser")
20542: class CCFZr4(Screen, CCsyCY):
20543:  def __init__(self, session, title, lst):
20544:   self.skin, self.VVfOli = FFiNEe(VVpLGo, 1600, 1000, 50, 20, 20, "#2200202a", "#11202020", 45, VVeFSs=40, VV0Ay7=2, VVt3Ak=20, VVUuJZ={"rows":4, "cols":5, "picR":0.65, "lblR":0.35, "w1R":0.85, "w2R":0.15, "bGap":8, "gapX":25, "gapY":25, "mGap":8, "lblTr":1, "picBgTr":1})
20545:   self.session   = session
20546:   self.Title    = title
20547:   self.VVGape    = CCFZr4.VV9Oyz(lst)
20548:   self.VVbKuB   = 0
20549:   self.useOrigSize  = False
20550:   self.firstTime   = True
20551:   FFZMxC(self, self.Title)
20552:   FFRLNq(self["keyRed"] , "Remove Plugins")
20553:   FFRLNq(self["keyGreen"] , "Download New Plugins")
20554:   FFRLNq(self["keyYellow"], "Package Info.")
20555:   FFRLNq(self["keyBlue"] , "Plugins Group")
20556:   CCsyCY.__init__(self)
20557:   FFBep1(self,
20558:   {
20559:    "ok"  : self.VVTZ6U   ,
20560:    "cancel" : self.close    ,
20561:    "menu"  : self.VVicIL ,
20562:    "info"  : self.VVfIeu  ,
20563:    "red"  : BF(self.VVAGF7, False),
20564:    "green"  : BF(self.VVAGF7, True),
20565:    "yellow" : self.VVtLaF ,
20566:    "blue"  : self.VV0oxQ
20567:   })
20568:   self.onShown.append(self.VV7OzD)
20569:  def VV7OzD(self):
20570:   self.onShown.remove(self.VV7OzD)
20571:   FF6W0I(self)
20572:   FFWgBS(self)
20573:   self.VVCHVq(shade="yes", cursor="")
20574:   self.VVjkVK([("", "
20575:   self.VV92tg()
20576:  def VV92tg(self):
20577:   self.VVbKuB = len(self.VVGape)
20578:   self.VVUeUp = int(self.VVbKuB / self.VVg3d5) + (self.VVbKuB % self.VVg3d5 > 0)
20579:   self.VVLckG(True)
20580:  def VVFnIO(self):
20581:   lst = CCFZr4.VVEjtP(PluginDescriptor.WHERE_PLUGINMENU)
20582:   if lst:
20583:    lst = CCFZr4.VV9Oyz(lst)
20584:    if lst != self.VVGape:
20585:     self.VVGape = lst
20586:     self.VV92tg()
20587:   else:
20588:    self.close()
20589:  def VVAGF7(self, isInstall):
20590:   FF28n1(self, "Processing ...")
20591:   try:
20592:    from Screens.PluginBrowser import PluginDownloadBrowser as pb
20593:    if isInstall:
20594:     self.session.openWithCallback(self.VVFnIO, pb, pb.DOWNLOAD, self.firstTime)
20595:     self.firstTime = False
20596:    else:
20597:     self.session.openWithCallback(self.VVFnIO, pb, pb.REMOVE)
20598:   except:
20599:    try:
20600:     from Screens.PluginBrowser import PluginAction as pa
20601:     if hasattr(pa, "DOWNLOAD") and hasattr(pa, "REMOVE"):
20602:      self.session.openWithCallback(self.VVFnIO, pa, pa.DOWNLOAD if isInstall else pa.REMOVE)
20603:     else:
20604:      self.session.openWithCallback(self.VVFnIO, pa, pa.MODE_INSTALL if isInstall else pa.MODE_REMOVE)
20605:    except:
20606:     try:
20607:      from Plugins.SystemPlugins.SoftwareManager.plugin import PluginManager as pb
20608:      self.session.openWithCallback(self.VVFnIO, pb)
20609:     except Exception as e:
20610:      FFdw58(self, 'Cannot open "Extensions Management" !', title=self.Title)
20611:   FF28n1(self)
20612:  def VVTZ6U(self):
20613:   name, desc = self.VVxIzw(self.VVBGsZ)
20614:   if name == VVh9hj and "VVaWs8" in globals() and VVaWs8:
20615:    FF28n1(self, "Already running.", 500)
20616:   else:
20617:    try:
20618:     p = self.VVGape[self.VVBGsZ]
20619:     p(session=self.session)
20620:    except:
20621:     FFdw58(self, "Cannot start from here !", title="Error in : %s" % name)
20622:  def VVfIeu(self):
20623:   def VVJi7Q(key, val):
20624:    return key + "\t: " + str(val) + "\n"
20625:   p = self.VVGape[self.VVBGsZ]
20626:   txt = ""
20627:   try:
20628:    txt += VVJi7Q("Path"  , p.path  )
20629:    txt += VVJi7Q("Description" , p.description )
20630:    txt += VVJi7Q("Icon"  , p.iconstr  )
20631:    txt += VVJi7Q("Wakeup Fnc" , p.wakeupfnc )
20632:    txt += VVJi7Q("NeedsRestart", p.needsRestart)
20633:    txt += VVJi7Q("Internal" , p.internal )
20634:    txt += VVJi7Q("Weight"  , p.weight  )
20635:   except:
20636:    pass
20637:   name, desc = self.VVxIzw(self.VVBGsZ)
20638:   if txt : FF4lCP(self, txt, title=name)
20639:   else : FFdw58(self, "Could not read plugin info.", title=name)
20640:  @FFOAKH()
20641:  def VVtLaF(self):
20642:   p = self.VVGape[self.VVBGsZ]
20643:   name, desc = self.VVxIzw(self.VVBGsZ)
20644:   path = p.path
20645:   pkg, err = CCeSkW.VVV8mM(path)
20646:   if pkg : CCeSkW.VVLFsP(self, pkg, name)
20647:   else : FFjADj(self, err, 1000)
20648:  def VVicIL(self):
20649:   path = self.VVGape[self.VVBGsZ].path
20650:   VV3wat = []
20651:   txt = "Open Plugin Path in File Manager"
20652:   VV3wat.append(FFsLU5("Open Plugin Path in File Manager", "inFileMan", VVmJwX(path)))
20653:   VV3wat.append(VVAL3j)
20654:   VV3wat.append(("Use Original Icon Size", "setOrigSize"))
20655:   FFLFTC(self, self.VVVZEm, title="Plugins Group", VV3wat=VV3wat)
20656:  def VVVZEm(self, item=None):
20657:   if item:
20658:    if item == "inFileMan":
20659:     self.session.open(CClYaF, mode=CClYaF.VVQTL1, VV1pbK=self.VVGape[self.VVBGsZ].path)
20660:    elif item == "setOrigSize":
20661:     self.useOrigSize = True
20662:     self.VVLckG(True)
20663:  def VV0oxQ(self):
20664:   FFLFTC(self, self.VVOvCr, title="Plugins Group", VV3wat=CCFZr4.VVq7at(True, True), width=700, VVU8mZ=True)
20665:  def VVOvCr(self, item=None):
20666:   if item:
20667:    title, where, ndx = item
20668:    self["myTitle"].setText("  %s (%s)" % (self.Title, title))
20669:    lst = CCFZr4.VVEjtP(where)
20670:    if lst:
20671:     self.VVGape = CCFZr4.VV9Oyz(lst)
20672:     self.VVSmMg = self.curCol = self.curRow = self.VVBGsZ = 0
20673:     self.VVbKuB = len(self.VVGape)
20674:     self.VVUeUp = int(self.VVbKuB / self.VVg3d5) + (self.VVbKuB % self.VVg3d5 > 0)
20675:     self.VVLckG(True)
20676:    else:
20677:     FFdw58(self, "Not found !", title=self.Title)
20678:  def VVe4Ro(self):
20679:   self.VVaFRk()
20680:   f1, f2 = self.VVS7BN()
20681:   row = col = 0
20682:   for ndx in range(f1, f2):
20683:    name, desc = self.VVxIzw(ndx)
20684:    pic, lbl = self.VVwbpA(row, col)
20685:    self.VVExY8(lbl, name)
20686:    iconOk = False
20687:    pngSz = None
20688:    if self.VVGape[ndx].icon:
20689:     try:
20690:      pngSz = self.VVGape[ndx].icon.size()
20691:      pic.instance.setScale(1)
20692:      pic.instance.setPixmap(self.VVGape[ndx].icon)
20693:      pic.show()
20694:      iconOk = True
20695:     except:
20696:      pass
20697:    if not iconOk:
20698:     icons = []
20699:     path = self.VVGape[ndx].path
20700:     if VVmJwX(path):
20701:      for f in ("iconfhd.png", "iconhd.png", "icon.png"):
20702:       icons.append(os.path.join(path, f))
20703:     icons.append(resolveFilename(SCOPE_CURRENT_SKIN, "icons/plugin.png"))
20704:     icons.append(VVIp2p + "plugin.png")
20705:     for path in icons:
20706:      pixMap = FFBFPY(pic, path)
20707:      if pixMap:
20708:       pngSz = pixMap.size()
20709:       break
20710:    if self.useOrigSize and pngSz:
20711:     try:
20712:      boxSz = pic.instance.size()
20713:      VVzIFK = pic.instance.position()
20714:      pngW, pngH = pngSz.width(), pngSz.height()
20715:      boxW, boxH = boxSz.width(), boxSz.height()
20716:      if boxW > pngW and boxH > pngH:
20717:       pic.instance.resize(pngSz)
20718:       pic.instance.move(ePoint(VVzIFK.x() + (boxW - pngW) // 2, VVzIFK.y() + (boxH - pngH) // 2))
20719:     except:
20720:      pass
20721:    self.VVcG7K = row
20722:    self.VVGCBk = col
20723:    col += 1
20724:    if col > (self.VVsHeH - 1):
20725:     col = 0
20726:     row += 1
20727:  def VVxIzw(self, ndx):
20728:   name = str(self.VVGape[ndx].name).strip()
20729:   desc = str(self.VVGape[ndx].description).strip().replace("\n", " >> ")
20730:   if not name or name == "Plugin":
20731:    name = desc or FFxtW5(self.VVGape[ndx].path)
20732:   return name, desc
20733:  def VVHvUS(self):
20734:   name, desc = self.VVxIzw(self.VVBGsZ)
20735:   self.VVkhlj(name, desc)
20736:  @staticmethod
20737:  def VVq7at(isMenu=False, addTot=False):
20738:   lst =[("Plugin Menu"   , PluginDescriptor.WHERE_PLUGINMENU    )
20739:    , ("Audio Menu"    , PluginDescriptor.WHERE_AUDIOMENU    )
20740:    , ("Auto-Start Menu"  , PluginDescriptor.WHERE_AUTOSTART    )
20741:    , ("Channel Context Menu" , PluginDescriptor.WHERE_CHANNEL_CONTEXT_MENU )
20742:    , ("Event Info"    , PluginDescriptor.WHERE_EVENTINFO    )
20743:    , ("Extensions Menu"  , PluginDescriptor.WHERE_EXTENSIONSMENU   )
20744:    , ("File Scan"    , PluginDescriptor.WHERE_FILESCAN    )
20745:    , ("Main Menu"    , PluginDescriptor.WHERE_MAINMENU    )
20746:    , ("Menu"     , PluginDescriptor.WHERE_MENU     )
20747:    , ("Movie List"    , PluginDescriptor.WHERE_MOVIELIST    )
20748:    , ("Network Configuration" , PluginDescriptor.WHERE_NETWORKCONFIG_READ  )
20749:    , ("Network Setup"   , PluginDescriptor.WHERE_NETWORKSETUP   )
20750:    , ("Session Start"   , PluginDescriptor.WHERE_SESSIONSTART   )
20751:    , ("Software Manager"  , PluginDescriptor.WHERE_SOFTWAREMANAGER  )
20752:    , ("Teletext"    , PluginDescriptor.WHERE_TELETEXT    )
20753:    , ("Wizard"     , PluginDescriptor.WHERE_WIZARD     )]
20754:   if addTot:
20755:    for ndx, item in enumerate(lst):
20756:     tot = len(CCFZr4.VVEjtP(item[1]))
20757:     lst[ndx] = ("%s   %s(%d)" % (lst[ndx][0], VVA4XU, tot), lst[ndx][1])
20758:   if isMenu: lst.insert(1, VVAL3j)
20759:   else  : lst.sort(key=lambda x: x[0].lower())
20760:   return lst
20761:  @staticmethod
20762:  def VVEjtP(where):
20763:   try: return iPlugins.getPlugins(where)
20764:   except: return []
20765:  @staticmethod
20766:  def VV9Oyz(lst):
20767:   tmp = []
20768:   for item in lst:
20769:    name = str(item.name).strip()
20770:    if not name or name == "Plugin":
20771:     name = str(item.description).strip() or FFxtW5(item.path)
20772:    tmp.append((name, item))
20773:   tmp.sort(key=lambda x: x[0].lower())
20774:   lst = []
20775:   for nm, obj in tmp:
20776:    lst.append(obj)
20777:   return lst
20778:  @staticmethod
20779:  def VVsCNi(session):
20780:   title = "Plugins Browser"
20781:   lst = CCFZr4.VVEjtP(PluginDescriptor.WHERE_PLUGINMENU)
20782:   if lst : session.open(CCFZr4, title, lst)
20783:   else : FFzcnp(session, "No plugins found !", title=title)
20784: class CCRlkm(Screen, CCsyCY):
20785:  VV9Ij0  = "Custom Menu"
20786:  VVPNMN = "ajpanel_menu.xml"
20787:  VVJK42  = {}
20788:  def __init__(self, session, subFile="", subName="", picpath="", startItem=0):
20789:   self.session  = session
20790:   self.VVPxk5Patt = r"^((?:[A-Fa-f0-9]+(?::|_)){9}(?:[A-Fa-f0-9]+))(.*)"
20791:   self.startItem  = startItem
20792:   self.def_cursor_fg = "
20793:   self.def_cursor_bg = "#11442244"
20794:   self.def_title_fg = "#00ffffaa"
20795:   self.def_title_bg = "#0cff0011"
20796:   self.def_body_bg = "#0c001122"
20797:   self.moveCM_data = None
20798:   self.moveCM_win  = None
20799:   self.VVUKLC = {"title": self.VV9Ij0, "mode": "list", "width": -1, "height": -1, "fg": "#00ffffff", "bg": self.def_body_bg, "font_size": 30, "align_items": 0, "title_fg": self.def_title_fg, "title_font_size": 50, "cursor_fg": self.def_cursor_fg, "cursor_bg": self.def_cursor_bg, "line_gap": 0.15, "box_gap": 0, "picpath": picpath, "lst": []}
20800:   for k in ("title_bg", "title1_fg", "title1_bg", "title2_fg", "title2_bg", "num_fg", "num_bg", "shade", "cursor"):
20801:    self.VVUKLC[k] = ""
20802:   if subFile:
20803:    self.filePath = subFile
20804:   else:
20805:    self.filePath = CCRlkm.VVGHsh()
20806:    CCRlkm.VVJK42 = {}
20807:   self.subName = subName
20808:   self.err  = self.VVCW1G(subName)
20809:   self.Title  = self.VVUKLC["title"]
20810:   self.isGrid, self.isStretch, cols, rows = self.VV2KRi(self.VVUKLC["mode"])
20811:   titleBg = self.VVUKLC["title_bg"] or self.def_title_bg
20812:   bodyBg = self.VVUKLC["bg"] if self.VVRmDl(self.VVUKLC["bg"]) else self.def_body_bg
20813:   cursC = self.VVUKLC["cursor"] if self.VVRmDl(self.VVUKLC["cursor"]) else ""
20814:   bGap = self.VVUKLC["box_gap"]
20815:   lblFR = FFjFSv(self.VVUKLC["font_size"], 10, 50, 0.4, 0.8)
20816:   w, h, VVllEU, VVSZWt, VVpeQE, textFg, VVgbF2 = self.VVUKLC["width"], self.VVUKLC["height"], self.VVUKLC["title_font_size"], 15, 15, self.VVUKLC["fg"], self.VVUKLC["font_size"]
20817:   if self.isGrid : self.skin, self.VVfOli = FFiNEe(VVpLGo, w, h, VVllEU, VVSZWt, VVpeQE, titleBg, bodyBg, VVgbF2, VV0Ay7=2, VVt3Ak=20, VVUuJZ={"rows":rows, "cols":cols, "picR":0.65, "lblR":0.35, "lblFR":lblFR, "w1R":0.80, "w2R":0.20, "trC":"", "bGap":bGap, "gapX":22, "gapY":22, "mGap":15, "lblFg":textFg, "lblTr":1, "picBgTr":1, "upSBar":True})
20818:   else   : self.skin, self.VVfOli = FFiNEe(VVWp3I   , w, h, VVllEU, VVSZWt, VVpeQE, titleBg, bodyBg, VVgbF2, VV0Ay7=2, VVptue=self.VVUKLC["line_gap"])
20819:   self.VVGape = self.VVoCYy() if self.VVUKLC["lst"] else []
20820:   FFZMxC(self, title=self.Title)
20821:   if self.isGrid:
20822:    CCsyCY.__init__(self)
20823:   else:
20824:    self["myMenu"] = MenuList(self.VVGape, True, eListboxPythonMultiContent)
20825:    self["myMenu"].l.setFont(0, gFont(VVNhAq, self.VVfOli["VVgbF2"]))
20826:    FFHlAU(self, {})
20827:   FFBep1(self,
20828:   {
20829:    "ok" : self.VVPr1F ,
20830:    "cancel": self.cancel ,
20831:    "menu" : self.VVWI8i ,
20832:    "info" : self.VVN5Mh
20833:   })
20834:   self.onShown.append(self.VV7OzD)
20835:   self.onClose.append(self.onExit)
20836:  def VV7OzD(self):
20837:   self.onShown.remove(self.VV7OzD)
20838:   FF6W0I(self)
20839:   if self.err:
20840:    CCwnHL.VVBfGR(self, os.path.basename(self.filePath), self.err, title=self.VVUKLC["title"])
20841:    self.close()
20842:    return
20843:   space = "  "
20844:   if self.isGrid:
20845:    self.VVCHVq(shade=self.VVUKLC["shade"], cursor=self.VVUKLC["cursor"])
20846:    self.VVbKuB = len(self.VVGape)
20847:    self.VVUeUp = int(self.VVbKuB / self.VVg3d5) + (self.VVbKuB % self.VVg3d5 > 0)
20848:    self.VVLckG(True)
20849:    if self.startItem > 0:
20850:     self.VVdLxd(min(self.startItem, len(self.VVGape) - 1))
20851:   else:
20852:    offset = {0: 20, 1: 0, 2: -20}.get(self.VVUKLC["align_items"])
20853:    FF2GM8(self, offset=offset)
20854:    if self.VVUKLC["align_items"] == 2:
20855:     obj = self["keyInfo"].instance
20856:     pos = obj.position()
20857:     obj.move(ePoint(10, pos.y()))
20858:     space = str(u"\u2007")
20859:    self["myTitle"].instance.setHAlign(self.VVUKLC["align_items"])
20860:    self["myMenu"].instance.setTransparent(True)
20861:    FFGUI5(self["myMenu"], self.VVUKLC["fg"])
20862:    FF4IPF(self["myMenu"], fg=self.VVUKLC["cursor_fg"], bg=self.VVUKLC["cursor_bg"])
20863:    try:
20864:     self["myMenu"].instance.setHAlign(self.VVUKLC["align_items"])
20865:    except:
20866:     pass
20867:    if self.startItem > 0:
20868:     self["myMenu"].moveToIndex(min(self.startItem, len(self.VVGape) - 1))
20869:   self["myTitle"].setText("%s%s%s" % (space, self.Title, space))
20870:   self.VVBRHT()
20871:  def onExit(self):
20872:   self.VVaQtC()
20873:  def VVBRHT(self):
20874:   wp = CCRlkm.VVY2v0(self["myWP"], self.VVUKLC["bg"])
20875:   if wp: self["myWP"].show()
20876:   else : self["myWP"].hide()
20877:   if not wp:
20878:    FFZ0AC(self["myBody"], self.VVUKLC["bg"] if self.VVRmDl(self.VVUKLC["bg"]) else self.def_body_bg)
20879:   self["myTitle"].instance.setTransparent(False)
20880:   FFGUI5(self["myTitle"], self.VVUKLC["title_fg"] or self.def_title_fg)
20881:   if self.VVUKLC["title_bg"]: FFZ0AC(self["myTitle"], self.VVUKLC["title_bg"])
20882:   else      : self["myTitle"].instance.setTransparent(True)
20883:   self["myTitle"].instance.invalidate()
20884:   if self.isGrid:
20885:    fg1, fg2, bg = "#0088ff88", "#00aaaaaa", "#11000a0b"
20886:    self.VVjkVK(((self.VVUKLC["title1_fg"] or fg1, self.VVUKLC["title1_bg"] or bg)
20887:          , (self.VVUKLC["title2_fg"] or fg2, self.VVUKLC["title2_bg"] or bg)
20888:          , (self.VVUKLC["num_fg"]   or fg2, self.VVUKLC["num_bg"]  or bg)
20889:          , (self.VVUKLC["num_fg"]   or fg2, self.VVUKLC["num_bg"]  or bg) ))
20890:    if wp:
20891:     for i, bg in enumerate((self.VVUKLC["title1_bg"], self.VVUKLC["title2_bg"], self.VVUKLC["num_bg"], self.VVUKLC["num_bg"])):
20892:      self["myPiconInf%d" % i].instance.setTransparent(False if bg else True)
20893:      self["myPiconInf%d" % i].instance.invalidate()
20894:  def VVPr1F(self):
20895:   if self.moveCM_data:
20896:    self.VVxqJP()
20897:   else:
20898:    txt, ref, itemDict = self.VV7JdF()
20899:    fnc = BF(self.VVSTO4, txt, ref, itemDict)
20900:    if "ask" in itemDict:
20901:     FFRMYv(self, fnc, itemDict.get("ask") or "Continue ?", title=txt)
20902:    else:
20903:     fnc()
20904:  def cancel(self):
20905:   if self.moveCM_data:
20906:    self.VVaQtC()
20907:   else:
20908:    FFIFeD()
20909:    self.close()
20910:  def VVWI8i(self, title="Options", mode=0):
20911:   c1, c2, c3, c4, c5 = VVFuwR, VVZtfx, VVJEMb, VVz22H, VVIH76
20912:   isGrid, _, _, _ = self.VV2KRi(self.VVUKLC["mode"])
20913:   VV3wat = []
20914:   if mode == 0:
20915:    if self.moveCM_data:
20916:     VV3wat.append(("Move to current position"    , "movGo" ))
20917:     VV3wat.append(("Cancel Move"       , "movNot" ))
20918:    else:
20919:     VV3wat.append((c1 + "Change Current Icon (File Path)" , "icnFil" ))
20920:     VV3wat.append((c1 + "Change Current Icon (Base64)" , "icnB64" ))
20921:     VV3wat.append((c1 + "Reset Current Icon (to Default)" , "icnDef" ))
20922:     VV3wat.append(VVAL3j)
20923:     VV3wat.append((c2 + "Main Title"      , "ttl"  ))
20924:     if isGrid:
20925:      VV3wat.append((c2 + "Information Title-1"   , "ttl1" ))
20926:      VV3wat.append((c2 + "Information Title-2"   , "ttl2" ))
20927:      VV3wat.append((c2 + "Scroll Page Number"   , "pg"  ))
20928:      VV3wat.append(VVAL3j)
20929:      VV3wat.append((c3 + "Shade"      , "gShad" ))
20930:      VV3wat.append((c3 + "Shade Gap"     , "bGap" ))
20931:      VV3wat.append((c3 + "Cursor"      , "gCurs" ))
20932:     else:
20933:      VV3wat.append(VVAL3j)
20934:      VV3wat.append((c3 + "Cursor"      , "lCurs" ))
20935:     VV3wat.append((c3 + "Background Color/Wallpaper"  , "wpMnu" ))
20936:     VV3wat.append(VVAL3j)
20937:     VV3wat.append((c4 + "Clear Cached Picture Files"  , "cach" ))
20938:     VV3wat.append(FFsLU5("Delete Current Item"  , "del"  , isGrid, c4))
20939:     VV3wat.append(VVAL3j)
20940:     VV3wat.append(FFsLU5("Move Selected Item"   , "movGo" , isGrid and not self.subName, c5))
20941:     VV3wat.append((c5 + "Change Current Menu Pictures Path", "pPath" ))
20942:     VV3wat.append(FFsLU5("Insert Menu XML File"   , "impX" , not self.subName, c5))
20943:    FFLFTC(self, self.VVsyNv, width=800, height=1050, title="Options", VV3wat=VV3wat, VVU8mZ=True, VVwltY="#0a111111", VVkxBG="#0a111111")
20944:   else:
20945:    if mode == 2:
20946:     VV3wat.append(("Change Wallpaper (File Path)" , "wpFil" ))
20947:     VV3wat.append(("Change Wallpaper (Base64)" , "wpB64" ))
20948:     VV3wat.append(("Change to a Color"   , "wpCol" ))
20949:     VV3wat.append(VVAL3j)
20950:     VV3wat.append((c4 + "Reset Wallpaper"   , "wpRm" ))
20951:    elif mode == 3:
20952:     VV3wat.append(("Change Picture (File Path)" , "shFil" ))
20953:     VV3wat.append(("Change Picture (Base64)"  , "shB64" ))
20954:     VV3wat.append(("Change Picture to default" , "shDef" ))
20955:     VV3wat.append(VVAL3j)
20956:     VV3wat.append((c4 + "Remove Shade"   , "shRm" ))
20957:    elif mode == 4:
20958:     VV3wat.append(("Change Picture (File Path))" , "crsFil" ))
20959:     VV3wat.append(("Change Picture (Base64)"  , "crsB64" ))
20960:     VV3wat.append(("Change Color"     , "crsCol" ))
20961:     VV3wat.append(VVAL3j)
20962:     VV3wat.append((c4 + "Reset to Default"  , "crsRm" ))
20963:    elif mode == 5:
20964:     VV3wat.append(("Change Text Color"   , "lColF" ))
20965:     VV3wat.append(("Change Background Color"  , "lColB" ))
20966:     VV3wat.append(VVAL3j)
20967:     VV3wat.append((c4 + "Reset to Default"  , "lRm"  ))
20968:    elif mode == 6:
20969:     VV3wat.append(("Change Text Color"   , "ttlF" ))
20970:     VV3wat.append(("Change Background Color"  , "ttlB" ))
20971:     VV3wat.append(VVAL3j)
20972:     VV3wat.append((c4 + "Reset Text Color"  , "ttlRf" ))
20973:     VV3wat.append((c4 + "Reset Background Color" , "ttlRb" ))
20974:    elif mode == 7:
20975:     VV3wat.append(("Change Text Color"   , "ttl1F" ))
20976:     VV3wat.append(("Change Background Color"  , "ttl1B" ))
20977:     VV3wat.append(VVAL3j)
20978:     VV3wat.append((c4 + "Reset Text Color"  , "ttl1Rf" ))
20979:     VV3wat.append((c4 + "Reset Background Color" , "ttl1Rb" ))
20980:    elif mode == 8:
20981:     VV3wat.append(("Change Text Color"   , "ttl2F" ))
20982:     VV3wat.append(("Change Background Color"  , "ttl2B" ))
20983:     VV3wat.append(VVAL3j)
20984:     VV3wat.append((c4 + "Reset Text Color"  , "ttl2Rf" ))
20985:     VV3wat.append((c4 + "Reset Background Color" , "ttl2Rb" ))
20986:    elif mode == 9:
20987:     VV3wat.append(("Change Text Color"   , "pgF"  ))
20988:     VV3wat.append(("Change Background Color"  , "pgB"  ))
20989:     VV3wat.append(VVAL3j)
20990:     VV3wat.append((c4 + "Reset Text Color"  , "pgRf" ))
20991:     VV3wat.append((c4 + "Reset Background Color" , "pgRb" ))
20992:    elif mode == 100:
20993:     for i in range(0, 110, 10):
20994:      VV3wat.append((str(i)      , "bGap%d" % i))
20995:    else:
20996:     return
20997:    FFLFTC(self, self.VVsyNv, title=title, width=700, VV3wat=VV3wat, VVU8mZ=True, VVwltY="#0a222222", VVkxBG="#0a222222")
20998:  def VVsyNv(self, item=None):
20999:   if item:
21000:    title, ref, ndx = item
21001:    if   ref == "icnFil": self.VVo0po(title, 1, False)
21002:    elif ref == "icnB64": self.VVo0po(title, 1, True )
21003:    elif ref == "icnDef": self.VVLz8f(title, 1, False, "")
21004:    elif ref == "wpMnu" : self.VVWI8i(title, 2)
21005:    elif ref == "wpFil" : self.VVo0po(title, 2, False)
21006:    elif ref == "wpB64" : self.VVo0po(title, 2, True )
21007:    elif ref == "wpCol" : self.VVaWfn(title , 2)
21008:    elif ref == "wpRm" : self.VVLz8f(title, 2, False, "")
21009:    elif ref == "gShad" : self.VVWI8i(title, 3)
21010:    elif ref == "shFil" : self.VVo0po(title, 3, False)
21011:    elif ref == "shB64" : self.VVo0po(title, 3, True )
21012:    elif ref == "shDef" : self.VVLz8f(title, 3, False, "yes")
21013:    elif ref == "shRm" : self.VVLz8f(title, 3, False, "")
21014:    elif ref == "gCurs" : self.VVWI8i(title, 4)
21015:    elif ref == "crsFil": self.VVo0po(title, 4, False)
21016:    elif ref == "crsB64": self.VVo0po(title, 4, True )
21017:    elif ref == "crsCol": self.VVaWfn(title , 4)
21018:    elif ref == "crsRm" : self.VVLz8f(title, 4, False, "")
21019:    elif ref == "lCurs" : self.VVWI8i(title, 5)
21020:    elif ref == "lColF" : self.VVaWfn(title , 50)
21021:    elif ref == "lColB" : self.VVaWfn(title , 51)
21022:    elif ref == "lRm" : self.VVLz8f(title, 51, False, "")
21023:    elif ref == "ttl" : self.VVWI8i(title, 6)
21024:    elif ref == "ttlF" : self.VVaWfn(title , 60)
21025:    elif ref == "ttlB" : self.VVaWfn(title , 61)
21026:    elif ref == "ttlRf" : self.VVLz8f(title, 60, False, "")
21027:    elif ref == "ttlRb" : self.VVLz8f(title, 61, False, "")
21028:    elif ref == "ttl1" : self.VVWI8i(title, 7)
21029:    elif ref == "ttl1F" : self.VVaWfn(title , 70)
21030:    elif ref == "ttl1B" : self.VVaWfn(title , 71)
21031:    elif ref == "ttl1Rf": self.VVLz8f(title, 70, False, "")
21032:    elif ref == "ttl1Rb": self.VVLz8f(title, 71, False, "")
21033:    elif ref == "ttl2" : self.VVWI8i(title, 8)
21034:    elif ref == "ttl2F" : self.VVaWfn(title , 80)
21035:    elif ref == "ttl2B" : self.VVaWfn(title , 81)
21036:    elif ref == "ttl2Rf": self.VVLz8f(title, 80, False, "")
21037:    elif ref == "ttl2Rb": self.VVLz8f(title, 81, False, "")
21038:    elif ref == "pg" : self.VVWI8i(title, 9)
21039:    elif ref == "pgF" : self.VVaWfn(title , 90)
21040:    elif ref == "pgB" : self.VVaWfn(title , 91)
21041:    elif ref == "pgRf" : self.VVLz8f(title, 90, False, "")
21042:    elif ref == "pgRb" : self.VVLz8f(title, 91, False, "")
21043:    elif ref == "bGap"   : self.VVWI8i(title, 100)
21044:    elif ref.startswith("bGap") : self.VVJHn2(title, mainAttr=("box_gap", ref[4:]))
21045:    elif ref == "cach" : FFRMYv(self, self.VV3fXu, "Continue ?", title=title)
21046:    elif ref == "del" : FFRMYv(self, BF(self.VVJHn2, title, delItem=True), "Continue ?", title=title)
21047:    elif ref == "movGo" : self.VVxqJP()
21048:    elif ref == "movNot": self.VVaQtC()
21049:    elif ref == "pPath" : self.session.openWithCallback(BF(self.VV71eW, title), BF(CClYaF, mode=CClYaF.VV9N82, VV1pbK=self.VVELQH(), width=1200, height=840, pickTitleBG="#11221122", pickBodyBG="#11221122", VVoCB2="#0a552255"))
21050:    elif ref == "impX" : self.session.openWithCallback(BF(self.VVM6Mb, title), BF(CClYaF, VV1gDA="custMnu", VV1pbK=self.VVZZAW()))
21051:  def VVxqJP(self):
21052:   title = "Move Selected Item"
21053:   curPos = self.VV6pYY()
21054:   if not self.moveCM_data:
21055:    self.moveCM_data = self.VVJHn2(title, getItem=True)
21056:    pos = self.instance.position()
21057:    x, y = pos.x(), pos.y()
21058:    self.moveCM_win = CChMGW.VVNLfa(self.session, "Move cursor and click OK", 35, shadW=2, bg="#00880000", x=x, y=y+20)
21059:    FFIGbj(self.moveCM_win, 0)
21060:   else:
21061:    oldNdx, elem = self.moveCM_data
21062:    newNdx, _ = self.VVJHn2(title, getItem=True)
21063:    if oldNdx == newNdx:
21064:     FF28n1(self, "Try another position", 1000)
21065:    else:
21066:     self.VVaQtC()
21067:     self.VVdLxd(newNdx)
21068:     self.VVJHn2(title, moveItem=(oldNdx, newNdx, elem))
21069:  def VVaQtC(self):
21070:   if self.moveCM_win:
21071:    self.session.deleteDialog(self.moveCM_win)
21072:   self.moveCM_data = self.moveCM_win = None
21073:  def VVELQH(self):
21074:   picP, xmlP = CFG.lastCustMenuPicDir.getValue(), CFG.lastCustMenuXmlDir.getValue()
21075:   if   picP: return picP
21076:   elif xmlP: return xmlP
21077:   else  : return CCRlkm.VVcQrm()
21078:  def VVZZAW(self):
21079:   picP, xmlP = CFG.lastCustMenuPicDir.getValue(), CFG.lastCustMenuXmlDir.getValue()
21080:   if   xmlP: return xmlP
21081:   elif picP: return picP
21082:   else  : return CCRlkm.VVcQrm()
21083:  def VVM6Mb(self, title, path=None):
21084:   if path:
21085:    FFjt1c(CFG.lastCustMenuXmlDir, os.path.dirname(path))
21086:    err = ""
21087:    try:
21088:     for ndx, (event, elem) in enumerate(iElem.iterparse(path, events=("start", ))):
21089:      if ndx == 0 and elem.tag == "ajp_menu":
21090:       mName = FFwW5m(elem, "title") or CCRlkm.VV9Ij0
21091:       icon, err = self.VViDaF(elem, "icon", False)
21092:       if not err:
21093:        fName = os.path.basename(path)
21094:        if not mName:
21095:         err = "No menu name in:\n\n%s" % fName
21096:        elif fName == CCRlkm.VVPNMN or fName in CCRlkm.VVJK42.keys():
21097:         err = "File is already used:\n\n%s" % fName
21098:        else:
21099:         el = iElem.Element("item")
21100:         el.set("name", mName)
21101:         if icon:
21102:          el.set("icon", icon)
21103:         el.text = path
21104:         el.tail = "\n\n\t"
21105:         self.VVJHn2(title, newElem=el)
21106:      else:
21107:       err = "Invalid Custom Menu file.\n\nCannot get menu name."
21108:      break
21109:    except Exception as e:
21110:     err = "Invalid Custom Menu file.\n\n%s" % str(e)
21111:    if err:
21112:     FFdw58(self, err, title=title)
21113:  def VVv79T(self, mode):
21114:   return {  1: "icon"
21115:     , 2: "bg"
21116:     , 3: "shade"
21117:     , 4: "cursor"
21118:     , 50: "cursor_fg" , 51: "cursor_bg"
21119:     , 60: "title_fg" , 61: "title_bg"
21120:     , 70: "title1_fg" , 71: "title1_bg"
21121:     , 80: "title2_fg" , 81: "title2_bg"
21122:     , 90: "num_fg"  , 91: "num_bg"
21123:     }.get(mode, "")
21124:  def VVaWfn(self, title, mode):
21125:   attr  = self.VVv79T(mode)
21126:   isBg  = False if attr.endswith("fg") else True
21127:   fg = self.VVUKLC[attr.replace("bg", "fg")]
21128:   bg = self.VVUKLC[attr.replace("fg", "bg")]
21129:   fg = fg if self.VVRmDl(fg) else "#00ffffff"
21130:   bg = bg if self.VVRmDl(bg) else "#00000040"
21131:   self.session.openWithCallback(BF(self.VVLdXS, title, mode), CC1FS2, defFG=fg, defBG=bg, onlyBG=True, isBgMode=isBg)
21132:  def VVLdXS(self, title, mode, fg, bg):
21133:   if fg or bg:
21134:    attr  = self.VVv79T(mode)
21135:    self.VVLz8f(title, mode, False, fg if attr.endswith("fg") else bg)
21136:  def VVo0po(self, title, mode, isB64):
21137:   self.session.openWithCallback(BF(self.VVev7c, title, mode, isB64), CClYaF, VV1gDA="poster", VV1pbK=self.VVELQH())
21138:  def VVev7c(self, title, mode, isB64, path=None):
21139:   if path:
21140:    FFjt1c(CFG.lastCustMenuPicDir, os.path.dirname(path))
21141:    err = self.VVr3Yq(path)
21142:    if err : FFdw58(self, err, title=title)
21143:    else : self.VVLz8f(title, mode, isB64, path)
21144:  def VVr3Yq(self, path):
21145:   fName = os.path.basename(path)
21146:   try:
21147:    p = LoadPixmap(path)
21148:    if not p:
21149:     return "Unloadable picture file:\n\n%s" % fName
21150:   except Exception as e:
21151:    return "Unloadable picture file:\n\n%s\n\nError : %s" % (fName, str(e))
21152:   return ""
21153:  @FFOAKH()
21154:  def VVLz8f(self, title, mode, isB64, path):
21155:   try:
21156:    pathTxt = path
21157:    if isB64 and path:
21158:     ext = os.path.splitext(path)[1][1:].lower().replace("jpg", "jpeg")
21159:     with open(path, "rb") as f:
21160:      pathTxt = str("data:image/%s;base64,%s" % (ext, b64encode(f.read()).decode()))
21161:    isSubmenu = self.subName and (os.path.basename(self.filePath) != os.path.basename(self.subName))
21162:    mainAttr = childAttr = None
21163:    elemID  = parent = ""
21164:    if mode > 1:
21165:     attr = self.VVv79T(mode)
21166:     if isSubmenu: childAttr, elemID = (attr, pathTxt), FFbhOc(self.subName)
21167:     else  : mainAttr = (attr, pathTxt)
21168:    else:
21169:     childAttr=("icon", pathTxt)
21170:     if isSubmenu:
21171:      elemID = self.VVZRrs()
21172:      parent = self.subName
21173:    self.VVJHn2(title, mainAttr=mainAttr, childAttr=childAttr, elemID=elemID, parent=parent)
21174:   except Exception as e:
21175:    FFdw58(self, str(e), title=title)
21176:  def VV71eW(self, title, path):
21177:   if path:
21178:    FFjt1c(CFG.lastCustMenuPicDir, path)
21179:    self.VVJHn2(title, picpath=path)
21180:  def VVJHn2(self, title, newElem=None, delItem=False, getItem=False, moveItem=None, picpath="", mainAttr=None, childAttr=None, elemID="", parent=""):
21181:   try:
21182:    head = ""
21183:    xTxt = FFYVq0(self.filePath, encLst="UTF-8")
21184:    ndx = xTxt.find("<ajp_menu")
21185:    if ndx > 0:
21186:     head = xTxt[:ndx]
21187:     xTxt = xTxt[ndx:]
21188:    tree = iElem.ElementTree(iElem.fromstring(xTxt, parser=iElem.XMLParser(target=CCYrUm.CC9usG())))
21189:    elemID = elemID or self.VVZRrs()
21190:    root = tree.getroot()
21191:    parents = {c:p for p in tree.iter( ) for c in p}
21192:    toSave = False
21193:    if mainAttr:
21194:     att, val = mainAttr
21195:     if val: root.set(att, val)
21196:     else  : root.attrib.pop(att, None)
21197:     toSave = True
21198:    elif picpath:
21199:     toSave = True
21200:     root.set("picpath", picpath)
21201:     p = FFwW5m(root, "cursor")
21202:     if p.startswith("/"): root.set("cursor", os.path.basename(p))
21203:     p = FFwW5m(root, "shade")
21204:     if p.startswith("/"): root.set("shade", os.path.basename(p))
21205:     for ndx, elem in enumerate(tree.iter()):
21206:      p = FFwW5m(elem, "icon")
21207:      if p and not self.VVYNQo(p): elem.set("icon", os.path.basename(p))
21208:      p = FFwW5m(elem, "bg")
21209:      if p and not self.VVYNQo(p): elem.set("bg", os.path.basename(p))
21210:    elif moveItem:
21211:     oldNdx, newNdx, newElem = moveItem
21212:     if oldNdx != newNdx:
21213:      toSave = True
21214:      for ndx, elem in enumerate(root):
21215:       if ndx == oldNdx:
21216:        elRoot = parents.get(elem, None)
21217:        if elRoot is not None: elRoot.remove(elem)
21218:        break
21219:      root.insert(newNdx, newElem)
21220:    else:
21221:     if not newElem is None or getItem: iterator = root
21222:     else        : iterator = tree.iter()
21223:     for ndx, elem in enumerate(iterator):
21224:      if self.VVP7EP(elem, elemID):
21225:       toSave = True
21226:       if not newElem is None:
21227:        root.insert(ndx, newElem)
21228:       elif delItem:
21229:        elRoot = parents.get(elem, None)
21230:        if elRoot is not None: elRoot.remove(elem)
21231:        else      : toSave = False
21232:       elif getItem:
21233:        return ndx, elem
21234:       elif childAttr:
21235:        if parent and parent != FFwW5m(parents[elem], "title"):
21236:         continue
21237:        att, val = childAttr
21238:        if val: elem.set(att, val)
21239:        else  : elem.attrib.pop(att, None)
21240:       else:
21241:        toSave = False
21242:       break
21243:     else:
21244:      FFdw58(self, "Current element not found.", title=title)
21245:      return
21246:    if toSave:
21247:     self.VVAYtY(root)
21248:     with open(self.filePath, "w") as f:
21249:      fTxt = str(iElem.tostring(root, encoding="UTF-8").decode())
21250:      line1 = "<?xml version='1.0' encoding='UTF-8'?>\n"
21251:      if fTxt.startswith(line1):
21252:       fTxt = fTxt[len(line1):]
21253:      f.write("%s%s" % (head, fTxt))
21254:     if mainAttr or childAttr: att, val = (mainAttr or childAttr)
21255:     else     : att = val = ""
21256:     if picpath or delItem or not newElem is None or att == "box_gap":
21257:      if delItem:
21258:       txt, ref, itemDict = self.VV7JdF()
21259:       fPath, isMain = self.VV7TrL(ref)
21260:       if fPath:
21261:        fName = os.path.basename(fPath)
21262:        if fName in CCRlkm.VVJK42.keys():
21263:         CCRlkm.VVJK42.pop(fName)
21264:      self.close(self.session, self.filePath, self.subName, self.VV6pYY())
21265:     elif att:
21266:      self.VVb8YI(att, val)
21267:    else:
21268:     FFjADj(self, "No change", 800)
21269:   except Exception as e:
21270:    FFdw58(self, str(e), title=title)
21271:  def VVb8YI(self, att, val):
21272:   if self.VVYNQo(val):
21273:    bg, err = self.VVBhHX(val)
21274:    if bg: val = bg
21275:    else : return
21276:   if att == "icon":
21277:    self.VVZXCy(val)
21278:    if self.isGrid : self.VVe4Ro()
21279:    else   : self["myMenu"].setList(self.VVGape)
21280:   else:
21281:    self.VVUKLC[att] = val
21282:    if att in ("bg", "title_fg", "title_bg", "title1_fg", "title1_bg", "title2_fg", "title2_bg", "num_fg", "num_bg"):
21283:     self.VVBRHT()
21284:    elif att in ("shade"):
21285:     self.VVGEkC(val)
21286:    elif att in ("cursor"):
21287:     self.VVrs4x(val)
21288:    elif att in ("cursor_fg", "cursor_bg"):
21289:     if   val == ""   : FF4IPF(self["myMenu"], fg=self.def_cursor_fg, bg=val or self.def_cursor_bg)
21290:     elif att == "cursor_fg" : FF4IPF(self["myMenu"], fg=val or self.def_cursor_fg)
21291:     elif att == "cursor_bg" : FF4IPF(self["myMenu"], bg=val or self.def_cursor_bg)
21292:     self["myMenu"].instance.invalidate()
21293:  def VVP7EP(self, elem, compId):
21294:   if   elem.tag == "submenu" : name = FFwW5m(elem, "title")
21295:   elif elem.tag == "item"  : name = FFwW5m(elem, "name")
21296:   else      : name = ""
21297:   return name and compId == FFbhOc(name)
21298:  def VVZRrs(self):
21299:   txt, ref, itemDict = self.VV7JdF()
21300:   return itemDict.get("id", "")
21301:  def VV6pYY(self):
21302:   if self.isGrid : txt, info, ndx, icon = self.VVGape[self.VVBGsZ]
21303:   else   : ndx = self["myMenu"].l.getCurrentSelectionIndex()
21304:   return ndx
21305:  def VV7JdF(self):
21306:   return self.VVUKLC["lst"][self.VV6pYY()]
21307:  def VVZXCy(self, path):
21308:   txt, ref, itemDict = self.VV7JdF()
21309:   itemDict["icon"] = path
21310:   self.VVUKLC["lst"][self.VV6pYY()] = (txt, ref, itemDict)
21311:   self.VVGape = self.VVoCYy()
21312:  def VVN5Mh(self):
21313:   txt, ref, itemDict = self.VV7JdF()
21314:   info = itemDict.get("info", "")
21315:   ask  = itemDict.get("ask", "Continue ?") if "ask" in itemDict else ""
21316:   icon = itemDict.get("icon", "")
21317:   tag  = itemDict["tag"]
21318:   fPath, isMain = self.VV7TrL(ref)
21319:   c1 = VVFuwR
21320:   if   self.VVYNQo(ref)   : act1, act2 = "Base64 Image", ref[:60] + " ..."
21321:   elif fPath       : act1, act2 = "External Menu File", fPath
21322:   elif tag == "submenu"    : act1, act2 = "Submenu", ref
21323:   elif ref.startswith("ajp_")   : act1, act2 = "AJPanel Option", ref
21324:   elif iMatch(self.VVPxk5Patt, ref) : act1, act2 = "Play a channel", ref
21325:   elif ref.startswith("/"):
21326:    fExt = os.path.splitext(ref)[1]
21327:    if fExt: fExt = fExt[1:]
21328:    isMedia = fExt in CCHmnm.VViatp()["mov"] or fExt in CCHmnm.VViatp()["mus"]
21329:    isPic = fExt in CCHmnm.VViatp()["pic"]
21330:    span = iSearch(r"^(\/.+sh)(\s+
21331:    if span     : act1, act2 = "Execute a Script file", ref
21332:    elif isMedia   : act1, act2 = "Play Media File", ref
21333:    elif isPic    : act1, act2 = "View Picture File", ref
21334:    elif os.path.isdir(ref) : act1, act2 = "Open in File Manager", ref
21335:    elif os.path.isfile(ref): act1, act2 = "Find in File Manager", ref
21336:    else     : act1, act2 = "", ref
21337:   else      : act1, act2 = "Run Command%s" % ("s" if "\n" in ref else ""), ref
21338:   ttl = lambda x, y: "%s:\n%s\n\n" % (FFjt5L(x, c1), str(y))
21339:   act = (FFjt5L(act1, VVJEMb, c1) if act1 else FFjt5L("Path not found", VVz22H, c1))
21340:   s1 = ""
21341:   if info: s1 += ttl("Description", info)
21342:   if icon:
21343:    if self.VVYNQo(icon): icon = icon[:60] + " ..."
21344:    s1 += ttl("Custom Icon", icon)
21345:   s1 += ttl("Action (%s)" % act, VVA4XU + act2)
21346:   s1 += ttl("Source File:", self.filePath)
21347:   FF4lCP(self, s1, title=txt)
21348:  def VVoCYy(self):
21349:   menuW = self.VVfOli["width"] - self.VVfOli["VVSZWt"] * 2
21350:   lineH = self.VVfOli["bodyLineH"]
21351:   align = {0: LEFT, 1: CENTER, 2: RIGHT}.get(self.VVUKLC["align_items"])
21352:   gap  = lineH // 8
21353:   pPath = CCafIt.VVjkKT()
21354:   resPath = lambda icn: "%s%s.png" % (VVIp2p, icn)
21355:   VV3wat = []
21356:   for ndx, (txt, ref, itemDict) in enumerate(self.VVUKLC["lst"]):
21357:    if itemDict["tag"] == "separator":
21358:     if self.isGrid:
21359:      continue
21360:     left = 0
21361:     txt, ref, icon = VVo7S9 + SEP, None, None
21362:     isSep = True
21363:    else:
21364:     isSep = False
21365:     icon = itemDict.get("icon", "")
21366:     if not icon:
21367:      fPath, isMain = self.VV7TrL(ref)
21368:      if itemDict["tag"] == "submenu":
21369:       isGrid, isStretch, cols, rows = self.VV2KRi(itemDict.get("mode", ""))
21370:       icon = resPath("menug" if isGrid else "menu")
21371:      elif fPath:
21372:       icon = resPath("menux")
21373:      elif iMatch(self.VVPxk5Patt, ref):
21374:       span = iSearch(self.VVPxk5Patt, ref)
21375:       for ext in ("png", "jpg"):
21376:        picon = "%s%s.%s" % (pPath, span.group(1).rstrip(":_").replace(":", "_").upper(), ext)
21377:        if FFCyVu(picon):
21378:         icon = picon
21379:         break
21380:       else:
21381:        icon = resPath("tv")
21382:      elif ref.startswith("/"):
21383:       fExt = os.path.splitext(ref)[1]
21384:       fExt = fExt[1:] if fExt else fExt
21385:       extLst = CCHmnm.VViatp()
21386:       span = iSearch(r"^(\/.+sh)(\s+
21387:       if span:
21388:        icon = resPath("scr")
21389:       elif fExt in extLst["mov"] or fExt in extLst["mus"]:
21390:        pathNoExt = os.path.join(os.path.dirname(ref), os.path.join(os.path.dirname(ref), os.path.basename(ref)[:-(len(fExt) + 1)]))
21391:        for ext in ("png", "jpg"):
21392:         poster = "%s.%s" % (pathNoExt, ext)
21393:         if FFCyVu(poster):
21394:          icon = poster
21395:          break
21396:        else:
21397:         icon = resPath("mov" if fExt in extLst["mov"] else "mus")
21398:       elif fExt in extLst["pic"]  : icon = ref if FFCyVu(ref) else resPath("pic")
21399:       elif os.path.isdir(ref)   : icon = resPath("dir")
21400:       elif os.path.isfile(ref)  :
21401:        s = txt.lower()
21402:        if s.startswith("about") : icon = resPath("info")
21403:        else      : icon = resPath("fil")
21404:       else       : icon = resPath("err")
21405:      elif ref.startswith("ajp_")   : icon = resPath("ajp2")
21406:      elif txt.lower().startswith("about"): icon = resPath("info")
21407:      elif "wget" in ref     : icon = resPath("wget")
21408:      else:
21409:       icon = resPath("teln")
21410:    if self.isGrid:
21411:     info = itemDict.get("info", "") or txt
21412:     VV3wat.append((txt, info, ndx, icon))
21413:    else:
21414:     if   isSep   : x = 0
21415:     elif align == LEFT : x = gap + lineH + lineH // 3
21416:     elif align == CENTER: x = 0
21417:     else    : x = -lineH - gap
21418:     tableRow = [ None if isSep else ndx ]
21419:     tableRow.append((eListboxPythonMultiContent.TYPE_TEXT, x, 0, menuW, lineH, 0, align | RT_VALIGN_CENTER, txt))
21420:     png = FFmNfu(icon)
21421:     if png:
21422:      sz = png.size()
21423:      pngW, pngH = sz.width(), sz.height()
21424:      w = h = lineH - 4
21425:      if pngW == pngH: x, y = 0, 2
21426:      else: x, y, w, h = self.VVF7W0(pngW, pngH, lineH - 4, lineH - 4)
21427:      if align == RIGHT:
21428:       x = menuW - w - gap
21429:      if not self.isGrid:
21430:       tableRow.append(CCnES5.VVmxDV(gap+x, y, w, h, png))
21431:     VV3wat.append(tableRow)
21432:   if not self.isGrid:
21433:    FFIFeD()
21434:   return VV3wat
21435:  def VV2KRi(self, mode):
21436:   isGrid, isStretch, cols, rows = False, True, 5, 4
21437:   span = iSearch(r"^grid(\d)?(?:_(\d)x(\d))?", mode, IGNORECASE)
21438:   if span:
21439:    isGrid = True
21440:    isStretch = span.group(1) != "1"
21441:    if span.group(2) : cols = FFsRWN(int(span.group(2)), 3, 9)
21442:    if span.group(3) : rows = FFsRWN(int(span.group(3)), 3, 6)
21443:   return isGrid, isStretch, cols, rows
21444:  def VVe4Ro(self):
21445:   self.VVaFRk()
21446:   f1, f2 = self.VVS7BN()
21447:   row = col = 0
21448:   for ndx in range(f1, f2):
21449:    txt, _, _, icon = self.VVGape[ndx]
21450:    pic, lbl = self.VVwbpA(row, col)
21451:    self.VVExY8(lbl, txt)
21452:    png = FFBFPY(pic, icon)
21453:    if png:
21454:     boxX, boxY = self.VVzIFK[(row, col)]
21455:     pngSz = png.size()
21456:     pngW, pngH = pngSz.width(), pngSz.height()
21457:     if not self.isStretch and self.VVP8y1 > pngW and self.VVIgWJ > pngH:
21458:      pic.instance.resize(pngSz)
21459:      pic.instance.move(ePoint(boxX + (self.VVP8y1 - pngW) // 2, boxY + (self.VVIgWJ - pngH) // 2))
21460:     else:
21461:      x, y, w, h = self.VVF7W0(pngW, pngH, self.VVP8y1, self.VVIgWJ)
21462:      pic.instance.resize(eSize(*(w, h)))
21463:      pic.instance.move(ePoint(boxX + (self.VVP8y1 - w) // 2, boxY + (self.VVIgWJ - h) // 2))
21464:    self.VVcG7K = row
21465:    self.VVGCBk = col
21466:    col += 1
21467:    if col > (self.VVsHeH - 1):
21468:     col = 0
21469:     row += 1
21470:  def VVHvUS(self):
21471:   txt, info, ndx, icon = self.VVGape[self.VVBGsZ]
21472:   self.VVkhlj(txt, info)
21473:  @FFOAKH()
21474:  def VVSTO4(self, txt, ref, itemDict):
21475:   tag = itemDict["tag"]
21476:   fPath, isMain = self.VV7TrL(ref)
21477:   isAbout = txt.lower().startswith("about")
21478:   if fPath:
21479:    if FFCyVu(fPath):
21480:     self.session.openWithCallback(CCRlkm.VVgQDN, CCRlkm, subFile=fPath, subName=ref)
21481:    else:
21482:     FFdw58(self, "Custom Menu file not found:\n\n%s" % fPath, title=txt)
21483:     return
21484:   elif tag == "submenu":
21485:    self.session.openWithCallback(CCRlkm.VVgQDN, CCRlkm, subFile=self.filePath, subName=ref, picpath=self.VVUKLC["picpath"])
21486:   elif iMatch(self.VVPxk5Patt, ref):
21487:    span = iSearch(self.VVPxk5Patt, ref)
21488:    VVu06s = span.group(1).replace("_", ":").upper() + span.group(2)
21489:    CCqWM2.VVHc02(self.session, VVaHNe=VVu06s)
21490:   elif ref.startswith("/"):
21491:    path = ref
21492:    fExt = os.path.splitext(path)[1]
21493:    if fExt: fExt = fExt[1:]
21494:    if not FFCyVu(path):
21495:     FFdw58(self, "Path Not found:\n\n%s" % path, title=txt)
21496:     return
21497:    span = iSearch(r"^(\/.+sh)(\s+
21498:    if span:
21499:     path = span.group(1)
21500:     if FFCyVu(path) : self.session.open(CCtzVm, VVGd7m=path, VV6TEx=True)
21501:     else    : FF8Wsn(self, path, title=txt)
21502:    elif fExt in CCHmnm.VViatp()["mov"] or fExt in CCHmnm.VViatp()["mus"]:
21503:     CClYaF.VVTWR0(self, path)
21504:    elif fExt in CCHmnm.VViatp()["pic"]:
21505:     CCf8zb.VVjnMn(self, ref)
21506:    elif os.path.isdir(path):
21507:     self.session.open(CClYaF, mode=CClYaF.VV4Ihm, VVHYTc=path)
21508:    elif os.path.isfile(path):
21509:     if isAbout:
21510:      if CClYaF.VVgIOw(path) : FFdw58(self, "Cannot view binary file:\n\n%s" % path, title=txt)
21511:      else        : self.VVy39X(txt, FFYVq0(path))
21512:     else:
21513:      self.session.open(CClYaF, mode=CClYaF.VV4Ihm, VVHYTc=path)
21514:    else:
21515:     FFdw58(self, "Cannot handle path:\n\n%s" % path, title=txt)
21516:   elif ref.startswith("ajp_"):
21517:    s = ref[4:]
21518:    if   s == "fman" : self.session.open(CClYaF)
21519:    elif s == "iptv" : self.session.open(CCkEI5)
21520:    elif s == "movie" : CCG2jh.VV7hTj(self)
21521:    elif s == "chan" : self.session.open(CCYrUm)
21522:    elif s == "chanBr" : CCjThi.VVJNjY(self)
21523:    elif s == "bouq" : self.session.open(CCLSIv)
21524:    elif s == "picon" : self.session.open(CCafIt)
21525:    elif s == "epg"  : self.session.open(CC5TsO)
21526:    elif s == "xmltv" : CCDJgl(self)
21527:    elif s == "term" : self.session.open(CCtzVm)
21528:    elif s == "soft" : self.session.open(CCid3A)
21529:    elif s == "plugin" : self.session.open(CCeSkW)
21530:    elif s == "plugBr" : CCFZr4.VVsCNi(self.session)
21531:    elif s == "bakup" : self.session.open(CCxSED)
21532:    elif s == "date" : self.session.open(CCbQCK)
21533:    elif s == "net"  : self.session.open(CCJIaP)
21534:    elif s == "info" : self.session.open(CC674y)
21535:    elif s == "inet" : self.session.open(CCoFdR)
21536:    else    : FFdw58(self, "Option not found in %s" % VVh9hj, title=txt)
21537:   elif isAbout:
21538:    self.VVy39X(txt, ref)
21539:   else:
21540:    if len(ref) > 20000 : FFdw58(self, "The script exceeds 20,000 characters !\n\nMove the script to a script file.", title=txt)
21541:    else    : self.session.open(CCtzVm, VVGd7m=ref, VVOuqa="Running Multiple Commands ..." if "\n" in ref else "", VV6TEx=True)
21542:  def VVy39X(self, title, txt):
21543:   FF4lCP(self, txt.strip()[:60000], title=title, VVwdmN=30, width=1600, height=1000, titleBg="
21544:  def VVCW1G(self, subName):
21545:   try:
21546:    tree = iElem.parse(self.filePath)
21547:   except Exception as e:
21548:    return str(e)
21549:   root = newRoot = tree.getroot()
21550:   self.tmpOtherFiles = []
21551:   for ndx, elem in enumerate(tree.iter()):
21552:    tag = elem.tag
21553:    if tag in ("ajp_menu", "submenu"):
21554:     err = self.VV54Ub(elem)
21555:     if err:
21556:      return err
21557:     if tag == "submenu" and FFwW5m(elem, "title") == subName:
21558:      newRoot = elem
21559:   txt = "Repeated custom menu file in : %s\nMenu File : %s"
21560:   lst = [elem for elem, count in iCounter((f, el) for f, el in self.tmpOtherFiles).items() if count > 1]
21561:   if lst:
21562:    return txt % lst[0]
21563:   else:
21564:    curF = os.path.basename(self.filePath)
21565:    for mnuF, mnuName in self.tmpOtherFiles:
21566:     if mnuF in CCRlkm.VVJK42:
21567:      tmpF, tmpName = CCRlkm.VVJK42[mnuF]
21568:      if tmpF != curF:
21569:       return txt % (mnuName, mnuF)
21570:     else:
21571:      CCRlkm.VVJK42[mnuF] = (curF, mnuName)
21572:   self.VVUKLC["title"] = (FFwW5m(newRoot, "title") or self.VV9Ij0)
21573:   self.VVUKLC["mode"]  = FFwW5m(newRoot, "mode").lower()
21574:   self.VVUKLC["picpath"] = FFwW5m(newRoot, "picpath") or self.VVUKLC["picpath"]
21575:   isGrid, _, _, _ = self.VV2KRi(self.VVUKLC["mode"])
21576:   if isGrid:
21577:    self.VVYMoP("width", newRoot, 600, 1920, "1600")
21578:    self.VVYMoP("height", newRoot, 600, 1080, "900")
21579:   else:
21580:    self.VVYMoP("width", newRoot, 500, 1920, "800")
21581:    self.VVYMoP("height", newRoot, 400, 1080, "1000")
21582:   self.VVYMoP("font_size", newRoot, 10, 50)
21583:   self.VVYMoP("title_font_size", newRoot, 20, 50)
21584:   val = FFwW5m(newRoot, "line_gap")
21585:   if val.isdigit():
21586:    val = FFsRWN(int(val), 0, 100)
21587:    self.VVUKLC["line_gap"] = FFjFSv(val, 0, 100, 0.15, 2)
21588:   val = FFwW5m(newRoot, "box_gap")
21589:   if val.isdigit():
21590:    val = FFsRWN(int(val), 0, 100)
21591:    self.VVUKLC["box_gap"] = FFjFSv(val, 0, 100, 0, 30)
21592:   v = newRoot.attrib.get("align_items", "left")
21593:   if   v == "left" : self.VVUKLC["align_items"] = 0
21594:   elif v == "center" : self.VVUKLC["align_items"] = 1
21595:   elif v == "right" : self.VVUKLC["align_items"] = 2
21596:   bg, err = self.VViDaF(newRoot, "bg", True)
21597:   if   bg : self.VVUKLC["bg"] = bg
21598:   elif err: return err
21599:   if isGrid:
21600:    bg, err = self.VViDaF(newRoot, "cursor", True)
21601:    if   bg : self.VVUKLC["cursor"] = bg
21602:    elif err: return err
21603:    if FFwW5m(newRoot, "shade").lower() == "yes":
21604:     self.VVUKLC["shade"] = "yes"
21605:    else:
21606:     bg, err = self.VViDaF(newRoot, "shade", False)
21607:     if   bg : self.VVUKLC["shade"] = bg
21608:     elif err: return err
21609:   for attr in ("fg", "title_fg", "title_bg", "cursor_fg", "cursor_bg", "title1_fg", "title1_bg", "title2_fg", "title2_bg", "num_fg", "num_bg"):
21610:    self.VV6H1w(attr, newRoot)
21611:   for elem in newRoot:
21612:    itemDict = {"tag": elem.tag}
21613:    if "ask" in elem.attrib  : itemDict["ask"] = FFwW5m(elem, "ask")
21614:    if "info" in elem.attrib : itemDict["info"] = FFwW5m(elem, "info")
21615:    name = ""
21616:    if elem.tag == "submenu":
21617:     name = FFwW5m(elem, "title")
21618:     itemDict["mode"] = FFwW5m(elem, "mode")
21619:     self.VVUKLC["lst"].append((name, name, itemDict))
21620:    elif elem.tag == "item":
21621:     name = FFwW5m(elem, "name")
21622:     action = FFax4p(elem)
21623:     action = "\n".join(list(map(str.strip, action.split("\n"))))
21624:     self.VVUKLC["lst"].append((name, action, itemDict))
21625:    elif elem.tag == "separator":
21626:     self.VVUKLC["lst"].append(("", "", itemDict))
21627:    bg, err = self.VViDaF(elem, "icon", False)
21628:    if   bg : itemDict["icon"] = bg
21629:    elif err: return err
21630:    itemDict["id"] = FFbhOc(name)
21631:  def VV54Ub(self, elem):
21632:   mainName = FFwW5m(elem, "title") or FFwW5m(elem, "name") or elem.tag
21633:   curIsSep = False
21634:   nameLst = set()
21635:   tot = 0
21636:   curName = ""
21637:   for ndx, elem in enumerate(elem):
21638:    tag = elem.tag
21639:    if tag == "ajp_menu":
21640:     curIsSep = False
21641:     titl  = curName = FFwW5m(elem, "title")
21642:     if not titl : return "No Main Title in : %s" % tag
21643:     else  : nameLst.add(titl.lower())
21644:    elif tag == "submenu":
21645:     tot += 1
21646:     curIsSep = False
21647:     titl = curName = FFwW5m(elem, "title")
21648:     if   not titl    : return "Found submenu with no title."
21649:     elif titl.lower() in nameLst: return "Duplicate submenu title : %s" % titl
21650:     else      : nameLst.add(titl.lower())
21651:    elif tag == "item":
21652:     tot += 1
21653:     curIsSep = False
21654:     name = curName = FFwW5m(elem, "name")
21655:     action = FFax4p(elem)
21656:     if   not name : return "Found menu item with no name."
21657:     elif not action : return "No action for : %s" % name
21658:     fPath, isMain = self.VV7TrL(action)
21659:     if fPath:
21660:      curName = FFjt5L(curName, VVZtfx)
21661:      if   isMain : return "Do not use the main custom file in : %s\n%s" % (curName, fPath)
21662:      else  : self.tmpOtherFiles.append((os.path.basename(fPath), curName))
21663:    elif tag == "separator":
21664:     tName = curName or mainName
21665:     if   ndx == 0 : return "Cannot use Separator as first menu item in : %s" % tName
21666:     elif curIsSep : return "Consecutive Separators are not allowed after : %s" % tName
21667:     else   : curIsSep = True
21668:    else:
21669:     return "Unknown Tag : %s" % tag
21670:   tName = curName or mainName
21671:   if   tot == 0: return "No menu items found in : %s" % tName
21672:   elif curIsSep: return "Cannot use Separator as last menu item after : %s" % tName
21673:   else   : return ""
21674:  def VVYMoP(self, dItem, elem, Min, Max, default=""):
21675:   if dItem in self.VVUKLC:
21676:    val = elem.attrib.get(dItem, default)
21677:    if val.isdigit():
21678:     self.VVUKLC[dItem] =  FFsRWN(int(val), Min, Max)
21679:  def VV6H1w(self, dItem, elem):
21680:   if dItem in self.VVUKLC:
21681:    val = elem.attrib.get(dItem, "")
21682:    if val and self.VVRmDl(val):
21683:     self.VVUKLC[dItem] = val
21684:     return True
21685:   return False
21686:  def VViDaF(self, elem, attr, canColor):
21687:   bg, err = self.VVygHh(elem, attr, canColor)
21688:   if err:
21689:    c1, c2, c3, c4 = VVZtfx, VV1fx4, VVYjI5, VVo7S9
21690:    val = FFwW5m(elem, attr)
21691:    txt  = FFjt5L(err, c3) + "\n\n"
21692:    txt += "Check : %s\n" % FFjt5L(self.VVUKLC["title"], c1)
21693:    txt += '%s="%s"' % (FFjt5L(attr, c2), FFjt5L(val if len(val) < 80 else val[:80] + " ...", c4))
21694:    return "", txt
21695:   else:
21696:    return bg, err
21697:  def VVygHh(self, elem, attr, canColor):
21698:   c1, c2, c3 = VVZtfx, VV1fx4, VVz22H
21699:   val = FFwW5m(elem, attr)
21700:   if not val:
21701:    return "", ""
21702:   elif canColor and self.VVRmDl(val):
21703:    self.VV6H1w(attr, elem)
21704:    return "", ""
21705:   elif val.endswith((".jpg", ".png")):
21706:    if not val.startswith("/"):
21707:     val = os.path.join(self.VVUKLC["picpath"], val)
21708:    fName = os.path.basename(val)
21709:    fil, ext = os.path.splitext(fName)
21710:    if ext == ".png" and fil in ("ajp", "dnld", "ajp2", "pic", "mov", "tv") and not FFCyVu(val):
21711:     val = VVIp2p + fName
21712:    return val, ""
21713:   elif self.VVYNQo(val):
21714:    return self.VVBhHX(val)
21715:   else:
21716:    if canColor : txt = "Value must be a color,"
21717:    else  : txt = "Picture files must be a"
21718:    return "", "%s jpg, png or Base64 format." % txt
21719:  def VVBhHX(self, b64):
21720:   span = iSearch(r"data:image\/(.+);base64,(.+)", b64)
21721:   if span:
21722:    cacheDir = CCRlkm.VVlOtF()
21723:    ext, b64 = span.groups()
21724:    pFile = "%s%s.%s" % (cacheDir, FFbhOc(b64), ext.replace("jpeg", "jpg"))
21725:    if FFCyVu(pFile):
21726:     return pFile, ""
21727:    else:
21728:     if not FFpwZS("mkdir -p '%s'" % cacheDir):
21729:      return "", "Cannot create icons directory:\n%s" % FFjt5L(cacheDir, c1)
21730:     try:
21731:      with open(pFile, "wb") as f:
21732:       f.write(b64decode(b64))
21733:     except Exception as e:
21734:      FFwgGB(pFile)
21735:      return "", "Cannot convert Base64 picture file.\n%s" % str(e)
21736:     try:
21737:      png = LoadPixmap(pFile)
21738:      if png:
21739:       return pFile, ""
21740:      else:
21741:       FFwgGB(pFile)
21742:       return "", "Unloadable picture file (or invalid jpg/png format)"
21743:     except Exception as e:
21744:      FFwgGB(pFile)
21745:      return "", "Unloadable picture file.:\n%s" % str(e)
21746:   else:
21747:    return "",
21748:  def VV7TrL(self, path):
21749:   fName = os.path.basename(path)
21750:   if fName.startswith(CCRlkm.VVPNMN[:-4]):
21751:    isMain = fName == CCRlkm.VVPNMN
21752:    if path.startswith("/") : fPath = path
21753:    else     : fPath = CCRlkm.VVcQrm() + fName
21754:    return fPath, isMain
21755:   else:
21756:    return "", False
21757:  def VVRmDl(self, c):
21758:   return bool(iMatch(r"^
21759:  def VVYNQo(self, txt):
21760:   return bool(iMatch(r"data:image\/.+;base64,.+", txt))
21761:  def VV3fXu(self):
21762:   lst = FF3xOt(r"find '%s' -type f \( -name '*.png' -o -name '*.jpg' \)" % CCRlkm.VVlOtF())
21763:   tot = 0
21764:   for f in lst:
21765:    if iMatch(r"(.+_ajp_.+|.+[A-Fa-f0-9]{32})\.(?:png|jpg)$", f):
21766:     tot += 1
21767:     FFwgGB(f)
21768:   if tot > 0 : FF1mVE(self, "%s deleted" % tot, 2000)
21769:   else  : FF28n1(self, "No cached files", 1000)
21770:  @staticmethod
21771:  def VVY2v0(pixMap, path, toPng=False):
21772:   newPath = CC6u6z.VVQuYE(pixMap, path, toPng=toPng)
21773:   inst = pixMap.instance
21774:   inst.setScale(1)
21775:   if FFCyVu(newPath):
21776:    inst.setAlphatest(0)
21777:    FFBFPY(pixMap, newPath)
21778:    return newPath
21779:   elif FFCyVu(path):
21780:    inst.setAlphatest(1)
21781:    FFBFPY(pixMap, path)
21782:    return path
21783:   else:
21784:    return ""
21785:  @staticmethod
21786:  def VVcQrm():
21787:   return FFoWxR(CFG.customMenuPath.getValue())
21788:  @staticmethod
21789:  def VVGHsh():
21790:   return CCRlkm.VVcQrm() + CCRlkm.VVPNMN
21791:  @staticmethod
21792:  def VVlOtF():
21793:   return CCRlkm.VVcQrm() + "ajpanel_menu/"
21794:  @staticmethod
21795:  def VVRqTG():
21796:   return str(u"\u00A4")
21797:  @staticmethod
21798:  def VVazeJ():
21799:   path = CCRlkm.VVGHsh()
21800:   cmTitle = CCRlkm.VV9Ij0
21801:   mrk = CCRlkm.VVRqTG()
21802:   if FFCyVu(path):
21803:    try:
21804:     for ndx, (event, elem) in enumerate(iElem.iterparse(path, events=("start", ))):
21805:      if ndx == 0 and elem.tag == "ajp_menu":
21806:       cmTitle = FFwW5m(elem, "title") or CCRlkm.VV9Ij0
21807:      break
21808:    except:
21809:     pass
21810:   return "%s %s %s" % (mrk, cmTitle, mrk)
21811:  def VVAYtY(self, tree, space="\t", level=0):
21812:   if isinstance(tree, iElem.ElementTree): tree = tree.getroot()
21813:   if not len(tree): return
21814:   indents = ["\n" + level * space]
21815:   def VVZwiy(elem, level):
21816:    chLevel = level + 1
21817:    try:
21818:     chInd = indents[chLevel]
21819:    except IndexError:
21820:     chInd = indents[level] + space
21821:     indents.append(chInd)
21822:    if not elem.text or not elem.text.strip() : elem.text = chInd
21823:    for ch in elem:
21824:     if len(ch)        : VVZwiy(ch, chLevel)
21825:     if not ch.tail or not ch.tail.strip() : ch.tail = chInd
21826:     if len(ch)        : ch.tail = "\n" + chInd
21827:    if not ch.tail.strip()      : ch.tail = indents[level]
21828:   VVZwiy(tree, 0)
21829:  @staticmethod
21830:  def VVEYRT(SELF, VV1rS5=False):
21831:   if VV1rS5: fnc, session = FF2JFr, SELF
21832:   else    : fnc, session = FFimQ3 , SELF.session
21833:   path = CCRlkm.VVGHsh()
21834:   Dir = os.path.dirname(path)
21835:   fil = os.path.basename(path)
21836:   if not VVmJwX(Dir) : FFzcnp(session, "%s\n\nPlease change %s path in Settings." % (Dir, FFjt5L("Custom Menu", VVFuwR)), title="Custom Menu path not found")
21837:   elif FFCyVu(path) : fnc(SELF, BF(session.openWithCallback, CCRlkm.VVgQDN, CCRlkm), title="Loading ...")
21838:   else     : FFRMYv(session, BF(fnc, SELF, BF(CCRlkm.VVoOWy, session, Dir, fil)), "Try a sample file ?\n\n%s" % path, title="Custom Menu file not found", VV1rS5=True)
21839:  @staticmethod
21840:  def VVoOWy(session, Dir, fil):
21841:   if FFpwZS("cp -f '%s%s' '%s'" % (VVIp2p, fil, Dir)):
21842:    session.openWithCallback(CCRlkm.VVgQDN, CCRlkm)
21843:   else:
21844:    FFzcnp(session, "Cannot copy template file to backup directory.", title=CCRlkm.VV9Ij0)
21845:  @staticmethod
21846:  def VVgQDN(session=None, subFile="", subName="", startItem=0):
21847:   if session and (subFile or subName):
21848:    FFIElK(BF(session.openWithCallback, CCRlkm.VVgQDN, CCRlkm, subFile=subFile, subName=subName, startItem=startItem))
21849: class CC9hzi(Screen):
21850:  def __init__(self, session, title="", csel=None, VVPxk5="", servName="", isFind=False):
21851:   self.skin, self.VVfOli = FFiNEe(VVWp3I, 700, 800, 50, 40, 30, "
21852:   self.session     = session
21853:   self.csel      = csel
21854:   self.VVPxk5     = VVPxk5
21855:   self.servName     = servName
21856:   self.findTxt     = servName
21857:   self.isFindMode     = isFind
21858:   self.VVpEX8  = 0
21859:   self.VVZnnj = 1
21860:   self.VVL0yl  = 2
21861:   VV3wat = []
21862:   VV3wat.append(("Find in All Service (from filter)" , "VVe3Fh" ))
21863:   VV3wat.append(VVAL3j)
21864:   VV3wat.append(("Find in All (Manual Entry)"   , "VV8w6L"    ))
21865:   VV3wat.append(("Find in TV"       , "VV3AjF"    ))
21866:   VV3wat.append(("Find in Radio"      , "VVqK0C"   ))
21867:   if self.VVNi5y():
21868:    VV3wat.append(VVAL3j)
21869:    VV3wat.append(("Hide Channel: %s" % self.servName , "VVmk6k"   ))
21870:   VV3wat.append(VVAL3j)
21871:   VV3wat.append(("Zap History"       , "zapH"      ))
21872:   VV3wat.append(VVAL3j)
21873:   VV3wat.append(("IPTV Tools"       , "iptv"      ))
21874:   VV3wat.append(("PIcons Tools"       , "PIconsTools"     ))
21875:   VV3wat.append(("Services/Channels Tools"    , "ChannelsTools"    ))
21876:   VV3wat.append(("EPG Tools"       , "epgTools"     ))
21877:   FFZMxC(self, VV3wat=VV3wat, title=title)
21878:   self.onShown.append(self.VV7OzD)
21879:  def VV7OzD(self):
21880:   self.onShown.remove(self.VV7OzD)
21881:   FF4IPF(self["myMenu"])
21882:   FF2GM8(self)
21883:   if self.isFindMode:
21884:    self.VVdb3C(self.VVGuCn())
21885:  def VVPr1F(self):
21886:   item = FFTmHZ(self)
21887:   if item is not None:
21888:    if   item == "VV8w6L"    : self.VV8w6L()
21889:    elif item == "VVe3Fh" : self.VVe3Fh()
21890:    elif item == "VV3AjF"    : self.VV3AjF()
21891:    elif item == "VVqK0C"   : self.VVqK0C()
21892:    elif item == "VVmk6k"   : self.VVmk6k()
21893:    elif item == "zapH"       : self.session.open(CCiCTh)
21894:    elif item == "iptv"       : self.session.open(CCkEI5)
21895:    elif item == "PIconsTools"     : self.session.open(CCafIt)
21896:    elif item == "ChannelsTools"    : self.session.open(CCYrUm)
21897:    elif item == "epgTools"      : self.session.open(CC5TsO)
21898:    if item in ("iptv", "PIconsTools", "ChannelsTools"):
21899:     self.close()
21900:  def VV3AjF(self) : self.VVdb3C(self.VVpEX8)
21901:  def VVqK0C(self) : self.VVdb3C(self.VVZnnj)
21902:  def VV8w6L(self) : self.VVdb3C(self.VVL0yl)
21903:  def VVdb3C(self, mode):
21904:   title = "Find %s Service" % ("TV", "Radio", "All")[mode]
21905:   FF4z45(self, BF(self.VViXQo, mode), defaultText=self.findTxt, title=title, message="Enter Name:")
21906:  def VVe3Fh(self):
21907:   filterObj = CCoErY(self)
21908:   filterObj.VVVPGN(self.VVbyGX)
21909:  def VVbyGX(self, item):
21910:   self.VViXQo(self.VVL0yl, item)
21911:  def VVNi5y(self):
21912:   if self.servName.strip() == ""      : return False
21913:   if self.VVPxk5.strip()  == ""      : return False
21914:   if self.VVPxk5.startswith("1:7:1:0:0:0:0:0:0:0:") : return False
21915:   if FFUPnc(self.VVPxk5)        : return False
21916:   return True
21917:  @FFOAKH("Searching ...")
21918:  def VViXQo(self, mode, VV8RqF):
21919:   if VV8RqF:
21920:    VV8RqF = VV8RqF.strip()
21921:   if VV8RqF:
21922:    self.findTxt = VV8RqF
21923:    CFG.lastFindContextFind.setValue(VV8RqF)
21924:    if   mode == self.VVpEX8  : titlTxt, servTypes = "TV"  , service_types_tv
21925:    elif mode == self.VVZnnj : titlTxt, servTypes = "Radio"  , service_types_radio
21926:    else          : titlTxt, servTypes = "All" , "1:7:"
21927:    title = 'Find %s : "%s"' % (titlTxt, VV8RqF)
21928:    if len(title) > 55:
21929:     title = title[:55] + ".."
21930:    VVAkuK = self.VV4W5L(VV8RqF, servTypes)
21931:    if self.isFindMode or mode == self.VVL0yl:
21932:     VVAkuK += self.VVUmsF(VV8RqF)
21933:    if VVAkuK:
21934:     VVAkuK.sort(key=lambda x: x[0].lower())
21935:     VVu8qI = self.VVZP6Z
21936:     VVu1YM  = ("Zap"   , self.VVKluW    , [])
21937:     VVwSzI = ("Current Service", self.VV0bf5 , [])
21938:     VVScQz = ("Options"  , self.VVC8BZ , [])
21939:     VV2ytr = (""    , self.VV7N77 , [])
21940:     header   = ("Name" , "Type", "Ref.", "Sat.", "Freq." , "Pol.", "FEC" , "SR" , "Bouq")
21941:     widths   = (38  , 17 , 0  , 10 , 10  , 7  , 8  , 10 , 0.01 )
21942:     VVLIqP  = (LEFT  , CENTER, LEFT  , CENTER, CENTER , CENTER, CENTER, CENTER, CENTER)
21943:     FFUQ0v(self, None, title=title, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVu1YM=VVu1YM, VVu8qI=VVu8qI, VVwSzI=VVwSzI, VVScQz=VVScQz, VV2ytr=VV2ytr, VVSLOq=CFG.lastFindContextFind)
21944:    else:
21945:     self.VVdb3C(self.VVGuCn())
21946:     FFipXT(self, "Not found", title=title)
21947:   elif self.isFindMode:
21948:    self.close()
21949:   else:
21950:    self.findTxt = self.servName
21951:  def VV4W5L(self, VV8RqF, servTypes):
21952:   VVGape = CCYrUm.VV3FRU(servTypes)
21953:   VVAkuK = []
21954:   if VVGape:
21955:    VVY1oT, VVvwHc = FF07Sg()
21956:    tp = CC3Z54()
21957:    words, asPrefix = CCoErY.VVPBNm(VV8RqF)
21958:    colorYellow  = CCuTnL.VVsAua(VV1fx4)
21959:    colorWhite  = CCuTnL.VVsAua(VVwdUw)
21960:    for s in VVGape:
21961:     name = s[1]
21962:     for word in words:
21963:      ok = False
21964:      tName = name.lower()
21965:      if asPrefix:
21966:       if tName.startswith(word):
21967:        ok = True
21968:      elif word in tName:
21969:       ok = True
21970:      if ok:
21971:       VVPxk5 = s[0]
21972:       if VVPxk5.count(":") > 8:
21973:        if asPrefix:
21974:         name = iSub(r"(%s)" % iEscape(word), r"%s\1%s" % (colorYellow, colorWhite), name, count=1, flags=IGNORECASE)
21975:        else:
21976:         name = iSub(r"(%s)" % iEscape(word), r"%s\1%s" % (colorYellow, colorWhite), name, flags=IGNORECASE)
21977:        sat = FFec0y(VVPxk5, False)
21978:        STYPE  = VVPxk5.split(":")[2]
21979:        sTypeInt = int(STYPE, 16)
21980:        if sTypeInt in VVY1oT:
21981:         STYPE = VVvwHc[sTypeInt]
21982:        freq, pol, fec, sr, syst = tp.VVFGvS(VVPxk5)
21983:        if not "-S" in syst:
21984:         sat = syst
21985:        VVAkuK.append((name, STYPE, VVPxk5, sat, freq, pol, fec, sr, ""))
21986:   return VVAkuK
21987:  def VVUmsF(self, VV8RqF):
21988:   VV8RqF = VV8RqF.lower()
21989:   VVAkuK = []
21990:   colorYellow  = CCuTnL.VVsAua(VV1fx4)
21991:   colorWhite  = CCuTnL.VVsAua(VVwdUw)
21992:   for b in CCMvE7.VVnZ35():
21993:    VVY5Mx  = b[0]
21994:    VVHCXP  = b[1].toString()
21995:    VVKETx = eServiceReference(VVHCXP)
21996:    VVlGGv = FFZcDI(VVKETx)
21997:    for service in VVlGGv:
21998:     VVPxk5  = service[0]
21999:     if FFUPnc(VVPxk5):
22000:      servName = service[1]
22001:      if VV8RqF in servName.lower():
22002:       servName = iSub(r"(%s)" % iEscape(VV8RqF), r"%s\1%s" % (colorYellow, colorWhite), servName, flags=IGNORECASE)
22003:       VVAkuK.append((servName, "IPTV", VVPxk5, "-", "-", "-", "-", "-", VVY5Mx))
22004:   return VVAkuK
22005:  def VVGuCn(self):
22006:   mode = CCLSIv.VVK7hm(default=-1)
22007:   return self.VVL0yl if mode == -1 else mode
22008:  def VVZP6Z(self, VV6A99):
22009:   self.close()
22010:   VV6A99.cancel()
22011:  def VVKluW(self, VV6A99, title, txt, colList):
22012:   FFnfiC(VV6A99.session, colList[2], checkParentalControl=True)
22013:  def VV0bf5(self, VV6A99, title, txt, colList):
22014:   VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(VV6A99)
22015:   if VVPxk5:
22016:    VV6A99.VVn5CC(2, FFtCD7(VVPxk5, VVfaDB, VV1wIO), True)
22017:  def VVC8BZ(self, VV6A99, title, txt, colList):
22018:   servName = colList[0]
22019:   mSel = CCzSCo(self, VV6A99)
22020:   VV3wat, cbFncDict = CCYrUm.VVuGRo(self, VV6A99, servName, 2)
22021:   mSel.VV9VR2(VV3wat, cbFncDict)
22022:  def VV7N77(self, VV6A99, title, txt, colList):
22023:   Name, Type, Ref, Sat, Freq, Pol, FEC, SR, Bouq = colList
22024:   Name = FFzBfi(Name)
22025:   txt  = ""
22026:   txt += "Name\t: %s\n" % Name
22027:   txt += "Type\t: %s\n" % Type
22028:   if Bouq: txt += "Bouquet\t: %s" % Bouq
22029:   if Sat != "-": txt += "Tuner\t: %s" % " ".join((Sat, Freq, Pol, FEC, SR))
22030:   CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVFOKm, params=(Ref, Name, txt))
22031:  def VVmk6k(self):
22032:   FFRMYv(self, self.VV2mMQ, 'Hide "%s" ?' % self.servName, title="Hide Channel")
22033:  def VV2mMQ(self):
22034:   ret = FFz2bQ(self.VVPxk5, True)
22035:   if ret:
22036:    self.VVPKGW()
22037:    self.close()
22038:   else:
22039:    FF28n1(self, "Cannot change state" , 1000)
22040:  def VVPKGW(self):
22041:   if self.csel:
22042:    self.csel.servicelist.removeCurrent()
22043:   try: CCiCTh.VVCZJa(self.VVPxk5)
22044:   except: CCiCTh.VVScph()
22045:   if self.VVPxk5.count(":") > 8:
22046:    servRef = self.session.nav.getCurrentlyPlayingServiceReference()
22047:    if servRef and self.VVPxk5 in servRef.toString():
22048:     self.session.nav.stopService()
22049:     if self.csel:
22050:      serviceRef = self.csel.servicelist.getCurrent()
22051:      if serviceRef:
22052:       FFqb3C(self.session, serviceRef)
22053:  @staticmethod
22054:  def VV3xGy():
22055:   global VVjIJk
22056:   try:
22057:    VVjIJk      = ChannelContextMenu.__init__
22058:    ChannelContextMenu.__init__   = CC9hzi.VViu8s
22059:    ChannelContextMenu.VVmUFM = CC9hzi.VVmUFM
22060:   except:
22061:    pass
22062:  @staticmethod
22063:  def VViu8s(SELF, session, csel):
22064:   from Components.ChoiceList import ChoiceEntryComponent
22065:   VVjIJk(SELF, session, csel)
22066:   if CFG.showInChannelListMenu.getValue():
22067:    for ndx, title in enumerate(("Channels Browser", "Find", "Bouquet Editor", "Channels Tools")):
22068:     title = "%s - %s" % (VVh9hj, title)
22069:     SELF["menu"].list.insert(ndx, ChoiceEntryComponent(key=" ", text=(title , BF(SELF.VVmUFM, csel, ndx, title))))
22070:  @staticmethod
22071:  def VVmUFM(SELF, csel, mode, title):
22072:   try:
22073:    currSel  = csel.getCurrentSelection()
22074:    VVPxk5  = currSel.toString()
22075:    refName  = FFCjjv(VVPxk5)
22076:   except:
22077:    VVPxk5 = refName = ""
22078:   if   mode == 0: CCjThi.VVJNjY(SELF, SELF.close)
22079:   elif mode == 2: SELF.session.openWithCallback(SELF.close, CCLSIv)
22080:   else    : SELF.session.openWithCallback(SELF.close, CC9hzi, title=title, csel=csel, VVPxk5=VVPxk5, servName=refName, isFind=True if mode == 1 else False)
22081: class CCiCTh(Screen):
22082:  def __init__(self, session):
22083:   self.skin, self.VVfOli = FFiNEe(VVlrZA, 10, 10, 30, 0, 0, "
22084:   self.session = session
22085:   self.Title  = "Zap History"
22086:   FFZMxC(self)
22087:   self.onShown.append(self.VV7OzD)
22088:  def VV7OzD(self):
22089:   self.onShown.remove(self.VV7OzD)
22090:   self.VVgFJe()
22091:  def cancel(self, VV6A99):
22092:   VV6A99.cancel()
22093:   self.close()
22094:  def VVgFJe(self):
22095:   VVCy6c = InfoBar.instance
22096:   VVAkuK = []
22097:   if VVCy6c:
22098:    VVFp6v = VVCy6c.servicelist
22099:    if VVFp6v:
22100:     VVY1oT, VVvwHc = FF07Sg()
22101:     for serv in VVFp6v.history:
22102:      VVPxk5 = serv[-1].toString()
22103:      VV1wIO = FFCjjv(VVPxk5)
22104:      path = serv[-1].getPath()
22105:      isLocal = path and path.startswith("/")
22106:      isIptv = FFUPnc(VVPxk5)
22107:      isSRel = FFHgaY(VVPxk5)
22108:      sat = "-" if isIptv and not isSRel or isLocal else FFec0y(VVPxk5, True)
22109:      if isIptv : STYPE = "Stream Relay" if isSRel else "IPTV"
22110:      elif isLocal: STYPE = "Local Media"
22111:      else:
22112:       STYPE  = VVPxk5.split(":")[2]
22113:       sTypeInt = int(STYPE, 16)
22114:       if sTypeInt in VVY1oT:
22115:        STYPE = VVvwHc[sTypeInt]
22116:      VVAkuK.append((VV1wIO, sat, STYPE, VVPxk5))
22117:   if VVAkuK:
22118:    VVu8qI = self.cancel
22119:    VVu1YM  = ("Zap"   , self.VVqQxm   , [])
22120:    VVScQz = ("Clear History" , self.VVpAc2   , [])
22121:    VV2ytr = (""    , self.VVh7mT , [])
22122:    header   = ("Service Name", "Satellite" , "Type" , "Ref. Code" )
22123:    widths   = (41    , 41   , 18  , 0    )
22124:    VVLIqP  = (LEFT    , LEFT   , CENTER , LEFT   )
22125:    FFUQ0v(self, None, title=self.Title, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=28, VVu1YM=VVu1YM, VVu8qI=VVu8qI, VVScQz=VVScQz, VV2ytr=VV2ytr)
22126:   else:
22127:    FFipXT(self, "Empty", title=self.Title)
22128:    self.close()
22129:  def VVqQxm(self, VV6A99, title, txt, colList):
22130:   FFnfiC(VV6A99.session, colList[3], checkParentalControl=True)
22131:   self.cancel(VV6A99)
22132:  def VVpAc2(self, VV6A99, title, txt, colList):
22133:   FFRMYv(self, BF(self.VVPFI3, VV6A99), "Clear Zap History ?", title=self.Title)
22134:  def VVPFI3(self, VV6A99):
22135:   CCiCTh.VVScph()
22136:   self.cancel(VV6A99)
22137:  def VVh7mT(self, VV6A99, title, txt, colList):
22138:   VV1wIO = colList[0]
22139:   VVPxk5 = colList[3]
22140:   CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVvVii, params=(VVPxk5, VV1wIO, txt))
22141:  @staticmethod
22142:  def VVScph():
22143:   inst = InfoBar.instance
22144:   csel = inst and inst.servicelist
22145:   if csel:
22146:    csel.history  = []
22147:    csel.history_pos = 0
22148:  @staticmethod
22149:  def VVCZJa(VVPxk5):
22150:   if not VVPxk5: return
22151:   servRef = eServiceReference(VVPxk5)
22152:   VVCy6c = InfoBar.instance
22153:   if VVCy6c:
22154:    VVFp6v = VVCy6c.servicelist
22155:    if VVFp6v:
22156:     hList = VVFp6v.history
22157:     newList = []
22158:     for rec in hList:
22159:      for servRef in rec:
22160:       if VVPxk5 in servRef.toString():
22161:        break
22162:      else:
22163:       newList.append(rec)
22164:     if newList:
22165:      oldLen = len(hList)
22166:      newLen = len(newList)
22167:      diff = oldLen - newLen
22168:      if not diff == 0:
22169:       pos = VVFp6v.history_pos - diff
22170:       if pos > newLen -1 : pos = newLen - 1
22171:       if pos < 0   : pos = 0
22172:       VVFp6v.history  = newList
22173:       VVFp6v.history_pos = pos
22174: class CCLSIv(Screen):
22175:  def __init__(self, session, VVPxk5="", servName=""):
22176:   self.skin, self.VVfOli = FFiNEe(VVlrZA, 10, 10, 30, 0, 0, "
22177:   self.session = session
22178:   self.Title  = "Bouquet Editor"
22179:   self.pPath  = CCafIt.VVjkKT()
22180:   self.bTables = []
22181:   FFZMxC(self)
22182:   self.onShown.append(self.VV7OzD)
22183:  def VV7OzD(self):
22184:   self.onShown.remove(self.VV7OzD)
22185:   self.VVfqM2()
22186:  def VVTEDg(self, tbl, bName, bRef):
22187:   self.bTables.append(tbl)
22188:   tbl.bouqName = bName
22189:   tbl.bouqRef  = bRef
22190:   self.VVHUOx(tbl)
22191:  def VVfqM2(self):
22192:   rootStr = CCLSIv.VVfejw()
22193:   rows = self.VVp5FP(rootStr)
22194:   if rows :
22195:    self.VVYUTb(self, "Main Bouquets List", rootStr, rows)
22196:    VVPxk5, refName, rootRef, rootName, inBouquet, rootSrc = CCjThi.VVZhZh()
22197:    if not self.bTables[-1].VVPkdw({3:VVPxk5}):
22198:     self.bTables[-1].VVPkdw({3:rootRef})
22199:   else:
22200:    FFdw58(self, "No bouquets Found !", title=self.Title)
22201:    self.close()
22202:  def VVj39p(self):
22203:   self.bTables[-1].cancel()
22204:   if len(self.bTables) > 0: del self.bTables[-1]
22205:   if not len(self.bTables): self.close()
22206:  def VVp5FP(self, bRef=None):
22207:   blkLst = CCLSIv.VVr4pQ()
22208:   rows = []
22209:   for ndx, row in enumerate(FFZcDI(eServiceReference(bRef), mode=1), start=1):
22210:    ref, name, flags = row
22211:    fTxt, fColor = CCLSIv.VVB9xW(flags)
22212:    lck = "1" if CCLSIv.VVAxzM(ref, blkLst) > -1 else ""
22213:    rows.append((str(ndx), "", fColor + name, ref, fTxt, str(flags), lck))
22214:   return rows
22215:  def VVYUTb(self, selfObj, bName, bRef, rows):
22216:   totTbl = len(self.bTables)
22217:   title = {0:"Main Bouquets List", 1:"%s %s" % (FFjt5L("Fav: ", VVA4XU), bName), 2:"%s %s" % (FFjt5L("Sub: ", VVA4XU), bName)}.get(totTbl, bName)
22218:   bg  = {0:"#11002233", 1:"#0a112222"}.get(totTbl, "#0a131111")
22219:   VVu8qI = self.VVhPrS
22220:   VVlJfJ = self.VVeypG
22221:   VV2ytr = (""     , self.VV4svQ   , [])
22222:   VVu1YM  = ("Enter Bouquet"  , self.VVLGpY  , [])
22223:   VVwWmA = ("Delete"    , self.VVm2gX  , [])
22224:   VVwSzI = ("Bouquets Importer" , self.VVgLtE , [])
22225:   VVScQz = ("Options"   , self.VVLGUd  , [])
22226:   VV4QTJ = ("Move Here"   , self.VVUTuK  , [])
22227:   VVoGCy  = (1, self.VVVbFn, None)
22228:   widths  = (12   , 7   , 81 , 0  , 0   , 0   , 0   )
22229:   VVLIqP = (CENTER  , CENTER , LEFT , LEFT , LEFT  , CENTER , CENTER )
22230:   tbl = FFUQ0v(self, None, title=title, VVGape=rows, VVLIqP=VVLIqP, width=1500, height=1000, VV3cHe=widths, VVwdmN=28, VVp4wm=False, VV2ytr=VV2ytr, VVu1YM=VVu1YM, VVu8qI=VVu8qI, VVlJfJ=VVlJfJ, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVHPI7=True, VVMfsO=2, VVoGCy=VVoGCy, VVSLOq=CFG.lastFindServices
22231:      , VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#0a005566", VVLf28=0, VVX9AA="#11330000")
22232:   tbl.VVIOX6(BF(self.VVeypG, tbl))
22233:   self.VVTEDg(tbl, bName, bRef)
22234:  def VVvQmZ(self, VV6A99, mutableList, tot, jumpDict=None):
22235:   if tot:
22236:    if mutableList:
22237:     mutableList.flushChanges()
22238:    FFfpyJ()
22239:    rows = self.VVp5FP(VV6A99.bouqRef)
22240:    if rows:
22241:     VV6A99.VVW3QY()
22242:     VV6A99.VVMqQ9(rows, isSort=False, VVDpzd=BF(self.VVQHvw, jumpDict))
22243:    else:
22244:     self.VVj39p()
22245:     totTbl = len(self.bTables)
22246:     FF28n1(self.bTables[-1] if totTbl > 0 else self, "Empty List !", 1500)
22247:   else:
22248:    FFjADj(VV6A99, "No change !", 1500)
22249:  def VVQHvw(self, jumpDict, VV6A99, title, txt, colList):
22250:   if jumpDict:
22251:    VV6A99.VVPkdw(jumpDict)
22252:  def VVeypG(self, VV6A99):
22253:   VV6A99["keyRed"].hide()
22254:   VV6A99["keyBlue"].hide()
22255:   if VV6A99.VVXWPu:
22256:    if VV6A99.VVc5NH() > 0:
22257:     VV6A99["keyRed"].show()
22258:     VV6A99["keyBlue"].show()
22259:   else:
22260:    VV6A99["keyRed"].show()
22261:   self.VVHUOx(VV6A99)
22262:  def VVHUOx(self, VV6A99):
22263:   if len(self.bTables) == 1 and not VV6A99.VViNen():
22264:    VV6A99.VVsd6P()
22265:   else:
22266:    VV6A99.VVucBj()
22267:  def VV4svQ(self, VV6A99, title, txt, colList):
22268:   c1, c2, c3 = VV1fx4, VVGCYL, VVz22H
22269:   ttl = lambda x, y, color=c1: "%s:\n%s\n\n" % (FFjt5L(x, color), y) if y else ""
22270:   num, picon, name, ref, rem, flags, lck = colList
22271:   path = CCLSIv.VVijn5(ref, mode=1)
22272:   txt  = ttl("Name"    , name)
22273:   txt += ttl("Bouquet File"  , path if path.startswith("/") else "")
22274:   txt += ttl("Parent Bouquet"  , VV6A99.bouqName, c2)
22275:   txt += ttl("Parent Bouquet File", CCLSIv.VVijn5(VV6A99.bouqRef, mode=1), c2)
22276:   txt += ttl("Ref."    , ref, c3) if VVBvqf else ""
22277:   txt += ttl("Remarks"   , rem, c3) if VVBvqf else ""
22278:   path = CCafIt.VVXjFJ(self.pPath, ref, name)
22279:   CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVnSfp, params=(txt, path))
22280:  @FFOAKH(par=1)
22281:  def VVLGpY(self, VV6A99, title, txt, colList):
22282:   maxLev = 2
22283:   num, picon, name, ref, rem, flags, lck = colList
22284:   flags = CCLSIv.VVzO8e(ref)
22285:   if FFWpih(ref):
22286:    if len(self.bTables) <= maxLev:
22287:     rows = self.VVp5FP(ref)
22288:     if rows : self.VVYUTb(VV6A99, name, ref, rows)
22289:     else : FFjADj(VV6A99, "Empty list !", 1500)
22290:    else:
22291:     FFdw58(self, "Maximum Level of Recursive Bouquets (%d) !" % maxLev, title=self.Title)
22292:   elif flags & 64:
22293:    FFjADj(VV6A99, "Cannot play markers", 500)
22294:   else:
22295:    FFnfiC(self.session, ref)
22296:    FFSqRh(self, "Cancel to go back to table")
22297:  def VVhPrS(self, VV6A99):
22298:   self.VVj39p()
22299:  def VVLGUd(self, VV6A99, title, txt, colList):
22300:   VV3wat = []
22301:   iMulSel = VV6A99.VViNen()
22302:   sortItem = ("Sort", )
22303:   if iMulSel:
22304:    tot = VV6A99.VVc5NH()
22305:    if tot > 1: sortItem = ("Sort", "sort")
22306:    isSel = tot > 0
22307:    bTxt = "Bouquet%s" % FFcacr(tot)
22308:   else:
22309:    isSel = True
22310:    bTxt = "Bouquet"
22311:   inMain = len(self.bTables) == 1
22312:   okToMain = False
22313:   if not inMain:
22314:    for ref in self.VVqtFh(VV6A99):
22315:     if not FFWpih(ref) and not ref.startswith("1:64:"): break
22316:    else:
22317:     okToMain = True
22318:   totDel = len(self.VV8yZz())
22319:   c1, c2, c3, c4 = VVGCYL, VVJEMb, VVFuwR, VVz22H
22320:   VV3wat.append(FFsLU5("Rename"   , "renm" , not iMulSel, c1))
22321:   VV3wat.append(VVAL3j)
22322:   VV3wat.append(FFsLU5("Add Marker"  , "mrkr" , not iMulSel, c2))
22323:   VV3wat.append(FFsLU5("Add Empty Bouquet", "addBouq" , not iMulSel and inMain, c2))
22324:   if totDel:
22325:    VV3wat.append(VVAL3j)
22326:    VV3wat.append((c4 + 'Delete %d Unused ".del" Bouquets File%s' % (totDel, FFcacr(totDel)), "unused"))
22327:   if inMain:
22328:    VVwltY, VVkxBG = "#22001122", "#22000a15"
22329:    VV3wat.append(VVAL3j)
22330:    VV3wat.append(FFsLU5("Hide %s" % bTxt , "hidOn" , isSel, c3))
22331:    VV3wat.append(FFsLU5("Unhide %s" % bTxt , "hidOff" , isSel, c3))
22332:    VV3wat.append(VVAL3j)
22333:    VV3wat.append(FFsLU5("Protect %s" % bTxt , "lckOn" , isSel, c3))
22334:    VV3wat.append(FFsLU5("Unprotect %s" % bTxt , "lckOff" , isSel, c3))
22335:    VV3wat.append(VVAL3j)
22336:    VV3wat.append(FFsLU5("Save Selected %s to M3U File" % bTxt , "toM3u", isSel, c2))
22337:    VV3wat.append((c1 + "Fix Local Media Path (ALL Bouquets)"   , "fixMed"))
22338:    VV3wat.append((c1 + "Set Local Media PIcons (ALL Bouquets)"  , "fixPic"))
22339:   else:
22340:    VVwltY, VVkxBG = "#2200120a", "#2200120a"
22341:   VV3wat.append(VVAL3j)
22342:   VV3wat.append(sortItem)
22343:   VV3wat.append(FFsLU5("Copy to Main Bouquets List" , "toMain", okToMain))
22344:   VV3wat.append(FFsLU5("Copy to a Bouquet"   , "toBouq", isSel))
22345:   cbFncDict = { "renm" : BF(self.VVHRA8  , VV6A99)
22346:      , "fixMed" : BF(self.VVXlR3, VV6A99)
22347:      , "fixPic" : BF(self.VV33rr, VV6A99)
22348:      , "toM3u" : BF(self.VVDCMj , VV6A99)
22349:      , "mrkr" : BF(self.VVieMk , VV6A99)
22350:      , "addBouq" : BF(self.VVItvG, VV6A99)
22351:      , "unused" : BF(self.VVwhHo , VV6A99)
22352:      , "hidOn" : BF(self.VVy2T1  , VV6A99, True)
22353:      , "hidOff" : BF(self.VVy2T1  , VV6A99, False)
22354:      , "lckOn" : BF(self.VVIhnB  , VV6A99, True)
22355:      , "lckOff" : BF(self.VVIhnB  , VV6A99, False)
22356:      , "sort" : BF(self.VVjtwy  , VV6A99)
22357:      , "toMain" : BF(self.VVwYG1 , VV6A99)
22358:      , "toBouq" : BF(self.VVjC5X , VV6A99) }
22359:   mSel = CCzSCo(self, VV6A99)
22360:   mSel.VV9VR2(VV3wat, cbFncDict, height=1000, VVwltY=VVwltY, VVkxBG=VVkxBG, VVptue=0.08)
22361:  def VVm2gX(self, VV6A99, title, txt, colList):
22362:   txt, totSel = "", 0
22363:   if VV6A99.VViNen():
22364:    totSel = VV6A99.VVc5NH()
22365:    if totSel:
22366:     txt = "Delete %s item%s" % (FFjt5L(totSel, VV1fx4), FFcacr(totSel))
22367:   else:
22368:    num, picon, name, ref, rem, flags, lck = colList
22369:    txt = "Delete : %s" % FFjt5L(name, VV1fx4)
22370:   if txt:
22371:    FFRMYv(self, BF(self.VV5FTI, VV6A99), "%s\n\nContinue ?" % txt, title=self.Title)
22372:  def VVgLtE(self, VV6A99, title, txt, colList):
22373:   CC9xd9.VVtXW3(self, cbFnc=BF(self.VVssKp, VV6A99))
22374:  def VVssKp(self, VV6A99):
22375:   self.VVvQmZ(VV6A99, None, 1)
22376:  @FFOAKH(par=1)
22377:  def VV5FTI(self, VV6A99):
22378:   lst, mutableList, csel, bServ = self.VV20TR(VV6A99)
22379:   if mutableList is not None:
22380:    tot = 0
22381:    for ref in lst:
22382:     serv = eServiceReference(ref)
22383:     if serv.valid() and not mutableList.removeService(serv):
22384:      tot += 1
22385:      bFile = CCMvE7.VV896q(ref)
22386:      if bFile:
22387:       bFile = VVQe79 + bFile
22388:       FFpwZS("rm -f '%s' '%s.del'" % (bFile, bFile))
22389:    self.VVvQmZ(VV6A99, mutableList, tot)
22390:  @FFOAKH(par=1)
22391:  def VVUTuK(self, VV6A99, title, txt, colList):
22392:   lst, mutableList, csel, bServ = self.VV20TR(VV6A99)
22393:   if mutableList is not None:
22394:    curNdx = VV6A99.VVGTqU()
22395:    if curNdx <= VV6A99.VV6LTe(): lst = reversed(lst)
22396:    else             : curNdx -= 1
22397:    tot = 0
22398:    for ref in lst:
22399:     serv = eServiceReference(ref)
22400:     if serv.valid() and not mutableList.moveService(serv, curNdx):
22401:      tot += 1
22402:    self.VVvQmZ(VV6A99, mutableList, tot)
22403:  @FFOAKH(par=1)
22404:  def VVjtwy(self, VV6A99):
22405:   lst, mutableList, csel, bServ = self.VV20TR(VV6A99)
22406:   if mutableList is not None:
22407:    nmlst = VV6A99.VVf3uT(2)
22408:    lst = list(zip(nmlst, lst))
22409:    lst.sort(key=lambda x: x[0].lower())
22410:    curNdx = VV6A99.VV6LTe()
22411:    tot = 0
22412:    for name, ref in reversed(lst):
22413:     serv = eServiceReference(ref)
22414:     if serv.valid() and not mutableList.moveService(serv, curNdx):
22415:      tot += 1
22416:    self.VVvQmZ(VV6A99, mutableList, tot)
22417:  def VVHRA8(self, VV6A99, item=None):
22418:   name = VV6A99.VV5crm()[2]
22419:   FF4z45(self, BF(self.VV75RP, VV6A99), defaultText=name, title="Rename", message="Enter new name")
22420:  def VV75RP(self, VV6A99, name):
22421:   lst, mutableList, csel, bServ = self.VV20TR(VV6A99)
22422:   if name and csel and mutableList:
22423:    name = name.strip()
22424:    if name:
22425:     ref = VV6A99.VV5crm()[3]
22426:     if FFWpih(ref):
22427:      CCMvE7.VV3r6m(ref, name)
22428:     else:
22429:      serv = eServiceReference(ref)
22430:      if serv.valid():
22431:       serv.setName(name)
22432:       mutableList.removeService(serv)
22433:       mutableList.addService(serv)
22434:       mutableList.moveService(serv, VV6A99.VVGTqU())
22435:     self.VVvQmZ(VV6A99, mutableList, 1)
22436:  def VVXlR3(self, VV6A99):
22437:   title = "Fix Media Path (for All Bouquets)"
22438:   newP = FFoWxR(CFG.MovieDownloadPath.getValue())
22439:   txt = FFjt5L("/media/.../movie/", VV1fx4)
22440:   FFRMYv(self, BF(FFimQ3, VV6A99, BF(self.VVDy4R, title, newP)), "Change Media path (%s) to:\n\n%s" % (txt, newP), title=title)
22441:  def VVDy4R(self, title, newP):
22442:   totF = totRepl = 0
22443:   for path in CCMvE7.VVHtVA():
22444:    txt = FFYVq0(path)
22445:    exp = iCompile(r"(\/media\/.+\/movie\/)", IGNORECASE)
22446:    lst = set()
22447:    for Str in exp.findall(txt):
22448:     if Str != newP:
22449:      lst.add(Str)
22450:    save = False
22451:    for Str in lst:
22452:     txt, tot = exp.subn(newP, txt)
22453:     totRepl += tot
22454:     save = True
22455:    if save:
22456:     totF += 1
22457:     with open(path, "w") as f:
22458:      f.write(txt)
22459:   if totF or totRepl:
22460:    txt  = "Total Files\t: %s\n"  % totF
22461:    txt += "Total Fixes\t: %s\n"  % totRepl
22462:    FF4lCP(self, txt, title=title)
22463:    FFfpyJ()
22464:   else:
22465:    FFipXT(self, "All OK (no changes).", title=title)
22466:  def VV33rr(self, VV6A99):
22467:   title = "Fix Movies PIcons"
22468:   if FFayeZ("ffmpeg"):
22469:    FFRMYv(self, BF(self.VVVbNG, VV6A99, title), "Set PIcons to local media services (from posters) ?", title=title)
22470:   else:
22471:    FFRMYv(self, BF(CCkEI5.VVGS56, self), '"FFmpeg" is required for this process.\n\nInstall FFmpeg ?', title=title)
22472:  @FFOAKH(par=1)
22473:  def VVVbNG(self, VV6A99, title):
22474:   lst = []
22475:   for bPath in CCMvE7.VVHtVA():
22476:    txt = FFYVq0(bPath)
22477:    exp = iCompile(r"
22478:    piconPath = CCafIt.VVjkKT()
22479:    for ref, path, VV1wIO in exp.findall(txt):
22480:     for ext in ("jpg", "png"):
22481:      poster = "%s.%s" % (os.path.splitext(path)[0], ext)
22482:      picon = piconPath + ref.strip(":").replace(":", "_").upper() + ".png"
22483:      if FFCyVu(poster) and not FFCyVu(picon):
22484:       lst.append((poster, picon))
22485:   if len(lst) :
22486:    CCh3tv.VV7Nf4(self
22487:        , VVixvy  = BF(self.VVcuCj, title, lst)
22488:        , VVbYwR = BF(self.VVcbYf, title, len(lst)))
22489:   else:
22490:    FFipXT(self, "Nothing to fix", title=title)
22491:  def VVcuCj(self, title, lst, VVXyP6):
22492:   VVXyP6.VVq8NF(len(lst))
22493:   VVXyP6.VVNc18 = 0
22494:   for poster, picon in lst:
22495:    if not VVXyP6 or VVXyP6.isCancelled: return
22496:    VVXyP6.VVxtQs(1)
22497:    if FFpwZS("cp -f '%s' '%s'" % (poster, picon)):
22498:     if FFpwZS(CCvjVs.VVQ9GP(picon)):
22499:      if not VVXyP6 or VVXyP6.isCancelled: return
22500:      VVXyP6.VVNc18 += 1
22501:     else:
22502:      FFwgGB(picon)
22503:  def VVcbYf(self, title, tot, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
22504:   FFipXT(self, "Added PIcons = %s" % VVNc18, title=title)
22505:  @FFOAKH(par=1)
22506:  def VVDCMj(self, VV6A99):
22507:   if VV6A99.VVXWPu : rows = VV6A99.VVbF9W()
22508:   else        : rows = [VV6A99.VV5crm()]
22509:   bName = rows[0][2]
22510:   outF = "%s%s_%s.m3u" % (FF7BT0(), FFOu5Y(bName), FFjTQe())
22511:   totCh = toB = 0
22512:   with open(outF, "w") as f:
22513:    f.write("#EXTM3U\n")
22514:    for num, picon, name, ref, rem, flags, lck in rows:
22515:     if ref and name and rem == "Directory":
22516:      for chR, chNm, chFlags in FFZcDI(eServiceReference(ref), mode=1):
22517:       if chR and chNm:
22518:        chR = chR.replace(":" + chNm, "").strip()
22519:        span = iSearch(r'^((?:[A-Fa-f0-9]+:){10})(.*)', chR, IGNORECASE)
22520:        if span:
22521:         totCh += 1
22522:         ref, url = span.groups()
22523:         url = FFXarh(url)
22524:         url = url or ref
22525:         if FFHgaY(url):
22526:          url = ref + url
22527:         f.write('#EXTINF:-1 group-title="%s",%s\n' % (name, chNm))
22528:         f.write("%s\n" % url)
22529:   title = "Save to M3U File"
22530:   if totCh:
22531:    totB = len(rows)
22532:    FFipXT(self, "Exported %s Channel%s (from %s Bouquet%s) to:\n\n%s" % (totCh, FFcacr(totCh), totB, FFcacr(totB), outF), title=title)
22533:   else:
22534:    FFdw58(self, "Nothing to save.", title=title)
22535:    FFwgGB(outF)
22536:  @FFOAKH(par=1)
22537:  def VVieMk(self, VV6A99):
22538:   name = "%s Marker %s" % ("=" * 7, "=" * 7)
22539:   lst, mutableList, csel, bServ = self.VV20TR(VV6A99)
22540:   if mutableList is not None:
22541:    curServ = eServiceReference(VV6A99.VV5crm()[3])
22542:    cnt = tot = 0
22543:    while mutableList:
22544:     serv = eServiceReference("1:64:%d:0:0:0:0:0:0:0::%s" % (cnt, name))
22545:     if curServ and curServ.valid():
22546:      if not mutableList.addService(serv, curServ):
22547:       csel.servicelist.addService(serv, True)
22548:       tot += 1
22549:       break
22550:     elif not mutableList.addService(serv):
22551:      csel.servicelist.addService(serv, True)
22552:      tot += 1
22553:      break
22554:     cnt += 1
22555:    self.VVvQmZ(VV6A99, mutableList, tot)
22556:  def VVItvG(self, VV6A99):
22557:   names = VV6A99.VVrc5p(2)
22558:   name = "Bouquet-1"
22559:   num = 0
22560:   while name in names:
22561:    num += 1
22562:    name = "Bouquet-%s" % num
22563:   FF4z45(self, BF(self.VVnrOk, VV6A99), defaultText=name, title="New Bouquet", message="Enter Bouquet name")
22564:  def VVnrOk(self, VV6A99, name=None):
22565:   if name and name.strip():
22566:    self.VVDERP(VV6A99, name.strip())
22567:  @FFOAKH(par=1)
22568:  def VVDERP(self, VV6A99, bName):
22569:   CCMvE7.VVCROO(bName)
22570:   self.VVvQmZ(VV6A99, None, 1, jumpDict={2:bName})
22571:  def VV8yZz(self):
22572:   lst = []
22573:   for fil in os.listdir(VVQe79):
22574:    if fil.endswith(".tv.del") or fil.endswith(".radio.del"):
22575:     lst.append(fil)
22576:   return lst
22577:  def VVwhHo(self, VV6A99):
22578:   lst = self.VV8yZz()
22579:   for fil in lst:
22580:    FFwgGB(VVQe79 + fil)
22581:   VV6A99.VV6fGE("Done")
22582:  def VVqtFh(self, VV6A99):
22583:   if VV6A99.VVXWPu : return VV6A99.VVf3uT(3)
22584:   else        : return [VV6A99.VV5crm()[3]]
22585:  def VVwYG1(self, VV6A99):
22586:   dstFile = "bouquets.%s" % ("tv" if CCLSIv.VVK7hm() == 0 else "radio")
22587:   self.VV5QCD(VV6A99, "Main Bouquets List", dstFile, True)
22588:  def VVjC5X(self, VV6A99):
22589:   bRows = CCMvE7.VVBTuE()
22590:   lst = self.VVqtFh(VV6A99)
22591:   VV3wat = []
22592:   for name, ref in bRows:
22593:    if not ref in lst:
22594:     VV3wat.append((name, ref))
22595:   if VV3wat : FFLFTC(self,  BF(self.VVJQSX, VV6A99), VV3wat=VV3wat, width=1100, height=900, VVwltY="#22220000", VVkxBG="#22110000", title="Destination Bouquet", VVU8mZ=True)
22596:   else  : FF28n1(VV6A99, "No bouquets left !", 1000)
22597:  def VVJQSX(self, VV6A99, item=None):
22598:   if item:
22599:    bName, bRef, ndx = item
22600:    dstFile = CCMvE7.VV896q(bRef)
22601:    self.VV5QCD(VV6A99, bName, dstFile)
22602:  @FFOAKH(par=1)
22603:  def VV5QCD(self, VV6A99, bName, dstFile, mainToo=False):
22604:   lst = self.VVqtFh(VV6A99)
22605:   tot = 0
22606:   for ref in lst:
22607:    ok = CCMvE7.VVsEnx(ref, dstFile)
22608:    if ok:
22609:     tot += 1
22610:   self.VVvQmZ(VV6A99, None, tot)
22611:   if mainToo:
22612:    rootStr = CCLSIv.VVfejw()
22613:    rows = self.VVp5FP(rootStr)
22614:    self.bTables[0].VVMqQ9(rows)
22615:   ttl = lambda x, y: "%s:\n%s\n\n" % (FFjt5L(x, VVFuwR), y)
22616:   txt  = ttl("Source Bouquet"  , VV6A99.bouqName)
22617:   txt += ttl("Destination Bouquet", bName)
22618:   txt += ttl("Copied Services" , tot)
22619:   FF4lCP(VV6A99, txt, title="Copy Services")
22620:  @FFOAKH(par=1)
22621:  def VVy2T1(self, VV6A99, isHide):
22622:   lst, mutableList, csel, bServ = self.VV20TR(VV6A99)
22623:   mode = CCLSIv.VVK7hm()
22624:   path = VVQe79 + "bouquets.%s" % ("tv" if mode==0 else "radio")
22625:   if FFCyVu(path):
22626:    tot = 0
22627:    lines = list(map(str.strip, FFL19l(path)))
22628:    for ref in lst:
22629:     if FFWpih(ref):
22630:      ref = "#SERVICE " + ref
22631:      nrm = ref.replace("1:519:", "1:7:")
22632:      hid = ref.replace("1:7:"  , "1:519:")
22633:      if isHide: r1, r2 = nrm, hid
22634:      else  : r1, r2 = hid, nrm
22635:      if r1 in lines:
22636:       ndx = lines.index(r1)
22637:       lines[ndx] = r2
22638:       tot += 1
22639:    if tot:
22640:     with open(path, "w") as f:
22641:      for line in lines:
22642:       f.write("%s\n" % line)
22643:     self.VVvQmZ(VV6A99, None, tot)
22644:  @FFOAKH(par=1)
22645:  def VVIhnB(self, VV6A99, isLck):
22646:   lst, mutableList, csel, bServ = self.VV20TR(VV6A99)
22647:   blkLst = CCLSIv.VVr4pQ()
22648:   tot = 0
22649:   for ref in lst:
22650:    if FFWpih(ref):
22651:     ndx = CCLSIv.VVAxzM(ref, blkLst)
22652:     if isLck:
22653:      if ndx == -1:
22654:       ref = ref.replace("1:519:", "1:0:").replace("1:7:", "1:0:")
22655:       blkLst.append(ref)
22656:       tot += 1
22657:     else:
22658:      if ndx > -1:
22659:       blkLst[ndx] = ""
22660:       tot += 1
22661:   if tot:
22662:    with open(VV3W4d, "w") as f:
22663:     for line in blkLst:
22664:      if line.strip():
22665:       f.write("%s\n" % line)
22666:    from Components.ParentalControl import parentalControl
22667:    parentalControl.open()
22668:    self.VVvQmZ(VV6A99, None, tot)
22669:  def VV20TR(self, VV6A99, bServ=None):
22670:   lst = self.VVqtFh(VV6A99)
22671:   mutableList = csel = None
22672:   VVCy6c = InfoBar.instance
22673:   if VVCy6c:
22674:    csel = VVCy6c.servicelist
22675:    if csel:
22676:     if not bServ:
22677:      bServ = eServiceReference(VV6A99.bouqRef)
22678:     if bServ.valid():
22679:      mutableList = csel.getMutableList(bServ)
22680:   return lst, mutableList, csel, bServ
22681:  def VVVbFn(self, colList):
22682:   num, picon, name, ref, rem, flags, lck = colList
22683:   png = lambda x: "%s%s.png" % (VVIp2p, x)
22684:   if   rem == "Marker"   : return png("mrk1")
22685:   elif rem == "Numbered Marker" : return png("mrk2")
22686:   elif rem == "Group"    : return png("grp")
22687:   elif FFWpih(ref):
22688:    if   lck == "1" and rem == "Invisible" : return png("dirLckInvis")
22689:    elif lck == "1"       : return png("dirLck")
22690:    elif rem == "Invisible"     : return png("dirInvis")
22691:    else         : return png("dir1")
22692:   else:
22693:    return CCafIt.VVXjFJ(self.pPath, ref, name)
22694:  @staticmethod
22695:  def VVB9xW(flag):
22696:   t = c = ""
22697:   try:
22698:    if   flag & eServiceReference.isInvisible  : t, c = "Invisible"  , "#f#00ff7722#"
22699:    elif flag & eServiceReference.isNumberedMarker : t, c = "Numbered Marker" , "#f#00ffffaa#"
22700:    elif flag & eServiceReference.isGroup   : t, c = "Group"   , "#f#00bbffbb#"
22701:    elif flag & eServiceReference.isMarker   : t, c = "Marker"   , "#f#00ffffaa#"
22702:    elif flag & eServiceReference.isDirectory  : t, c = "Directory"  , ""
22703:   except:
22704:    pass
22705:   return t, c
22706:  @staticmethod
22707:  def VVijn5(ref, mode=0):
22708:   path = ""
22709:   serv = eServiceReference(ref)
22710:   if serv.valid():
22711:    path = serv.getPath()
22712:    if path and not VVBvqf:
22713:     path = iSub(r"[&?]mode=.+end=", r"", path, flags=IGNORECASE)
22714:    if mode == 1:
22715:     span = iSearch(r'FROM\s+BOUQUET\s+"(.+)"\s+ORDER\s+BY\s+bouquet', path, IGNORECASE)
22716:     if span:
22717:      path = VVQe79 + span.group(1)
22718:   return path
22719:  @staticmethod
22720:  def VVzO8e(ref):
22721:   path = ""
22722:   serv = eServiceReference(ref)
22723:   if serv.valid():
22724:    return serv.flags
22725:   return -1
22726:  @staticmethod
22727:  def VVK7hm(default=0):
22728:   VVCy6c = InfoBar.instance
22729:   if VVCy6c:
22730:    csel = VVCy6c.servicelist
22731:    if csel:
22732:     return csel.mode
22733:   return default
22734:  @staticmethod
22735:  def VVfejw():
22736:   VVCy6c = InfoBar.instance
22737:   if VVCy6c:
22738:    csel = VVCy6c.servicelist
22739:    if csel:
22740:     return csel.bouquet_rootstr
22741:   return ""
22742:  @staticmethod
22743:  def VVr4pQ():
22744:   return FFL19l(VV3W4d) if FFCyVu(VV3W4d) else []
22745:  @staticmethod
22746:  def VVAxzM(ref, lst=None):
22747:   if not lst:
22748:    lst = CCLSIv.VVr4pQ()
22749:   if FFWpih(ref):
22750:    ref1 = ref.replace("1:7:", "1:0:")
22751:    ref2 = ref.replace("1:519:", "1:0:")
22752:    if   ref1 in lst: return lst.index(ref1)
22753:    elif ref2 in lst: return lst.index(ref2)
22754:   return -1
22755: class CCafIt(Screen, CCsyCY, CCa36K):
22756:  VVwy9X   = 0
22757:  VVMHWR  = 1
22758:  VVQzY6  = 2
22759:  VVxUTE  = 3
22760:  VVmvJo  = 4
22761:  VVR4LO  = 5
22762:  VV6Rs1  = 6
22763:  VV2tBs = 7
22764:  VVKBzs = 8
22765:  VV8XEV = 9
22766:  VVEXya = 10
22767:  VVfxSo  = 11
22768:  def __init__(self, session):
22769:   self.skin, self.VVfOli = FFiNEe(VVujxw, 1800, 950, 30, 0, 0, "
22770:   self.session   = session
22771:   self.Title    = "PIcons Tools"
22772:   self.pPath    = CCafIt.VVjkKT()
22773:   self.curChanName  = ""
22774:   self.curChanFile  = ""
22775:   self.curChanIndex  = -1
22776:   self.curChanRefCode  = 0
22777:   self.curChanIptvRef  = ""
22778:   self.VVGape    = []
22779:   self.nsList    = set()
22780:   self.lastSortCol  = 0
22781:   self.lastMode   = 0
22782:   self.lastWords   = ['']
22783:   self.lastAsPrefix  = False
22784:   self.lastTimeStamp  = 0
22785:   self.lastSTypeList  = []
22786:   self.lastFind   = ""
22787:   self.filterTitle  = ""
22788:   self.firstTime   = True
22789:   self.rTypeLst   = set()
22790:   FFZMxC(self, self.Title)
22791:   FFRLNq(self["keyRed"] , "OK = Zap")
22792:   FFRLNq(self["keyYellow"], "Page Options")
22793:   FFRLNq(self["keyBlue"] , "Filter")
22794:   CCsyCY.__init__(self, CFG.transpColorPicons)
22795:   CCa36K.__init__(self)
22796:   FFBep1(self,
22797:   {
22798:    "ok"  : self.VVFWp4     ,
22799:    "green"  : self.VVRX2k    ,
22800:    "yellow" : self.VVb3d0     ,
22801:    "blue"  : self.VVfmub     ,
22802:    "menu"  : self.VVEzGg     ,
22803:    "info"  : self.VVz0Rw    ,
22804:    "cancel" : self.close
22805:   })
22806:   self.onShown.append(self.VV7OzD)
22807:  def VV7OzD(self):
22808:   if self.firstTime:
22809:    self.firstTime = False
22810:    FF6W0I(self)
22811:    FFWgBS(self)
22812:    FFZ0AC(self["keyRed"], "#0a333333")
22813:    self.VVCHVq()
22814:    self.VVJf8n("Loading ...", mode=self.lastMode, words=self.lastWords, asPrefix=self.lastAsPrefix, VVpQCY=True)
22815:   else:
22816:    self.VV4l5c()
22817:    self.VVHvUS()
22818:  def VVEzGg(self):
22819:   if not self.VV6wbi:
22820:    c1, c2 = VVSGsk, VVJEMb
22821:    VV3wat = []
22822:    VV3wat.append(("Statistics"          , "VVoNnq"    ))
22823:    VV3wat.append(VVAL3j)
22824:    VV3wat.append((c1 + "Suggest PIcons for Current Channel"   , "VVitxh"   ))
22825:    VV3wat.append((c2 + "Set to Current Channel (copy file)"   , "VVWg3p_file"  ))
22826:    VV3wat.append((c2 + "Set to Current Channel (as SymLink)"   , "VVWg3p_link"  ))
22827:    VV3wat.append(VVAL3j)
22828:    VV3wat.append(("Export Current File Names List"     , "VVDZB5" ))
22829:    VV3wat.append(CCafIt.VVdmZZ())
22830:    VV3wat.append(VVAL3j)
22831:    c, cond = VVyFI2, self.filterTitle == "PIcons without Channels"
22832:    VV3wat.append(FFsLU5("Move Unused PIcons to a Directory", "VVkeuU" , cond, c ))
22833:    VV3wat.append(FFsLU5("DELETE Unused PIcons"    , "VVGnGr" , cond, c ))
22834:    VV3wat.append(VVAL3j)
22835:    VV3wat.append(("Delete Broken PIcons SymLinks (in PIcons Directory)" , "VVtFSa"  ))
22836:    VV3wat.append(VVAL3j)
22837:    VV3wat += CCafIt.VVC3jQ()
22838:    VV3wat.append(VVAL3j)
22839:    VV3wat.append(("Change Poster/Picon Transparency Color"    , "VVA2WD" ))
22840:    VV3wat.append(("Keys Help"           , "VVOz5Q"    ))
22841:    FFLFTC(self, self.VVeDfm, width=1100, height=1050, title=self.Title, VV3wat=VV3wat, VVwltY="#22001020", VVkxBG="#22001020")
22842:  def VVeDfm(self, item=None):
22843:   if item is not None:
22844:    if   item == "VVoNnq"    : self.VVoNnq()
22845:    elif item == "VVitxh"   : self.VVitxh()
22846:    elif item == "VVWg3p_file"  : self.VVWg3p(0)
22847:    elif item == "VVWg3p_link"  : self.VVWg3p(1)
22848:    elif item == "VVDZB5"  : self.VVDZB5()
22849:    elif item == "VVZxA1"  : CCafIt.VVZxA1(self)
22850:    elif item == "VVkeuU"   : self.VVkeuU()
22851:    elif item == "VVGnGr"  : self.VVGnGr()
22852:    elif item == "VVtFSa"  : self.VVtFSa()
22853:    elif item == "VVS8ig"  : CCafIt.VVS8ig(self)
22854:    elif item == "findPiconBrokenSymLinks" : CCafIt.VVqb9O(self, True)
22855:    elif item == "FindAllBrokenSymLinks" : CCafIt.VVqb9O(self, False)
22856:    elif item == "VVA2WD" : self.VVA2WD()
22857:    elif item == "VVOz5Q"     : FFw2rR(self, "_help_picons", "PIcons Tools (Keys Help)")
22858:  def VVb3d0(self):
22859:   if not self.VV6wbi:
22860:    VV3wat = []
22861:    VV3wat.append(("Go to First PIcon"  , "VVPhaY"  ))
22862:    VV3wat.append(("Go to Last PIcon"   , "VVGc2k"  ))
22863:    VV3wat.append(VVAL3j)
22864:    VV3wat.append(("Sort by Channel Name"     , "sortByChan" ))
22865:    VV3wat.append(("Sort by File Name"  , "sortByFile" ))
22866:    VV3wat.append(VVAL3j)
22867:    VV3wat.append(("Find from File List .." , "VVPBn1" ))
22868:    FFLFTC(self, self.VVf9YF, title=self.Title, VV3wat=VV3wat)
22869:  def VVf9YF(self, item=None):
22870:   if item is not None:
22871:    if   item == "VVPhaY"   : self.VVPhaY()
22872:    elif item == "VVGc2k"   : self.VVGc2k()
22873:    elif item == "sortByChan"  : self.VVc6bm(2)
22874:    elif item == "sortByFile"  : self.VVc6bm(0)
22875:    elif item == "VVPBn1"  : self.VVPBn1()
22876:  def VVPBn1(self):
22877:   VV3wat = []
22878:   for item in self.VVGape:
22879:    VV3wat.append((item[0], item[0]))
22880:   FFLFTC(self, self.VVf9l1, title='PIcons ".png" Files', VV3wat=VV3wat, VVU8mZ=True)
22881:  def VVf9l1(self, item=None):
22882:   if item:
22883:    txt, ref, ndx = item
22884:    self.VVdLxd(ndx)
22885:  def VVFWp4(self):
22886:   if not self.VV6wbi and self["keyRed"].getVisible():
22887:    filName, VVPxk5, VV1wIO, sat, inDB = self.VVaWmO()
22888:    if VVPxk5:
22889:     CCqWM2.VVHc02(self.session, VVaHNe=VVPxk5)
22890:  def VVRX2k(self):
22891:   if self["keyGreen"].getVisible():
22892:    self.VVdLxd(self.curChanIndex)
22893:  def VVc6bm(self, col):
22894:   reverseSort = self.lastSortCol == col
22895:   self.lastSortCol = col
22896:   self.VVJf8n("Sorting ...", mode=self.lastMode, words=self.lastWords, asPrefix=self.lastAsPrefix, reverseSort=reverseSort)
22897:  def VVWg3p(self, mode):
22898:   title = "Change Current Channel PIcon"
22899:   VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(self)
22900:   curChF = "%s%s.png" % (self.pPath, VVPxk5.replace(":", "_"))
22901:   if VVPxk5:
22902:    filName, VVPxk5, VV1wIO, sat, inDB = self.VVaWmO()
22903:    selPiconF = "%s%s"  % (self.pPath, filName)
22904:    if not curChF == selPiconF:
22905:     if FFCyVu(curChF):
22906:      VV3wat = []
22907:      VV3wat.append(("Overwrite current PIcon"    ,  "overwrite" ))
22908:      VV3wat.append(('Rename current PIcon to ".bak.png"' ,  "backup" ))
22909:      FFLFTC(self, BF(self.VVvHw6, mode, curChF, selPiconF), VV3wat=VV3wat, title="Current Channel PIcon (already exists)")
22910:     else:
22911:      self.VVvHw6(mode, curChF, selPiconF, "overwrite")
22912:    else:
22913:     FFdw58(self, "Cannot change PIcon to itself !", title=title)
22914:   else:
22915:    FFdw58(self, "Could not read current channel info. !", title=title)
22916:  def VVvHw6(self, mode, curChF, selPiconF, item=None):
22917:   if item is not None:
22918:    cmd  = ""
22919:    if item == "backup" : cmd += "mv -f '%s' '%s';" % (curChF, curChF + ".bak.png")
22920:    else    : cmd += "rm -f '%s';" % curChF
22921:    if mode == 0: cmd += "cp -f '%s' '%s'" % (selPiconF, curChF)
22922:    else  : cmd += "ln -sf '%s' '%s'" % (selPiconF, curChF)
22923:    FFpwZS(cmd)
22924:    self.VVJf8n("PIcon Changed.\nRefreshing ...", goToFirst=False)
22925:  def VVkeuU(self):
22926:   defDir = FFoWxR(CCafIt.VVjkKT() + "picons_backup")
22927:   FFpwZS("mkdir '%s'" % defDir)
22928:   self.session.openWithCallback(BF(self.VV7yXU, defDir), BF(CClYaF
22929:          , mode=CClYaF.VV9N82, VV1pbK=CCafIt.VVjkKT()))
22930:  def VV7yXU(self, defDir, path):
22931:   if len(path) > 0:
22932:    title = "Move Unused PIcons"
22933:    if path == CCafIt.VVjkKT():
22934:     FFdw58(self, "Cannot move to same directory !", title=title)
22935:    else:
22936:     if not FFoWxR(path) == FFoWxR(defDir):
22937:      self.VVLp78(defDir)
22938:     FFRMYv(self, BF(self.VVJ3ic, title, defDir, path), "Move %d files to:\n\n%s" % (len(self.VVGape), path), title=title)
22939:   else:
22940:    self.VVLp78(defDir)
22941:  @FFOAKH("Moving Files ...")
22942:  def VVJ3ic(self, title, defDir, toPath):
22943:   if not iMove:
22944:    self.VVLp78(defDir)
22945:    FFdw58(self, "Module not found:\n\nshutil", title=title)
22946:    return
22947:   toPath = FFoWxR(toPath)
22948:   pPath = CCafIt.VVjkKT()
22949:   err  = ""
22950:   totOK = 0
22951:   for fName, fType, VV1wIO, sat, inDB in self.VVGape:
22952:    if fName:
22953:     fName += ".png"
22954:     From = "%s%s" % (pPath, fName)
22955:     try:
22956:      iMove(From, "%s%s" % (toPath, fName))
22957:      totOK +=1
22958:     except Exception as e:
22959:      err  = "\nError while moving the file:\n   %s\n\n" % From
22960:      err += "Error:\n   %s" % str(e)
22961:      break
22962:   txt  = "Files\t: %d\n" % len(self.VVGape)
22963:   txt += "Moved\t: %d\n" % totOK
22964:   txt += err
22965:   FF4lCP(self, txt, title=title, VVemyB="#22330000" if err else "#22002020")
22966:   if totOK > 0:
22967:    self.VVBwh5("all")
22968:  def VVLp78(self, defDir):
22969:   try:
22970:    os.rmdir(defDir)
22971:   except:
22972:    pass
22973:  def VVGnGr(self):
22974:   title = "Delete Unused PIcons"
22975:   tot = len(self.VVGape)
22976:   FFRMYv(self, BF(self.VVxSQo, title), "Delete %s unused PIcon file%s ?" % (tot, FFcacr(tot)), title=title)
22977:  @FFOAKH("Deleting Files ...")
22978:  def VVxSQo(self, title):
22979:   pPath = CCafIt.VVjkKT()
22980:   totErr = 0
22981:   for fName, fType, VV1wIO, sat, inDB in self.VVGape:
22982:    if fName:
22983:     fName = "%s%s.png" % (pPath, fName)
22984:     try:
22985:      os.remove(fName)
22986:     except:
22987:      totErr += 1
22988:   tot = len(self.VVGape)
22989:   txt  = "Found\t: %d\n"  % tot
22990:   txt += "Deleted\t: %d\n" % (tot - totErr)
22991:   if totErr:
22992:    txt += "Errors\t: %s" % FFjt5L(totErr, VVz22H)
22993:   FF4lCP(self, txt, title=title)
22994:  def VVtFSa(self):
22995:   lines = FF3xOt("find -L '%s' -type l -print" % self.pPath)
22996:   if lines:
22997:    tot = len(lines)
22998:    FFRMYv(self, BF(self.VVRV0F, lines), "\n".join(lines), title="Delete %d Broken SymLink%s ?" % (tot, FFcacr(tot)), VVAgUy=True)
22999:   else:
23000:    FFipXT(self, "No broken SymLinks in:\n\n%s" % self.pPath)
23001:  def VVRV0F(self, fList):
23002:   FFpwZS("find -L '%s' -type l -delete" % self.pPath)
23003:   FFipXT(self, "Files deleted:\n\n%s" % "\n".join(fList), title=self.Title)
23004:  @FFOAKH()
23005:  def VVz0Rw(self):
23006:   if self.VV6wbi:
23007:    return
23008:   txt = ""
23009:   filName, VVPxk5, VV1wIO, sat, inDB = self.VVaWmO()
23010:   if filName:
23011:    path = self.pPath + filName
23012:    txt += FFjt5L("PIcon Directory:\n", VVGCYL)
23013:    txt += "  Path\t: %s\n"  % self.pPath
23014:    target = FFtu2k(self.pPath)
23015:    if target:
23016:     txt += "  Target\t: %s\n" % target
23017:    txt += "\n"
23018:    target = FFtu2k(path)
23019:    txt += FFjt5L("PIcon File:\n", VVGCYL)
23020:    if target:
23021:     txt += "  SymLink\t: %s\n"   % filName
23022:     txt += "  Target File\t: %s\n" % (os.path.dirname(target) + "/" + os.path.basename(target))
23023:    else:
23024:     txt += "  File\t: %s\n" % filName
23025:    txt += "\n"
23026:    slLst = []
23027:    if not os.path.islink(FFVc4H(path)):
23028:     OrigRealPath = os.path.realpath(path)
23029:     for fName in os.listdir(self.pPath):
23030:      fPath = os.path.join(self.pPath, fName)
23031:      if os.path.islink(FFVc4H(fPath)):
23032:       fRealPath = os.path.realpath(fPath)
23033:       if fRealPath == OrigRealPath:
23034:        slLst.append(fRealPath)
23035:     if slLst:
23036:      tot = len(slLst)
23037:      txt += FFjt5L("Found %d SymLink%s to this file from:\n" % (tot, FFcacr(tot)), VVGCYL)
23038:      for fPath in slLst:
23039:       txt += "  %s\n" % FFjt5L(fPath, VVA4XU)
23040:      txt += "\n"
23041:    if VV1wIO:
23042:     txt += FFjt5L("Channel:\n", VVGCYL)
23043:     if VVPxk5:
23044:      txt += "  Reference\t: %s\n" % (VVPxk5)
23045:     txt += "  Channel\t: %s\n" % FFjt5L(VV1wIO, VVSGsk)
23046:     if sat and not sat == "IPTV":
23047:      txt += "  Satellite\t: %s" % sat
23048:    elif not slLst:
23049:     txt += FFjt5L("Remarks:\n", VVGCYL)
23050:     txt += "  %s\n" % FFjt5L("Unused", VVz22H)
23051:   CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVga62, title="Picon Info", params=(VVPxk5, VV1wIO, txt, self.pPath + filName))
23052:  def VVaWmO(self):
23053:   fName = VVPxk5 = VV1wIO = sat = inDB = ""
23054:   if self.VVBGsZ > -1 and self.VVBGsZ < self.VVbKuB:
23055:    fName, fType, VV1wIO, sat, inDB = self.VVGape[self.VVBGsZ]
23056:    if fName.count("_") > 8 : VVPxk5 = fName.replace("_", ":").upper()
23057:    else     : VVPxk5 = ""
23058:    fName += ".png"
23059:    sat  = FFR9yH(sat)
23060:   return fName, VVPxk5, VV1wIO, sat, inDB
23061:  def VV4l5c(self):
23062:   vLst = ("myPiconF", "myPiconBG", "myPiconPic")
23063:   for v in vLst: self[v].hide()
23064:   self["keyGreen"].hide()
23065:   self.curChanName = ""
23066:   self.curChanFile = ""
23067:   self.curChanIndex = -1
23068:   self.curChanRefCode = ""
23069:   self.curChanIptvRef = ""
23070:   VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(self)
23071:   if VVPxk5:
23072:    self.curChanRefCode = VVPxk5
23073:    self.curChanName = VV1wIO
23074:    self.curChanIptvRef = VVfaDB
23075:    path = CCafIt.VVXjFJ(self.pPath, VVPxk5, VV1wIO)
23076:    if path:
23077:     self.curChanFile = os.path.splitext(os.path.basename(path))[0]
23078:     if FFBFPY(self["myPiconPic"], path):
23079:      for v in vLst: self[v].show()
23080:     for ndx, item in enumerate(self.VVGape):
23081:      if item[0] == self.curChanFile:
23082:       self.curChanIndex = ndx
23083:       if self.curChanFile.startswith(os.path.splitext(VVPxk5)[0].replace(":", "_")) : txt = "Current Service"
23084:       else                   : txt = "Current PIcon"
23085:       self["keyGreen"].show()
23086:       self["keyGreen"].setText(txt)
23087:       break
23088:  def VVHvUS(self):
23089:   title = "  " + self.Title
23090:   if self.filterTitle:
23091:    title += "  ..  Filter = " + self.filterTitle
23092:   if len(title) > 65:
23093:    title = title[:65] + ".."
23094:   self["myTitle"].setText(title)
23095:   tabLft = " " * 4
23096:   filName, VVPxk5, VV1wIO, sat, inDB = self.VVaWmO()
23097:   fNum = "Num. : %d / %d" % (self.VVBGsZ + 1, self.VVbKuB)
23098:   page = "Page: %d / %d"  % (self.VVSmMg + 1, self.VVUeUp)
23099:   self["myPiconInf0"].setText(FFjt5L("%s%s%s%s" % (tabLft, fNum, " " * 12, page), VVGCYL))
23100:   self["myPiconInf1"].setText("%sFile : %s" % (tabLft, filName))
23101:   self["myPiconInf2"].setText("%sRef. : %s" % (tabLft, self.VVaWmO()[1]))
23102:   if self.curChanIptvRef : typ = "Stream Relay" if FFHgaY(self.curChanIptvRef) else "IPTV"
23103:   else     : typ = "Current Ch."
23104:   self["myPiconInf3"].setText("%s%s : %s" % (tabLft, typ, FFjt5L(self.curChanName, VV1fx4)))
23105:   self["myPiconInf4"].setText("%sFile : %s\n" % (tabLft, (self.curChanFile + ".png")))
23106:   self["myPiconInf5"].setText("%sRef. : %s" % (tabLft, self.curChanRefCode))
23107:   filName, VVPxk5, VV1wIO, sat, inDB = self.VVaWmO()
23108:   if inDB and not sat == "IPTV" : self["keyRed"].show()
23109:   else       : self["keyRed"].hide()
23110:  @FFOAKH()
23111:  def VVoNnq(self):
23112:   VVY1oT, VVvwHc = FF07Sg()
23113:   sTypeNameDict = {}
23114:   for key, val in VVvwHc.items():
23115:    sTypeNameDict[key] = 0
23116:   totUsedFiles = 0
23117:   totUsedLinks = 0
23118:   totSymLinks  = 0
23119:   totInDB   = 0
23120:   totNoRefCode = 0
23121:   totNoSType  = 0
23122:   sTypeDict  = {}
23123:   for fName, fType, VV1wIO, sat, inDB in self.VVGape:
23124:    if VV1wIO:
23125:     if fType == 0 : totUsedFiles += 1
23126:     else   : totUsedLinks += 1
23127:    if fType == 1:
23128:     totSymLinks += 1
23129:    if inDB == 1:
23130:     totInDB += 1
23131:    span = iSearch(r"(?:[A-Fa-f0-9]+_){2}([A-Fa-f0-9]+)(?:_[A-Fa-f0-9]+){7}", fName, IGNORECASE)
23132:    if span:
23133:     stNum = int(span.group(1), 16)
23134:     if stNum in VVvwHc: sTypeDict[VVvwHc[stNum]] = sTypeDict.get(VVvwHc[stNum], 0) + 1
23135:     else     : totNoSType += 1
23136:    else:
23137:     totNoRefCode += 1
23138:   totBrokSL = FFTKR0("find -L '%s' -type l -print | wc -l" % self.pPath)
23139:   VVAkuK = []
23140:   c = "#b#11003333#"
23141:   VVAkuK.append((c + "PIcons" , "%d\tUsed = %s" % (self.VVbKuB, totUsedFiles + totUsedLinks)))
23142:   VVAkuK.append((c + "Files" , "%d\tUsed = %s" % (self.VVbKuB - totSymLinks, totUsedFiles)))
23143:   VVAkuK.append((c + "SymLinks" , "%d\tUsed = %s" % (totSymLinks, totUsedLinks)))
23144:   c = "#b#11004040#"
23145:   VVAkuK.append((c + "In Database (lamedb)"  , str(totInDB)))
23146:   VVAkuK.append((c + "Not In Database (lamedb)" , str(self.VVbKuB - totInDB)))
23147:   VVAkuK.append((c + "Satellites"    , str(len(self.nsList))))
23148:   VVAkuK.append((c + "Broken SymLinks"   , str(totBrokSL)))
23149:   if totNoRefCode : VVAkuK.append((c + "File name is not a Reference Code" , str(totNoRefCode)))
23150:   if totNoSType : VVAkuK.append((c + "Unknown Service Type"    , str(totNoSType)))
23151:   s = "Service Type "
23152:   if sTypeDict:
23153:    sTypeRows = []
23154:    for key, val in sTypeDict.items():
23155:     sTypeRows.append(("Service Type (%s)" % key, str(val)))
23156:    sTypeRows.sort(key=lambda x: x[0].lower())
23157:    VVAkuK.extend(sTypeRows)
23158:   FFUQ0v(self, None, title=self.Title, VVGape=VVAkuK, VVwdmN=28, VVJKqd="#00003333", VVbcr0="#00222222")
23159:  def VVDZB5(self):
23160:   if self.filterTitle:
23161:    txt = FFfCtV(self.filterTitle, r"_")
23162:    txt = "FilteredBy_%s_" % FFMYNg(txt, "_")
23163:   else:
23164:    txt = "All_"
23165:   path = "%sPIconsList_%s%s.txt" % (FFeAlZ(), txt, FFjTQe())
23166:   with open(path, "w") as f:
23167:    for fName, fType, VV1wIO, sat, inDB in self.VVGape:
23168:     f.write("%s%s.png\n" % (self.pPath, fName))
23169:   FFipXT(self, "List exported to file:\n\n%s" % path, title=self.Title)
23170:  def VVfmub(self):
23171:   if not self.VV6wbi:
23172:    VV3wat = []
23173:    VV3wat.append(("All"        , "all"  ))
23174:    VV3wat.append(VVAL3j)
23175:    VV3wat.append(("Used by Channels"     , "used" ))
23176:    VV3wat.append(("Unused PIcons"     , "unused" ))
23177:    VV3wat.append(VVAL3j)
23178:    VV3wat.append(("PIcons Files (no SymLinks)"  , "pFiles" ))
23179:    VV3wat.append(("SymLinks to PIcons"    , "pLinks" ))
23180:    VV3wat.append(("PIcons Files Targeted by SymLinks", "pTargets"))
23181:    VV3wat.append(("By Files Date ..."    , "pDate" ))
23182:    VV3wat.append(("By Service Type ..."    , "servType"))
23183:    if self.rTypeLst:
23184:     VV3wat.append(("Reference Type ..."   , "rType" ))
23185:    if self.nsList:
23186:     VV3wat.append(FF0bQE("Satellites (Reference in PIcon name)"))
23187:     satsHex = list(self.nsList)
23188:     satsHex.sort()
23189:     for sHex in satsHex:
23190:      val = int(sHex, 16)
23191:      if val > 0:
23192:       sat = FFS0T2(val)
23193:       VV3wat.append((sat, "__s__" + sHex + "__sat__" + sat))
23194:    filterObj = CCoErY(self)
23195:    filterObj.VVywN2(VV3wat, self.nsList, self.VVp3gu)
23196:  def VVp3gu(self, item=None):
23197:   if item is not None:
23198:    self.VVBwh5(item)
23199:  def VVBwh5(self, item=None):
23200:    if   item == "all"    : mode, words, self.filterTitle = self.VVwy9X   , ""  , ""
23201:    elif item == "used"    : mode, words, self.filterTitle = self.VVMHWR   , ""  , "PIcons with Channels"
23202:    elif item == "unused"   : mode, words, self.filterTitle = self.VVQzY6  , ""  , "PIcons without Channels"
23203:    elif item == "pFiles"   : mode, words, self.filterTitle = self.VVxUTE  , ""  , "PIcons Files"
23204:    elif item == "pLinks"   : mode, words, self.filterTitle = self.VVmvJo  , ""  , "SymLinks"
23205:    elif item == "pTargets"   : mode, words, self.filterTitle = self.VVR4LO  , ""  , "Targets"
23206:    elif item == "pDate"   : mode, words, self.filterTitle = self.VV8XEV , ""  , "Date"
23207:    elif item == "servType"   : mode, words, self.filterTitle = self.VVEXya , ""  , "Service Type"
23208:    elif item == "rType"   : mode, words, self.filterTitle = self.VVfxSo  , ""  , "Reference Type"
23209:    elif item.startswith("__s__") : mode, words, self.filterTitle = self.VV6Rs1   , item[5:].split("__sat__")[0] , item[5:].split("__sat__")[1]
23210:    elif item.startswith("__w__") : mode, words, self.filterTitle = self.VV2tBs , item[5:] , item[5:]
23211:    else       : return
23212:    asPrefix = self.lastAsPrefix
23213:    if mode == self.VVR4LO:
23214:     words = []
23215:     pngFiles = self.pPath + "*.png"
23216:     lines = FF3xOt("find %s -type l | while read -r FILE; do if [ -L \"$FILE\" ] && [ -e \"$FILE\" ]; then ls -l \"$FILE\" 2> /dev/null | awk '{$1=$2=$3=$4=$5=$6=$7=$8=$9=$10=\"\";print}' | xargs; fi; done" % pngFiles)
23217:     if lines:
23218:      for f in lines:
23219:       fName = FFxtW5(f)
23220:       if fName.endswith(".png"):
23221:        fName = fName[:-4]
23222:        words.append(fName)
23223:     if not words:
23224:      FF28n1(self, "Not found", 1000)
23225:      return
23226:    elif mode == self.VV8XEV:
23227:     self.VVbdHZ(mode)
23228:     return
23229:    elif mode == self.VVEXya:
23230:     self.VVyBU7(mode)
23231:     return
23232:    elif mode == self.VVfxSo:
23233:     err = self.VV1EaD(mode, self.filterTitle)
23234:     if err: FF28n1(self, "No valid Reference Type", 1000)
23235:     return
23236:    elif mode == self.VVKBzs:
23237:     return
23238:    else:
23239:     words, asPrefix = CCoErY.VVPBNm(words)
23240:    if not words and mode in (self.VV6Rs1, self.VV2tBs):
23241:     FF28n1(self, "Incorrect filter", 2000)
23242:    elif not self.lastMode == mode or not self.lastWords == words or not self.lastAsPrefix == asPrefix:
23243:     self.VVJf8n("Filtering ...", mode=mode, words=words, asPrefix=asPrefix)
23244:  def VVbdHZ(self, mode):
23245:   VV3wat = []
23246:   VV3wat.append(("Today"   , "today" ))
23247:   VV3wat.append(("Since Yesterday" , "yest" ))
23248:   VV3wat.append(("Since 7 days"  , "week" ))
23249:   FFLFTC(self, BF(self.VVtVEv, mode), VV3wat=VV3wat, title="Filter by Added/Modified Date")
23250:  def VVtVEv(self, mode, item=None):
23251:   if item:
23252:    if   item == "today": stamp, self.filterTitle = FFZVA0(0) , "Today"
23253:    elif item == "yest" : stamp, self.filterTitle = FFZVA0(-1), "Yesterday"
23254:    elif item == "week" : stamp, self.filterTitle = FFZVA0(-7), "Last 7 Days"
23255:    self.filterTitle = "File Date (%s)" % self.filterTitle
23256:    if not self.lastMode == mode or not self.lastTimeStamp == stamp:
23257:     self.VVJf8n("Filtering ...", mode=mode, timeStamp=stamp)
23258:  def VV1EaD(self, mode, title):
23259:   FFLFTC(self, BF(self.VVd5SW, mode), VV3wat=[(x,x) for x in sorted(list(self.rTypeLst))], width=400, title=title)
23260:  def VVd5SW(self, mode, rt=None):
23261:   if rt and (mode, [rt]) != (self.lastMode, self.lastWords):
23262:    self.VVJf8n("Filtering ...", mode=mode, words=[rt])
23263:  def VVyBU7(self, mode):
23264:   VVY1oT, VVvwHc = FF07Sg()
23265:   lst = set()
23266:   for key, val in VVvwHc.items():
23267:    lst.add(val)
23268:   VV3wat = []
23269:   for item in lst:
23270:    VV3wat.append((item, item))
23271:   VV3wat.sort(key=lambda x: x[0])
23272:   FFLFTC(self, BF(self.VVdDA1, mode), VV3wat=VV3wat, title="Filter by Service Type")
23273:  def VVdDA1(self, mode, item=None):
23274:   if item:
23275:    VVY1oT, VVvwHc = FF07Sg()
23276:    sTypeList = []
23277:    for key, val in VVvwHc.items():
23278:     if item == val:
23279:      self.filterTitle = val
23280:      sTypeList.append(("%01x" % key).upper())
23281:    if not self.lastMode == mode or not self.lastSTypeList == sTypeList:
23282:     self.VVJf8n("Filtering ...", mode=mode, sTypeList=sTypeList)
23283:  def VVitxh(self):
23284:   CCh3tv.VV7Nf4(self
23285:       , VVixvy  = self.VVNBsa
23286:       , VVbYwR = self.VVDSFM)
23287:  def VVNBsa(self, VVXyP6):
23288:   VVHj48, err = CCYrUm.VVJud0(self, CCYrUm.VVXNWJ, VVXwzE=False, VV49Lf=False)
23289:   files = []
23290:   words = []
23291:   if not VVXyP6 or VVXyP6.isCancelled:
23292:    return
23293:   VVXyP6.VVNc18 = []
23294:   VVXyP6.VVq8NF(len(VVHj48))
23295:   if VVHj48:
23296:    curCh = self.VVBgSG(self.curChanName)
23297:    for VVPxk5 in VVHj48:
23298:     if not VVXyP6 or VVXyP6.isCancelled: return
23299:     VVXyP6.VVxtQs(1, True)
23300:     VV1wIO, sat, inDB = VVHj48.get(VVPxk5, ("", "", 0))
23301:     ratio = CCafIt.VV8e0X(VV1wIO.lower(), curCh)
23302:     if ratio > 50:
23303:      allPath, fName, VVy4K7, pList = CCafIt.VV6Tzh(VVPxk5.replace("_", ":"), self.curChanName, addSimilar=True)
23304:      if pList:
23305:       for f in pList:
23306:        f = FFxtW5(f)
23307:        fil = f.replace(".png", "")
23308:        if not VVXyP6 or VVXyP6.isCancelled: return
23309:        if not fil in VVXyP6.VVNc18:
23310:         VVXyP6.VVNc18.append(fil)
23311:  def VVDSFM(self, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
23312:   if VVNc18 : self.VVJf8n("Loading ...", mode=self.VVKBzs, words=VVNc18)
23313:   else   : FF28n1(self, "Not found", 2000)
23314:  @FFOAKH(tNdx=1)
23315:  def VVJf8n(self, wTxt, mode=0, words=None, asPrefix=False, reverseSort=False, VVpQCY=False, goToFirst=True, timeStamp=None, sTypeList=None):
23316:   if not self.VV8nAD(VVpQCY):
23317:    return
23318:   self.VV6wbi = True
23319:   VV49Lf = True if VVpQCY else False
23320:   VVHj48, err = CCYrUm.VVJud0(self, CCYrUm.VVXNWJ, VVXwzE=False, VV49Lf=VV49Lf)
23321:   if err:
23322:    self.close()
23323:   VVf1kq = self.VVKwNf()
23324:   tList = []
23325:   for fName, fType in CCafIt.VVq4T1(self.pPath):
23326:    fName = fName[:-4]
23327:    namSp = ""
23328:    if fName.count("_") > 8 and VVHj48:
23329:     if fName in VVHj48:
23330:      VV1wIO, sat, inDB = VVHj48.get(fName)
23331:      VV1wIO = VV1wIO or "?"
23332:      namSp = fName.split("_")[6].zfill(8)[:4]
23333:      if VVpQCY and namSp: self.nsList.add(namSp)
23334:     elif fName in VVf1kq:
23335:      VV1wIO = VVf1kq.get(fName) or "?"
23336:      sat, inDB = "IPTV", 1
23337:     else:
23338:      VV1wIO, sat, inDB = "", "", 0
23339:     if VVpQCY:
23340:      span = iSearch(r"^([a-f0-9]+)(?:_[a-f0-9]+){9}", fName, IGNORECASE)
23341:      if span: self.rTypeLst.add(span.group(1))
23342:    else:
23343:     VV1wIO, sat, inDB = "", "", 0
23344:    entry = (fName, fType, VV1wIO, sat, inDB)
23345:    isAdd = False
23346:    if mode == self.VVwy9X              : isAdd = True
23347:    elif mode == self.VVMHWR  and VV1wIO         : isAdd = True
23348:    elif mode == self.VVQzY6 and not VV1wIO        : isAdd = True
23349:    elif mode == self.VVxUTE  and fType == 0        : isAdd = True
23350:    elif mode == self.VVmvJo  and fType == 1        : isAdd = True
23351:    elif mode == self.VVR4LO  and fName in words       : isAdd = True
23352:    elif mode == self.VVKBzs and fName in words       : isAdd = True
23353:    elif mode == self.VV6Rs1  and namSp.lower() == words[0]    : isAdd = True
23354:    elif mode == self.VV2tBs:
23355:     if asPrefix:
23356:      if any(VV1wIO.lower().startswith(x) for x in words)       : isAdd = True
23357:     elif any(x in VV1wIO.lower() for x in words)         : isAdd = True
23358:    elif mode == self.VV8XEV:
23359:     try:
23360:      if os.stat("%s%s.png" % (self.pPath, fName)).st_ctime >= timeStamp   : isAdd = True
23361:     except:
23362:      pass
23363:    elif mode == self.VVEXya:
23364:     span = iSearch(r"(?:[A-Fa-f0-9]+_){2}([A-Fa-f0-9]+)(?:_[A-Fa-f0-9]+){7}", fName, IGNORECASE)
23365:     if span and span.group(1) in sTypeList           : isAdd = True
23366:    elif mode == self.VVfxSo:
23367:     if iMatch(r"^(%s(?:_[a-f0-9]+){9})" % words[0], fName, IGNORECASE)    : isAdd = True
23368:    if isAdd:
23369:     tList.append(entry)
23370:   if tList:
23371:    self.VVGape   = list(tList)
23372:    tList    = None
23373:    self.lastMode  = mode
23374:    self.lastWords  = words
23375:    self.lastAsPrefix = asPrefix
23376:    self.lastTimeStamp = timeStamp
23377:    self.lastSTypeList = sTypeList
23378:   else:
23379:    self.VV6wbi = False
23380:    FFjADj(self, "Not found", 1000)
23381:    return
23382:   self.VVGape.sort(key=lambda x: x[self.lastSortCol], reverse=reverseSort)
23383:   self.VV4l5c()
23384:   self.VVbKuB = len(self.VVGape)
23385:   self.VVUeUp = int(self.VVbKuB / self.VVg3d5) + (self.VVbKuB % self.VVg3d5 > 0)
23386:   if goToFirst:
23387:    self.VVSmMg = 0
23388:    self.curRow  = 0
23389:    self.curCol  = 0
23390:    self.VVBGsZ = 0
23391:    self.VVcG7K = 0
23392:    self.VVGCBk = 0
23393:   self.VV6wbi = False
23394:   self.VVLckG(True)
23395:  def VV8nAD(self, VVpQCY):
23396:   if FFCyVu(self.pPath):
23397:    for fName, fType in CCafIt.VVq4T1(self.pPath):
23398:     if fName:
23399:      return True
23400:    if VVpQCY : FFdw58(self, 'No ".png" files in path:\n\n%s' % self.pPath, title=self.Title)
23401:    else   : FF28n1(self, "Not found", 1000)
23402:   else:
23403:    FFdw58(self, "PIcons path not found.\n\n%s" % self.pPath)
23404:   if VVpQCY:
23405:    self.close()
23406:   return False
23407:  def VVKwNf(self):
23408:   VVAkuK = {}
23409:   files  = CCkEI5.VVjMS6()
23410:   if files:
23411:    for path in files:
23412:     txt = FFYVq0(path)
23413:     list = iFindall(r"
23414:     if list:
23415:      for item in list:
23416:       VVPxk5 = item[0].upper().replace(":", "_").strip("_")
23417:       VVAkuK[VVPxk5] = item[1]
23418:   return VVAkuK
23419:  def VVe4Ro(self):
23420:   self.VVaFRk()
23421:   f1, f2 = self.VVS7BN()
23422:   row = col = 0
23423:   for ndx in range(f1, f2):
23424:    fName, fType, VV1wIO, sat, inDB = self.VVGape[ndx]
23425:    fName = self.VVGape[ndx][0]
23426:    path  = self.pPath + fName + ".png"
23427:    VVPxk5  = fName.replace("_", ":").upper()
23428:    pic, lbl = self.VVwbpA(row, col)
23429:    ok = self.VVaJVd(ndx, row, col, pic, path)
23430:    if ok   : color = VVSGsk if inDB else ""
23431:    elif not VV1wIO : color = ""
23432:    else   : color = VVcPtB
23433:    self.VVExY8(lbl, VV1wIO or "-", color)
23434:    self.VVcG7K = row
23435:    self.VVGCBk = col
23436:    col += 1
23437:    if col > (self.VVsHeH - 1):
23438:     col = 0
23439:     row += 1
23440:  @staticmethod
23441:  def VV8e0X(s1, s2):
23442:   row = -1
23443:   rows, cols, dist = len(s1) + 1, len(s2) + 1, []
23444:   for i in range(rows): dist.append([0.] * cols)
23445:   for i in range(1, rows):
23446:    for j in range(1,cols): dist[i][0], dist[0][j] = i, j
23447:   for col in range(1, cols):
23448:    for row in range(1, rows):
23449:     cost = 0 if s1[row-1] == s2[col-1] else 2
23450:     dist[row][col] = min(dist[row-1][col] + 1, dist[row][col-1] + 1, dist[row-1][col-1] + cost)
23451:   return int( ( ( len(s1) + len(s2) ) - dist[row][col] ) / ( len(s1) + len(s2) ) * 100 ) if row != -1 else 0
23452:  @staticmethod
23453:  def VVdmZZ():
23454:   return ("Export Current Channel PIcon File", "VVZxA1")
23455:  @staticmethod
23456:  def VVC3jQ():
23457:   VV3wat = []
23458:   VV3wat.append(("Find SymLinks (to PIcon Directory)"   , "VVS8ig"  ))
23459:   VV3wat.append(("Find Broken SymLinks (to PIcon Directory)" , "findPiconBrokenSymLinks" ))
23460:   VV3wat.append(("Find all Broken SymLinks"      , "FindAllBrokenSymLinks" ))
23461:   return VV3wat
23462:  @staticmethod
23463:  def VVZxA1(SELF):
23464:   png, path = CCafIt.VV81vh(CC3rDi(SELF.session).VVXbok)
23465:   if path : CCafIt.VVqLQB(SELF, png, path)
23466:   else : FFdw58(SELF, "No PIcon found for current channel in:\n\n%s" % CCafIt.VVjkKT())
23467:  @staticmethod
23468:  def VVS8ig(SELF):
23469:   if VV1fx4:
23470:    sed1 = FFSPDv("->", VV1fx4)
23471:    sed2 = FFSPDv("picon", VVz22H)
23472:    sed3 = r"| sed 's/... Broken Link/\\t\\%s&\%s/gI'" % (VVcPtB, VVwdUw)
23473:   else:
23474:    sed1 = sed2 = sed3 = ""
23475:   grep = "| grep -i 'picon'"
23476:   FFXD60(SELF, "find / %s -type l %s | while read -r FILE; do if [ -L \"$FILE\" ] && [ ! -e \"$FILE\" ]; then BROK='... Broken Link'; else BROK=''; fi; ls -l \"$FILE\" 2> /dev/null | sed \"s/$/${BROK}/\" | awk '{$1=$2=$3=$4=$5=$6=$7=$8=\"\";print}' | xargs; done %s %s %s" % (FF5W9s(1), grep, sed1, sed2, sed3))
23477:  @staticmethod
23478:  def VVqb9O(SELF, isPIcon):
23479:   sed1 = FFSPDv("->", VVcPtB)
23480:   if isPIcon:
23481:    grep = "| grep -i 'picon'"
23482:    sed2 = FFSPDv("picon", VVz22H)
23483:   else:
23484:    grep = "| grep -v /proc | grep -v /run | grep -v /etc/rcS.d"
23485:    sed2 = ""
23486:   FFXD60(SELF, "find / %s -type l %s | while read -r FILE; do if [ -L \"$FILE\" ] && [ ! -e \"$FILE\" ]; then ls -l \"$FILE\" 2> /dev/null | awk '{$1=$2=$3=$4=$5=$6=$7=$8=\"\";print}' | xargs; fi; done %s %s" % (FF5W9s(1), grep, sed1, sed2))
23487:  @staticmethod
23488:  def VVqLQB(SELF, png, path):
23489:   dest = FFriZ7()
23490:   andTxt = "echo -e 'PIcon file copied to:\n\n%s%s' %s" % (dest, png, FFSPDv("%s%s" % (dest, png), VVSGsk))
23491:   errTxt = "Could not copy PIcon file!"
23492:   orTxt = "echo -e '%s' %s" % (errTxt, FFSPDv(errTxt, VVYjI5))
23493:   cmd = "cp -f '%s' '%s' &> /dev/null && %s || %s" % (path, dest, andTxt, orTxt)
23494:   FFZQVC(SELF, cmd)
23495:  @staticmethod
23496:  def VVq4T1(path):
23497:   for f in os.listdir(path):
23498:    if f.endswith(".png"):
23499:     p = path + f
23500:     if os.path.islink(FFVc4H(p)) and os.path.exists(p) : yield f , 1
23501:     elif os.path.isfile(p)          : yield f , 0
23502:  @staticmethod
23503:  def VVjkKT():
23504:   return FFoWxR(CFG.PIconsPath.getValue())
23505:  @staticmethod
23506:  def VV81vh(VVPxk5, VV1wIO=""):
23507:   if FFUPnc(VVPxk5):
23508:    VVPxk5, VVZcRP, VV57TX, VVfaDB = CC3rDi.VVGg6H(VVPxk5)
23509:   allPath, fName, VVy4K7, pList = CCafIt.VV6Tzh(VVPxk5, VV1wIO)
23510:   if pList:
23511:    if VVy4K7 : return fName, VVy4K7
23512:    else   : return fName, pList[0]
23513:   else:
23514:    return "", ""
23515:  @staticmethod
23516:  def VVXjFJ(pPath, VVPxk5, VV1wIO):
23517:   span = iSearch(r"^((?:[a-f0-9]+:){9}(?:[a-f0-9]+))", VVPxk5.strip(), IGNORECASE)
23518:   if span:
23519:    exts = ("png", "jpg")
23520:    VVPxk5 = span.group(1).replace(":", "_")
23521:    tPath = "%s%s." % (pPath, VVPxk5)
23522:    for ext in exts:
23523:     path = tPath + ext
23524:     if FFCyVu(path):
23525:      return path
23526:    refParts = VVPxk5.split("_", 1)
23527:    for rType in CCkEI5.VV5LSJ():
23528:     if not rType == refParts[0]:
23529:      for ext in exts:
23530:       path = "%s%s_%s.%s" %  (pPath, rType, refParts[1], ext)
23531:       if FFCyVu(path):
23532:        return path
23533:    VV1wIO = FFzBfi(VV1wIO)
23534:    VV1wIO1 = VV1wIO.replace(" ", "")
23535:    for name in (VV1wIO, VV1wIO.lower(), VV1wIO.upper(), VV1wIO1.lower(), VV1wIO1.upper()):
23536:     for ext in exts:
23537:      path = "%s%s.%s" % (pPath, name, ext)
23538:      if FFCyVu(path):
23539:       return path
23540:   return ""
23541:  @staticmethod
23542:  def VV6Tzh(VVPxk5, VV1wIO, addSimilar=False):
23543:   allPath = fName = VVy4K7 = pList = None
23544:   if VVPxk5.count(":") > 8:
23545:    VVPxk5 = VVPxk5.rstrip(":")
23546:    fName = VVPxk5.strip()
23547:    fName = fName.rstrip(":")
23548:    fName = VVPxk5.replace(":", "_") + ".png"
23549:    allPath = CCafIt.VVjkKT()
23550:    pList = []
23551:    lst = FFkzic(allPath, "*_" + "_".join(fName.split("_")[3:]))
23552:    if lst:
23553:     pList += lst
23554:    if VV1wIO:
23555:     pList.extend(CCafIt.VVKnlA(FFzBfi(VV1wIO), addSimilar=addSimilar))
23556:    VVy4K7 = ""
23557:    if pList:
23558:     for item in pList:
23559:      if fName == FFxtW5(item):
23560:       VVy4K7 = item
23561:     pList.sort()
23562:   return allPath, fName, VVy4K7, pList
23563:  @staticmethod
23564:  def VVKnlA(VV1wIO, addSimilar=False):
23565:   lst  = []
23566:   pPath = CCafIt.VVjkKT()
23567:   if VVmJwX(pPath):
23568:    VV1wIO = VV1wIO.lower()
23569:    exts = ("png", "jpg")
23570:    fLst = os.listdir(pPath)
23571:    if addSimilar:
23572:     for s in ("sd", "hd", "hd+", "fhd", "fhd+", "4k", "tv"):
23573:      VV1wIO = VV1wIO.replace(s, "")
23574:     VV1wIO = VV1wIO.strip()
23575:     for x in fLst:
23576:      tName = x[:-4].lower()
23577:      if (VV1wIO in tName or tName in VV1wIO) and x[-3:] in exts:
23578:       lst.append(x)
23579:    else:
23580:     lst = [x for x in fLst if VV1wIO == x[:-4].lower() and x[-3:] in exts]
23581:   return lst
23582: class CCOZ3M():
23583:  def __init__(self):
23584:   self.VVS566()
23585:  def VVS566(self):
23586:   noService = "No data"
23587:   self.VV8Jvc = ""
23588:   self.VVM9tN  = noService
23589:   self.VVlbWC = 0
23590:   self.VVJVEp  = noService
23591:   self.VVFl8C = 0
23592:   self.VVFMtk  = "-"
23593:   self.VVek6Y = 0
23594:   self.VVH03T  = ""
23595:   self.serviceName = ""
23596:   self.infoAvailable = False
23597:   self.VVo5l5  = None
23598:  def VVAo5r(self, service):
23599:   self.VVS566()
23600:   if service:
23601:    feinfo = service.frontendInfo()
23602:    if feinfo:
23603:     self.infoAvailable = True
23604:     frontEndStatus = feinfo.getFrontendStatus()
23605:     if frontEndStatus:
23606:      self.VVo5l5 = frontEndStatus
23607:      self.VVJima()
23608:    info = service.info()
23609:    if info:
23610:     self.serviceName = info.getName()
23611:  def VVJima(self):
23612:   if self.VVo5l5:
23613:    val = self.VVo5l5.get("tuner_signal_quality_db", 0x12345678)
23614:    if val is not None and val != 0x12345678: self.VV8Jvc = "%3.02f dB" % (val / 100.0)
23615:    else         : self.VV8Jvc = ""
23616:    val = self.VVo5l5.get("tuner_signal_quality", 0) * 100 / 65536
23617:    self.VVlbWC = int(val)
23618:    self.VVM9tN  = "%d%%" % val
23619:    val = self.VVo5l5.get("tuner_signal_power" , 0) * 100 / 65536
23620:    self.VVFl8C = int(val)
23621:    self.VVJVEp  = "%d%%" % val
23622:    val = self.VVo5l5.get("tuner_bit_error_rate", 0)
23623:    if not val:
23624:     val = 0
23625:    self.VVFMtk  = "%d" % val
23626:    val = int(val * 100 / 500)
23627:    self.VVek6Y = min(500, val)
23628:    val = self.VVo5l5.get("tuner_locked", 0)
23629:    if val == 1 : self.VVH03T = "Locked"
23630:    else  : self.VVH03T = "Not locked"
23631:  def VVSwl4(self)   : return self.VV8Jvc
23632:  def VVlX6a(self)   : return self.VVM9tN
23633:  def VVRpcw(self)  : return self.VVlbWC
23634:  def VVr4Yo(self)   : return self.VVJVEp
23635:  def VVX9tR(self)  : return self.VVFl8C
23636:  def VVU8EL(self)   : return self.VVFMtk
23637:  def VVZwV4(self)  : return self.VVek6Y
23638:  def VVO1mH(self)   : return self.VVH03T
23639:  def VVvVTk(self) : return self.serviceName
23640: class CC3Z54():
23641:  def __init__(self):
23642:   self.sat1 = self.sat2 = self.freq = self.sr = self.syst = self.inv = self.pol = self.fec    = ""
23643:   self.mod = self.rolof = self.pil = self.plsMod = self.plsCod = self.iStId = self.t2PlId = self.t2PId = ""
23644:   self.data  = None
23645:   self.namespace = ""
23646:   self.txMedia = ""
23647:   self.D_POL  = {0:"Horizontal" , 1:"Vartical" , 2:"Left" , 3:"Right"}
23648:   self.D_SYS_S = {0:"DVB-S", 1:"DVB-S2"}
23649:   self.D_SYS_T = {0:"DVB-T", 1:"DVB-T2"}
23650:   self.D_SYS_C = {0:"DVB-C", 1:"DVB-C2", 2:"DVB-C3", 3:"ATSC"}
23651:   self.D_PIL_INV = {0:"Off" , 1:"On" , 2:"Auto"}
23652:   self.D_PLS_MOD = {0:"Root" , 1:"Gold" , 2:"Combo" , 3:"Unknown"}
23653:   self.D_ROLOF = {0:"35%" , 1:"25%" , 2:"20%" , 3:"Auto"}
23654:   self.D_MOD  = {0:"Auto" , 1:"QPSK" , 2:"8PSK" , 3:"QAM16" , 4:"16APSK", 5:"32APSK"}
23655:   self.D_FEC  = {0:"Auto" , 1:"1/2" , 2:"2/3" , 3:"3/4" , 4:"5/6" , 5:"7/8", 6:"8/9", 7:"3/5", 8:"4/5", 9:"9/10", 10:"6/7", 15:"None"}
23656:   self.FREQ  = "frequency"
23657:   self.SR   = "symbol_rate"
23658:   self.POL  = "polarization"
23659:   self.FEC  = "fec_inner"
23660:   self.ORPOS  = "orbital_position"
23661:   self.SYST  = "system"
23662:   self.INV  = "inversion"
23663:  def VVH3lH(self, VVPxk5):
23664:   self.data = None
23665:   if not VVPxk5: return
23666:   self.namespace = FFARk6(VVPxk5)
23667:   if   self.namespace.startswith("EEEE") : self.txMedia, syst = "DVB-T", self.D_SYS_T
23668:   elif self.namespace.startswith("FFFF") : self.txMedia, syst = "DVB-C", self.D_SYS_C
23669:   else         : self.txMedia, syst = "DVB-S", self.D_SYS_S
23670:   servRef = eServiceReference(VVPxk5)
23671:   if servRef:
23672:    info = eServiceCenter.getInstance().info(servRef)
23673:    if info:
23674:     self.data = info.getInfoObject(servRef, iServiceInformation.sTransponderData)
23675:     if self.data:
23676:      self.sat1  = self.VVBvvD(self.ORPOS  , mod=1   )
23677:      self.sat2  = self.VVBvvD(self.ORPOS  , mod=2   )
23678:      self.freq  = self.VVBvvD(self.FREQ  , mod=3   )
23679:      self.sr   = self.VVBvvD(self.SR   , mod=4   )
23680:      self.inv  = self.VVBvvD(self.INV  , self.D_PIL_INV)
23681:      self.pol  = self.VVBvvD(self.POL  , self.D_POL )
23682:      self.fec  = self.VVBvvD(self.FEC  , self.D_FEC )
23683:      self.syst  = self.VVBvvD(self.SYST  , syst   )
23684:      if "S2" in self.syst:
23685:       self.mod = self.VVBvvD("modulation" , self.D_MOD )
23686:       self.rolof = self.VVBvvD("rolloff"  , self.D_ROLOF )
23687:       self.pil = self.VVBvvD("pilot"   , self.D_PIL_INV)
23688:       self.plsMod = self.VVBvvD("pls_mode"  , self.D_PLS_MOD)
23689:       self.plsCod = self.VVBvvD("pls_code"  )
23690:       self.iStId = self.VVBvvD("is_id"   )
23691:       self.t2PlId = self.VVBvvD("t2mi_plp_id" )
23692:       self.t2PId = self.VVBvvD("t2mi_pid"  )
23693:  def VVBvvD(self, key, valDict=None, mod=0):
23694:   val = self.data.get(key, "?")
23695:   if   val in ("?", -1) : return ""
23696:   elif valDict   : return valDict.get(val, str(val))
23697:   elif mod == 1   : return FFS0T2(val)
23698:   elif mod == 2   : return FFycBE(val)
23699:   elif mod == 3   : return str(int(val) // 1000)
23700:   elif mod == 4   : return str(int(val) // 1000)
23701:   else     : return str(val)
23702:  def VVQh97(self, refLst):
23703:   for VVPxk5 in refLst:
23704:    self.VVH3lH(VVPxk5)
23705:    if self.data: break
23706:   txt = ""
23707:   if self.data:
23708:    def VVJi7Q(subj, val):
23709:     if val : return "%s\t: %s\n" % (subj, val)
23710:     else : return ""
23711:    if self.txMedia == "DVB-S":
23712:     txt += VVJi7Q("System"   , self.syst)
23713:     txt += VVJi7Q("Satellite"  , self.sat2)
23714:     txt += VVJi7Q("Frequency"  , self.freq)
23715:     txt += VVJi7Q("Inversion"  , self.inv)
23716:     txt += VVJi7Q("Symbol Rate"  , self.sr)
23717:     txt += VVJi7Q("Polarization" , self.pol)
23718:     txt += VVJi7Q("FEC"    , self.fec)
23719:     if "S2" in self.syst:
23720:      txt += VVJi7Q("Modulation" , self.mod)
23721:      txt += VVJi7Q("Roll-Off" , self.rolof)
23722:      txt += VVJi7Q("Pilot"  , self.pil)
23723:      txt += VVJi7Q("Input Stream", self.iStId)
23724:      txt += VVJi7Q("T2MI PLP ID" , self.t2PlId)
23725:      txt += VVJi7Q("T2MI PID" , self.t2PId)
23726:      txt += VVJi7Q("PLS Mode" , self.plsMod)
23727:      txt += VVJi7Q("PLS Code" , self.plsCod)
23728:    else:
23729:     txt += VVJi7Q("System"   , self.txMedia)
23730:     txt += VVJi7Q("Frequency"  , self.freq)
23731:   return txt, self.namespace
23732:  def VVsDkA(self, refLst, maxLen=0, nonTxt="-"):
23733:   for VVPxk5 in refLst:
23734:    self.VVH3lH(VVPxk5)
23735:    if self.data: break
23736:   if self.data:
23737:    if self.txMedia == "DVB-S":
23738:     txt1, txt2, txt3 = ("%s %s %s %s" % (self.freq, self.pol[:1], self.fec, self.sr)).strip(), "  ", self.sat2.strip()
23739:     len1, len2, len3 = len(txt1), 2, len(txt3)
23740:     if maxLen and (len1 + len2 + len3 > maxLen):
23741:      txt3 = txt3[:maxLen - len1 - len2] + ".."
23742:     return (txt1 + txt2 + (FFjt5L(txt3, VVZtfx) if txt3 else "")).strip()
23743:    else:
23744:     return "Freq = %s  (%s)" % (self.freq, FFjt5L(self.txMedia, VVZtfx))
23745:   elif nonTxt : return FFjt5L(nonTxt, VVyFI2)
23746:   else  : return ""
23747:  def VVNNi3(self, VVPxk5):
23748:   self.VVH3lH(VVPxk5)
23749:   if self.data:
23750:    if all((self.pol[:1], self.fec, self.sr)): return ("%s %s %s %s" % (self.freq, self.pol[:1], self.fec, self.sr)).strip()
23751:    else          : return ("Freq=%s" % self.freq).strip()
23752:   else           : return ""
23753:  def VVFGvS(self, VVPxk5):
23754:   if VVPxk5 and VVPxk5.count(":") > 8: servRef = eServiceReference(VVPxk5)
23755:   else         : servRef = None
23756:   self.data = None
23757:   if servRef:
23758:    info = eServiceCenter.getInstance().info(servRef)
23759:    if info:
23760:     self.data = info.getInfoObject(servRef, iServiceInformation.sTransponderData)
23761:     if self.data:
23762:      self.namespace = FFARk6(VVPxk5)
23763:      if   self.namespace.startswith("EEEE") : isSat, syst = False, self.VVBvvD(self.SYST, self.D_SYS_T)
23764:      elif self.namespace.startswith("FFFF") : isSat, syst = False, self.VVBvvD(self.SYST, self.D_SYS_C)
23765:      else         : isSat, syst = True , self.VVBvvD(self.SYST, self.D_SYS_S)
23766:      freq = self.VVBvvD(self.FREQ , mod=3  )
23767:      if isSat:
23768:       pol = self.VVBvvD(self.POL , self.D_POL)
23769:       fec = self.VVBvvD(self.FEC , self.D_FEC)
23770:       sr = self.VVBvvD(self.SR  , mod=4  )
23771:       return freq, pol[:1], fec, sr, syst
23772:      else:
23773:       return freq, "-", "-", "-", syst
23774:   return "-", "-", "-", "-", ""
23775:  def VVoQfv(self, VVPxk5):
23776:   self.data = None
23777:   self.VVH3lH(VVPxk5)
23778:   if self.data and self.freq : return True
23779:   else      : return False
23780: class CCyMCP():
23781:  def __init__(self, VVv0AW, path, VVbYwR=None, VVPhQC=-1):
23782:   self.VVv0AW  = VVv0AW
23783:   self.origFile   = path
23784:   self.Title    = "File Editor: " + FFxtW5(path)
23785:   self.VVbYwR  = VVbYwR
23786:   self.tmpFile   = "/tmp/ajp_edit"
23787:   self.fileChanged  = False
23788:   self.fileSaved   = False
23789:   self.insertMode   = 0
23790:   self.lastLineNum  = -1
23791:   self.editorTable  = None
23792:   self.starterRow   = VVPhQC
23793:   if FFpwZS("cp -f '%s' '%s'" % (self.origFile, self.tmpFile)):
23794:    self.VVYlGN(self.VVv0AW)
23795:   else:
23796:    FFdw58(self.VVv0AW, "Error while preparing edit!")
23797:  @FFOAKH("Loading file ...", par=1)
23798:  def VVYlGN(self, wObj):
23799:   VVAkuK = self.VVIh43()
23800:   VVwSzI = ("Save Changes" , self.VVZyGq   , [])
23801:   VVu1YM  = ("Edit Line"  , self.VVM4gv    , [])
23802:   VV2ytr = (""    , self.VVlDhI   , [])
23803:   VVScQz = ("Options"  , self.VV5LSQ  , [])
23804:   VV4QTJ = ("Go to Line No." , self.VVZff7   , [])
23805:   VVCOpO = (""    , self.VVmoPp , [])
23806:   VVu8qI = self.VVuYnO
23807:   VV2x9J  = self.VV5L35
23808:   header   = ("Line No." , " Text" )
23809:   widths   = (8   , 92  )
23810:   VVLIqP  = (CENTER  , LEFT  )
23811:   bg    = "#0a001111"
23812:   self.editorTable = FFUQ0v(self.VVv0AW, None, title=self.Title, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, width=1600, height=1000, VVwdmN=26, VViWgK=True, VVwSzI=VVwSzI, VVu1YM=VVu1YM, VV2ytr=VV2ytr, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVu8qI=VVu8qI, VV2x9J=VV2x9J, VVCOpO=VVCOpO, VVHPI7=True, VVMfsO=1, VVSLOq=CFG.lastFindEditor
23813:         , VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#06334444", VVbcr0="#00222222", VVX9AA="#06333322")
23814:  def VV5L35(self, VV6A99):
23815:   VV6A99.VVucBj()
23816:  def VVlDhI(self, VV6A99, title, txt, colList):
23817:   txt = "File\t: %s\n%s" % (self.origFile, txt)
23818:   FF4lCP(self.VVv0AW, txt, title=title)
23819:  def VV5LSQ(self, VV6A99, title, txt, colList):
23820:   c1, c2, c3 = VVJEMb, VVFuwR, VVz22H
23821:   isMulti = VV6A99.VVXWPu
23822:   tot  = VV6A99.VVc5NH()
23823:   lineNum = int(colList[0])
23824:   totRows = VV6A99.VVbyOe()
23825:   isPaste = not isMulti and VVLtQt and len(VVLtQt) > 0
23826:   isSel = not isMulti or tot > 0
23827:   selTxt =  ("Selected " if isMulti else "", FFcacr(tot))
23828:   VV3wat = []
23829:   VV3wat.append(FFsLU5("Insert Empty Line (before line-%d)" % lineNum, "ins1" , not isMulti      , c1))
23830:   VV3wat.append(FFsLU5("Insert Empty Line (after line-%d)"  % lineNum, "ins2" , not isMulti and lineNum == totRows, c1))
23831:   VV3wat.append(VVAL3j)
23832:   VV3wat.append(FFsLU5("Copy %sLine%s to Clipboard" % selTxt , "VVwsNz" , isSel  , c2))
23833:   VV3wat.append(VVAL3j)
23834:   VV3wat.append(FFsLU5("Insert lines from clipboard"   , "paste2"   , isPaste , c2))
23835:   VV3wat.append(FFsLU5("Paste from clipboard (overwrite line)", "paste1"   , isPaste , c2))
23836:   VV3wat.append(VVAL3j)
23837:   VV3wat.append(FFsLU5("Delete %sLine%s" % selTxt, "del", isSel, c3))
23838:   VV3wat.append(VVAL3j)
23839:   VV3wat.append(FFsLU5("Find & Replace" , "repl", not isMulti ))
23840:   cbFncDict = { "ins1"   : BF(self.VVyOTA, "sed -i '%d i %s' '%s'" % (lineNum, "", self.tmpFile))
23841:      , "ins2"   : BF(self.VVVvCv, lineNum)
23842:      , "VVwsNz" : self.VVwsNz
23843:      , "paste1"   : BF(FFimQ3, self.editorTable, BF(self.VVkoCz, lineNum, "\n".join(VVLtQt), 1))
23844:      , "paste2"   : BF(FFimQ3, self.editorTable, BF(self.VVkoCz, lineNum, "\n".join(VVLtQt), 2))
23845:      , "del"    : BF(FFimQ3, self.editorTable, self.VVLtpg)
23846:      , "repl"   : BF(self.VVARU6, title) }
23847:   mSel = CCzSCo(self.VVv0AW, VV6A99, setsOk=True)
23848:   mSel.VV9VR2(VV3wat, cbFncDict, width=750, height=1000)
23849:  def VVARU6(self, title):
23850:   fnd = CFG.lastFindRepl_fnd.getValue()
23851:   rpl = CFG.lastFindRepl_rpl.getValue()
23852:   lst = [(" Find", fnd, str(len(fnd))), (" Replace with", rpl, str(len(rpl)))]
23853:   bg = "#11101010"
23854:   VVu1YM  = ("Change" , BF(self.VVRHwg, title, lst) , [])
23855:   VVwSzI = ("Start" , BF(self.VViopn, title)  , [])
23856:   header  = (" Subject", " Text" , "Len.")
23857:   widths  = (20   , 70  , 10 )
23858:   VVLIqP = (LEFT   , LEFT  , CENTER)
23859:   FFUQ0v(self.VVv0AW, None, title=title, VVGape=lst, header=header, VVLIqP=VVLIqP, VV3cHe=widths, width=1200, VVwdmN=30, VViWgK=True, VVu1YM=VVu1YM, VVwSzI=VVwSzI, VVKDPJ=2
23860:     , VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#06224455", VVbcr0="#0a303030")
23861:  def VVRHwg(self, Title, lst, VV6A99, title, txt, colList):
23862:   title = VV6A99.VVeE40(0)
23863:   ndx = VV6A99.VVGTqU()
23864:   txt = CFG.lastFindRepl_fnd.getValue() if ndx == 0 else CFG.lastFindRepl_rpl.getValue()
23865:   FF4z45(self.VVv0AW, BF(self.VVialY, VV6A99, ndx), title=title, defaultText=txt, message="New entry")
23866:  def VVialY(self, VV6A99, ndx, newTxt=None):
23867:   if newTxt:
23868:    if ndx == 0 : FFjt1c(CFG.lastFindRepl_fnd, newTxt)
23869:    else  : FFjt1c(CFG.lastFindRepl_rpl, newTxt)
23870:    VV6A99.VVFKAn({1:newTxt, 2:len(newTxt)})
23871:  def VViopn(self, Title, VV6A99, title, txt, colList):
23872:   fnd = CFG.lastFindRepl_fnd.getValue()
23873:   rpl = CFG.lastFindRepl_rpl.getValue()
23874:   if len(fnd) > 0:
23875:    txt = FFYVq0(self.tmpFile)
23876:    tot = txt.count(fnd)
23877:    if tot > 0:
23878:     FFRMYv(self.VVv0AW, BF(self.VVPDLq, VV6A99, fnd, rpl), "Replace %d occurrences ?" % tot, title=Title)
23879:    else:
23880:     FF28n1(VV6A99, "Not found in file !", 1000)
23881:     VV6A99.VVrqBw(0)
23882:   else:
23883:    FF28n1(VV6A99, "Nothing to find", 1000)
23884:  @FFOAKH("Replacing ...", par=1)
23885:  def VVPDLq(self, VV6A99, fnd, rpl):
23886:   txt = FFYVq0(self.tmpFile)
23887:   txt = txt.replace(fnd, rpl)
23888:   with open(self.tmpFile, "w") as f:
23889:    f.write(txt)
23890:   VV6A99.cancel()
23891:   self.fileChanged = True
23892:   self.editorTable.VVsd6P()
23893:   VVAkuK = self.VVIh43()
23894:   self.editorTable.VVMqQ9(VVAkuK)
23895:  def VVZff7(self, VV6A99, title, txt, colList):
23896:   totRows = self.editorTable.VVn1uo()
23897:   lineNum = self.editorTable.VVGTqU() + 1 if self.lastLineNum == -1 else self.lastLineNum
23898:   FF4z45(self.VVv0AW, BF(self.VV2cxV, lineNum, totRows), title="Go to Line Num (1 - %d)" % totRows, defaultText="%d" % lineNum, message="Enter Line Number")
23899:  def VV2cxV(self, lineNum, totRows, VVRD20):
23900:   if VVRD20:
23901:    VVRD20 = VVRD20.strip()
23902:    if VVRD20.isdigit():
23903:     num = FFsRWN(int(VVRD20) - 1, 0, totRows - 1)
23904:     self.editorTable.VVrqBw(num)
23905:     self.lastLineNum = num + 1
23906:    else:
23907:     FF28n1(self.editorTable, "Incorrect number", 1500)
23908:  def VVmoPp(self, VV6A99, title, txt, colList):
23909:   if   self.starterRow > -1: VV6A99.VVrqBw(self.starterRow)
23910:   elif self.insertMode == 1: VV6A99.VV5Kmd()
23911:   elif self.insertMode == 2: VV6A99.VVMjPT()
23912:   self.insertMode = 0
23913:   self.starterRow = -1
23914:  def VVVvCv(self, lineNum):
23915:   if lineNum == self.editorTable.VVbyOe():
23916:    self.insertMode = 1
23917:    self.VVyOTA("echo '' >> '%s'" % self.tmpFile)
23918:   else:
23919:    self.insertMode = 2
23920:    self.VVyOTA("sed -i '%d i %s' '%s'" % (lineNum + 1, "", self.tmpFile))
23921:  def VVwsNz(self):
23922:   global VVLtQt
23923:   isMulti = self.editorTable.VVXWPu
23924:   if isMulti : VVLtQt = self.editorTable.VVf3uT(1, isStrip=False)
23925:   else  : VVLtQt = [self.editorTable.VVeE40(1, isStrip=False)]
23926:   FF1mVE(self.editorTable, "Copied to clipboard", 800)
23927:  def VVZyGq(self, VV6A99, title, txt, colList):
23928:   if self.fileChanged:
23929:    if FFj2hO(self.origFile):
23930:     if FFpwZS("cp -f '%s' '%s'" % (self.tmpFile, self.origFile)):
23931:      FF1mVE(VV6A99, "Saved", 800)
23932:      self.fileSaved   = True
23933:      self.fileChanged = False
23934:      VV6A99.VVucBj()
23935:     else:
23936:      FFdw58(self.VVv0AW, "Cannot save file!")
23937:    else:
23938:     FFdw58(self.VVv0AW, "Cannot create backup copy of original file!")
23939:  def VVuYnO(self, VV6A99):
23940:   if self.fileChanged:
23941:    FFRMYv(self.VVv0AW, BF(self.VVJeP1, VV6A99), "Cancel changes ?")
23942:   else:
23943:    FFpwZS("cp -f '%s' '%s'" % (self.tmpFile, self.origFile))
23944:    self.VVJeP1(VV6A99)
23945:  def VVJeP1(self, VV6A99):
23946:   VV6A99.cancel()
23947:   FFwgGB(self.tmpFile)
23948:   if self.VVbYwR:
23949:    self.VVbYwR(self.fileSaved)
23950:  def VVM4gv(self, VV6A99, title, txt, colList):
23951:   lineNum = int(VV6A99.VVeE40(0))
23952:   lineTxt = VV6A99.VVeE40(1, isStrip=False)
23953:   message = VVwdUw + "ORIGINAL TEXT:\n" + VVA4XU + lineTxt
23954:   FF4z45(self.VVv0AW, BF(self.VVSnhm, lineNum), title="File Line", defaultText=lineTxt, message=message)
23955:  def VVSnhm(self, lineNum, VVRD20):
23956:   if not VVRD20 is None:
23957:    if self.editorTable.VVbyOe() <= 1:
23958:     self.VVyOTA("echo %s > '%s'" % (VVRD20, self.tmpFile))
23959:    else:
23960:     self.VVkoCz(lineNum, VVRD20, 1)
23961:  def VVkoCz(self, lineNum, newTxt, mode):
23962:   self.editorTable.VVoNlW("Saving ...")
23963:   lines = FFL19l(self.tmpFile)
23964:   with open(self.tmpFile, "w") as f:
23965:    for ndx, line in enumerate(lines, start=1):
23966:     if lineNum == ndx:
23967:      if   mode == 1: line = newTxt
23968:      elif mode == 2: f.write(newTxt + "\n")
23969:     f.write(line + "\n")
23970:   self.fileChanged = True
23971:   self.editorTable.VVsd6P()
23972:   VVAkuK = self.VVIh43()
23973:   self.editorTable.VVMqQ9(VVAkuK)
23974:  def VVLtpg(self):
23975:   isMulti = self.editorTable.VVXWPu
23976:   if isMulti : lst = self.editorTable.VVf3uT(0)
23977:   else  : lst = [self.editorTable.VVeE40(0)]
23978:   self.editorTable.VVW3QY()
23979:   lines = FFL19l(self.tmpFile)
23980:   with open(self.tmpFile, "w") as f:
23981:    for ndx, line in enumerate(lines, start=1):
23982:     if not str(ndx) in lst:
23983:      f.write(line + "\n")
23984:   self.fileChanged = True
23985:   self.editorTable.VVsd6P()
23986:   VVAkuK = self.VVIh43()
23987:   self.editorTable.VVMqQ9(VVAkuK)
23988:  def VVyOTA(self, cmd):
23989:   FF4iwG(cmd, self.VVHHQq)
23990:   self.fileChanged = True
23991:   self.editorTable.VVsd6P()
23992:  def VVHHQq(self, result, retval):
23993:   VVAkuK = self.VVIh43()
23994:   self.editorTable.VVMqQ9(VVAkuK)
23995:  def VVIh43(self):
23996:   if FFCyVu(self.tmpFile):
23997:    lines = FFL19l(self.tmpFile)
23998:    VVAkuK = []
23999:    if lines:
24000:     for ndx, line in enumerate(lines, start=1):
24001:      VVAkuK.append((str(ndx), line))
24002:    if not VVAkuK:
24003:     VVAkuK.append((str(1), ""))
24004:    return VVAkuK
24005:   else:
24006:    FF8Wsn(self.VVv0AW, self.tmpFile)
24007: class CCoErY():
24008:  def __init__(self, VVv0AW, VVwltY="
24009:   self.VVv0AW = VVv0AW
24010:   self.VV3wat  = []
24011:   self.satList  = []
24012:   self.VVwltY  = VVwltY
24013:   self.VVkxBG   = VVkxBG
24014:  def VVVPGN(self, VVbYwR):
24015:   self.VV3wat = []
24016:   VV3wat, VV0mqE = CCoErY.VVHRan(self.VVv0AW, False, True)
24017:   if VV3wat:
24018:    self.VV3wat += VV3wat
24019:    self.VVIAhz(VVbYwR, VV0mqE)
24020:  def VVmRCa(self, mode, VV6A99, satCol, VVbYwR, inFilterFnc=None):
24021:   VV6A99.VVoNlW("Loading Filters ...")
24022:   self.VV3wat = []
24023:   self.VV3wat.append(("All Services" , "all"))
24024:   if mode == 1:
24025:    self.VV3wat.append(VVAL3j)
24026:    self.VV3wat.append(("Parental Control", "parentalControl" ))
24027:    self.VV3wat.append(("Hidden Services" , "hiddenServices" ))
24028:    self.VV3wat.append(VVAL3j)
24029:    self.VV3wat.append(("Radio Services", "radio"))
24030:    if CCYrUm.VVWp6i() or FFCyVu(VVl57H):
24031:     self.VV3wat.append(("Stream Relay Services", "streamRelay"))
24032:   elif mode == 2:
24033:    self.VV3wat.append(VVAL3j)
24034:    self.VV3wat.append(("Selected Transponder"  , "selectedTP" ))
24035:    self.VV3wat.append(("Channels with no Transponder", "emptyTP"  ))
24036:   self.VVEqow(VV6A99, satCol)
24037:   VV3wat, VV0mqE = CCoErY.VVHRan(self.VVv0AW, True, False)
24038:   if VV3wat:
24039:    VV3wat.insert(0, FF0bQE("Custom Words"))
24040:    self.VV3wat += VV3wat
24041:   VV6A99.VVrmMb()
24042:   self.VVIAhz(VVbYwR, VV0mqE, inFilterFnc)
24043:  def VVywN2(self, VV3wat, sats, VVbYwR, inFilterFnc=None):
24044:   self.VV3wat = VV3wat
24045:   VV3wat, VV0mqE = CCoErY.VVHRan(self.VVv0AW, True, False)
24046:   if VV3wat:
24047:    self.VV3wat.append(FF0bQE("Custom Words"))
24048:    self.VV3wat += VV3wat
24049:   self.VVIAhz(VVbYwR, VV0mqE, inFilterFnc)
24050:  def VVIAhz(self, VVbYwR, VV0mqE, inFilterFnc=None):
24051:   VVwJOl  = ("Filter in Filter", inFilterFnc) if inFilterFnc else None
24052:   VVB4pu = ("Edit Filter"  , BF(self.VViwOH, VV0mqE))
24053:   VVaTeF  = ("Filter Help"  , BF(self.VVJ1xY, VV0mqE))
24054:   FFLFTC(self.VVv0AW, BF(self.VVVWaX, VVbYwR), VV3wat=self.VV3wat, title="Select Filter", VVwJOl=VVwJOl, VVB4pu=VVB4pu, VVaTeF=VVaTeF, VVlaGv=True, VVwltY=self.VVwltY, VVkxBG=self.VVkxBG)
24055:  def VVVWaX(self, VVbYwR, item):
24056:   if item:
24057:    VVbYwR(item)
24058:  def VViwOH(self, VV0mqE, selectionObj, sel):
24059:   if FFCyVu(VV0mqE) : CCyMCP(self.VVv0AW, VV0mqE, VVbYwR=None)
24060:   else       : FF8Wsn(self.VVv0AW, VV0mqE)
24061:   selectionObj.cancel()
24062:  def VVJ1xY(self, VV0mqE, selectionObj, sel):
24063:   FFw2rR(self.VVv0AW, "_help_service_filter", "Service Filter")
24064:  def VVEqow(self, VV6A99, satColNum):
24065:   if not self.satList:
24066:    satList = VV6A99.VVrc5p(satColNum)
24067:    if satList:
24068:     satList = set(satList)
24069:     satList = list(satList)
24070:     if satList:
24071:      sats = []
24072:      for ndx, sat in enumerate(satList):
24073:       if not sat.strip() == "":
24074:        self.satList.append((FFR9yH(sat), "__s__" + sat))
24075:      self.satList.sort(key=lambda x: x[0])
24076:      self.satList.insert(0, FF0bQE("Satellites"))
24077:   if self.VV3wat:
24078:    self.VV3wat += self.satList
24079:  @staticmethod
24080:  def VVHRan(SELF, addTag, VVwb7n):
24081:   FFzcnD()
24082:   fileName  = "ajpanel_services_filter"
24083:   VV0mqE = FF0cqc() + fileName
24084:   VV3wat  = []
24085:   if not FFCyVu(VV0mqE):
24086:    FFpwZS("cp -f '%s' '%s'" % (VVIp2p + fileName, VV0mqE))
24087:   fileFound = False
24088:   if FFCyVu(VV0mqE):
24089:    fileFound = True
24090:    lines = FFL19l(VV0mqE)
24091:    if lines:
24092:     for line in lines:
24093:      line = line.strip()
24094:      if line and not line.startswith("#"):
24095:       if "#" in line:
24096:        line = line.split("#")[0].strip()
24097:       if "," in line:
24098:        lst = list(map(str.strip, line.split(",")))
24099:        lst = list(filter(None, lst))
24100:        if lst: line = ",".join(lst)
24101:        else  : line = ""
24102:       if line:
24103:        if addTag: VV3wat.append((line, "__w__" + line))
24104:        else  : VV3wat.append((line, line))
24105:   if VVwb7n:
24106:    if   not fileFound : FF8Wsn(SELF, VV0mqE)
24107:    elif not VV3wat : FFNICS(SELF, VV0mqE)
24108:   return VV3wat, VV0mqE
24109:  @staticmethod
24110:  def VVPBNm(txt):
24111:   txt = txt.strip()
24112:   lst = []
24113:   prefix = False
24114:   if "," in txt:
24115:    lst = list(map(str.strip, txt.split(",")))
24116:    lst = list(filter(None, lst))
24117:    if lst and len(lst) > 1 and lst[0] == "^":
24118:     lst = lst[1:]
24119:     prefix = True
24120:   else:
24121:    txt = txt.strip()
24122:    if txt:
24123:     if len(txt) > 1 and txt.startswith("^"):
24124:      txt = txt[1:]
24125:      prefix = True
24126:     lst = [txt]
24127:   return tuple(map(str.lower, lst)), prefix
24128: class CCzSCo():
24129:  def __init__(self, VVv0AW, VV6A99, addSep=True, setsOk=False, setsRed=False, setsGreen=False, setsYellow=False, setsBlue=False):
24130:   self.VVv0AW = VVv0AW
24131:   self.VV6A99 = VV6A99
24132:   self.VV6A99.VVcqGs  = setsOk
24133:   self.VV6A99.VVJ6ki  = setsRed
24134:   self.VV6A99.VVGxei = setsGreen
24135:   self.VV6A99.VVez0o = setsYellow
24136:   self.VV6A99.VVMayE = setsBlue
24137:   self.VV3wat = []
24138:   iMulSel = self.VV6A99.VViNen()
24139:   if iMulSel : self.VV3wat.append( ("Disable Multi-Select " , "MultSelDisab" ))
24140:   else  : self.VV3wat.append( ("Enable Multi-Select"  , "multSelEnab"  ))
24141:   tot = self.VV6A99.VVc5NH()
24142:   self.VV3wat.append(    ("Select all"    , "selectAll"  ))
24143:   if iMulSel and tot > 0:
24144:    self.VV3wat.append(   ("Unselect all"    , "unselectAll"  ))
24145:   if addSep:
24146:    self.VV3wat.append(VVAL3j)
24147:  def VV9VR2(self, extraMenu, cbFncDict, width=1000, height=850, VVwltY="#22003344", VVkxBG="#22002233", VVptue=0.15):
24148:   if extraMenu:
24149:    self.VV3wat.extend(extraMenu)
24150:   FFLFTC(self.VVv0AW, BF(self.VVIdPJ, cbFncDict), width=width, height=height, VVptue=VVptue, title="Options", VV3wat=self.VV3wat, VVwltY=VVwltY, VVkxBG=VVkxBG)
24151:  def VVIdPJ(self, cbFncDict, item=None):
24152:   if item:
24153:    if   item == "multSelEnab" : self.VV6A99.VVL66W()
24154:    elif item == "MultSelDisab" : self.VV6A99.VVW3QY()
24155:    elif item == "selectAll" : self.VV6A99.VVtrFZ()
24156:    elif item == "unselectAll" : self.VV6A99.VV3Ezh()
24157:    elif cbFncDict:
24158:     fnc = cbFncDict.get(item)
24159:     if fnc:
24160:      fnc()
24161: class CCbQCK(Screen):
24162:  def __init__(self, session):
24163:   self.skin, self.VVfOli = FFiNEe(VVHfYH, 900, 480, 50, 0, 0, "#22660066", "#22330033", 35, VVeFSs=40)
24164:   self.session = session
24165:   FFZMxC(self, title="Date/Time -> Manual Mode")
24166:   FFRLNq(self["keyRed"]  , "Exit")
24167:   FFRLNq(self["keyGreen"]  , "Save")
24168:   FFRLNq(self["keyYellow"] , "Refresh")
24169:   FFRLNq(self["keyBlue"]  , "NTP Mode")
24170:   self["curTime"]  = Label()
24171:   self["yearTitle"] = Label("Year")
24172:   self["monthTitle"] = Label("Month")
24173:   self["dayTitle"] = Label("Day")
24174:   self["gapTitle"] = Label()
24175:   self["hourTitle"] = Label("Hour")
24176:   self["minTitle"] = Label("Min")
24177:   self["secTitle"] = Label("Sec")
24178:   self["year"]  = Label()
24179:   self["month"]  = Label()
24180:   self["day"]   = Label()
24181:   self["gap"]   = Label()
24182:   self["hour"]  = Label()
24183:   self["min"]   = Label()
24184:   self["sec"]   = Label()
24185:   self.index   = 0
24186:   self.list   = [self["year"], self["month"], self["day"], self["hour"], self["min"], self["sec"]]
24187:   self.timer   = eTimer()
24188:   self["gapTitle"].hide()
24189:   self["gap"].hide()
24190:   FFHlAU(self,
24191:   {
24192:    "red" : self.VVf07a  ,
24193:    "green" : self.VVktHt ,
24194:    "yellow": self.VVj2LV  ,
24195:    "blue" : self.VVAo2T   ,
24196:    "up" : self.VVx0di    ,
24197:    "down" : self.VVDBsZ   ,
24198:    "left" : self.VVziFC   ,
24199:    "right" : self.VVLe1s   ,
24200:    "cancel": self.VVf07a
24201:   })
24202:   self.onShown.append(self.VV7OzD)
24203:   self.onClose.append(self.onExit)
24204:  def VV7OzD(self):
24205:   self.onShown.remove(self.VV7OzD)
24206:   self.VVj2LV()
24207:   self.VVwhvR()
24208:   FFWgBS(self)
24209:   try: self.timer_conn = self.timer.timeout.connect(self.VVVuVb)
24210:   except: self.timer.callback.append(self.VVVuVb)
24211:   self.timer.start(1000, False)
24212:   self.VVVuVb()
24213:  def onExit(self):
24214:   self.timer.stop()
24215:  def VVf07a(self) : self.close(True)
24216:  def VVut7N(self) : self.close(False)
24217:  def VVAo2T(self):
24218:   self.session.openWithCallback(self.VVU1fm, BF(CCvlWs))
24219:  def VVU1fm(self, VVJ2pQ):
24220:   if VVJ2pQ:
24221:    self.close()
24222:  def VVVuVb(self):
24223:   self["curTime"].setText(str(FFTS4w(iTime())))
24224:  def VVx0di(self):
24225:   self.VVtR6o(1)
24226:  def VVDBsZ(self):
24227:   self.VVtR6o(-1)
24228:  def VVziFC(self):
24229:   self.index -= 1
24230:   if self.index < 0:
24231:    self.index = 5
24232:   self.VVwhvR()
24233:  def VVLe1s(self):
24234:   self.index += 1
24235:   if self.index > 5:
24236:    self.index = 0
24237:   self.VVwhvR()
24238:  def VVtR6o(self, increment):
24239:   year = int(self["year" ].getText())
24240:   month = int(self["month"].getText())
24241:   if   self.index == 0: minVal, maxVal = 2000, 3000
24242:   elif self.index == 1: minVal, maxVal = 1, 12
24243:   elif self.index == 2: minVal, maxVal = 1, self.VV3rkL(month, year)
24244:   elif self.index == 3: minVal, maxVal = 0, 23
24245:   elif self.index == 4: minVal, maxVal = 0, 59
24246:   elif self.index == 5: minVal, maxVal = 0, 59
24247:   val  = int(self.list[self.index].getText()) + increment
24248:   if val < minVal: val = maxVal
24249:   if val > maxVal: val = minVal
24250:   if self.index == 0:
24251:    val = "%04d" % val
24252:   else:
24253:    val = "%02d" % val
24254:   self.list[self.index].setText(val)
24255:   if self.index < 2:
24256:    year = int(self["year" ].getText())
24257:    month = int(self["month"].getText())
24258:    day = int(self["day"].getText())
24259:    monthDays = self.VV3rkL(month, year)
24260:    if day > monthDays:
24261:     self["day"].setText("%02d" % monthDays)
24262:  def VV3rkL(self, month, year):
24263:   MonthList = [31,28,31,30,31,30,31,31,30,31,30,31]
24264:   days = MonthList[month-1]
24265:   if (month == 2) and (self.VVu7Bq(year)):
24266:    days += 1
24267:   return days
24268:  def VVu7Bq(self, year):
24269:   if year % 4 == 0:
24270:    if year % 100 == 0:
24271:     if year % 400 == 0:
24272:      return True
24273:     else:
24274:      return False
24275:    else:
24276:     return True
24277:   else:
24278:    return False
24279:  def VVwhvR(self):
24280:   for obj in self.list:
24281:    FFZ0AC(obj, "#11404040")
24282:   FFZ0AC(self.list[self.index], "#11ff8000")
24283:  def VVj2LV(self):
24284:   year, month, day, hour, minute, second, weekDay, yearDay, dayLight = localtime()
24285:   self["year" ].setText("%04d" % year)
24286:   self["month"].setText("%02d" % month)
24287:   self["day"  ].setText("%02d" % day)
24288:   self["hour" ].setText("%02d" % hour)
24289:   self["min"  ].setText("%02d" % minute)
24290:   self["sec"  ].setText("%02d" % second)
24291:  def VVktHt(self):
24292:   year = int(self["year" ].getText())
24293:   month = self["month"].getText()
24294:   day  = self["day"  ].getText()
24295:   hour = self["hour" ].getText()
24296:   minute = self["min"  ].getText()
24297:   second = self["sec"  ].getText()
24298:   cmd = "date -s '%s-%s-%s %s:%s:%s'" % (year, month, day, hour, minute, second)
24299:   FF4iwG("echo -e 'System Response:\n'; %s" % cmd, self.VVVobm)
24300:  def VVVobm(self, result, retval):
24301:   result = str(result.strip())
24302:   if len(result) == 0 : FFipXT(self, "Nothing returned from the system!")
24303:   else    : FFipXT(self, str(result))
24304: class CCvlWs(Screen):
24305:  def __init__(self, session):
24306:   self.skin, self.VVfOli = FFiNEe(VVf2e8, 900, 480, 50, 40, 10, "#22660066", "#22330033", 35, VVeFSs=40)
24307:   self.session = session
24308:   FFZMxC(self, title="Date/Time -> NTP Mode", addLabel=True)
24309:   FFRLNq(self["keyRed"]  , "Exit")
24310:   FFRLNq(self["keyGreen"]  , "Sync")
24311:   FFRLNq(self["keyYellow"] , "Refresh")
24312:   FFRLNq(self["keyBlue"]  , "Manual Mode")
24313:   FFHlAU(self,
24314:   {
24315:    "red" : self.VVf07a   ,
24316:    "green" : self.VVYuW7  ,
24317:    "yellow": self.VVhfAa ,
24318:    "blue" : self.VVocqg  ,
24319:    "cancel": self.VVf07a
24320:   })
24321:   self.VV5YRV()
24322:   self.onShown.append(self.VV7OzD)
24323:  def VV7OzD(self):
24324:   self.onShown.remove(self.VV7OzD)
24325:   FFWgBS(self)
24326:   FFIElK(self.VVTwnW)
24327:  def VVTwnW(self):
24328:   self.VVABcY()
24329:   self.VVFaDd(False)
24330:  def VVf07a(self)  : self.close(True)
24331:  def VVocqg(self) : self.close(False)
24332:  def VV5YRV(self):
24333:   self["myLabel"].setText("Getting NTP time ... ")
24334:  def VVABcY(self):
24335:   self.VVj52G()
24336:   self.VVe3c6()
24337:   self.VViJ8W()
24338:   self.VVZGfm()
24339:  def VVhfAa(self):
24340:   if len(self["keyYellow"].getText()) > 0:
24341:    self.VV5YRV()
24342:    self.VVABcY()
24343:    FFIElK(self.VVTwnW)
24344:  def VVYuW7(self):
24345:   if len(self["keyGreen"].getText()) > 0:
24346:    FFRMYv(self, self.VVo4ln, "Synchronize with Internet Date/Time ?")
24347:  def VVo4ln(self):
24348:   self.VVABcY()
24349:   FFIElK(BF(self.VVFaDd, True))
24350:  def VVj52G(self)  : self["keyRed"].show()
24351:  def VVVpIB(self)  : self["keyGreen"].show()
24352:  def VVfqnf(self) : self["keyYellow"].show()
24353:  def VVP4Uw(self)  : self["keyBlue"].show()
24354:  def VVe3c6(self)  : self["keyGreen"].hide()
24355:  def VViJ8W(self) : self["keyYellow"].hide()
24356:  def VVZGfm(self)  : self["keyBlue"].hide()
24357:  def VVFaDd(self, sync):
24358:   localTime = FFIPdt()
24359:   ok = False
24360:   server_list = ['ntp.iitb.ac.in', 'time.nist.gov', 'time.windows.com', 'pool.ntp.org']
24361:   for server in server_list:
24362:    epoch_time = self.VVsUeC(server)
24363:    if epoch_time is not None:
24364:     ntpTime = FFTS4w(epoch_time)
24365:     time1 = mktime(datetime.strptime(localTime, "%Y-%m-%d %H:%M:%S").timetuple())
24366:     time2 = mktime(datetime.strptime(ntpTime  , "%Y-%m-%d %H:%M:%S").timetuple())
24367:     diff = time1 - time2
24368:     if   diff == 0 : timeDiff = "None"
24369:     elif diff == 1 : timeDiff = "%d second"  % diff
24370:     else   : timeDiff = "%d seconds" % diff
24371:     timeDiff = "Difference\t=  %s" % timeDiff
24372:     if sync:
24373:      FF4iwG("echo -e '\nSystem Response:\n'; date -s '%s'" % ntpTime, BF(self.VVVobm, True))
24374:     else:
24375:      txt = "Local Time\t= %s\nInternet Time\t= %s\n%s\n" % (localTime, ntpTime, timeDiff)
24376:      self["myLabel"].setText(txt)
24377:     ok = True
24378:     break
24379:    else:
24380:     pass
24381:   self.VVfqnf()
24382:   self.VVP4Uw()
24383:   if ok:
24384:    self.VVVpIB()
24385:   else:
24386:    self["myLabel"].setText("Local Time\t= %s\n\nCould not get NTP time !\n" % localTime)
24387:  def VVVobm(self, syncAgain, result, retval):
24388:   result = str(result.strip())
24389:   if   len(result) == 0  : result = "\n\nNothing returned from the system!"
24390:   elif result.count("\n") < 20: result = "\n\n" + result
24391:   try:
24392:    self["myLabel"].setText(result)
24393:    if syncAgain:
24394:     self.VVFaDd(False)
24395:   except:
24396:    pass
24397:  def VVsUeC(self, addr='time.nist.gov'):
24398:   from socket import socket, AF_INET, SOCK_DGRAM
24399:   from struct import unpack as iUnpack
24400:   time1970 = 2208988800
24401:   data  = '\x1b' + 47 * '\0'
24402:   data  = data.encode()
24403:   if CCuqoc.VVSuvZ():
24404:    try:
24405:     client = socket(AF_INET, SOCK_DGRAM)
24406:     client.settimeout(1.0)
24407:     client.sendto(data, (addr, 123))
24408:     data, address = client.recvfrom(1024)
24409:     if data:
24410:      epoch_time = iUnpack('!12I', data)[10]
24411:      epoch_time -= time1970
24412:      return epoch_time
24413:    except:
24414:     pass
24415:   return None
24416: class CCoFdR(Screen):
24417:  def __init__(self, session):
24418:   self.skin, self.VVfOli = FFiNEe(VVQrjc, 900, 300, 50, 20, 0, "#22000060", "#22000020", 35)
24419:   self.session  = session
24420:   FFZMxC(self, addLabel=True, addCloser=True)
24421:   self["myTitle"].setText("  Internet Connectivity")
24422:   self["myLabel"].setText("Checking Connection ...")
24423:   self.onShown.append(self.VV7OzD)
24424:  def VV7OzD(self):
24425:   self.onShown.remove(self.VV7OzD)
24426:   FFIElK(self.VVUUii)
24427:  def VVUUii(self):
24428:   if CCuqoc.VVSuvZ() : color, txt = "#22002020", "Internet Connection = Successful."
24429:   else     : color, txt = "#22500000", "Cannot connect (or server is down) !"
24430:   try:
24431:    self["myLabel"].setText("  " + txt)
24432:    FFZ0AC(self["myBody"], color)
24433:    FFZ0AC(self["myLabel"], color)
24434:   except:
24435:    pass
24436: class CCtKqU(Screen):
24437:  VV0DI2 = None
24438:  def __init__(self, session):
24439:   size = CFG.signalSize.getValue()
24440:   screenW = FFrPd1()[0]
24441:   ratio = size / 5.0
24442:   self.skin, self.VVfOli = FFiNEe(VVnhJ8, 650, 320, 26, 20, 20, "#22003040", "#22001122", 25, VVFz5T=ratio)
24443:   self.session   = session
24444:   self["mySNRdB"]   = Label()
24445:   self["mySNR"]   = Label()
24446:   self["myAGC"]   = Label()
24447:   self["myBER"]   = Label()
24448:   self["mySliderSNR"]  = Pixmap()
24449:   self["mySliderAGC"]  = Pixmap()
24450:   self["mySliderBER"]  = Pixmap()
24451:   self["mySliderCovSNR"] = Label()
24452:   self["mySliderCovAGC"] = Label()
24453:   self["mySliderCovBER"] = Label()
24454:   color     = self.VVfOli["VVPTnB"]
24455:   self.sliderSNR   = CCAbWp(self, self["mySliderSNR"], self["mySliderCovSNR"], minN=0, maxN=100, covColor=color)
24456:   self.sliderAGC   = CCAbWp(self, self["mySliderAGC"], self["mySliderCovAGC"], minN=0, maxN=100, covColor=color)
24457:   self.sliderBER   = CCAbWp(self, self["mySliderBER"], self["mySliderCovBER"], minN=0, maxN=100, covColor=color)
24458:   self["myTPInfo"]  = Label()
24459:   self.timer    = eTimer()
24460:   self.tunerInfo   = CCOZ3M()
24461:   self.stateCounter  = 0
24462:   self.top    = 0
24463:   self.left    = 0
24464:   self.curPosNum   = CFG.signalPos.getValue()
24465:   self.curSize   = CFG.signalSize.getValue()
24466:   self.tpData    = CC3Z54()
24467:   FFZMxC(self, title="Signal")
24468:   FFHlAU(self,
24469:   {
24470:    "ok"  : self.close      ,
24471:    "up"  : self.VVx0di       ,
24472:    "down"  : self.VVDBsZ      ,
24473:    "left"  : self.VVziFC      ,
24474:    "right"  : self.VVLe1s      ,
24475:    "info"  : self.VVyiuk     ,
24476:    "epg"  : self.VVyiuk     ,
24477:    "menu"  : self.VVOz5Q      ,
24478:    "cancel" : self.close      ,
24479:    "red"  : self.close      ,
24480:    "last"  : BF(self.VVmvbJ, -1)  ,
24481:    "next"  : BF(self.VVmvbJ, 1)  ,
24482:    "pageUp" : BF(self.VVdMXX, True) ,
24483:    "chanUp" : BF(self.VVdMXX, True) ,
24484:    "pageDown" : BF(self.VVdMXX, False) ,
24485:    "chanDown" : BF(self.VVdMXX, False) ,
24486:    "0"   : BF(self.VVmvbJ, 0)  ,
24487:    "1"   : BF(self.VVH1bN, pos=1) ,
24488:    "2"   : BF(self.VVH1bN, pos=2) ,
24489:    "3"   : BF(self.VVH1bN, pos=3) ,
24490:    "4"   : BF(self.VVH1bN, pos=4) ,
24491:    "5"   : BF(self.VVH1bN, pos=5) ,
24492:    "6"   : BF(self.VVH1bN, pos=6) ,
24493:    "7"   : BF(self.VVH1bN, pos=7) ,
24494:    "8"   : BF(self.VVH1bN, pos=8) ,
24495:    "9"   : BF(self.VVH1bN, pos=9) ,
24496:   })
24497:   self.onShown.append(self.VV7OzD)
24498:   self.onClose.append(self.onExit)
24499:  def VV7OzD(self):
24500:   self.onShown.remove(self.VV7OzD)
24501:   if not CCtKqU.VV0DI2:
24502:    CCtKqU.VV0DI2 = self
24503:   self.sliderSNR.VVi3uI()
24504:   self.sliderAGC.VVi3uI()
24505:   self.sliderBER.VVi3uI(isBER=True)
24506:   pos   = self.instance.position()
24507:   self.left = pos.x()
24508:   self.top = pos.y()
24509:   self.VVH1bN()
24510:   self.VVEPh9()
24511:   try: self.timer_conn = self.timer.timeout.connect(self.VVXpZW)
24512:   except: self.timer.callback.append(self.VVXpZW)
24513:   self.timer.start(500, False)
24514:  def VVEPh9(self):
24515:   service = self.session.nav.getCurrentService()
24516:   self.tunerInfo.VVAo5r(service)
24517:   serviceName = self.tunerInfo.VVvVTk()
24518:   if not serviceName   : serviceName = "Signal"
24519:   if len(serviceName) > 25 : serviceName = serviceName[:25] + ".."
24520:   self["myTitle"].setText("  " + serviceName)
24521:   s = CC3rDi(self.session)
24522:   self["myTPInfo"].setText(self.tpData.VVsDkA([s.VVPxk5, s.VVAQqG], maxLen=54))
24523:  def VVXpZW(self):
24524:   s = CC3rDi(self.session)
24525:   self.tunerInfo.VVAo5r(s.servPtr)
24526:   if self.tunerInfo.infoAvailable:
24527:    self["mySNRdB"].setText(self.tunerInfo.VVSwl4())
24528:    self["mySNR"].setText(self.tunerInfo.VVlX6a())
24529:    self["myAGC"].setText(self.tunerInfo.VVr4Yo())
24530:    self["myBER"].setText(self.tunerInfo.VVU8EL())
24531:    self.sliderSNR.VVMjzk(self.tunerInfo.VVRpcw())
24532:    self.sliderAGC.VVMjzk(self.tunerInfo.VVX9tR())
24533:    self.sliderBER.VVMjzk(self.tunerInfo.VVZwV4())
24534:   else:
24535:    self["mySNRdB"].setText("")
24536:    self["mySNR"].setText("?")
24537:    self["myAGC"].setText("?")
24538:    self["myBER"].setText("?")
24539:    self.sliderSNR.VVMjzk(0)
24540:    self.sliderAGC.VVMjzk(0)
24541:    self.sliderBER.VVMjzk(0)
24542:   if self.stateCounter > -1:
24543:    self.stateCounter += 1
24544:    if self.stateCounter > 8:
24545:     self.stateCounter = -1
24546:    else:
24547:     if s.state.startswith("*"):
24548:      FF28n1(self, s.state.replace("*", ""), 1500)
24549:      self.stateCounter = -1
24550:  def VVyiuk(self):
24551:   CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVvrVY)
24552:  def VVOz5Q(self):
24553:   FFw2rR(self, "_help_signal", "Signal Monitor (Keys)")
24554:  def VVx0di(self)  : self.VVH1bN(posMap={7:4, 4:1, 8:5, 5:2, 9:6, 6:3})
24555:  def VVDBsZ(self) : self.VVH1bN(posMap={1:4, 4:7, 2:5, 5:8, 3:6, 6:9})
24556:  def VVziFC(self) : self.VVH1bN(posMap={3:2, 2:1, 6:5, 5:4, 9:8, 8:7})
24557:  def VVLe1s(self) : self.VVH1bN(posMap={1:2, 2:3, 4:5, 5:6, 7:8, 8:9})
24558:  def VVH1bN(self, posMap=None, pos=-1):
24559:   if pos > -1 or posMap:
24560:    if pos > -1:
24561:     self.curPosNum = pos
24562:    elif posMap:
24563:     self.curPosNum = posMap.get(self.curPosNum, self.curPosNum)
24564:    FFjt1c(CFG.signalPos, self.curPosNum)
24565:   scrSize = getDesktop(0).size()
24566:   gapH = gapV = 20
24567:   w  = self.instance.size().width()
24568:   h  = self.instance.size().height()
24569:   left = self.left
24570:   top  = self.top
24571:   bot  = scrSize.height() - h - gapV
24572:   rigth = scrSize.width()  - w - gapH
24573:   if   self.curPosNum == 1: left, top = gapH , gapV
24574:   elif self.curPosNum == 2: left, top = left , gapV
24575:   elif self.curPosNum == 3: left, top = rigth , gapV
24576:   elif self.curPosNum == 4: left, top = gapH , top
24577:   elif self.curPosNum == 5: left, top = left , top
24578:   elif self.curPosNum == 6: left, top = rigth , top
24579:   elif self.curPosNum == 7: left, top = gapH , bot
24580:   elif self.curPosNum == 8: left, top = left , bot
24581:   elif self.curPosNum == 9: left, top = rigth , bot
24582:   else     : left, top = left , top
24583:   self.instance.move(ePoint(left, top))
24584:  def VVmvbJ(self, sizeNum):
24585:   oldSizeNum = CFG.signalSize.getValue()
24586:   if sizeNum == 0:
24587:    sizeNum = 5
24588:   else:
24589:    sizeNum += oldSizeNum
24590:    sizeNum = FFsRWN(sizeNum, 1, 13)
24591:   if not oldSizeNum == sizeNum:
24592:    FFjt1c(CFG.signalSize, sizeNum)
24593:    self.close(True)
24594:  def onExit(self):
24595:   self.timer.stop()
24596:   CCtKqU.VV0DI2 = None
24597:  def VVdMXX(self, isUp):
24598:   FF28n1(self)
24599:   try:
24600:    if isUp : InfoBar.instance.zapDown()
24601:    else : InfoBar.instance.zapUp()
24602:    self.stateCounter = 0
24603:    self.VVEPh9()
24604:   except:
24605:    pass
24606: class CCAbWp(object):
24607:  def __init__(self, SELF, barObj, covObj, minN=0, maxN=100, covColor="#00440000"):
24608:   self.SELF   = SELF
24609:   self.barObj   = barObj
24610:   self.covObj   = covObj
24611:   self.minN   = minN
24612:   self.maxN   = maxN
24613:   self.covColor  = covColor
24614:   self.isColormode = False
24615:  def VVi3uI(self, isBER=False):
24616:   self.barWidth = self.barObj.instance.size().width()
24617:   self.VVeFSs = self.barObj.instance.size().height()
24618:   self.barLeft = self.barObj.getPosition()[0]
24619:   self.barTop  = self.barObj.getPosition()[1]
24620:   if isBER:
24621:    FFZ0AC(self.covObj, "#0aaa0000")
24622:    self.isColormode = True
24623:   else:
24624:    path = VVIp2p +  "bar_sig.png"
24625:    if FFBFPY(self.barObj, path):
24626:     FFZ0AC(self.covObj, self.covColor)
24627:    else:
24628:     FFZ0AC(self.covObj, "#00006688")
24629:     self.isColormode = True
24630:   self.VVMjzk(0)
24631:  def VVMjzk(self, val):
24632:   val  = FFsRWN(val, self.minN, self.maxN)
24633:   width = int(FFjFSv(val, 0, 100, 0, self.barWidth))
24634:   height = int(self.VVeFSs)
24635:   if self.isColormode:
24636:    self.covObj.instance.resize(eSize(*(width, height)))
24637:   else:
24638:    width = int(FFsRWN(self.barWidth - width, 0, self.barWidth))
24639:    top  = int(self.barTop)
24640:    left = int(self.barLeft + self.barWidth - width)
24641:    self.covObj.hide()
24642:    self.covObj.instance.resize(eSize(*(width, height)))
24643:    self.covObj.instance.move(ePoint(left, top))
24644:    self.covObj.show()
24645: class CCh3tv(Screen):
24646:  VVARhl = 0
24647:  VVgJkc  = 1
24648:  VVQJNo = 2
24649:  VVYfDc = 3
24650:  def __init__(self, session, VVLL7M="Processing ...", endTitle="Finishing ...", VVixvy=None, VVIZBP=VVARhl, totBars=1, titleBg="#0a042328", bodyBg="#0a042328", barBg="#0a995533"):
24651:   ratio = self.VVq0XK(VVIZBP)
24652:   if totBars == 1 : h, margT = 150, 20
24653:   else   : h, margT = 200, 15
24654:   self.skin, self.VVfOli = FFiNEe(VVsg3D, 900, h, 30, 20, margT, titleBg, bodyBg, 30, VVFz5T=ratio, VVUuJZ={"totBars":totBars})
24655:   self.session  = session
24656:   self.VVIZBP  = VVIZBP
24657:   self.totBars  = totBars
24658:   self.barBg   = barBg
24659:   self.VVLL7M = VVLL7M
24660:   self.newTitle  = self.VVLL7M
24661:   self.endTitle  = endTitle
24662:   self.VVixvy  = VVixvy
24663:   self.isCancelled = False
24664:   self.isError  = False
24665:   self.maxValue  = 0
24666:   self.maxValue2  = 0
24667:   self.barWidth  = 0
24668:   self.VVeFSs  = 0
24669:   self.counter  = 0
24670:   self.counter2  = 0
24671:   self.VVNc18 = None
24672:   self.timer   = eTimer()
24673:   self.myThread  = None
24674:   FFZMxC(self, title=self.VVLL7M)
24675:   for i in range(1, 3):
24676:    self["myProgFr%s"  % i] = Label()
24677:    self["myProgBG%s"  % i] = Label()
24678:    self["myProgFG%s"  % i] = Label()
24679:    self["myProgVal%s" % i] = Label()
24680:   FFHlAU(self, {"cancel" : self.cancel})
24681:   self.onShown.append(self.VV7OzD)
24682:   self.onClose.append(self.onExit)
24683:  def VV7OzD(self):
24684:   self.onShown.remove(self.VV7OzD)
24685:   self.VVP1TC()
24686:   for i in range(1, 3):
24687:    self["myProgVal%s" % i].setText("0%")
24688:   for i in range(1, 3):
24689:    FFZ0AC(self["myProgFG%s" % i], self.barBg)
24690:    size = self["myProgVal%s" % i].instance.size()
24691:    self.barWidth = int(size.width())
24692:    self.VVeFSs = int(size.height())
24693:    self.VVHMlK()
24694:   try: self.timer_conn = self.timer.timeout.connect(self.VVHMlK)
24695:   except: self.timer.callback.append(self.VVHMlK)
24696:   self.timer.start(50, False)
24697:   self.myThread = iThread(name="ajp_progBar", target=BF(self.VVixvy, self))
24698:   self.myThread.start()
24699:  def VVq8NF(self, val):
24700:   self.maxValue = val
24701:  def VVUIH1(self, val):
24702:   self.maxValue2 = val
24703:  def VVSW9b(self, catName):
24704:   self.newTitle = "Found %d    %d/%d %s" % (len(self.VVNc18), self.counter, self.maxValue, catName)
24705:  def VV6j41(self, ev, pic):
24706:   self.newTitle = "Downloading ... Events: %s    PIcons: %s" % (ev, pic)
24707:  def VV0ddK(self, tot):
24708:   self.newTitle = "Downloaded %d    Processed : %d of %d" % (tot, self.counter, self.maxValue)
24709:  def VVYQKA(self, tot, evName):
24710:   self.newTitle = "Translated: %d   ... %d/%d >> %s" % (tot, self.counter, self.maxValue, evName)
24711:  def VVK5RO(self, tot, name):
24712:   self.newTitle = "Added: %d   ... %d/%d >> %s" % (tot, self.counter, self.maxValue, name)
24713:  def VVaks5(self, txt):
24714:   self.newTitle = str(txt)
24715:  def VVxtQs(self, addVal, showFound=False):
24716:   try:
24717:    self.counter += addVal
24718:    if showFound:
24719:     self.newTitle = "Found : %d    .. Processed : %d of %d" % (len(self.VVNc18), self.counter, self.maxValue)
24720:   except:
24721:    pass
24722:  def VVEpLv(self, addVal, totFound):
24723:   try:
24724:    self.counter += addVal
24725:    self.newTitle = "Found : %d    .. Processed : %s of %s" % (totFound, self.counter, self.maxValue)
24726:   except:
24727:    pass
24728:  def VVg2Dw(self, addVal):
24729:   try:
24730:    self.counter2 += addVal
24731:   except:
24732:    pass
24733:  def VV78Id(self, val):
24734:   try:
24735:    self.counter = val
24736:   except:
24737:    pass
24738:  def VVV3RA(self, val):
24739:   try:
24740:    self.counter2 = val
24741:   except:
24742:    pass
24743:  def VVlmol(self):
24744:   self.isError = True
24745:   self.cancel()
24746:  def onExit(self):
24747:   self.timer.stop()
24748:  def cancel(self):
24749:   self.timer.stop()
24750:   self.isCancelled = True
24751:   self.VVsre8(False)
24752:  def VVsre8(self, isDone):
24753:   self.close(isDone, self.VVNc18, self.counter, self.maxValue, self.isError)
24754:  def VVHMlK(self):
24755:   if   self.newTitle  : self["myTitle"].setText("  %s  " % self.newTitle)
24756:   elif self.maxValue > 0 : self["myTitle"].setText("  %s  ( %d of %d ) ..." % (self.VVLL7M, self.counter, self.maxValue))
24757:   if self.maxValue > 0:
24758:    val = FFsRWN(self.counter, 0, self.maxValue)
24759:    width = int(FFjFSv(val, 0, self.maxValue, 0, self.barWidth))
24760:    self["myProgVal1"].setText(str(int(val * 100.0 / self.maxValue)) + "%")
24761:   else:
24762:    width = 0
24763:   self["myProgFG1"].instance.resize(eSize(*(width, self.VVeFSs)))
24764:   if self.maxValue2 > 0:
24765:    val = FFsRWN(self.counter2, 0, self.maxValue2)
24766:    width = int(FFjFSv(val, 0, self.maxValue2, 0, self.barWidth))
24767:    self["myProgVal2"].setText(str(int(val * 100.0 / self.maxValue2)) + "%")
24768:   else:
24769:    width = 0
24770:   self["myProgFG2"].instance.resize(eSize(*(width, self.VVeFSs)))
24771:   if self.myThread and not self.myThread.is_alive():
24772:    self.timer.stop()
24773:    self["myTitle"].setText("  %s  " % self.endTitle)
24774:    self.VVsre8(True)
24775:  def VVP1TC(self):
24776:   if self.totBars == 1:
24777:    self["myProgFr2"].hide()
24778:    self["myProgFG2"].hide()
24779:    self["myProgBG2"].hide()
24780:    self["myProgVal2"].hide()
24781:   scrW = getDesktop(0).size().width()
24782:   winW = self.instance.size().width()
24783:   gap  = 30
24784:   if self.VVIZBP in (self.VVARhl, self.VVgJkc):
24785:    self.instance.move(ePoint(int(scrW - winW - gap), gap))
24786:  def VVq0XK(self, VVIZBP):
24787:   if   VVIZBP == self.VVARhl : return 0.7
24788:   if   VVIZBP == self.VVgJkc : return 0.5
24789:   if   VVIZBP == self.VVQJNo: return 0.5
24790:   else           : return 1
24791:  @staticmethod
24792:  def VV7Nf4(SELF, **kwargs):
24793:   VVbYwR = kwargs.pop("VVbYwR", None)
24794:   SELF.session.openWithCallback(VVbYwR, CCh3tv, **kwargs)
24795: class CCaTk8(object):
24796:  def __init__(self):
24797:   self.VV2ilt = {}
24798:   self.VVHvdg  = {}
24799:   self.VVimES = {}
24800:   self.VVbYwR = {}
24801:   self.VVuiSx = False
24802:   self.VVyCS0  = FFgrjX()
24803:  def VVtIZD(self, cmd, VVbYwR, VVimES=None, VVXgOC=None):
24804:   self.VVuiSx = True
24805:   name = cmd
24806:   i  = 0
24807:   while name in self.VV2ilt:
24808:    name = cmd + '_' + str(i)
24809:    i += 1
24810:   self.VVHvdg[name] = ""
24811:   self.VVimES[name] = VVimES
24812:   self.VVbYwR[name] = VVbYwR
24813:   try:
24814:    from enigma import eConsoleAppContainer
24815:    self.VV2ilt[name] = eConsoleAppContainer()
24816:    if self.VVyCS0:
24817:     self.VV2ilt[name].dataAvail_conn = self.VV2ilt[name].dataAvail.connect(BF(self.VVMUWQ, name))
24818:     self.VV2ilt[name].appClosed_conn = self.VV2ilt[name].appClosed.connect(BF(self.VVQ9iV , name))
24819:    else:
24820:     self.VV2ilt[name].dataAvail.append(BF(self.VVMUWQ, name))
24821:     self.VV2ilt[name].appClosed.append(BF(self.VVQ9iV , name))
24822:   except:
24823:    self.VVuiSx = False
24824:    return False
24825:   if isinstance(cmd, str):
24826:    cmd = [cmd]
24827:   if VVXgOC:
24828:    try:
24829:     self.VV2ilt[name].setCWD(VVXgOC)
24830:    except:
24831:     pass
24832:   retval = self.VV2ilt[name].execute(*cmd)
24833:   if retval:
24834:    self.VVQ9iV(name, retval)
24835:   return True
24836:  def VVMUWQ(self, name, data):
24837:   try:
24838:    data = data.decode("UTF-8")
24839:   except:
24840:    data = "%s%s\n" % ("" if self.VVHvdg[name].endswith("\n") else "\n", FFjt5L("[UN-DECODED STRING]", VVyFI2))
24841:   self.VVHvdg[name] += data
24842:   if self.VVimES[name]:
24843:    self.VVimES[name](data)
24844:  def VVQ9iV(self, name, retval):
24845:   if not self.VVyCS0:
24846:    del self.VV2ilt[name].dataAvail[:]
24847:    del self.VV2ilt[name].appClosed[:]
24848:   del self.VV2ilt[name]
24849:   del self.VVimES[name]
24850:   self.VVuiSx = False
24851:   if self.VVbYwR[name]:
24852:    self.VVbYwR[name](self.VVHvdg[name], retval)
24853:   del self.VVbYwR[name]
24854:  def VVY7lz(self):
24855:   return self.VVuiSx
24856:  def kill(self, name):
24857:   if name in self.VV2ilt:
24858:    self.VV2ilt[name].kill()
24859:  def killAll(self):
24860:   for name in self.VV2ilt:
24861:    self.kill(name)
24862:   self.VVuiSx = False
24863: class CCp90q(Screen):
24864:  def __init__(self, session, title="", VVmbsE=None, VVgoZo=False, VVS7yC=False, VV9qqT=False, VVIk01=False, VVB4JK=False, VV4naX=False, VV47Xm=VVje9A, VVoasw=None, VVtByE=None, VV26L0=None, VV62hm=False, VVwdmN=30, consFont=True, VVl5LQ=True):
24865:   self.skin, self.VVfOli = FFiNEe(VVmSQ6, 1600, 1000, 50, 40, 20, "
24866:   self.session   = session
24867:   FFZMxC(self, addScrollLabel=True)
24868:   self.VVgoZo   = VVgoZo
24869:   self.VVS7yC   = VVS7yC
24870:   self.VV9qqT   = VV9qqT
24871:   self.VVIk01  = VVIk01
24872:   self.VVB4JK = VVB4JK
24873:   self.VV4naX = VV4naX
24874:   self.VV47Xm   = VV47Xm
24875:   self.VVoasw = VVoasw
24876:   self.VVtByE = VVtByE
24877:   self.VV26L0  = VV26L0
24878:   self.VV62hm  = VV62hm
24879:   self.VVl5LQ  = VVl5LQ
24880:   self.cmdNum    = 0
24881:   self.VVwZZX  = CCaTk8()
24882:   self.justStarted  = True
24883:   self.dataFound   = False
24884:   self.VVUxFi = "Processing ..."
24885:   if len(title) == 0:
24886:    title = FFGNZA()
24887:   self["myTitle"].setText("  %s" % title)
24888:   if isinstance(VVmbsE, str):
24889:    self.VVmbsE = [VVmbsE]
24890:   else:
24891:    self.VVmbsE = VVmbsE
24892:   if self.VV9qqT or self.VVIk01:
24893:    restartNote = "%s\\\\nGUI WILL RESTART NOW\\\\n%s" % (SEP, SEP)
24894:    self.VVmbsE.append("echo -e '\n%s\n' %s" % (restartNote, FFSPDv(restartNote, VVz22H)))
24895:    if self.VV9qqT : self.VVmbsE.append(CCp90q.VV0los())
24896:    else    : self.VVmbsE.append(CCp90q.VVvDIy())
24897:   self.onShown.append(self.VV7OzD)
24898:   self.onClose.append(self.onExit)
24899:  def VV7OzD(self):
24900:   self.onShown.remove(self.VV7OzD)
24901:   self["myLabel"].VV5kEH(VVRhqH="console" if self.VVl5LQ else "", maxChars=40000)
24902:   if self.VVB4JK:
24903:    FF28n1(self, self.VVUxFi)
24904:   if self.VV62hm:
24905:    self.VVgi3m("Checking Internet Access ... ")
24906:    if not CCuqoc.VVSuvZ():
24907:     self.VVMZGG("No connection to internet !", True)
24908:     return
24909:   self.VVgi3m(self.VVUxFi)
24910:   allOK = self.VVwZZX.VVtIZD(self.VVmbsE[0], self.VVqL3h, VVimES=self.VVCsHg)
24911:   if not allOK:
24912:    self.VVgi3m()
24913:    self.VVMZGG("Console Problem (in cmd-0) !", True)
24914:  def onExit(self):
24915:   if self.VVwZZX.VVY7lz():
24916:    self.VVwZZX.killAll()
24917:  def VVgi3m(self, altTxt=""):
24918:   if self.VV4naX or self.VV9qqT or self.VVIk01:
24919:    self.VV2pQl(FFGEAF("STARTED", VVA4XU))
24920:    self.VVkvE0(altTxt)
24921:   else:
24922:    self.VV2pQl(altTxt)
24923:   if self.VVgoZo:
24924:    self["myLabel"].VVfu0l()
24925:  def VVMZGG(self, txt="", isErr=False):
24926:   if txt:
24927:    self.VVkvE0("\n%s\n" % (FFjt5L(txt, VVz22H) if isErr else txt))
24928:   if not self.dataFound or self.VV8fBr():
24929:    self.VVgi3m()
24930:    self.VVkvE0("Done.")
24931:   if self.VV4naX and not (self.VV9qqT or self.VVIk01):
24932:    self.VVkvE0("\n%s" % FFGEAF("FINISHED", VVA4XU))
24933:   if self.VVS7yC:
24934:    self["myLabel"].VVfu0l()
24935:   if self.VVB4JK:
24936:    FF28n1(self)
24937:   if self.VVoasw : self.VVoasw()
24938:   if self.VVtByE : self.VVtByE(self)
24939:  def VVkvE0(self, txt) : self["myLabel"].appendText(txt, VV47Xm=self.VV47Xm)
24940:  def VV2pQl(self, txt) : self["myLabel"].setText(txt)
24941:  def VV6VWc(self)  : return FFzBfi(self["myLabel"].getText())
24942:  def VV8fBr(self, txt=""):
24943:   consTxt = self.VV6VWc().strip()
24944:   return not consTxt or consTxt.strip().endswith(self.VVUxFi)
24945:  def VVCsHg(self, txt):
24946:   if len(txt) > 0:
24947:    self.dataFound = True
24948:   if self.justStarted:
24949:    self.justStarted = False
24950:    if self.dataFound and self.VV8fBr():
24951:     self.VVgi3m()
24952:   if self.VV26L0:
24953:    colorWhite = CCuTnL.VVsAua(VVwdUw)
24954:    color  = CCuTnL.VVsAua(self.VV26L0[0])
24955:    words  = self.VV26L0[1:]
24956:    for word in words:
24957:     txt = iSub(r"(%s)" % iEscape(word), r"%s\1%s" % (color, colorWhite), txt, flags=IGNORECASE)
24958:   self.VVkvE0(txt)
24959:   if self.VVgoZo or self.VVS7yC:
24960:    self["myLabel"].VVfu0l()
24961:  def VVqL3h(self, data, retval):
24962:   self.cmdNum += 1
24963:   if self.cmdNum < len(self.VVmbsE):
24964:    allOK = self.VVwZZX.VVtIZD(self.VVmbsE[self.cmdNum], self.VVqL3h, VVimES=self.VVCsHg)
24965:    if not allOK:
24966:     self.VVMZGG("Console Problem (in cmd-%s) !" % self.cmdNum, True)
24967:   else:
24968:    self.VVMZGG()
24969:  @staticmethod
24970:  def VViIAR(isInst=False):
24971:   txt  = "apt-get install -f -y > /dev/null 2>&1;" if isInst else ""
24972:   return "sync; sleep 3; if which systemctl > /dev/null 2>&1; then %s systemctl restart enigma2; else killall -9 enigma2; fi" % txt
24973:  @staticmethod
24974:  def VVvDIy(): return CCp90q.VViIAR()
24975:  @staticmethod
24976:  def VV0los(): return CCp90q.VViIAR(True)
24977:  @staticmethod
24978:  def VV6bHp(SELF):
24979:   from Screens.Standby import TryQuitMainloop
24980:   SELF.session.open(TryQuitMainloop, 3)
24981: class CCtzVm(Screen):
24982:  def __init__(self, session, VVGd7m="", VVOuqa="", VV6TEx=False):
24983:   self.skin, self.VVfOli = FFiNEe(VVmSQ6, 1700, 1000, 40, 20, 20, "
24984:   self.session   = session
24985:   self.VVGd7m   = VVGd7m
24986:   self.VVOuqa   = VVOuqa.strip()
24987:   self.VV6TEx   = VV6TEx
24988:   self.VVK0Cy = FF0cqc() + "ajpanel_terminal.history"
24989:   self.VVXuHn = ""
24990:   self.VVB2xR  = "ls"
24991:   self.VVoEDc   = ">>"
24992:   self.VVXgOC    = FFTKR0("pwd") or "/home/root"
24993:   self.VVwZZX  = CCaTk8()
24994:   self.VV3sPE  = []
24995:   self.VV33tl  = ""
24996:   self.VVNNLQ   = None
24997:   self.VVjMlz   = (VVo7S9, VVMibI,VVSGsk,VV1fx4,VV9nWG,VVcPtB,VVGCYL,VVwdUw)
24998:   self.VVPkpc  = 0
24999:   FFZMxC(self, title="Terminal", addScrollLabel=True)
25000:   FFRLNq(self["keyRed"] , "Stop Process")
25001:   FFRLNq(self["keyGreen"] , "Minimize")
25002:   FFRLNq(self["keyYellow"], "Terminal Options")
25003:   FFRLNq(self["keyBlue"] , "New Command")
25004:   FFBep1(self,
25005:   {
25006:    "ok" : self.VVZ1Ie ,
25007:    "cancel": self.VVhDrW  ,
25008:    "menu" : self.VVcXw8 ,
25009:    "info" : self.VVse0r  ,
25010:    "red" : self.VV4N2S   ,
25011:    "green" : self.VVebLl   ,
25012:    "yellow": self.VVOeUB ,
25013:    "blue" : self.VVWf1a  ,
25014:    "last" : self["myLabel"].VV8AUA ,
25015:    "next" : self["myLabel"].VV7yIn ,
25016:    "0"  : self["myLabel"].VVc4HF  ,
25017:   })
25018:   self.onShown.append(self.VV7OzD)
25019:   self.onClose.append(self.VV4N2S)
25020:  def VV7OzD(self):
25021:   self.onShown.remove(self.VV7OzD)
25022:   self["myLabel"].VV5kEH(VV7u0U=False, VVRhqH="terminal", addNewLine=False, hideBtns=True)
25023:   self["myLabel"].VVv22o(CFG.terminalTextWrap.getValue())
25024:   FFWgBS(self)
25025:   FF6W0I(self)
25026:   self.VV0wMe(FFTKR0("date"), 5)
25027:   result = FFTKR0("tUSER=$(whoami) || tUSER=""; tHOST=$(hostname) || tHOST=""; echo $tUSER,$tHOST")
25028:   if result and "," in result:
25029:    result = result.replace(",", "@")
25030:    if len(result) < 15:
25031:     self.VVoEDc = "%s: " % result
25032:   self.VVGp1e()
25033:   if VVmJwX(FF0cqc()):
25034:    self.VVECGC()
25035:    if self.VVGd7m:
25036:     self.VVShXV(self.VVGd7m, self.VVOuqa)
25037:   else:
25038:    FFdw58(self, 'Cannot access the path:\n\n%s' % FF0cqc())
25039:    self.close()
25040:  def VVhDrW(self):
25041:   if   self.VVNNLQ     : self.VVebLl()
25042:   elif self.VVwZZX.VVY7lz()  : self.VVCPhp()
25043:   elif self.VV6TEx      : self.close()
25044:   elif CFG.ConfirmTerminalExit.getValue() : FFRMYv(self, self.close, "Exit ?")
25045:   else         : self.close()
25046:  def VVebLl(self):
25047:   if self.VVNNLQ:
25048:    self.session.deleteDialog(self.VVNNLQ)
25049:    self.VVNNLQ = None
25050:    self.show()
25051:   else:
25052:    self.VVNNLQ = CChMGW.VVNLfa(self.session, self.VV33tl, 24, shadW=0, bg="#77000000")
25053:    self.hide()
25054:  def VVECGC(self):
25055:   userFile = CFG.terminalCmdFile.getValue()
25056:   alterFile = FF0cqc() + "ajpanel_cmd"
25057:   templPath = VVIp2p + "ajpanel_cmd_list"
25058:   if   FFCyVu(userFile) : self.VVXuHn = userFile
25059:   elif FFCyVu(alterFile): self.VVXuHn = alterFile
25060:   else:
25061:    if not FFpwZS("cp -f '%s' '%s'" % (templPath, alterFile)):
25062:     FF7ymp("echo -e 'pwd\ncd\ncd /tmp\nls\nls -ls' > '%s'" % alterFile)
25063:    self.VVXuHn = alterFile
25064:  def VV4N2S(self):
25065:   if self.VVNNLQ:
25066:    self.VVebLl()
25067:   elif self.VVwZZX.VVY7lz():
25068:    self.VVwZZX.killAll()
25069:    self.VVYrFJ("Process killed")
25070:    self.VVGp1e()
25071:  def VVCPhp(self):
25072:   if self.VVNNLQ:
25073:    self.VVebLl()
25074:   FF28n1(self, "Terminal is busy", 800)
25075:  def VVYrFJ(self, err):
25076:   txt = self["myLabel"].getText()
25077:   if   txt.endswith("\n\n"): cr = ""
25078:   elif txt.endswith("\n")  : cr = "\n"
25079:   else      : cr = "\n\n"
25080:   self.VV0wMe("%s---(  %s  )---\n" % (cr, err), 4)
25081:  def VVGp1e(self):
25082:   txt = self["myLabel"].getText()
25083:   self.VVPkpc = len(txt)
25084:   if   txt.endswith("\n\n"): cr = ""
25085:   elif txt.endswith("\n")  : cr = "\n"
25086:   else      : cr = "\n\n"
25087:   self.VV0wMe(cr + self.VVoEDc, 1)
25088:   self["keyRed"].hide()
25089:  def VV0wMe(self, txt, mode):
25090:   if   mode == 0 : color = VVwdUw
25091:   elif mode == 1 : color = VV1fx4
25092:   elif mode == 2 : color = VVGCYL
25093:   elif mode == 3 : color = VVwdUw
25094:   elif mode == 4 : color = VVz22H
25095:   elif mode == 5 : color = VVA4XU
25096:   elif mode == 6 : color = VVo7S9
25097:   else   : color = VVwdUw
25098:   txt = iSub(r"\x1B\[0m", CCuTnL.VVsAua(VVwdUw), txt, flags=IGNORECASE)
25099:   for i, c in enumerate(self.VVjMlz):
25100:    txt = iSub(r"\x1B\[[\d\;]*%sm" % i, CCuTnL.VVsAua(c), txt, flags=IGNORECASE)
25101:   txt = iSub(r"\x1B\[(\d{,3};?){,3}m", "", txt, flags=IGNORECASE)
25102:   if not txt.strip() or iMatch(r"^\\c.{8}.*", txt):
25103:    color = ""
25104:   try:
25105:    txt = str(txt)
25106:    oldTxt = self["myLabel"].getText()
25107:    done = False
25108:    if chr(13) in txt:
25109:     pos = oldTxt.rfind(chr(13))
25110:     if pos > self.VVPkpc:
25111:      self["myLabel"].setText(oldTxt[:pos] + txt)
25112:      done = True
25113:    if not done:
25114:     self["myLabel"].setText(oldTxt + color + txt)
25115:    txt = txt.strip().rpartition("\n")[2]
25116:    if txt:
25117:     if len(txt) > 20: txt = "%s .. %s" % (txt[:10], txt[-10:])
25118:     self.VV33tl = color + txt
25119:     if self.VVNNLQ:
25120:      CChMGW.VVr9Gs(self.VVNNLQ, self.VV33tl)
25121:   except:
25122:    pass
25123:  @FFOAKH("Loading History ...")
25124:  def VVZ1Ie(self):
25125:   title = "Command History"
25126:   if not FFCyVu(self.VVK0Cy) or self.VVZCpJ() == "":
25127:    self.VVeI3W("cd /tmp")
25128:    self.VVeI3W("ls")
25129:   VVAkuK = []
25130:   if FFCyVu(self.VVK0Cy):
25131:    lines  = FFL19l(self.VVK0Cy)
25132:    c  = 0
25133:    lNum = len(lines) + 1
25134:    for line in reversed(lines):
25135:     line = line.strip()
25136:     lNum -= 1
25137:     if line and not line.startswith("#"):
25138:      c += 1
25139:      VVAkuK.append((str(c), line, str(lNum)))
25140:    self.VVUwCB(VVAkuK, title, self.VVK0Cy, isHistory=True)
25141:   else:
25142:    FF8Wsn(self, self.VVK0Cy, title=title)
25143:  def VVZCpJ(self):
25144:   lastLine = FFTKR0("grep '.' '%s' | tail -1" % self.VVK0Cy)
25145:   return lastLine.strip()
25146:  def VVeI3W(self, cmd):
25147:   try:
25148:    with open(self.VVK0Cy, "a") as f:
25149:     f.write("%s\n" % cmd)
25150:   except Exception as e:
25151:    FFdw58(self, str(e))
25152:  def VVcXw8(self, VV6A99=None):
25153:   FFimQ3(VV6A99 or self, BF(self.VVaS8y, VV6A99), "Loading Commands ...")
25154:  def VVaS8y(self, VV6A99=None):
25155:   if FFCyVu(self.VVXuHn):
25156:    lines = FFL19l(self.VVXuHn)
25157:    VVAkuK = []
25158:    c  = 0
25159:    lNum = 0
25160:    defColor = ""
25161:    for line in lines:
25162:     line = line.strip()
25163:     lNum += 1
25164:     if line:
25165:      c += 1
25166:      color, line = self.VVdRY8(line)
25167:      if not color.startswith("
25168:       color = "#f#00FF8055#" + defColor
25169:      if color:
25170:       if line:
25171:        line = color + line
25172:       else:
25173:        defColor = color
25174:        continue
25175:      elif not line:
25176:       defColor = ""
25177:       continue
25178:      else:
25179:       line = defColor + line
25180:      VVAkuK.append((str(c), line, str(lNum)))
25181:    if VV6A99:
25182:     VV6A99.VVMqQ9(VVAkuK)
25183:     VV6A99.VVrqBw(CFG.lastTerminalCustCmdLineNum.getValue())
25184:    else:
25185:     self.VVUwCB(VVAkuK, "File : %s" % os.path.basename(self.VVXuHn), filePath=self.VVXuHn, isHistory=False)
25186:   else:
25187:    FF8Wsn(self, self.VVXuHn, title="Custom Commands")
25188:  def VVdRY8(self, line):
25189:   found = False
25190:   span = iSearch(r"^\s*\[(.+)?\](.+?
25191:   if span:
25192:    fgBg, line = span.groups()
25193:    found = True
25194:   else:
25195:    span = iSearch(r"^([^
25196:    if span:
25197:     line, sep, txt1, fgBg, txt2 = span.groups()
25198:     txt1 = txt1.strip(" #") if txt1 else ""
25199:     txt2 = txt2.strip("
25200:     if   txt1 and txt2 : line += "\t%s %s ... %s" % (sep, txt1, txt2)
25201:     elif txt1 or txt2 : line += "\t%s %s" % (sep, txt1 or txt2)
25202:     found = True
25203:    else:
25204:     span = iSearch(r"^\s*\[(.+)?\](.+)?", line)
25205:     if span:
25206:      fgBg, line = span.groups()
25207:      found = True
25208:   if found:
25209:    fg = bg = color = ""
25210:    line = line.strip() if line else ""
25211:    if fgBg:
25212:     fg, _, bg = fgBg.partition(",")
25213:     fg, bg = fg.strip("
25214:    c = self.VVPh6j(fg)
25215:    if c: color = "#f#%s#" % c
25216:    c = self.VVPh6j(bg)
25217:    if c: color += "#b#%s#" % c
25218:    return color, line
25219:   return "", line
25220:  def VVPh6j(self, txt):
25221:   if txt:
25222:    Dict = {"black": "000000", "red": "FF0000", "green": "00FF00", "blue": "0000FF", "yellow": "FFFF00", "cyan": "00FFFF", "purple": "FF00FF", "grey": "666666", "gray": "666666", "white": "FFFFFF"}
25223:    tc = "22"
25224:    Len = len(txt)
25225:    color = Dict.get(txt.lower(), "")
25226:    if color:
25227:     return tc + color
25228:    elif Len in (6,8) and iMatch("[a-fA-F0-9]", txt):
25229:     if Len == 6 : return tc + txt
25230:     if Len == 8 : return txt
25231:   return ""
25232:  def VVUwCB(self, VVAkuK, title, filePath=None, isHistory=False):
25233:   if VVAkuK:
25234:    if isHistory: VVwltY = VVkxBG = VVemyB = "
25235:    else  : VVwltY = VVkxBG = VVemyB = "#06002020"
25236:    VVu1YM   = ("Send"   , BF(self.VVhugd, isHistory)  , [])
25237:    VVwSzI  = ("Modify & Send" , self.VV3Tdh     , [])
25238:    if isHistory:
25239:     VVwdmN  = CFG.terminalFontSizeHist.getValue()
25240:     VVScQz = ("Clear History" , self.VV9nUL     , [])
25241:     VV4QTJ = None
25242:     VV2ytr = None
25243:    elif filePath:
25244:     VVwdmN  = CFG.terminalFontSizeCmd.getValue()
25245:     VVScQz = ("Options"  , self.VV7d13      , [])
25246:     VV4QTJ = ("Edit File"  , BF(self.VVmsFF, filePath) , [])
25247:     VV2ytr = (""    , self.VVlEf6     , [])
25248:    header  = ("No." , "Commands", "LineNum" )
25249:    widths  = (7  , 93   , 0    )
25250:    VVLIqP = (CENTER , LEFT   , CENTER )
25251:    VV6A99 = FFUQ0v(self, None, title=title, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, height=1000, VVwdmN=VVwdmN, VVu1YM=VVu1YM, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VV2ytr=VV2ytr, VVSLOq=CFG.lastFindTerminal, VVHPI7=True, VVMfsO=1
25252:          , VVwltY=VVwltY, VVkxBG=VVkxBG, VVemyB=VVemyB, VVoRat="#00ffffff", VVJKqd="#0a884400")
25253:    if not isHistory:
25254:     VV6A99.VVrqBw(CFG.lastTerminalCustCmdLineNum.getValue())
25255:   else:
25256:    FFRMYv(self, self.VV5K7M, "File is empty:\n\n%s\n\nSelect another file ?" % self.VVXuHn, title=title)
25257:  def VVlEf6(self, VV6A99, title, txt, colList):
25258:   txt  = "%s\n%s\n\n" % (FFjt5L("Command:", VVFuwR), colList[1])
25259:   txt += "%s\n%s\n\n" % (FFjt5L("Line %s in File:" % colList[2], VVFuwR), self.VVXuHn)
25260:   FF4lCP(self, txt, title=title)
25261:  def VV7d13(self, VV6A99, title, txt, colList):
25262:   if VV6A99.VVXWPu:
25263:    totSel = VV6A99.VVc5NH()
25264:    totTxt = str(totSel)
25265:    txt = "Send %s Command%s" % (FFjt5L(totTxt, VVFuwR) if totSel else totTxt, FFcacr(totSel))
25266:    item = (txt, "send") if totSel else (txt,)
25267:   else:
25268:    txt = "Send current line"
25269:    item = (txt, "send")
25270:   CCzSCo(self, VV6A99, setsOk=True, setsBlue=True, setsGreen=True).VV9VR2([item], { "send": BF(self.VVhugd, False, VV6A99, title, txt, colList) })
25271:  def VVOeUB(self):
25272:   VV3wat = []
25273:   VV3wat.append(("Change Custom Commands File" , "chCmdF" ))
25274:   VV3wat.append(VVAL3j)
25275:   VV3wat.append(("%s Text Wrapping"     % ("Disable" if self["myLabel"].VViW1R else "Enable"), "wrap" ))
25276:   VV3wat.append(("%s Terminal-Exit Confirmation" % ("Disable" if CFG.ConfirmTerminalExit.getValue() else "Enable"), "togExit"))
25277:   VV3wat.append(VVAL3j)
25278:   VV3wat.append(("Commands Table Font Size" , "cmdFntSz" ))
25279:   VV3wat.append(("History Table Font Size" , "histFntSz" ))
25280:   VV3wat.append(VVAL3j)
25281:   VV3wat.append(("Save Terminal Log File"  , "saveLog" ))
25282:   FFLFTC(self, self.VVKvYu, VV3wat=VV3wat, title="Terminal Options", width=700)
25283:  def VVKvYu(self, item):
25284:   if item:
25285:    if   item == "chCmdF" : self.VV5K7M()
25286:    elif item == "wrap"  : self.VVxyCd()
25287:    elif item == "togExit" : FFjt1c(CFG.ConfirmTerminalExit, not CFG.ConfirmTerminalExit.getValue())
25288:    elif item == "cmdFntSz" : self.VVxWPa(True)
25289:    elif item == "histFntSz": self.VVxWPa(False)
25290:    elif item == "saveLog" : self["myLabel"].VVxeSU()
25291:  def VVxyCd(self):
25292:   self["myLabel"].VVOJVi()
25293:   FFjt1c(CFG.terminalTextWrap, self["myLabel"].VViW1R)
25294:  def VVxWPa(self, isCmdTbl):
25295:   if isCmdTbl : confItem, txt = CFG.terminalFontSizeCmd , "Commands"
25296:   else  : confItem, txt = CFG.terminalFontSizeHist, "History"
25297:   CCJaSw.VV5YpJ(self, confItem, "%s Table Font Size" % txt, cbFnc=BF(FF1mVE, self, "Saved"), isSave=True, width=700)
25298:  def VV5K7M(self):
25299:   title = "Custom Commands File"
25300:   VV3wat = []
25301:   bPath = FF0cqc()
25302:   for fName in sorted(os.listdir(bPath), key=lambda x: x[0].lower()):
25303:    path = os.path.join(bPath, fName)
25304:    if fName.lower().startswith(("ajpanel_cmd", "linuxcommands")) and os.path.isfile(path):
25305:     if path == self.VVXuHn:
25306:      fName = FFjt5L(fName, VVSGsk)
25307:     VV3wat.append((fName, path))
25308:   if VV3wat : FFLFTC(self, BF(self.VVcQf7, title), VV3wat=VV3wat, title=title, VVyRCy=3, VVtboQ="", VVwltY="
25309:   else  : FFdw58(self, "No valid files found in:\n\n%s" % bPath, title=title)
25310:  def VVcQf7(self, title, path=None):
25311:   if path:
25312:    oldF = self.VVXuHn
25313:    if CClYaF.VVgIOw(path):
25314:     FFdw58(self, "Incorrect file format:\n\n%s" % path, title=title)
25315:    elif path == self.VVXuHn:
25316:     FF28n1(self, "No change", 1000)
25317:    else:
25318:     self.VVXuHn = path
25319:     FFjt1c(CFG.terminalCmdFile, path)
25320:     FFjt1c(CFG.lastTerminalCustCmdLineNum, 0)
25321:     FF1mVE(self, "Changed")
25322:  def VVhugd(self, isHistory, VV6A99, title, txt, colList):
25323:   if VV6A99.VVXWPu:
25324:    lst = VV6A99.VVf3uT(1)
25325:    curNdx = VV6A99.VV6LTe()
25326:   else:
25327:    lst = [colList[1]]
25328:    curNdx = VV6A99.VVGTqU()
25329:   if not isHistory:
25330:    FFjt1c(CFG.lastTerminalCustCmdLineNum, curNdx)
25331:   self.VV3sPE = lst
25332:   VV6A99.cancel()
25333:   FFIElK(self.VVsnmC)
25334:  def VVsnmC(self):
25335:   if self.VV3sPE:
25336:    cmd = self.VV3sPE[0]
25337:    self.VV3sPE.pop(0)
25338:    if not iMatch("^[a-zA-Z0-9_/]", cmd):
25339:     self.VV0wMe("\n%s\n" % cmd, 6)
25340:     self.VV0wMe(self.VVoEDc, 1)
25341:     self.VVsnmC()
25342:    else:
25343:     self.VVShXV(cmd)
25344:  def VVShXV(self, cmd, VVOuqa=""):
25345:   if self.VVwZZX.VVY7lz():
25346:    self.VVCPhp()
25347:    return
25348:   self["keyRed"].show()
25349:   if cmd.startswith("passwd"):
25350:    self.VV0wMe(cmd, 2)
25351:    self.VV0wMe("\nCannot change passwrod from Console this way. Try using:\n", 4)
25352:    txt = r'echo -e "NEW_PASSWORD\#nNEW_PASSWORD" | passwd'
25353:    for ch in txt:
25354:     if not ch == "#":
25355:      self.VV0wMe(ch, 0)
25356:    self.VV0wMe("\nor\n", 4)
25357:    self.VV0wMe("echo root:NEW_PASSWORD | chpasswd\n", 0)
25358:    self.VVGp1e()
25359:   else:
25360:    cmd = cmd.strip()
25361:    modCmd = cmd
25362:    span = iSearch(r"^(\/.+sh)(\s+
25363:    if span:
25364:     modCmd = "sh '%s'" % span.group(1)
25365:     FFpwZS(FFb2oQ("chmod 755 '%s'" % cmd))
25366:     txt = "%s%s\n" % (VVcPtB, cmd)
25367:    elif cmd.endswith((".py", ".pyo", ".pyc")) and os.path.isfile(cmd):
25368:     FFpwZS(FFb2oQ("chmod 755 '%s'" % cmd))
25369:     modCmd = "python%s '%s'" % ("3" if pyVersion[0] >= 3 else "", cmd)
25370:     txt = "%s%s\n" % (VVcPtB, cmd)
25371:    elif "#" in cmd and not "\n" in cmd:
25372:     parts = cmd.split("#")
25373:     left  = VVGCYL + parts[0].strip()
25374:     right = VVo7S9 + "#" + parts[1].strip()
25375:     txt = "%s    %s\n" % (left, right)
25376:    else:
25377:     txt = "%s\n" % cmd
25378:    self.VV0wMe(VVOuqa if VVOuqa else txt, 2)
25379:    lastLine = self.VVZCpJ()
25380:    if not lastLine or not cmd == lastLine:
25381:     self.VVB2xR = cmd
25382:     self.VVeI3W(cmd)
25383:    span = iSearch(r".*cd\s+([\/?\w\.+\~]+)", cmd + ";")
25384:    if span:
25385:     self.VVXgOC = span.group(1)
25386:    allOK = self.VVwZZX.VVtIZD(modCmd, self.VVGdej, VVimES=self.VVfg69, VVXgOC=self.VVXgOC)
25387:    if not allOK:
25388:     FFdw58(self, "Cannot connect to Console!")
25389:    self.VVB2xR = cmd
25390:  def VVfg69(self, data):
25391:   self.VV0wMe(data, 3)
25392:  def VVGdej(self, data, retval):
25393:   if not retval == 0:
25394:    self.VVYrFJ("Exit Code : %d" % retval)
25395:   self.VVGp1e()
25396:   if self.VV3sPE:
25397:    self.VVsnmC()
25398:  def VV3Tdh(self, VV6A99, title, txt, colList):
25399:   if VV6A99.VVOOzr():
25400:    cmd = colList[1]
25401:    self.VVDxAJ(VV6A99, cmd)
25402:  def VV9nUL(self, VV6A99, title, txt, colList):
25403:   FFRMYv(self, BF(self.VVFQ6N, VV6A99), "Reset History File ?", title="Command History")
25404:  def VVFQ6N(self, VV6A99):
25405:   FF7ymp("> '%s'" % self.VVK0Cy)
25406:   VV6A99.cancel()
25407:  def VVmsFF(self, filePath, VV6A99, title, txt, colList):
25408:   rowNum = int(colList[2].strip()) - 1
25409:   if FFCyVu(filePath) : CCyMCP(self, filePath, VVbYwR=BF(self.VVlTnm, VV6A99), VVPhQC=rowNum)
25410:   else     : FF8Wsn(self, filePath)
25411:  def VVlTnm(self, VV6A99, fileChanged):
25412:   if fileChanged:
25413:    VV6A99.cancel()
25414:    FFIElK(self.VVcXw8)
25415:  def VVWf1a(self):
25416:   if self.VVwZZX.VVY7lz():
25417:    self.VVCPhp()
25418:   else:
25419:    self.VVDxAJ(None, "")
25420:  def VVDxAJ(self, VV6A99, cmd):
25421:   if "
25422:    cmd = cmd.split("#")[0].strip()
25423:   FF4z45(self, BF(self.VVHUbU, VV6A99), title="Terminal", defaultText=cmd, message="Enter Command:")
25424:  def VVHUbU(self, VV6A99, cmd):
25425:   if cmd and len(cmd) > 0:
25426:    self.VVShXV(cmd)
25427:    if VV6A99:
25428:     VV6A99.cancel()
25429:  def VVse0r(self):
25430:   FFw2rR(self, "_help_terminal", "Terminal Help")
25431: class CCn30s(Screen):
25432:  def __init__(self, session, title="", message="", VV47Xm=VVje9A, width=1400, height=900, VViOjF=False, isErr=False, titleBg="
25433:   if isErr: titleBg, VVemyB = "#22330000", "#22200000"
25434:   self.skin, self.VVfOli = FFiNEe(VVmSQ6, width, height, VVllEU, 30, 20, titleBg, VVemyB, VVwdmN)
25435:   self.session   = session
25436:   FFZMxC(self, title, addScrollLabel=True)
25437:   self.VV47Xm   = VV47Xm
25438:   self.VViOjF   = VViOjF
25439:   self.resize    = resize
25440:   self.VVRhqH = VVRhqH
25441:   if isinstance(message, list):
25442:    try:
25443:     self.message = "\n".join(message)
25444:    except:
25445:     pass
25446:   self.message = str(message)
25447:   self.onShown.append(self.VV7OzD)
25448:  def VV7OzD(self):
25449:   self.onShown.remove(self.VV7OzD)
25450:   self["myLabel"].VV5kEH(VViOjF=self.VViOjF, VVRhqH=self.VVRhqH)
25451:   self["myLabel"].setText(self.message, self.VV47Xm)
25452:   self.VVvCvc()
25453:  def VVDiQh(self, txt):
25454:   self["myLabel"].appendText(txt)
25455:   self.VVvCvc()
25456:  def VVvCvc(self):
25457:   if self.resize:
25458:    self["myLabel"].VVfu0l()
25459: class CCea0a(Screen):
25460:  def __init__(self, session, txt):
25461:   self.skin, self.VVfOli = FFiNEe(VVoNDw, 1800, 60, 30, 30, 20, "#55000000", "#ff000000", 30)
25462:   self.session  = session
25463:   self.txt   = txt
25464:   self["myWinTitle"] = Label()
25465:   FFZMxC(self, " ", addCloser=True)
25466:   self.onShown.append(self.VV7OzD)
25467:  def VV7OzD(self):
25468:   self.onShown.remove(self.VV7OzD)
25469:   CChMGW.VVr9Gs(self, self.txt)
25470:   self.instance.move(ePoint((getDesktop(0).size().width() - self.instance.size().width()) // 2, 20))
25471: class CCtjms(Screen):
25472:  def __init__(self, session, title="", message=""):
25473:   self.skin, self.VVfOli = FFiNEe(VV5jiO, 1200, 300, 50, 20, 0, "
25474:   self.session = session
25475:   FFZMxC(self, title, addLabel=True, addCloser=True)
25476:   self["errPic"] = Pixmap()
25477:   self["myLabel"].setText(message)
25478:   self.onShown.append(self.VV7OzD)
25479:  def VV7OzD(self):
25480:   self.onShown.remove(self.VV7OzD)
25481:   FFkDgm(self["errPic"], "err")
25482: class CCtm4v(Screen):
25483:  def __init__(self, session, fnc, title="Processing ...", fntSize=28, bg="#22331133"):
25484:   self.skin, self.VVfOli = FFiNEe(VVoNDw, 500, 100, 10, 10, 30, "#FF000000", "#FF000000", 30, VVU4ws=False)
25485:   self.session = session
25486:   self.fnc  = fnc
25487:   self.Title  = str(title)
25488:   self.fntSize = fntSize
25489:   self.bg   = bg
25490:   FFZMxC(self, " ")
25491:   self["myWinTitle"] = Label()
25492:   self.onShown.append(self.VV7OzD)
25493:  def VV7OzD(self):
25494:   self.onShown.remove(self.VV7OzD)
25495:   self["myInfoFrame"].show()
25496:   body = self["myInfoBody"]
25497:   body.show()
25498:   body.setText(self.Title)
25499:   body.instance.setFont(gFont(VVNhAq, self.fntSize))
25500:   FFZ0AC(body, self.bg)
25501:   FF4iwG(":", self.VVxPtx)
25502:  def VVxPtx(self, result, retval):
25503:   self.fnc()
25504:   self.close()
25505: class CC8Nur(Screen):
25506:  def __init__(self, session, title, timeout=1500, fntSize=28, fg="#22ffffaa", bg="#22001100", isRed=False):
25507:   self.skin, self.VVfOli = FFiNEe(VVoNDw, 500, 100, 10, 10, 30, "#FF000000", "#FF000000", 30, VVU4ws=False)
25508:   self.session = session
25509:   self.Title  = str(title)
25510:   self.fntSize = fntSize
25511:   self.fg   = fg
25512:   self.bg   = "#00550000" if isRed else bg
25513:   FFZMxC(self, " ", addCloser=True)
25514:   self["myWinTitle"] = Label()
25515:   self.timer = eTimer()
25516:   try: self.timer_conn = self.timer.timeout.connect(self.close)
25517:   except: self.timer.callback.append(self.close)
25518:   self.timer.start(timeout, True)
25519:   self.onShown.append(self.VV7OzD)
25520:  def VV7OzD(self):
25521:   self.onShown.remove(self.VV7OzD)
25522:   self["myInfoFrame"].show()
25523:   body = self["myInfoBody"]
25524:   body.show()
25525:   body.setText(self.Title)
25526:   body.instance.setFont(gFont(VVNhAq, self.fntSize))
25527:   FF7hy1(body, self.fg, self.bg)
25528: class CCqGqw(Screen):
25529:  def __init__(self, session, txt, fntSize, bg="#FF000000"):
25530:   self.skin, self.VVfOli = FFiNEe(VVoNDw, 1000, 50, 20, 30, 20, bg, bg, fntSize, VVU4ws=False)
25531:   self.session  = session
25532:   self["myWinTitle"] = Label()
25533:   FFZMxC(self, " ", addCloser=True)
25534: class CChMGW():
25535:  def __init__(self, session, txt, timeout=1500, fonSize=24, x=30, y=20):
25536:   self.session = session
25537:   self.win  = CChMGW.VVNLfa(session, txt, fonSize, x=x, y=y)
25538:   self.timer = eTimer()
25539:   try: self.timer_conn = self.timer.timeout.connect(self.VVpxgz)
25540:   except: self.timer.callback.append(self.VVpxgz)
25541:   self.timer.start(timeout, True)
25542:  def VVpxgz(self):
25543:   self.session.deleteDialog(self.win)
25544:  @staticmethod
25545:  def VVNLfa(session, txt, fonSize, shadW=2, shadColor="#440000", bg="#FF000000", x=30, y=20):
25546:   win = session.instantiateDialog(CCqGqw, str(txt).strip(), fonSize, bg=bg)
25547:   win.show()
25548:   FFK4PQ(win["myWinTitle"], shadColor, shadW)
25549:   CChMGW.VVr9Gs(win, txt)
25550:   if x < 0: x = (getDesktop(0).size().width() - win.instance.size().width()) // 2
25551:   if y < 0: y = (getDesktop(0).size().height() - win.instance.size().height()) // 2
25552:   win.instance.move(ePoint(x, y))
25553:   return win
25554:  @staticmethod
25555:  def VVr9Gs(win, txt):
25556:   win["myWinTitle"].setText(str(txt).strip())
25557:   inst = win["myWinTitle"].instance
25558:   w = inst.calculateSize().width() + 30
25559:   h = int(inst.size().height())
25560:   inst.resize(eSize(*(w, h)))
25561:   win.instance.resize(eSize(*(w, h)))
25562: class CCHRcZ():
25563:  VVLHSO    = 0
25564:  VVyzIo  = 1
25565:  VVTaMF   = ""
25566:  VVyEAg    = ""
25567:  VVy3rX   = {}
25568:  VVwbS2    = "ajpDownload"
25569:  def __init__(self, SELF, mode, title, startDnld, VVZcRP=""):
25570:   self.SELF     = SELF
25571:   self.mode     = mode
25572:   self.Title     = title
25573:   self.VV6A99   = None
25574:   self.timer     = eTimer()
25575:   self.VV68m8   = 0
25576:   self.VVfsD9  = 1
25577:   self.VVqBma  = 2
25578:   self.VVf0kA   = 3
25579:   self.VVewiH   = 4
25580:   CCHRcZ.VVyEAg = ""
25581:   VVAkuK = self.VVX0Su()
25582:   if VVAkuK:
25583:    self.VV6A99 = self.VVFWOb(VVAkuK)
25584:   if not VVAkuK and mode == self.VVLHSO:
25585:    self.VVQ5VQ("Download list is empty !")
25586:    self.cancel()
25587:   if mode == self.VVyzIo:
25588:    FFimQ3(self.VV6A99 or self.SELF, BF(self.VVCz4F, startDnld, VVZcRP), title="Checking Server ...")
25589:   self.VVFPJZ(force=True)
25590:   try: self.timer_conn = self.timer.timeout.connect(self.VVFPJZ)
25591:   except: self.timer.callback.append(self.VVFPJZ)
25592:   self.timer.start(1000, False)
25593:  def VVFWOb(self, VVAkuK):
25594:   VVAkuK.sort(key=lambda x: int(x[0]))
25595:   VVu8qI = self.VVAvqF
25596:   VVu1YM  = ("Play"  , self.VVx0TS , [])
25597:   VV2ytr = (""   , self.VVlDhI  , [])
25598:   VVwWmA = ("Stop"  , self.VVSOdJ  , [])
25599:   VVwSzI = ("Resume"  , self.VVr1ws , [])
25600:   VVScQz = ("Options" , self.VVEzGg  , [])
25601:   VV4QTJ = ("Play URL" , self.VV0iZw , [])
25602:   header   = ("No." , "Name" , "Type", "File Size", "Status" , "Progress", "Path", "sizeVal" , "URL" , "decoded-Url" , "oldSize" , "Speed" , "m3u8Log" )
25603:   widths   = (5  , 39  , 8  , 13   , 13   , 11   , 0.01 , 0   , 0.01 , 0    , 0   , 11  , 0   )
25604:   VVLIqP  = (CENTER, LEFT  , CENTER, CENTER  , CENTER , CENTER , LEFT , CENTER , LEFT , LEFT   , CENTER , CENTER , LEFT  )
25605:   return FFUQ0v(self.SELF, None, title=self.Title, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVu1YM=VVu1YM, VV2ytr=VV2ytr, VVu8qI=VVu8qI, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVSLOq=CFG.lastFindIptv, VVwltY="#11220022", VVkxBG="#11110011", VVemyB="#11110011", VVJKqd="#00223025", VVbcr0="#0a333333", VVX9AA="#0a400040", VVHPI7=True, VVMfsO=1)
25606:  def VVX0Su(self):
25607:   lines = CCHRcZ.VVXGK6()
25608:   VVAkuK = []
25609:   if lines:
25610:    for ndx, line in enumerate(lines):
25611:     if "," in line:
25612:      parts  = line.split(",", 1)
25613:      left  = parts[0].strip()
25614:      VVZcRP = parts[1].strip()
25615:      if left == "-1" or left.isdigit(): size, m3u8Log = int(left), ""
25616:      else        : size, m3u8Log = -1  , left
25617:      if VVZcRP:
25618:       fName, VV1wIO, url = self.VVQajF(VVZcRP)
25619:       if fName:
25620:        if   FFKxIH(VVZcRP) : sType = "Movie"
25621:        elif FF1BEt(VVZcRP) : sType = "Series"
25622:        else      : sType = ""
25623:        path = self.VVBFa1(VVZcRP, fName)
25624:        if size > -1: sizeTxt = CClYaF.VV99gM(size, mode=4)
25625:        else  : sizeTxt = ""
25626:        status = prog = speed = oldSize = ""
25627:        VVAkuK.append((str(len(VVAkuK) + 1), VV1wIO, sType, sizeTxt, status, prog, path, str(size), url, VVZcRP, oldSize, speed, m3u8Log))
25628:   return VVAkuK
25629:  def VV6wof(self):
25630:   VVAkuK = self.VVX0Su()
25631:   if VVAkuK:
25632:    if self.VV6A99 : self.VV6A99.VVMqQ9(VVAkuK, VV5YRVMsg=False)
25633:    else     : self.VV6A99 = self.VVFWOb(VVAkuK)
25634:   else:
25635:    self.cancel()
25636:  def VVFPJZ(self, force=False):
25637:   if self.VV6A99:
25638:    thrListUrls = self.VV1sva()
25639:    VVAkuK = []
25640:    changed = False
25641:    for ndx, row in enumerate(self.VV6A99.VVrrm9()):
25642:     row = list(map(str.strip, row))
25643:     num, name, typ, fSize, state, progr, path, sizeV, url, VVZcRP, oldSize, speed, m3u8Log = row
25644:     flag = self.VV68m8
25645:     if m3u8Log:
25646:      percent = CCHRcZ.VVlzpX(m3u8Log)
25647:      if percent > -1:
25648:       if percent < 100: flag, progr = self.VVf0kA , "%.2f %%" % percent
25649:       else   : flag, progr = self.VVewiH , "100 %"
25650:      mPath = m3u8Log[:-9]
25651:      curSize = FFXhoc(mPath)
25652:      if curSize > -1:
25653:       fSize = CClYaF.VV99gM(curSize, mode=4)
25654:      try:
25655:       if not oldSize in ("", "0", "-"):
25656:        diff = int(curSize - int(oldSize))
25657:        if diff:
25658:         speed = CClYaF.VV99gM(diff, mode=4) + "/s"
25659:      except:
25660:       pass
25661:     else:
25662:      curSize = FFXhoc(path)
25663:      if curSize > -1:
25664:       if sizeV.isdigit():
25665:        percent = float(curSize) / float(sizeV) * 100.0
25666:        if percent < 100: flag, progr = self.VVf0kA , "%.2f %%" % percent
25667:        else   : flag, progr = self.VVewiH , "100 %"
25668:        try:
25669:         if not oldSize in ("", "0", "-"):
25670:          diff = int(curSize - int(oldSize))
25671:          if diff:
25672:           speed = CClYaF.VV99gM(diff, mode=4) + "/s"
25673:        except:
25674:         pass
25675:     if VVZcRP in thrListUrls:
25676:      flag = self.VVqBma
25677:      if m3u8Log :
25678:       if not speed and not force : flag = self.VVfsD9
25679:       elif curSize == -1   : self.VVZGqS(False)
25680:     elif flag == self.VV68m8  : speed = progr = "-"
25681:     else        : speed = "-"
25682:     color1 = "#f#00FF9999#" if m3u8Log else ""
25683:     if   flag == self.VV68m8  : color2 = "
25684:     elif flag == self.VVfsD9 : color2 = "#f#0000FFFF#"
25685:     elif flag == self.VVqBma : color2 = "#f#0000FFFF#"
25686:     elif flag == self.VVf0kA  : color2 = "#f#00FF8000#"
25687:     elif flag == self.VVewiH  : color2 = "#f#0000FF00#"
25688:     else        : color2 = "#f#00AAAAAA#"
25689:     state = self.VV9va5(flag)
25690:     oldSize = str(curSize)
25691:     if [num, name, typ, fSize, state, progr, path, sizeV, url, VVZcRP, oldSize, speed, m3u8Log] != row:
25692:      changed = True
25693:     row[1]  = color1 + name
25694:     row[2]  = color1 + typ
25695:     row[3]  = color1 + fSize
25696:     row[4]  = color2 + state
25697:     row[5]  = color2 + progr
25698:     row[10] = oldSize
25699:     row[11] = speed if not speed.startswith("-") else "-"
25700:     VVAkuK.append(row)
25701:    if changed or force:
25702:     self.VV6A99.VVMqQ9(VVAkuK, VV5YRVMsg=False)
25703:    if CCHRcZ.VVyEAg : title = "%s\t %s%s" % (self.Title, VVYjI5, CCHRcZ.VVyEAg)
25704:    else          : title = self.Title
25705:    if self.VV6A99.VVpVUj().strip() != title:
25706:     self.VV6A99.VV0ZtI(title)
25707:  def VV9va5(self, flag):
25708:   tDict = self.VVKcCc()
25709:   return tDict.get(flag, "?")
25710:  def VVxdi0(self, state):
25711:   for flag, txt in self.VVKcCc().items():
25712:    if txt == state:
25713:     return flag
25714:   return -1
25715:  def VVKcCc(self):
25716:   return { self.VV68m8: "Not started", self.VVfsD9: "Connecting", self.VVqBma: "Downloading", self.VVf0kA: "Stopped", self.VVewiH: "Completed" }
25717:  def VVxIyd(self, title):
25718:   colList = self.VV6A99.VV5crm()
25719:   path = colList[6]
25720:   url  = colList[8]
25721:   if self.VVk3yS() : self.VVQ5VQ("Cannot delete while downloading.")
25722:   else      : FFRMYv(self.SELF, BF(self.VVcgkp, path, url), "Delete ?\n\n%s" % path, title=title)
25723:  def VVcgkp(self, path, url):
25724:   m3u8Log = self.VV6A99.VV5crm()[12]
25725:   if m3u8Log : FFpwZS("rm -f '%s' '%s' '%s'" % (m3u8Log, m3u8Log[:-4], m3u8Log[:-9]))
25726:   else  : FFpwZS("rm -rf '%s'" % path)
25727:   self.VVd1mb(False)
25728:   self.VV6wof()
25729:  def VVd1mb(self, VVwb7n=True):
25730:   if self.VVk3yS():
25731:    FF28n1(self.VV6A99, self.VV9va5(self.VVqBma), 500)
25732:   else:
25733:    colList  = self.VV6A99.VV5crm()
25734:    state  = colList[4]
25735:    VVZcRP = colList[9]
25736:    if self.VVxdi0(state) in (self.VV68m8, self.VVewiH, self.VVf0kA):
25737:     lines = CCHRcZ.VVXGK6()
25738:     newLines = []
25739:     found = False
25740:     for line in lines:
25741:      if CCHRcZ.VV6h6K(VVZcRP, line): found = True
25742:      else            : newLines.append(line)
25743:     if found:
25744:      self.VVdJSh(newLines)
25745:      self.VV6wof()
25746:      FF28n1(self.VV6A99, "Removed.", 1000)
25747:     else:
25748:      FF28n1(self.VV6A99, "Not found.", 1000)
25749:    elif VVwb7n:
25750:     self.VVQ5VQ("Cannot remove partial download !\n\nYou can delete the file (from options).")
25751:  def VV3Qjo(self, flag, title):
25752:   ques = "Only remove from table (no file deletion).\n\nContinue ?"
25753:   FFRMYv(self.SELF, BF(self.VVAkoO, flag), ques, title=title)
25754:  def VVAkoO(self, flag):
25755:   list = []
25756:   for ndx, row in enumerate(self.VV6A99.VVrrm9()):
25757:    state  = row[4].strip()
25758:    VVZcRP = row[9].strip()
25759:    flagVal  = self.VVxdi0(state)
25760:    if   flag == flagVal == self.VVewiH: list.append(VVZcRP)
25761:    elif flag == flagVal == self.VV68m8 : list.append(VVZcRP)
25762:   lines = CCHRcZ.VVXGK6()
25763:   totRem = 0
25764:   newLines = []
25765:   for line in lines:
25766:    if any(x in line for x in list) : totRem += 1
25767:    else       : newLines.append(line)
25768:   if totRem > 0:
25769:    self.VVdJSh(newLines)
25770:    self.VV6wof()
25771:    FF28n1(self.VV6A99, "%d removed." % totRem, 1000)
25772:   else:
25773:    FF28n1(self.VV6A99, "Not found.", 1000)
25774:  def VVQ2Kb(self):
25775:   colList  = self.VV6A99.VV5crm()
25776:   path  = colList[6]
25777:   VVZcRP = colList[9]
25778:   png   = "%s.png" % os.path.splitext(path)[0]
25779:   if FFCyVu(png) : FF28n1(self.VV6A99, "Poster exists", 1500)
25780:   else    : FFimQ3(self.VV6A99, BF(self.VVXbFa, VVZcRP, path, png), title="Checking Server ...")
25781:  def VVXbFa(self, VVZcRP, path, png):
25782:   err = self.VVbwYV(VVZcRP, path, png)
25783:   if err:
25784:    FFdw58(self.SELF, err, title="Poster Download")
25785:  def VVbwYV(self, VVZcRP, path, png):
25786:   epg, evLst, VVfbmn, err = CCvjVs.VVPhf6(VVZcRP)
25787:   if not VVfbmn:
25788:    return "Cannot download poster.\n\nTry downloading it from IPTV the tables."
25789:   ext = os.path.splitext(VVfbmn)[1] or ".png"
25790:   tPath, err = FFx9uM(VVfbmn, "ajp_tmp%s" % ext, timeout=2, VVzHui=True)
25791:   if err:
25792:    return "Cannot download poster !\n\n%s" % err
25793:   else:
25794:    png = "%s%s" % (os.path.splitext(path)[0], ext)
25795:    FFpwZS("mv -f '%s' '%s'" % (tPath, png))
25796:    CCf8zb.VVjnMn(self.SELF, VVPq2Z=png, showGrnMsg="Saved")
25797:    return ""
25798:  def VVlDhI(self, VV6A99, title, txt, colList):
25799:   def VVVuRT(key, val) : return "%s\t: %s\n" % (key, val.strip())
25800:   def VVJi7Q(key, val) : return "\n%s:\n%s\n" % (FFjt5L(key, VVFuwR), val.strip())
25801:   heads  = self.VV6A99.VVeVZB()
25802:   txt = ""
25803:   for i in range(6):
25804:    if i == 3:
25805:     totSize = colList[7].strip()
25806:     curSize = colList[10].strip()
25807:     if totSize and totSize.isdigit(): txt += VVVuRT(heads[i]  , CClYaF.VV99gM(int(totSize), mode=0))
25808:     if curSize and curSize.isdigit(): txt += VVVuRT("Downloaded" , CClYaF.VV99gM(int(curSize), mode=0))
25809:    else:
25810:     txt += VVVuRT(heads[i], colList[i])
25811:   if not "j.php" in colList[9]:
25812:    for i in (6, 8):
25813:     txt += VVJi7Q(heads[i], colList[i])
25814:   FF4lCP(self.SELF, txt, title=title)
25815:  def VVx0TS(self, VV6A99, title, txt, colList):
25816:   path = colList[6].strip()
25817:   m3u8Log = colList[12].strip()
25818:   if m3u8Log:
25819:    path = m3u8Log[:-9]
25820:   if FFCyVu(path) : CClYaF.VVTWR0(self.SELF, path)
25821:   else    : FF28n1(self.VV6A99, "File not found", 1000)
25822:  def VV0iZw(self, VV6A99, title, txt, colList):
25823:   VV1wIO = colList[1].strip()
25824:   path = colList[6].strip()
25825:   tUrl = colList[9].strip()
25826:   tUrl = tUrl.replace(":" + VV1wIO, "")
25827:   tUrl = tUrl.replace(":", "%3a")
25828:   Id  = "555"
25829:   VVPxk5 = CCkEI5.VVpX1r(Id, Id, Id)
25830:   chUrl = "%s%s:%s" % (VVPxk5, tUrl, VV1wIO)
25831:   VVAfO9 = CCvjVs.VVbTkM(path)
25832:   CCqWM2.VVHc02(self.SELF.session, VVaHNe=chUrl, VVAfO9=VVAfO9, VVEBd5=False, VVdxwH=False, VVOOLD=False)
25833:  def VVAvqF(self, VV6A99):
25834:   self.cancel()
25835:  def cancel(self):
25836:   self.timer.stop()
25837:   if self.VV6A99:
25838:    self.VV6A99.cancel()
25839:   del self
25840:  def VVEzGg(self, VV6A99, title, txt, colList):
25841:   c1, c2, c3 = VVIH76, VVz22H, VVFuwR
25842:   path  = colList[6].strip()
25843:   VVZcRP = colList[9].strip()
25844:   resumeTxt = "Disable" if CFG.downloadAutoResume.getValue() else "Enable"
25845:   showMonitor = "Disable" if CFG.downloadMonitor.getValue() else "Enable"
25846:   VV3wat = []
25847:   VV3wat.append((c1 + "Remove current row"       , "VVd1mb" ))
25848:   VV3wat.append(VVAL3j)
25849:   VV3wat.append((c1 + 'Remove all "Completed"'      , "remFinished"   ))
25850:   VV3wat.append((c1 + 'Remove all "Not started"'     , "remPending"   ))
25851:   VV3wat.append(VVAL3j)
25852:   VV3wat.append((c2 + "Delete the file (and remove from list)"  , "VVxIyd"))
25853:   VV3wat.append(VVAL3j)
25854:   VV3wat.append((resumeTxt + " Auto Resume"       , "VVsvWO" ))
25855:   VV3wat.append((showMonitor + " On-screen Download Monitor"  , "toggleMonitor"  ))
25856:   VV3wat.append(VVAL3j)
25857:   cond = FFKxIH(VVZcRP)
25858:   VV3wat.append(FFsLU5("Download Movie Poster %s" % ("(from server)" if cond else "... Movies only"), "VVQ2Kb", cond, c3))
25859:   VV3wat.append(FFsLU5("Open in File Manager", "inFileMan,%s" % path, FFCyVu(path), c3))
25860:   FFLFTC(self.SELF, BF(self.VVZ8HY, VV6A99), VV3wat=VV3wat, title=self.Title, VVU8mZ=True, width=800, VVlaGv=True, VVwltY="#1a001122", VVkxBG="#1a001122")
25861:  def VVZ8HY(self, VV6A99, item=None):
25862:   if item:
25863:    txt, ref, ndx = item
25864:    if   ref == "VVd1mb"  : self.VVd1mb()
25865:    elif ref == "remFinished"   : self.VV3Qjo(self.VVewiH, txt)
25866:    elif ref == "remPending"   : self.VV3Qjo(self.VV68m8, txt)
25867:    elif ref == "VVxIyd" : self.VVxIyd(txt)
25868:    elif ref == "VVQ2Kb"  : self.VVQ2Kb()
25869:    elif ref == "VVsvWO"  : FFjt1c(CFG.downloadAutoResume, not CFG.downloadAutoResume.getValue())
25870:    elif ref == "toggleMonitor"   : FFjt1c(CFG.downloadMonitor, not CFG.downloadMonitor.getValue())
25871:    elif ref.startswith("inFileMan,") :
25872:     path = ref.split(",", 1)[1]
25873:     if VVmJwX(path) : self.SELF.session.open(CClYaF, mode=CClYaF.VV4Ihm, VVHYTc=path)
25874:     else    : FF28n1(VV6A99, "Path not found !", 1500)
25875:  def VVCz4F(self, startDnld, VVZcRP):
25876:   refreshToken = True
25877:   if not VVZcRP:
25878:    VVZcRP = CC3rDi(self.SELF.session).VVZcRP
25879:   else:
25880:    ndx = VVZcRP.find("j.php")
25881:    if ndx > -1:
25882:     url = CC96QG.VVqzuM(VVZcRP)
25883:     if url:
25884:      span = iSearch(r"&.+=", VVZcRP)
25885:      if span : VVZcRP = url + "&" + VVZcRP[ndx + 6:]
25886:      else : VVZcRP = url + VVZcRP[ndx + 5:]
25887:      refreshToken = False
25888:     else:
25889:      self.VVQ5VQ("Could not get download link !\n\nTry again later.")
25890:      return
25891:   for line in CCHRcZ.VVXGK6():
25892:    if CCHRcZ.VV6h6K(VVZcRP, line):
25893:     if self.VV6A99:
25894:      self.VVYJQw(VVZcRP)
25895:      FFIElK(BF(FF28n1, self.VV6A99, "Already listed !", 2000))
25896:     break
25897:   else:
25898:    fnc = self.cancel if self.mode == self.VVyzIo else None
25899:    params = self.VVVwJR(VVZcRP, refreshToken)
25900:    if len(params) == 1:
25901:     self.VVQ5VQ(params[0])
25902:     if fnc:
25903:      fnc()
25904:    elif len(params) == 2:
25905:     resp, VV1wIO = params
25906:     FFRMYv(self.SELF, BF(self.VVB92s, resp, VVZcRP), "Start downloading ?\n\n%s" % VV1wIO, callBack_No=fnc, title="Download (m3u8)")
25907:    else:
25908:     url, fSize, path, resp, resumable = params
25909:     title= "Download : %s" % CClYaF.VV99gM(fSize)
25910:     FFRMYv(self.SELF, BF(self.VVBfeH, VVZcRP, url, fSize, path, resp, startDnld), "Download to\n\n%s" % path, callBack_No=fnc, title=title)
25911:  def VVBfeH(self, VVZcRP, url, fSize, path, resp, startDnld):
25912:   with open(CCHRcZ.VVotCb(), "a") as f:
25913:    f.write("%s,%s\n" % (fSize, VVZcRP))
25914:   self.VV6wof()
25915:   if self.VV6A99:
25916:    self.VV6A99.VVMjPT()
25917:   if startDnld:
25918:    threadName = "%s{%s,Sz,}%s" % (CCHRcZ.VVwbS2, path, VVZcRP)
25919:    self.VVRbSF(threadName, url, VVZcRP, path, resp)
25920:  def VVYJQw(self, VVZcRP):
25921:   if self.VV6A99:
25922:    for ndx, row in enumerate(self.VV6A99.VVrrm9()):
25923:     VVZcRP2 = row[9].strip()
25924:     if VVZcRP == VVZcRP2 and self.VV6A99:
25925:      self.VV6A99.VVrqBw(ndx)
25926:      break
25927:  def VVVwJR(self, VVZcRP, checkExist=True, resumeByte=-1, refreshToken=True):
25928:   fName = ""
25929:   if VVZcRP:
25930:    fName, VV1wIO, url = self.VVQajF(VVZcRP)
25931:   if not fName:
25932:    return ["Cannot process URL parameters !"]
25933:   path = self.VVBFa1(VVZcRP, fName)
25934:   if checkExist and FFCyVu(path):
25935:    return ["File already exists:\n\n%s" % path]
25936:   if refreshToken and "chCode" in VVZcRP:
25937:    url = CC96QG.VVqzuM(VVZcRP)
25938:    if not url:
25939:     return ["Could not get download link from server!"]
25940:   fSize = 0
25941:   resumable = False
25942:   try:
25943:    headers = CCkEI5.VVgoVw()
25944:    if resumeByte > -1:
25945:     headers["Range"] = "bytes=%d-" % resumeByte
25946:    import requests
25947:    resp = requests.get(url, headers=headers, timeout=3, stream=True, verify=True)
25948:    if not resp.ok:
25949:     return ["Err-%d : %s" % (resp.status_code, resp.reason)]
25950:    head = resp.headers
25951:    fSize = head.get("Content-Length", "")
25952:    cType = head.get("Content-Type", "")
25953:    resumable = CCHRcZ.VV5qrn(resp)
25954:   except:
25955:    return ["Could not get file info from server !"]
25956:   if not fSize or not fSize.isdigit():
25957:    return ["Cannot get file size from server !"]
25958:   fSize = int(fSize)
25959:   if not "video" in cType and not "application/octet-stream" in cType:
25960:    if ".m3u8" in resp.url:
25961:     return [resp, VV1wIO]
25962:    elif path and resp.url and fSize:
25963:     pass
25964:    else:
25965:     return ["Cannot download this video !\n\nIncorrect download data (or not allowed by server)."]
25966:   err = CCHRcZ.VVymoR(fSize)
25967:   if err:
25968:    return [err]
25969:   return [url, fSize, path, resp, resumable]
25970:  def VVB92s(self, resp, VVZcRP):
25971:   if not FFayeZ("ffmpeg"):
25972:    FFRMYv(self.SELF, BF(CCkEI5.VVGS56, self.SELF), '"FFmpeg" not found !\n\nInstall FFmpeg ?', title=VV1wIO)
25973:    return
25974:   fName, VV1wIO, url = self.VVQajF(VVZcRP)
25975:   dest = os.path.join(CFG.MovieDownloadPath.getValue(), fName)
25976:   self.m3u8_params = resp, VVZcRP, dest, fName, VV1wIO, url
25977:   rTxt = str(resp.text)
25978:   rUrl = str(resp.url)
25979:   if "#EXT-X-STREAM-INF" in rTxt:
25980:    self.VVMZr7(rTxt, rUrl)
25981:   elif "#EXTINF:" in rTxt:
25982:    if FFCyVu(dest) : FFRMYv(self.SELF, BF(self.VVCo20, rTxt, rUrl), "Overwrite existing file ?\n\n%s" % dest, title=VV1wIO)
25983:    else    : self.VVCo20(rTxt, rUrl)
25984:   else:
25985:    self.VVQ5VQ("Cannot process m3u8 file !")
25986:  def VVMZr7(self, rTxt, rUrl):
25987:   lst   = iFindall(r"RESOLUTION=(\d+x\d+).*\n(.+)", rTxt, IGNORECASE)
25988:   VV3wat = []
25989:   for resol, fPath in lst:
25990:    resol = str(resol).replace("x", " x ")
25991:    fPath = str(fPath)
25992:    fullUrl = CCkEI5.VVyjSu(rUrl, fPath)
25993:    VV3wat.append((resol, fullUrl))
25994:   if VV3wat:
25995:    FFLFTC(self.SELF, self.VVpq1h, VV3wat=VV3wat, title="Resolution", VVU8mZ=True, VVlaGv=True)
25996:   else:
25997:    self.VVQ5VQ("Cannot get Resolutions list from server !")
25998:  def VVpq1h(self, item=None):
25999:   if item:
26000:    txt, resolUrl, ndx = item
26001:    resp, VVZcRP, dest, fName, VV1wIO, url = self.m3u8_params
26002:    resol = txt.replace(" ", "")
26003:    fPath, fExt = os.path.splitext(fName)
26004:    fName = "%s_%s%s" % (fPath, resol, fExt)
26005:    fPath, fExt = os.path.splitext(dest)
26006:    dest = "%s_%s%s" % (fPath, resol, fExt)
26007:    self.m3u8_params = resp, VVZcRP, dest, fName, VV1wIO, url
26008:    if FFCyVu(dest):
26009:     FFRMYv(self.SELF, BF(FFIElK, BF(self.VVObWI, resolUrl)), "Overwrite existing file ?\n\n%s" % dest, title=VV1wIO)
26010:    else:
26011:     FFIElK(BF(self.VVObWI, resolUrl))
26012:  def VVObWI(self, resolUrl):
26013:   resp, txt, err = CC96QG.VVKe8x(resolUrl)
26014:   if err : self.VVQ5VQ(err)
26015:   else : self.VVCo20(txt, resolUrl)
26016:  def VVTuFo(self, logF, VVZcRP):
26017:   found = False
26018:   lines = CCHRcZ.VVXGK6()
26019:   with open(CCHRcZ.VVotCb(), "w") as f:
26020:    for line in lines:
26021:     if CCHRcZ.VV6h6K(VVZcRP, line):
26022:      line = "%s,%s" % (logF, VVZcRP)
26023:      found = True
26024:     f.write(line + "\n")
26025:   if not found:
26026:    with open(CCHRcZ.VVotCb(), "a") as f:
26027:     f.write("%s,%s\n" % (logF, VVZcRP))
26028:   self.VV6wof()
26029:   if self.VV6A99:
26030:    self.VV6A99.VVMjPT()
26031:  def VVCo20(self, rTxt, rUrl):
26032:   resp, VVZcRP, dest, fName, VV1wIO, url = self.m3u8_params
26033:   fName = FFOu5Y(fName)
26034:   dest  = FFOu5Y(dest)
26035:   m3u8File = os.path.join(CFG.MovieDownloadPath.getValue(), "%s.m3u8" % fName)
26036:   with open(m3u8File, "w") as f:
26037:    lines = rTxt.splitlines()
26038:    for line in lines:
26039:     line = line.strip()
26040:     if line.startswith(("#EXTM", "#EXT-")) and not line.startswith("#EXT-X-ENDLIST"):
26041:      f.write(line + "\n")
26042:   lst = iFindall(r"(
26043:   if lst:
26044:    with open(m3u8File, "a") as f:
26045:     for extInf, fPath in lst:
26046:      extInf = str(extInf)
26047:      fPath = str(fPath)
26048:      fPath = CCkEI5.VVyjSu(rUrl, fPath)
26049:      f.write(extInf + "\n")
26050:      f.write(fPath + "\n")
26051:     f.write("#EXT-X-ENDLIST\n")
26052:   else:
26053:    self.VVQ5VQ("Incorrect m3u8 file from server !")
26054:    return
26055:   logF = "%s.log" % m3u8File
26056:   self.VVTuFo(logF, VVZcRP)
26057:   cmd  = "ffmpeg -y -hide_banner -protocol_whitelist file,http,https,tcp,tls,crypto -i '%s' -c copy '%s' > '%s' 2>&1" % (m3u8File, dest, logF)
26058:   cmd += " && %s" % FFb2oQ("rm -f '%s' '%s'" % (m3u8File, logF))
26059:   threadName = "%s{%s,,%s}%s" % (CCHRcZ.VVwbS2, dest, logF, VVZcRP)
26060:   myThread = iThread(name=threadName, target=BF(os.system, cmd))
26061:   myThread.start()
26062:  @staticmethod
26063:  def VVlzpX(dnldLog):
26064:   if FFCyVu(dnldLog):
26065:    dur = CCHRcZ.VVHu70(dnldLog)
26066:    if dur > -1:
26067:     tim = CCHRcZ.VV1Wre(dnldLog)
26068:     if tim > -1:
26069:      return float(tim) / float(dur) * 100
26070:   elif FFCyVu(dnldLog[:-9]):
26071:    return 100
26072:   return -1
26073:  @staticmethod
26074:  def VVHu70(dnldLog):
26075:   lines = FF3xOt("head -n 15 %s" % dnldLog)
26076:   for line in lines:
26077:    span = iSearch(r"Duration:\s*(\d+):(\d+):(\d+.\d+)\s*", line, IGNORECASE)
26078:    if span:
26079:     return int(span.group(1)) * 3600 + int(span.group(2)) * 60 + float(span.group(3))
26080:   return -1
26081:  @staticmethod
26082:  def VV1Wre(dnldLog):
26083:   lines = FF3xOt("tail -n 15 %s" % dnldLog)
26084:   for line in reversed(lines):
26085:    span = iSearch(r"time=\s*(\d+):(\d+):(\d+.\d+)\s*", line, IGNORECASE)
26086:    if span:
26087:     return int(span.group(1)) * 3600 + int(span.group(2)) * 60 + float(span.group(3))
26088:   return -1
26089:  def VVBFa1(self, url, fName):
26090:   path = CFG.MovieDownloadPath.getValue()
26091:   if FF1BEt(url):
26092:    span = iSearch(r"(.+)S\d\dE\d\d|(.+)Season_\d{1,2}_\d{1,2}", fName, IGNORECASE)
26093:    if span:
26094:     path1 = path + (span.group(1) or span.group(2)).strip("_(")
26095:     FFpwZS("mkdir '%s'" % path1)
26096:     if VVmJwX(path1):
26097:      return path1 + "/" + fName
26098:   return path + fName
26099:  def VVRbSF(self, threadName, url, VVZcRP, path, resp, isAppend=False):
26100:   totFileSize = int(self.VV6A99.VV5crm()[7])
26101:   threadName = threadName.replace(",Sz,", ",%s," % totFileSize)
26102:   myThread = iThread(name=threadName, target=BF(self.VVHkvh, url, VVZcRP, path, resp, totFileSize, isAppend))
26103:   myThread.start()
26104:  def VVHkvh(self, url, VVZcRP, path, resp, totFileSize, isAppend):
26105:   CCHRcZ.VVyEAg = ""
26106:   totBytes = 0
26107:   try:
26108:    with open(path, "ab" if isAppend else "wb") as f:
26109:     for chunk in resp.iter_content(chunk_size=8192):
26110:      if FFCyVu(path):
26111:       if chunk:
26112:        try:
26113:         f.write(chunk)
26114:         self.VVQpOu(path)
26115:        except Exception as e:
26116:         CCHRcZ.VVyEAg = str(e)
26117:         return
26118:       if CCHRcZ.VVTaMF == path:
26119:        CCHRcZ.VVTaMF = ""
26120:        return
26121:      else:
26122:       break
26123:   except Exception as e:
26124:    if not self.VVpAqb(path, e):
26125:     return
26126:   if CFG.downloadAutoResume.getValue():
26127:    curSize = FFXhoc(path)
26128:    if curSize > -1 and not curSize == totFileSize:
26129:     params = self.VVVwJR(VVZcRP, checkExist=False, resumeByte=curSize)
26130:     if len(params) > 1:
26131:      url, fSize, path, resp, resumable = params
26132:      if resumable:
26133:       self.VVHkvh(url, VVZcRP, path, resp, totFileSize, True)
26134:  def VVpAqb(self, path, e):
26135:   if "IncompleteRead" in str(e):
26136:    now = iTime()
26137:    cnt, tm = 0, now
26138:    if path in CCHRcZ.VVy3rX:
26139:     cnt, tm = CCHRcZ.VVy3rX[path]
26140:     if cnt > 2 and now > tm + 3:
26141:      self.VVQpOu(path)
26142:      return False
26143:     else:
26144:      iSleep(1)
26145:    self.VVDZip(path, cnt + 1, tm)
26146:   return True
26147:  def VVDZip(self, path, cnt, tm):
26148:   CCHRcZ.VVy3rX[path] = (cnt, tm)
26149:  def VVQpOu(self, path):
26150:   if path in CCHRcZ.VVy3rX: CCHRcZ.VVy3rX.pop(path)
26151:  def VVSOdJ(self, VV6A99, title, txt, colList):
26152:   m3u8Log = colList[12].strip()
26153:   VVZcRP = colList[9].strip()
26154:   if       self.VVE8tj() : FF28n1(self.VV6A99, self.VV9va5(self.VVewiH), 500)
26155:   elif not self.VVk3yS() : FF28n1(self.VV6A99, self.VV9va5(self.VVf0kA), 500)
26156:   elif m3u8Log      : FFRMYv(self.SELF, self.VVZGqS, "This may stop other non-resumable files !\n\nStop anyway ?", title="Stopping non-resumable download")
26157:   else:
26158:    if VVZcRP in self.VV1sva():
26159:     CCHRcZ.VVTaMF = colList[6]
26160:     FF28n1(self.VV6A99, "Stopping ...", 1000)
26161:    else:
26162:     FF28n1(self.VV6A99, "Stopped", 500)
26163:  def VVZGqS(self, withMsg=True):
26164:   if withMsg:
26165:    FF28n1(self.VV6A99, "Stopping ...", 1000)
26166:   FFpwZS("killall -INT ffmpeg")
26167:  def VVr1ws(self, *args):
26168:   if   self.VVE8tj() : FF28n1(self.VV6A99, self.VV9va5(self.VVewiH) , 500)
26169:   elif self.VVk3yS() : FF28n1(self.VV6A99, self.VV9va5(self.VVqBma), 500)
26170:   else:
26171:    resume = False
26172:    m3u8Log = self.VV6A99.VV5crm()[12]
26173:    if m3u8Log:
26174:     if FFCyVu(m3u8Log) : FFRMYv(self.SELF, BF(self.VV2fZj, m3u8Log), "Cannot resume m3u8 type !\n\nDelete file and restart download ?", title="Resume")
26175:     else     : resume = True
26176:    elif self.VVjN99():
26177:     resume = True
26178:    if resume: self.VVGE1C(self.VV6A99)
26179:    else  : FF28n1(self.VV6A99, "Cannot resume !", 500)
26180:  def VV2fZj(self, m3u8Log):
26181:   FFpwZS("rm -f '%s' '%s' '%s'" % (m3u8Log, m3u8Log[:-4], m3u8Log[:-9]))
26182:   self.VVGE1C(self.VV6A99)
26183:  @FFOAKH("Checking Server ...", par=1)
26184:  def VVGE1C(self, tbl):
26185:   colList  = self.VV6A99.VV5crm()
26186:   path  = colList[6]
26187:   size  = colList[7]
26188:   VVZcRP = colList[9]
26189:   if "j.php" in VVZcRP:
26190:    url = CC96QG.VVqzuM(VVZcRP)
26191:    if url:
26192:     VVZcRP = self.VVSHyu(VVZcRP, url)
26193:    else:
26194:     self.VVQ5VQ("Could not get download link !\n\nTry again later.")
26195:     return
26196:   curSize = FFXhoc(path)
26197:   params = self.VVVwJR(VVZcRP, checkExist=False, resumeByte=curSize)
26198:   if len(params) == 1:
26199:    self.VVQ5VQ(params[0])
26200:    return
26201:   elif len(params) == 2:
26202:    self.VVB92s(params[0], VVZcRP)
26203:    return
26204:   url, fSize, path, resp, resumable = params
26205:   if size == "-1":
26206:    VVZcRP = self.VVSHyu(VVZcRP, url, fSize)
26207:   threadName = "%s{%s,Sz,}%s" % (CCHRcZ.VVwbS2, path, VVZcRP)
26208:   if resumable: self.VVRbSF(threadName, url, VVZcRP, path, resp, isAppend=True)
26209:   else  : self.VVQ5VQ("Cannot resume from server !")
26210:  def VVQajF(self, VVZcRP):
26211:   span = iSearch(r"\?ext=(\..{3})", VVZcRP)
26212:   fileExt = CCkEI5.VVZniM(VVZcRP) or (span.group(1) if span else "") or ".mp4"
26213:   fixName = True
26214:   url = fName = VV1wIO = ""
26215:   tUrl = iSub(r"[&?]mode=.+end=", r"", VVZcRP, flags=IGNORECASE)
26216:   span = iSearch(r"(https?:\/\/.+\/(?:movie|series).+\/.+\/)(.+)(:.+)", tUrl, IGNORECASE)
26217:   if span:
26218:    url  = span.group(1)
26219:    fName = span.group(2)
26220:    VV1wIO = span.group(3)
26221:   elif "j.php" in tUrl:
26222:    span = iSearch(r"(.+j.php)(:.+)", tUrl, IGNORECASE)
26223:    if span:
26224:     url  = span.group(1)
26225:     fName = "tmp"
26226:     VV1wIO = span.group(2)
26227:   elif "/play/" in VVZcRP:
26228:    span = iSearch(r"(.+)&mode.+&end=(:.+)", VVZcRP, IGNORECASE)
26229:    if span:
26230:     url = span.group(1)
26231:     VV1wIO = span.group(2)
26232:    span = iSearch(r".+movie.php?.+stream=(.+\..{3,4})&.+", VVZcRP, IGNORECASE)
26233:    if span     : fName = span.group(1)
26234:    elif fileExt == ".php" : fName = ".mkv" if ".mkv" in VVZcRP else ".mp4"
26235:    else     : fName = fileExt
26236:   elif "get_download_link" in VVZcRP:
26237:    span = iSearch(r"(.+)&mode.+chCm=(.+)&end=(:.+)", VVZcRP, IGNORECASE)
26238:    if span:
26239:     url  = span.group(1)
26240:     fName = os.path.basename(span.group(2))
26241:     VV1wIO = span.group(3).replace(":", "_").strip("_")
26242:     fixName = False
26243:   elif "/timeshift/" in VVZcRP:
26244:    span = iSearch(r"(http.+\/timeshift\/.+(\..+)):(.+)(?:\s>>\s(.+))", VVZcRP, IGNORECASE)
26245:    if span:
26246:     url, ext, VV1wIO, movNm = span.groups()
26247:     fName = movNm + (ext or ".ts")
26248:     fixName = False
26249:   else:
26250:    ok = False
26251:    span = iSearch(r"(.+\/(.+.mp4).+m3u8).+:(.+)", VVZcRP, IGNORECASE)
26252:    if span:
26253:     url  = span.group(1)
26254:     fName = span.group(2)
26255:     VV1wIO = span.group(3)
26256:     fixName = False
26257:     ok  = True
26258:    if not ok:
26259:     span = iSearch(r"(.+\/.+m3u8).*:(.+)", VVZcRP, IGNORECASE)
26260:     if span:
26261:      url  = span.group(1)
26262:      VV1wIO = span.group(2)
26263:      fName = VV1wIO + fileExt
26264:      fixName = False
26265:      ok  = True
26266:    if not ok and FFUl6q(VVZcRP):
26267:     span = iSearch(r"(.+)\?\:(.+)", VVZcRP, IGNORECASE)
26268:     if span:
26269:      url  = span.group(1)
26270:      VV1wIO = span.group(2)
26271:      fName = VV1wIO + fileExt
26272:      fixName = False
26273:     else:
26274:      span = iSearch(r"(.+):(.+)", VVZcRP, IGNORECASE)
26275:      if span:
26276:       url  = span.group(1)
26277:       VV1wIO = span.group(2)
26278:       fName = VV1wIO + fileExt
26279:       fixName = False
26280:   if url and fName and VV1wIO:
26281:    if fixName:
26282:     mix  = fName + VV1wIO
26283:     parts = mix.split(":", 1)
26284:     fName = parts[0]
26285:     VV1wIO = parts[1]
26286:     fName = iSub(r"[?]play_token.+", r"", fName, flags=IGNORECASE)
26287:     url += fName
26288:    VV1wIO1 = VV1wIO.replace(" ", "_")
26289:    fName = VV1wIO1 + "_" + fName.lstrip("_")
26290:    fName = FFOu5Y(fName)
26291:    if fName.endswith(".vod"): fName += ".mp4"
26292:    return fName, VV1wIO, url
26293:   else:
26294:    return "", "", ""
26295:  def VVQ5VQ(self, txt):
26296:   FFdw58(self.SELF, txt, title=self.Title)
26297:  def VV1sva(self):
26298:   thrListUrls = []
26299:   for thr in iEnumerate():
26300:    span = iSearch(r"%s(?:{.+})*(.+)" % CCHRcZ.VVwbS2, thr.name, IGNORECASE)
26301:    if span:
26302:     thrListUrls.append(span.group(1))
26303:   return thrListUrls
26304:  def VVk3yS(self):
26305:   VVZcRP = self.VV6A99.VV5crm()[9]
26306:   return VVZcRP in self.VV1sva()
26307:  def VVE8tj(self):
26308:   colList = self.VV6A99.VV5crm()
26309:   path = colList[6]
26310:   size = colList[7]
26311:   m3u8Log = colList[12]
26312:   if m3u8Log:
26313:    return FFCyVu(m3u8Log[:-9]) and not FFCyVu(m3u8Log)
26314:   else:
26315:    if size == "-1" : return False
26316:    else   : return str(FFXhoc(path)) == size
26317:  def VVjN99(self):
26318:   colList = self.VV6A99.VV5crm()
26319:   path = colList[6]
26320:   size = int(colList[7])
26321:   curSize = FFXhoc(path)
26322:   if curSize > -1:
26323:    size -= curSize
26324:   err = CCHRcZ.VVymoR(size)
26325:   if err:
26326:    FFdw58(self.SELF, err, title=self.Title)
26327:    return False
26328:   return True
26329:  def VVdJSh(self, list):
26330:   with open(CCHRcZ.VVotCb(), "w") as f:
26331:    for line in list:
26332:     f.write(line + "\n")
26333:  def VVSHyu(self, VVZcRP, newUrl, newSize=-1):
26334:   found = False
26335:   lines = CCHRcZ.VVXGK6()
26336:   url = VVZcRP
26337:   with open(CCHRcZ.VVotCb(), "w") as f:
26338:    for line in lines:
26339:     if CCHRcZ.VV6h6K(VVZcRP, line):
26340:      parts = line.split(",", 1)
26341:      oldUrl = parts[1].strip()
26342:      if newSize and not newSize == -1: fSize = str(newSize)
26343:      else       : fSize = parts[0]
26344:      ndx = url.find("j.php")
26345:      if ndx > -1:
26346:       url = newUrl + url[ndx + 5:]
26347:      line = "%s,%s" % (fSize, url)
26348:      found = True
26349:     f.write(line + "\n")
26350:   if found:
26351:    self.VV6wof()
26352:   return url
26353:  @staticmethod
26354:  def VVXGK6():
26355:   list = []
26356:   if FFCyVu(CCHRcZ.VVotCb()):
26357:    for line in FFL19l(CCHRcZ.VVotCb()):
26358:     line = line.strip()
26359:     if line:
26360:      list.append(line)
26361:   return list
26362:  @staticmethod
26363:  def VV6h6K(VVZcRP, line):
26364:   span = iSearch(r"(mode=.+end=.+)", VVZcRP, IGNORECASE)
26365:   if span: VVZcRP = span.group(1)
26366:   span = iSearch(r"(mode=.+end=.+)", line, IGNORECASE)
26367:   if span: line = span.group(1)
26368:   return VVZcRP in line
26369:  @staticmethod
26370:  def VVymoR(size, path=""):
26371:   dest = path or CFG.MovieDownloadPath.getValue()
26372:   if VVmJwX(dest):
26373:    total, used, free, avail, err = CClYaF.VVdlF7(dest)
26374:    if avail > size : return ""
26375:    else   : return "No enough space on mount for:\n%s\n\nFile Size = %s\nAvailable Space = %s" % (dest, CClYaF.VV99gM(size), CClYaF.VV99gM(avail))
26376:   else:
26377:    return "Path not found !\n\n%s" % dest
26378:  @staticmethod
26379:  def VVn3G5(SELF):
26380:   tot = CCHRcZ.VVY2Xw()
26381:   if tot:
26382:    FFdw58(SELF, "Cannot change while downloading.", title="")
26383:    return True
26384:   else:
26385:    return False
26386:  @staticmethod
26387:  def VVY2Xw():
26388:   c = 0
26389:   for thr in iEnumerate():
26390:    if thr.name.startswith(CCHRcZ.VVwbS2):
26391:     c += 1
26392:   return c
26393:  @staticmethod
26394:  def VVs4T7():
26395:   lst = []
26396:   for thr in iEnumerate():
26397:    span = iSearch(r"%s(?:{(.+),(.*),(.*)}).+" % CCHRcZ.VVwbS2, thr.name, IGNORECASE)
26398:    if span:
26399:     lst.append((span.group(1), span.group(2), span.group(3)))
26400:   return lst
26401:  @staticmethod
26402:  def VVAbZK():
26403:   return len(CCHRcZ.VVXGK6()) == 0
26404:  @staticmethod
26405:  def VVubE7():
26406:   list = []
26407:   for p in harddiskmanager.getMountedPartitions():
26408:    list.append(p.mountpoint)
26409:   return list
26410:  @staticmethod
26411:  def VVehLC():
26412:   mPoints = CCHRcZ.VVubE7()
26413:   list = []
26414:   for mPath in mPoints:
26415:    if not mPath == "/":
26416:     path = mPath + "/movie/"
26417:     if VVmJwX(path) : return path
26418:     else    : list.append(mPath)
26419:   drives = ("/hdd", "/usb", "/sd")
26420:   for mPath in list:
26421:    if any(x in mPath for x in drives):
26422:     path = mPath + "/movie/"
26423:     FFpwZS("mkdir '%s'" % path)
26424:     if VVmJwX(path):
26425:      return path
26426:   return "/tmp/"
26427:  @staticmethod
26428:  def VVotCb():
26429:   return FF0cqc() + "ajpanel_downloads"
26430:  @staticmethod
26431:  def VVSZMa(SELF, waitMsgObj=None):
26432:   FFimQ3(waitMsgObj or SELF, BF(CCHRcZ.VVb4jU, SELF, CCHRcZ.VVLHSO))
26433:  @staticmethod
26434:  def VVIcV1(SELF):
26435:   CCHRcZ.VVb4jU(SELF, CCHRcZ.VVyzIo, startDnld=True)
26436:  @staticmethod
26437:  def VVXNDk(SELF, url):
26438:   CCHRcZ.VVb4jU(SELF, CCHRcZ.VVyzIo, startDnld=True, VVZcRP=url)
26439:  @staticmethod
26440:  def VVfHMV(SELF):
26441:   added, skipped = CCHRcZ.VVNrGg([CC3rDi(SELF.session).VVZcRP])
26442:   FF1mVE(SELF, "Added", 1000)
26443:  @staticmethod
26444:  def VVNrGg(list):
26445:   added = skipped = 0
26446:   for line in CCHRcZ.VVXGK6():
26447:    for ndx, url in enumerate(list):
26448:     if url and CCHRcZ.VV6h6K(url, line):
26449:      skipped += 1
26450:      list[ndx] = ""
26451:      break
26452:   with open(CCHRcZ.VVotCb(), "a") as f:
26453:    for url in list:
26454:     if url:
26455:      added += 1
26456:      f.write("-1,%s\n" % url)
26457:   return added, skipped
26458:  @staticmethod
26459:  def VVb4jU(SELF, mode, startDnld=False, VVZcRP=""):
26460:   title = "Download Manager"
26461:   if not CCwhE4.VVOJRa(SELF):
26462:    return
26463:   if mode == CCHRcZ.VVLHSO and CCHRcZ.VVAbZK():
26464:    FFdw58(SELF, "Download list is empty !", title=title)
26465:   else:
26466:    inst = CCHRcZ(SELF, mode, title, startDnld=startDnld, VVZcRP=VVZcRP)
26467:  @staticmethod
26468:  def VV5qrn(res):
26469:   if res.status_code == 206:
26470:    return True
26471:   else:
26472:    hResume = res.headers.get("Accept-Ranges" , "")
26473:    if hResume and not hResume == "none":
26474:     return True
26475:   return False
26476:  @staticmethod
26477:  def VVcUJs(url, timeout=3):
26478:   err = ""
26479:   try:
26480:    import requests
26481:    res = requests.get(url, headers=CCkEI5.VVgoVw(), allow_redirects=True, timeout=timeout)
26482:    if res.ok:
26483:     return res, ""
26484:    else:
26485:     if res.status_code == 407: reason = "Proxy Authentication Required"
26486:     if res.status_code == 423: reason = "Access Locked"
26487:     if res.status_code == 521: reason = "Server Is Down"
26488:     else      : reason = "Unknown"
26489:     err = "Err-%d : %s" % (res.status_code, res.reason or reason)
26490:   except Exception as e:
26491:    err = "Error\n" + str(e)[:120]
26492:   return "", err
26493: class CCzCDl():
26494:  def __init__(self, SELF, url, path, title, pbTxt="", cbFnc=None, timeout=3, showRes=True):
26495:   self.SELF  = SELF
26496:   self.url  = url
26497:   self.Path  = path
26498:   self.Title  = title
26499:   self.pbTxt  = pbTxt or "Checking File Size ..."
26500:   self.cbFnc  = cbFnc
26501:   self.timeout = timeout
26502:   self.showRes = showRes
26503:   self.webFile = ""
26504:   self.webSize = ""
26505:   self.err  = ""
26506:   self.done  = False
26507:   Dir = os.path.dirname(path)
26508:   if not VVmJwX(Dir):
26509:    FFdw58(SELF, "Path does not exist:\n\n%s" % Dir, title)
26510:    return
26511:   CCh3tv.VV7Nf4(SELF, titleBg="#22110011", bodyBg="#22110011", barBg="#06117722"
26512:       , VVixvy  = self.VV2VNO
26513:       , VVbYwR = self.VVn5ox)
26514:  def VV2VNO(self, VVXyP6):
26515:   VVXyP6.VVaks5(self.pbTxt)
26516:   fSize = wSize = 0
26517:   err = ""
26518:   try:
26519:    import requests
26520:    resp = requests.get(self.url, headers=CCkEI5.VVgoVw(), timeout=self.timeout, stream=True, verify=True)
26521:    if not resp.ok:
26522:     if resp.reason : self.err = "Err-%d : %s" % (resp.status_code, resp.reason)
26523:     else   : self.err = "Cannot download data from server"
26524:     return
26525:    head  = resp.headers
26526:    cType = head.get("Content-Type", "")
26527:    if "stream" in cType:
26528:     fSize = head.get("Content-Length", "")
26529:     fSize = int(fSize) if fSize.isdigit() else 0
26530:    if not fSize: wSize = wSize = 200 * 1000 * 1000
26531:    self.webFile = FFvTve(head)
26532:   except requests.Timeout as e  : err = "Connection Timeout (> %s sec)" % self.timeout
26533:   except requests.ConnectionError as e: err = "Connection Error"
26534:   except Exception as e    : err = "Error\n" + str(e)[:120]
26535:   if not VVXyP6 or VVXyP6.isCancelled:
26536:    return
26537:   if err:
26538:    self.err = err
26539:    return
26540:   self.webSize = fSize or wSize
26541:   if not self.webSize:
26542:    self.err = "Cannot get size from server !"
26543:    return
26544:   err = CCHRcZ.VVymoR(self.webSize)
26545:   if err:
26546:    self.err = err
26547:    return
26548:   if not VVXyP6 or VVXyP6.isCancelled: return
26549:   VVXyP6.VVq8NF(self.webSize)
26550:   VVXyP6.VVaks5("Downloading (%s) ..." % CClYaF.VV99gM(self.webSize, mode=4))
26551:   totBytes = 0
26552:   try:
26553:    with open(self.Path, "wb") as f:
26554:     for chunk in resp.iter_content(chunk_size=8192):
26555:      if not FFCyVu(self.Path):
26556:       self.err = "Cannot access file:\n\n%s" % self.Path
26557:       return
26558:      if not VVXyP6 or VVXyP6.isCancelled:
26559:       self.err = "Download Cancelled"
26560:       return
26561:      if chunk:
26562:       try:
26563:        f.write(chunk)
26564:        VVXyP6.VVxtQs(len(chunk))
26565:       except:
26566:        self.err = "Cannot write to file:\n\n%s" % self.Path
26567:        return
26568:   except Exception as e:
26569:    self.err = str(e)
26570:  def VVn5ox(self, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
26571:   if self.showRes:
26572:    perc = int(100.0 * threadCounter / threadTotal) if threadTotal else 0
26573:    path = self.Path if FFCyVu(self.Path) else ""
26574:    if not VVRI6P:
26575:     if path:
26576:      if self.cbFnc: self.cbFnc(VVRI6P, self.url, self.webFile, self.Path)
26577:      else   : FFdw58(self.SELF, "Download cancelled (at %s%%) in:\n\n%s" % (perc, path) if path else ".", self.Title)
26578:    elif self.err:
26579:     FFdw58(self.SELF, self.err + (" (at %s%%) in:\n\n%s" % (perc, path) if path else ""), self.Title)
26580:    elif self.cbFnc:
26581:     self.cbFnc(VVRI6P, self.url, self.webFile, self.Path)
26582:    else:
26583:     FFipXT(self.SELF, "Successfully downloaded to:\n\n%s" % path, self.Title)
26584: class CCMdqL():
26585:  def __init__(self, SELF):
26586:   self.SELF   = SELF
26587:   self.VVoq1H = False
26588:   self.scrW, self.scrH = FFrPd1()
26589:   self.X, self.Y, self.W, self.H = FFpMtN(self.SELF)
26590:  def VVbIw5(self, x, y): self.SELF.instance.move(ePoint(x, y))
26591:  def VVH0AA(self, w, h): self.SELF.instance.resize(eSize(*(w, h)))
26592:  def VVxy2b(self, fnc=None):
26593:   self.VVbIw5(self.X, self.Y)
26594:   self.VVH0AA(self.W, self.H)
26595:   self.VVoq1H = False
26596:  def VV5HIg(self, up):
26597:   if self.VVoq1H: return
26598:   self.VVoq1H = True
26599:   origY = -(self.Y + self.H) if up else self.scrH
26600:   self.VVbIw5(self.X, origY)
26601:   self.SELF.show()
26602:   self.VVwmLx(up)
26603:  def VVwmLx(self, up):
26604:   try: y = self.SELF.instance.position().y() + (20 if up else -20)
26605:   except: return
26606:   if up and y < self.Y or not up and y > self.Y:
26607:    self.VVbIw5(self.X, y)
26608:    FFIElK(BF(self.VVwmLx, up))
26609:   else:
26610:    self.VVxy2b()
26611:  def VVvj1p(self, up):
26612:   if self.VVoq1H: return
26613:   self.VVoq1H = True
26614:   self.VVMxzh(up)
26615:  def VVMxzh(self, up):
26616:   try: y = self.SELF.instance.position().y() + (-20 if up else 20)
26617:   except: return
26618:   if up and y > -(self.Y + self.H) or not up and y < self.scrH:
26619:    self.VVbIw5(self.X, y)
26620:    FFIElK(BF(self.VVMxzh, up))
26621:   else:
26622:    self.SELF.hide()
26623:    self.VVxy2b()
26624:  def VVOVs9(self):
26625:   if self.VVoq1H: return
26626:   self.VVoq1H = True
26627:   self.VVbstD()
26628:  def VVbstD(self):
26629:   x, y, w, h = FFpMtN(self.SELF)
26630:   x += 70
26631:   w -= 140
26632:   if w > 1:
26633:    self.VVH0AA(w, h)
26634:    self.VVbIw5(x, y)
26635:    FFIElK(self.VVbstD)
26636:   else:
26637:    self.SELF.close()
26638:    self.VVoq1H = False
26639: class CCqWM2(Screen, CChyfE):
26640:  VVyLCv = None
26641:  def __init__(self, session, VVwqHQ=None, VVEBd5=True, VVdxwH=True, VVOOLD=True, VVV4a7=False, VVaHNe="", endRef="", zapFnc=None, VVAfO9="", cbFnc=None, VV1rS5=0):
26642:   self.skin, self.VVfOli = FFiNEe(VVakGB, 1600, 190, 28, 10, 6, "
26643:   CChyfE.__init__(self)
26644:   self.session    = session
26645:   self.VVwqHQ  = VVwqHQ
26646:   self.VVEBd5   = VVEBd5
26647:   self.VVdxwH  = VVdxwH
26648:   self.VVOOLD  = VVOOLD
26649:   self.VVV4a7  = VVV4a7
26650:   self.VVaHNe    = VVaHNe
26651:   self.endRef     = endRef
26652:   self.zapFnc     = zapFnc
26653:   self.VVAfO9    = VVAfO9
26654:   self.cbFnc     = cbFnc
26655:   self.VV1rS5   = VV1rS5
26656:   self.Title     = ""
26657:   self.VVArDB    = "Catch-up"
26658:   self.resetMediaTxt   = 'You can restart media with "<" Button'
26659:   self.VVr01a    = eTimer()
26660:   self.VVKh5A    = 250
26661:   self.VVZRZD   = int(CFG.playerTimeout.getValue()) * 1000
26662:   self.VVJnYA   = 0
26663:   self.barWidth    = 0
26664:   self.VVeFSs    = 0
26665:   self.VVU7zm   = False
26666:   self.VV8Ook   = 0
26667:   self.VVv4Yb   = 0
26668:   self.VVGLaR   = CFG.playerJumpMin.getValue()
26669:   self.VVEzCB    = 0
26670:   self.VViSIe    = ""
26671:   self.VVb70o   = 0
26672:   self.VVIzhS  = 0
26673:   self.VVAPQr   = None
26674:   self.VVepQx  = False
26675:   self.VVxrPx    = False
26676:   self.VVWG0C  = ""
26677:   self.VVnkEu   = False
26678:   self.tpData     = CC3Z54()
26679:   self.tunerInfo    = CCOZ3M()
26680:   self.VVU0YF   = None
26681:   self.VVbLh6   = ("", "", 0)
26682:   self.lastPIconPath   = None
26683:   self.animate    = None
26684:   self.firstTime    = True
26685:   FFZMxC(self, "")
26686:   self["myPlayBarF"] = Label()
26687:   self["myPlayBarBG"] = Label()
26688:   self["myPlayBar"] = Label()
26689:   self["myPlayMov"] = Label()
26690:   self["myPlayVal"] = Label()
26691:   self["myPlayPos"] = Label()
26692:   self["myPlaySkp"] = Label()
26693:   self["myPlayMsg"] = Label()
26694:   self["myPlayRem"] = Label()
26695:   self["myPlayDur"] = Label()
26696:   self["myPlaySep"] = Label()
26697:   self["myPlayGrn"] = Label("Refresh")
26698:   self["myPlayJmp"] = Label(self.VVxPj0())
26699:   self["myPlayDat"] = Label("")
26700:   self["myPlayTim"] = Label("")
26701:   self["myPlayRes"] = Label("")
26702:   self["myPlayFps"] = Label()
26703:   self["myPlayAsp"] = Label()
26704:   self["myPlayYel"] = Label("")
26705:   self["myPlayBlu"] = Label("Cut-List")
26706:   self["myPlayTyp"] = Label()
26707:   self["myPlayPic"] = Pixmap()
26708:   for nm in ( "myPlayCc", "myPlayAud", "myPlayDnld", "myPlayRpt"):
26709:    self[nm] = Pixmap()
26710:    self[nm].hide()
26711:   color = self.VVfOli["VVPTnB"]
26712:   nms = ("SNR", "AGC", "BER")
26713:   for nm in nms: self["mySliderTxt%s" % nm] = Label(nm)
26714:   for nm in nms: self["mySliderFrm%s" % nm] = Label()
26715:   for nm in nms: self["mySliderBak%s" % nm] = Label()
26716:   for nm in nms: self["mySliderCov%s" % nm] = Label()
26717:   for nm in nms: self["mySliderPic%s" % nm] = Pixmap()
26718:   self.sliderSNR = CCAbWp(self, self["mySliderPicSNR"], self["mySliderCovSNR"], minN=0, maxN=100, covColor=color)
26719:   self.sliderAGC = CCAbWp(self, self["mySliderPicAGC"], self["mySliderCovAGC"], minN=0, maxN=100, covColor=color)
26720:   self.sliderBER = CCAbWp(self, self["mySliderPicBER"], self["mySliderCovBER"], minN=0, maxN=100, covColor=color)
26721:   FFHlAU(self,
26722:   {
26723:    "ok"  : self.VVPr1F       ,
26724:    "info"  : self.VVyiuk      ,
26725:    "epg"  : self.VVyiuk      ,
26726:    "pvr"  : self.VVOkVn     ,
26727:    "menu"  : self.VVdk84     ,
26728:    "cancel" : self.cancel       ,
26729:    "red"  : self.VVcWzZ    ,
26730:    "green"  : self.VVgKuW  ,
26731:    "blue"  : self.VVea74      ,
26732:    "yellow" : self.VVqe3J ,
26733:    "longPlay" : self.VVRchb    ,
26734:    "play"  : self.VVgu5Z      ,
26735:    "pause"  : self.VVgu5Z      ,
26736:    "playPause" : self.VVgu5Z      ,
26737:    "stop"  : self.VVgu5Z      ,
26738:    "stopLong" : self.VVtCtg     ,
26739:    "powerLong" : self.VVtCtg     ,
26740:    "rewind" : self.VVJup6      ,
26741:    "forward" : self.VVzX0n      ,
26742:    "rewindDm" : self.VVJup6      ,
26743:    "forwardDm" : self.VVzX0n      ,
26744:    "last"  : self.VVrnc2      ,
26745:    "next"  : self.VVmYut      ,
26746:    "left"  : BF(self.VVkvpy, -1)    ,
26747:    "right"  : BF(self.VVkvpy,  1)    ,
26748:    "up"  : BF(self.VVuSeV, True)  ,
26749:    "down"  : BF(self.VVuSeV, False)  ,
26750:    "pageUp" : BF(self.VVuSeV, True)  ,
26751:    "pageDown" : BF(self.VVuSeV, False)  ,
26752:    "chanUp" : BF(self.VVuSeV, True)  ,
26753:    "chanDown" : BF(self.VVuSeV, False)  ,
26754:    "audio"  : BF(self.VVT1cG, True)  ,
26755:    "subtitle" : BF(self.VVT1cG, False)  ,
26756:    "text"  : self.VV8O6K  ,
26757:    "0"   : BF(self.VVmuJn , 10)   ,
26758:    "1"   : BF(self.VVmuJn , 1)   ,
26759:    "2"   : BF(self.VVmuJn , 2)   ,
26760:    "3"   : BF(self.VVmuJn , 3)   ,
26761:    "4"   : BF(self.VVmuJn , 4)   ,
26762:    "5"   : BF(self.VVmuJn , 5)   ,
26763:    "6"   : BF(self.VVmuJn , 6)   ,
26764:    "7"   : BF(self.VVmuJn , 7)   ,
26765:    "8"   : BF(self.VVmuJn , 8)   ,
26766:    "9"   : BF(self.VVmuJn , 9)
26767:   })
26768:   self.onShown.append(self.VV7OzD)
26769:   self.onClose.append(self.onExit)
26770:  def VV7OzD(self):
26771:   if self.firstTime:
26772:    self.firstTime = False
26773:    self.VVK5Px()
26774:   else:
26775:    self.VVYWev()
26776:  def VVK5Px(self):
26777:   FF6W0I(self)
26778:   for b in ("myPlayGrn", "myPlayYel", "myPlayBlu"):
26779:    FFK4PQ(self[b], "#000000", 3)
26780:   if not CCqWM2.VVyLCv:
26781:    CCqWM2.VVyLCv = self
26782:   for k, v in {"myPlayCc": "cc1", "myPlayAud": "aud", "myPlayDnld": "dnld", "myPlayRpt": "rpt"}.items():
26783:    FFkDgm(self[k], v)
26784:   self.sliderSNR.VVi3uI()
26785:   self.sliderAGC.VVi3uI()
26786:   self.sliderBER.VVi3uI(isBER=True)
26787:   self.VVZABq()
26788:   self.instance.move(ePoint(40, 40))
26789:   self.VV5s1h(CFG.playerPos.getValue())
26790:   self["myPlayMov"].hide()
26791:   self["myPlaySkp"].hide()
26792:   size = self["myPlayBar"].instance.size()
26793:   self.barWidth = int(size.width())
26794:   self.VVeFSs = int(size.height())
26795:   self["myPlayBar"].instance.resize(eSize(*(1, self.VVeFSs)))
26796:   try: self.VVr01a_conn = self.VVr01a.timeout.connect(self.VVCWQ4)
26797:   except: self.VVr01a.callback.append(self.VVCWQ4)
26798:   self.VVr01a.start(self.VVKh5A, False)
26799:   seekSt, chSt, chStTxt = self.VV7Pt6()
26800:   self.VVCWQ4("" if seekSt == "Playing" else "Checking ...")
26801:   if self.VVaHNe:
26802:    VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(self)
26803:    if self.VVaHNe != VVPxk5 + ":" + VV57TX:
26804:     self.VVmqIY(self.VVaHNe, "Starting Service ...")
26805:     return
26806:   if not self.VVwqHQ:
26807:    self.VVZvgO()
26808:  def VVgKuW(self):
26809:   if not self["myPlayGrn"].getVisible():
26810:    return
26811:   VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(self)
26812:   self.VVAPQr = CCfpAm.VVeLpu()
26813:   p = CC96QG()
26814:   valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVGNGo(VVZcRP)
26815:   if "chCode" in VVfaDB and not "deviceMac=" in chCm:
26816:    if CCwhE4.VVOJRa(self):
26817:     self.VVZvgO(True)
26818:   else:
26819:    self.VVCWQ4("Refreshing ...")
26820:    self.VVepQx = True
26821:    FFIElK(BF(CCYrUm.VV0iSP, self.session))
26822:   FFIElK(self.VVZABq)
26823:  def VVKEef(self, VVZcRP):
26824:   data = CCkEI5.VV9F1k(VVZcRP)
26825:   if data and (not self.VVWG0C or data != self.VVWG0C):
26826:    iThread(name="ajp_catchup", target=BF(self.VV13mI, data)).start()
26827:  def VV13mI(self, data):
26828:   uHost, uUser, uPass, uId, VV1wIO = data
26829:   if all([uHost, uUser, uPass, uId]) and CCuqoc.VVSuvZ():
26830:    pList, err = CCkEI5.VVigje("%s/player_api.php?username=%s&password=%s" % (uHost, uUser, uPass), uId, mode=0)
26831:    if pList:
26832:     self.VVWG0C = data
26833:     self.VVnkEu = True
26834:  def VVZABq(self):
26835:   self.VViSIe = ""
26836:   self.VVWG0C = None
26837:   self.VVnkEu  = False
26838:   self.VVMpAl()
26839:   s = self.VVGrMh()
26840:   if self.VVV4a7:
26841:    self.VVnkEu = True
26842:   elif s._prov in ("Playlist", "Portal") and not FFUl6q(s.VVZcRP):
26843:    FFOKt0(self, 1500, BF(self.VVKEef, s.VVZcRP))
26844:   s.VV1wIO = FFzBfi(s.VV1wIO)
26845:   if s.VVPxk5 or s.VV1wIO: self.Title = s.VV1wIO.replace("\n", " > ")
26846:   else     : self.Title = VVyFI2 + "No Service !"
26847:   self["myTitle"].setText("  " + self.Title + "  ")
26848:   FFZ0AC(self["myTitle"], s._tColor)
26849:   FFZ0AC(self["myBody"], s._tColor)
26850:   for item in ("Pos", "Skp", "Msg", "Rem", "Dur", "Jmp", "Dat", "Tim", "Res", "Fps", "Asp", "Pic", "Typ", "Yel"):
26851:    FFZ0AC(self["myPlay%s" % item], s._tColor)
26852:   FFGUI5(self["myPlayYel"], "#0080dddd" if s.isDvb else "#00cccccc")
26853:   for nm in ("SNR", "AGC", "BER"):
26854:    FFZ0AC(self["mySliderTxt%s" % nm], s._tColor)
26855:   if s._prov == "Others" : self["myPlayGrn"].hide()
26856:   else     : self["myPlayGrn"].show()
26857:   picFile = self.VVAfO9
26858:   if not FFCyVu(picFile):
26859:    if not iMatch(r"^\d*:(0:){9}\/.+", s.VVPxk5):
26860:     picFile = CCvjVs.VVi5vZ(s.VVPxk5)
26861:     if not FFCyVu(picFile):
26862:      picFile = CCvjVs.VVi5vZ(s.VVAQqG)
26863:   if not FFCyVu(picFile):
26864:    fPath, fDir, fName, picFile = CCvjVs.VVSY7D(self)
26865:   if not FFCyVu(picFile):
26866:    pPath = CCafIt.VVjkKT()
26867:    picFile = CCafIt.VVXjFJ(pPath, s.VVPxk5, s.VV1wIO)
26868:   if picFile != self.lastPIconPath:
26869:    self["myPlayTyp"].setText(s.streamType)
26870:    self.lastPIconPath = picFile
26871:    self["myPlayPic"].hide()
26872:    self["myPlayTyp"].show()
26873:    if os.path.isfile(picFile) and FF0TBx(self["myPlayPic"], picFile, VVemyB=s._tColor):
26874:     self["myPlayPic"].show()
26875:     self["myPlayTyp"].hide()
26876:  def VVCWQ4(self, stateTxt="", highlight=False):
26877:   if self.VVZRZD:
26878:    if self.shown:
26879:     self.VVJnYA += self.VVKh5A
26880:     if self.VVJnYA >= self.VVZRZD:
26881:      self.VVD7p5()
26882:    else:
26883:     self.VVJnYA = 0
26884:   now = datetime.now()
26885:   self["myPlayDat"].setText(now.strftime("%Y-%m-%d"))
26886:   self["myPlayTim"].setText(now.strftime("%H:%M:%S"))
26887:   if CCHRcZ.VVY2Xw() : self["myPlayDnld"].show()
26888:   else         : self["myPlayDnld"].hide()
26889:   s = self.VVGrMh()
26890:   tTitle = self.Title
26891:   if s._prov == self.VVArDB and " >> " in s.VV1wIO:
26892:    ch, _, ev = s.VV1wIO.partition(" >> ")
26893:    ch, ev = ch.strip(), ev.strip()
26894:    if ch and ev:
26895:     tTitle, s._evName = ch, ev
26896:   if s._evName:
26897:    s._evName = "    %s    " % FFjt5L(s._evName, VVA4XU)
26898:   self["myTitle"].setText("  %s%s  " % (tTitle, s._evName))
26899:   self["myPlayYel"].setText(s._prov)
26900:   if s._prov == self.VVArDB or self.VVnkEu:
26901:    FF7hy1(self["myPlayYel"], "#00ffffff", "#11a08000", inv=False)
26902:   if s._seekable and s._durVal > 60:
26903:    self["myPlayBlu"].show()
26904:    self["myPlayJmp"].show()
26905:   else:
26906:    self["myPlayBlu"].hide()
26907:    self["myPlayJmp"].hide()
26908:   if s.isDvb or s.VVAQqG:
26909:    self.tunerInfo.VVAo5r(s.servPtr)
26910:    if self.tunerInfo.infoAvailable:
26911:     self.sliderSNR.VVMjzk(self.tunerInfo.VVRpcw())
26912:     self.sliderAGC.VVMjzk(self.tunerInfo.VVX9tR())
26913:     self.sliderBER.VVMjzk(self.tunerInfo.VVZwV4())
26914:   if not self.VVU7zm:
26915:    player = CCkEI5.VV4IKy(s.VVPxk5)
26916:    if player:
26917:     self["myPlaySkp"].show()
26918:     self["myPlaySkp"].setText(VVo7S9 + player)
26919:    else:
26920:     self["myPlaySkp"].hide()
26921:   self["myPlayRes"].setText(s._res)
26922:   self["myPlayFps"].setText(s._fr)
26923:   self["myPlayAsp"].setText(s._ratio)
26924:   self["myPlayPos"].setText(s._posTxt if s._posTxt else "")
26925:   self["myPlayVal"].setText(s._percTxt if s._percTxt else "")
26926:   self["myPlayRem"].setText("-%s" % s._remTxt if s._remTxt else "")
26927:   self["myPlayDur"].setText(s._durTxt if s._durTxt else "")
26928:   if s._durTxt:
26929:    FFZ0AC(self["myPlayBarBG"], "#11000000")
26930:    self["myPlayBarBG"].show()
26931:    self["myPlayBarF"].show()
26932:    self["myPlayBar"].show()
26933:    width = 0
26934:    percent = FFsRWN(s._percVal, 0, 100)
26935:    width = int(FFjFSv(percent, 0, 100, 0, self.barWidth))
26936:    self["myPlayBar"].instance.resize(eSize(*(width, self.VVeFSs)))
26937:   else:
26938:    self["myPlayBarBG"].hide()
26939:    self["myPlayBarF"].hide()
26940:    self["myPlayBar"].hide()
26941:    self["myPlayVal"].setText(">>>>")
26942:    FFZ0AC(self["myPlayBarBG"], s._tColor)
26943:   self.VVk55g()
26944:   if stateTxt:
26945:    if highlight: FFGUI5(self["myPlayMsg"], "#0000ffff")
26946:    else  : FFGUI5(self["myPlayMsg"], "#00ffaa00")
26947:    self["myPlayMsg"].setText(stateTxt)
26948:    self.VVEzCB = iTime()
26949:   if self.VVEzCB and iTime() - self.VVEzCB < 1:
26950:    return
26951:   else:
26952:    self.VVEzCB = 0
26953:    FFGUI5(self["myPlayMsg"], "#00ffaa00")
26954:    self["myPlayMsg"].setText(s._state)
26955:   if s.VVDiQp or s.VVAQqG:
26956:    FFGUI5(self["myPlayMsg"], "#00ffaaff")
26957:    txt = "Stream Relay"
26958:    if len(self.VViSIe) > 1: txt = "%s - %s%s" % (txt, VVwdUw, self.VViSIe)
26959:    self["myPlayMsg"].setText(txt)
26960:   elif s.isDvb:
26961:    FFGUI5(self["myPlayMsg"], "#00aaaaaa")
26962:    self["myPlayMsg"].setText(self.VViSIe)
26963:   stateTxt = ""
26964:   chkResume = False
26965:   seekSt, chSt, chStTxt = self.VV7Pt6()
26966:   if seekSt:
26967:    stateTxt = seekSt
26968:    if s._percVal == 100:
26969:     stateTxt = "End"
26970:     self.VVMpAl()
26971:     if self.VVxrPx:
26972:      self.VVrnc2()
26973:    elif seekSt == "Playing":
26974:     if s._posTxt:
26975:      chkResume = True
26976:     elif chSt == CCo1b7.VVaGf1 and s.isIptv and s.VVPxk5.startswith("1:"):
26977:      stateTxt = seekSt
26978:     else:
26979:      stateTxt = "%sWaiting for state change ..." % (("State: %s - " % chStTxt) if chStTxt else "")
26980:   if chSt == CCo1b7.VVaGf1:
26981:    Id, rt, sIcon = self.VVbLh6
26982:    if (s.uniqueId, s.refType) != (Id, rt):
26983:     sIcon = CCvjVs.VVL5jW()
26984:     self.VVbLh6 = (s.uniqueId, s.refType, sIcon)
26985:     if sIcon > 0:
26986:      FFkDgm(self["myPlayCc"], "cc%s" % sIcon)
26987:      self["myPlayCc"].show()
26988:     else:
26989:      self["myPlayCc"].hide()
26990:     if CCvjVs.VVHlVI(self.session) > 1 : self["myPlayAud"].show()
26991:     else             : self["myPlayAud"].hide()
26992:   if not s._seekable and not s.isIptv:
26993:    return
26994:   if chkResume:
26995:    if not self.VVepQx:
26996:     self.VVb70o = s._posVal
26997:    elif not s._durVal:
26998:     self.VVepQx = False
26999:    else:
27000:     if self.VVb70o > 0:
27001:      move = end = False
27002:      s1 = "." * self.VVIzhS
27003:      stateTxt = ("%s Restoring Posistion %s" % (s1, s1)).strip()
27004:      self.VVIzhS += 1
27005:      diff = abs(s._posVal - self.VVb70o)
27006:      if   diff < 10     : end = True
27007:      elif self.VVIzhS == 1: move = True
27008:      elif self.VVIzhS >= 10:
27009:       if diff > 10:
27010:        move = True
27011:       end = True
27012:      if move and CFG.resumeMovies.getValue() == "off":
27013:       self.VVhB9S(self.VVb70o * 90000.0)
27014:      if end:
27015:       self.VVIzhS = 0
27016:       self.VVepQx = False
27017:       CCfpAm.VVDjVi(self.VVAPQr)
27018:     else:
27019:      self.VVepQx = False
27020:   bufS = self.VVFlpV()
27021:   if bufS:
27022:    stateTxt = bufS
27023:   FFGUI5(self["myPlayMsg"], "#0000ff00" if stateTxt == "Playing" else "#00FF8F5F" )
27024:   self["myPlayMsg"].setText(stateTxt)
27025:  def VVGrMh(self):
27026:   s = CC3rDi(self.session)
27027:   s._state = s.state.replace("*", "") or "No system info"
27028:   s._seekable, s._percVal, s._durVal, s._posVal, s._remVal, s._percTxt, s._durTxt, s._posTxt, s._remTxt = CCqWM2.VVVxSJ(self)
27029:   s._VVFzFe = "chCode" in s.VVZcRP
27030:   s._VVoAvc = CCkEI5.VVYuoh(s.VVZcRP)
27031:   s._VVjwdZ = "/timeshift/" in s.VVZcRP
27032:   iptv   = s.isIptv or "http" in s.VVZcRP
27033:   if   s.isDvb  : s._tColor, cat = "#1100102a", "DVB"
27034:   elif s.isLocal  : s._tColor, cat = "#0a401100", "Local Media"
27035:   elif s._VVFzFe : s._tColor, cat = "#1120002a", "Portal"
27036:   elif s.isFtp  : s._tColor, cat = "#11222222", "FTP"
27037:   elif s._VVjwdZ : s._tColor, cat = "#11223322", self.VVArDB
27038:   elif s._VVoAvc : s._tColor, cat = "#11001c1c", "Playlist"
27039:   elif s.VVDiQp  : s._tColor, cat = "#11223344", "S. Relay"
27040:   elif iptv   : s._tColor, cat = "#11113030", "IPTV"
27041:   else    : s._tColor, cat = "#11111111", "Others"
27042:   s._prov = self.VVArDB if self.VVnkEu else (s.prov or cat)
27043:   if (s.isDvb or s.VVAQqG) and not self.VViSIe:
27044:    self.VViSIe = self.tpData.VVsDkA([s.VVPxk5, s.VVAQqG], nonTxt="-")
27045:   valid = (s.isDvb and s.isValid) or s.VVAQqG
27046:   for nm1 in ("Txt", "Frm", "Cov", "Bak", "Pic"):
27047:    for nm2 in ("SNR", "AGC", "BER"):
27048:     if valid: self["mySlider%s%s" % (nm1, nm2)].show()
27049:     else : self["mySlider%s%s" % (nm1, nm2)].hide()
27050:   s._evName = s._evNameNext = ""
27051:   evLst = CC5TsO.VVj18Y(s.VVPxk5)
27052:   if evLst:
27053:    s._evName, evShort, evDesc, genre, PR, evTime, evTimeTxt, evDur, evDurTxt, evEnd, evEndTxt, evPos, evPosTxt, evRem, evRemTxt, evCom, evComTxt = evLst[0]
27054:    if not s._durVal:
27055:     if len(evLst) > 1:
27056:      s._evNameNext = evLst[1][0]
27057:     if evPos >= evDur:
27058:      s._percVal = 100
27059:      percTxt = "%d %%" % s._percVal
27060:     else:
27061:      s._percVal = float(evPos) * 100.0 / float(evDur)
27062:      percTxt = "%.2f %%" % s._percVal
27063:     s._posVal, s._remVal, s._percTxt, s._durTxt, s._posTxt, s._remTxt = evPos, evRem, percTxt, evDurTxt, evPosTxt, evRemTxt
27064:   s._res = CCvjVs.VVZHUt(s.info)
27065:   s._fr, rate = "", FFMzWf(s.info, iServiceInformation.sFrameRate)
27066:   if rate.isdigit() and not rate == "0":
27067:    s._fr = "%d fps" % (int(rate) / 1000)
27068:   s._ratio = CCvjVs.VVNYXU(s.info)
27069:   return s
27070:  @staticmethod
27071:  def VVVxSJ(SELF):
27072:   percVal = durVal = posVal = remVal = seekable = 0
27073:   percTxt = durTxt = posTxt = remTxt = ""
27074:   isEnded = False
27075:   try:
27076:    service = SELF.session.nav.getCurrentService()
27077:    if service:
27078:     pSeek = service.seek()
27079:     if pSeek:
27080:      seekable = pSeek.isCurrentlySeekable()
27081:      durLst  = pSeek.getLength()
27082:      posLst  = pSeek.getPlayPosition()
27083:      if durLst[0] == 0:
27084:       durVal = durLst[1] / 90000.0
27085:       if durVal:
27086:        durTxt = FFFHEC(durVal)
27087:      if posLst[0] == 0:
27088:       posVal = posLst[1] / 90000.0
27089:       posTxt = FFFHEC(posVal)
27090:      if durVal > 0 and posVal > 0:
27091:       remVal = durVal - posVal + 1
27092:       remTxt = FFFHEC(remVal)
27093:      if durVal > 0:
27094:       if round(posVal) >= int(durVal):
27095:        percVal = 100
27096:        percTxt = "%d %%" % percVal
27097:        posVal = durVal
27098:        posTxt = durTxt
27099:        remTxt = ""
27100:       else:
27101:        percVal = float(posVal) * 100.0 / float(durVal)
27102:        percTxt = "%.2f %%" % percVal
27103:   except:
27104:    pass
27105:   return seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt
27106:  def VVdk84(self):
27107:   s = self.VVGrMh()
27108:   VV3wat = []
27109:   c1, c2, c3, c4 = VVyFI2, VVFuwR, VVZtfx, VVJEMb
27110:   VV3wat.append(("Service Info.", "info"))
27111:   VV3wat.append(FFsLU5("Play with ..."   , "playWith", s.VVPxk5 and not s.isDvb , c4))
27112:   VV3wat.append(FFsLU5("Restart Current Service" , "restart" , s.VVPxk5     , c1))
27113:   VV3wat.append(FFsLU5("Stop Current Service"  , "stop" , s.VVPxk5     , c1))
27114:   VV3wat.append(VVAL3j)
27115:   if s._durTxt and s._posTxt:
27116:    VV3wat.append((c2 + "Start Subtitle", "VV0xaU"))
27117:    VV3wat.append(VVAL3j)
27118:   canDownload = s.VVZcRP and s._seekable == 3 and s._durVal > 0
27119:   if canDownload:
27120:    VV3wat.append((c3 + "File Size (on server)", "fileSize"))
27121:   if self.VVdxwH:
27122:    if canDownload:
27123:     VV3wat.append((c3 + "Start Download"  , "dload_cur" ))
27124:     VV3wat.append((c3 + "Add to Download List", "addToDload" ))
27125:   show = not CCHRcZ.VVAbZK()
27126:   VV3wat.append(FFsLU5("Download Manager", "dload_stat", show, c3))
27127:   VV3wat.append(VVAL3j)
27128:   addSep = False
27129:   fPath, fDir, fName = CClYaF.VV4zSS(self)
27130:   if fPath:
27131:    c = VVJEMb
27132:    if not "VVyg7B" in globals():
27133:     VV3wat.append((c + "Open Path in File Manager", "VVKtV9"))
27134:    VV3wat.append((c + "Add to Bouquet"            , "VV51sJ" ))
27135:    VV3wat.append((c + "%s Auto-Repeat" % ("Disable" if self.VVxrPx else "Enable"), "VVMxOs"  ))
27136:    addSep = True
27137:   elif s.isFtp:
27138:    VV3wat.append((c2 + "Add FTP Media to Bouquet", "VVLm66"))
27139:    addSep = True
27140:   if addSep: VV3wat.append(VVAL3j)
27141:   if s.isDvb:
27142:    VV3wat.append((c4 + "Signal Monitor (Red Button)", "sigMon"))
27143:    VV3wat.append(VVAL3j)
27144:   if not "VVaWs8" in globals() and not "VVyXy5" in globals():
27145:    VV3wat.append((c4 + "IPTV Menu", "iptv"))
27146:    VV3wat.append(VVAL3j)
27147:   if self.VVOOLD:
27148:    path, lst, err = CC6F0F.VVjp9r()
27149:    if lst:
27150:     VV3wat.append((c3 + "Movies Resume History", "resume"))
27151:     VV3wat.append(VVAL3j)
27152:   VV3wat.append(("Set Bar Visibility Timeout", "timeout"))
27153:   VV3wat.append(("Set Red Button Action"  , "red" ))
27154:   if CFG.playerPos.getValue() : VV3wat.append(("Move Bar to Bottom" , "botm"))
27155:   else      : VV3wat.append(("Move Bar to Top" , "top" ))
27156:   VVJbOd = self.VVs6QS
27157:   FFLFTC(self, self.VVMq7h, VV3wat=VV3wat, width=650, height=1050, title="Options", VVy8OB=True, VVJbOd=VVJbOd, VVwltY="#22001122", VVkxBG="#11000919")
27158:  def VVMq7h(self, item=None):
27159:   if item:
27160:    if   item == "info"     : self.VVyiuk()
27161:    elif item == "playWith"    : self.VVRchb()
27162:    elif item == "restart"    : self.VVHTNd()
27163:    elif item == "stop"     : self.VVtCtg()
27164:    elif item == "VV0xaU"  : self.VVWBSu()
27165:    elif item == "fileSize"    : CCvjVs.VVnMBE(self)
27166:    elif item == "dload_cur"   : CCHRcZ.VVIcV1(self)
27167:    elif item == "addToDload"   : CCHRcZ.VVfHMV(self)
27168:    elif item == "dload_stat"   : CCHRcZ.VVSZMa(self)
27169:    elif item == "VVKtV9" : self.VVj4vX("VVEAiH")
27170:    elif item == "VV51sJ" : self.VV51sJ()
27171:    elif item == "VVMxOs"  : self.VVMxOs()
27172:    elif item == "VVLm66" : self.VVLm66()
27173:    elif item == "sigMon"    : self.VVctJ7()
27174:    elif item == "iptv"     : self.VVj4vX("VV3NZB")
27175:    elif item == "resume"    : self.VVj4vX("VVmZ3h")
27176:    elif item == "timeout"    : CCJaSw.VV5YpJ(self, CFG.playerTimeout, "Bar Timeout (Seconds)" , isSave=True, width=700, cbFnc=self.VVHjPB)
27177:    elif item == "red"     : CCJaSw.VV5YpJ(self, CFG.playerRedBtn , "Red Button Action"  , isSave=True, width=700)
27178:    elif item == "botm"     : self.VV5s1h(0)
27179:    elif item == "top"     : self.VV5s1h(1)
27180:    elif item == "VVy8OB"    : self.VVHyXT()
27181:  def VVHyXT(self):
27182:   VV3wat = []
27183:   s = self.VVGrMh()
27184:   m2 = s.VVPxk5 and not s.isDvb and FFPCZY(self)
27185:   VV3wat.append(FFsLU5("Stop Current Service"       , "st1" , s.VVPxk5 ))
27186:   VV3wat.append(FFsLU5("Stop Current Service & Close %s" % VVh9hj, "st2" , m2  ))
27187:   VV3wat.append(VVAL3j)
27188:   VV3wat.append(FFsLU5("Play Last Stopped Channel", "pl", not s.VVPxk5))
27189:   VV3wat.append(VVAL3j)
27190:   VV3wat.append(("Channel Selection", "chS" ))
27191:   VV3wat.append(("Channels Browser" , "chB" ))
27192:   VV3wat.append(("Zap History"  , "zh" ))
27193:   VV3wat.append(VVAL3j)
27194:   VV3wat.append(FFsLU5("Download Poster (for current event)", "ps0", CC5TsO.VVMZqx(self)))
27195:   if VVBvqf:
27196:    VV3wat.append(("Find a poster T", "ps1"))
27197:    VV3wat.append(("Find a poster I", "ps2"))
27198:   VV3wat.append(VVAL3j)
27199:   VV3wat.append(("Close %s" % VVh9hj, "end"))
27200:   FFLFTC(self, self.VVeyTi, VV3wat=VV3wat, width=740, title="More Options", VVwltY="#22220000", VVkxBG="#11110000")
27201:  def VVeyTi(self, item=None):
27202:   if item:
27203:    if   item == "st1": self.VVtCtg()
27204:    elif item == "st2": self.VVtCtg(True)
27205:    elif item == "pl" : self.VVM2ZW()
27206:    elif item == "chS": self.VVOkVn()
27207:    elif item == "chB": CCjThi.VVJNjY(self)
27208:    elif item == "zh" : self.session.open(CCiCTh)
27209:    elif item == "ps0": self.session.open(CChtNF)
27210:    elif item == "ps1": self.session.open(CChtNF, mode=1)
27211:    elif item == "ps2": self.session.open(CChtNF, mode=2)
27212:    elif item == "end": FFHxAC(self)
27213:  def VVHjPB(self):
27214:   self.VVZRZD = int(CFG.playerTimeout.getValue()) * 1000
27215:  def VVcWzZ(self):
27216:   v = CFG.playerRedBtn.getValue()
27217:   if  v == "s": self.VVctJ7()
27218:   elif v == "e": self.VVRLgb()
27219:  def VVctJ7(self):
27220:   if self.shown:
27221:    s = CC3rDi(self.session)
27222:    if s.isDvb : self.VVj4vX("VV9RX6")
27223:    else  : self.VVCWQ4("No Signal for Current Service")
27224:  def VVRLgb(self):
27225:   s = self.VVGrMh()
27226:   if not s.isDvb or not s.isValid:
27227:    CCYrUm.VVO7YY(self.session, s.servRef)
27228:   self.close()
27229:  def onExit(self):
27230:   self.VVr01a.stop()
27231:   CCqWM2.VVyLCv = None
27232:   if self.cbFnc: self.cbFnc()
27233:   if self.endRef: FFnfiC(self.session, self.endRef)
27234:  def cancel(self):
27235:   if self.VVU7zm: self.VVMpAl()
27236:   elif self.shown  : self.VVj4vX()
27237:   else    : self.VVXkRr()
27238:  def VVXkRr(self):
27239:   self.animate.VV5HIg(CFG.playerPos.getValue())
27240:  def VVD7p5(self):
27241:   self.animate.VVvj1p(CFG.playerPos.getValue())
27242:  def VVj4vX(self, act=None):
27243:   if act     : self.close(act)
27244:   elif self.VV1rS5: self.animate.VVOVs9()
27245:   else     : self.close()
27246:  def VVs6QS(self, VV7tND, txt, ref, ndx):
27247:   FFw2rR(self, "_help_player", "Player Bar (Keys)")
27248:  def VVHTNd(self):
27249:   self.VVCWQ4("Restarting Service ...")
27250:   FFIElK(BF(CCYrUm.VV0iSP, self.session))
27251:  def VVtCtg(self, end=False):
27252:   self.VVCWQ4("Stopping current service ...")
27253:   FFIElK(BF(self.VVoPnb, end))
27254:  def VVoPnb(self, end):
27255:   fromTbls = self.VVwqHQ or self.zapFnc
27256:   zapped = False
27257:   serv = self.session.nav.getCurrentlyPlayingServiceReference()
27258:   if serv:
27259:    path = serv.getPath()
27260:    self.session.nav.stopService()
27261:    self.show()
27262:    self.VVZABq()
27263:    if path.startswith(("/", "http")) or fromTbls:
27264:     zapped = CCYrUm.VVO7YY(self.session, serv)
27265:   if end:
27266:    FFHxAC(self)
27267:   else:
27268:    if fromTbls : self.VVj4vX()
27269:    elif zapped : self.VVZABq()
27270:    else  : self.VVOkVn()
27271:  def VVM2ZW(self):
27272:   rootR, servR = CCYrUm.VVotT7()
27273:   if servR:
27274:    self.VVmqIY(servR, "Playing Last Service ...")
27275:  def VVRchb(self):
27276:   CCkEI5.VVMYQY(self, self.VVGy1Q)
27277:  def VVGy1Q(self, rType=None):
27278:   if rType:
27279:    FFIElK(BF(self.VVBh4l, rType))
27280:  def VVBh4l(self, rType=None):
27281:   serv = self.session.nav.getCurrentlyPlayingServiceReference()
27282:   if serv : FFqb3C(self.session, eServiceReference(rType + ":" + serv.toString().split(":", 1)[1]))
27283:   else : self.VVCWQ4("No active service !")
27284:   self.VVZABq()
27285:  def VV51sJ(self):
27286:   fPath, fDir, fName = CClYaF.VV4zSS(self)
27287:   if fPath: picker = CCMvE7(self, self, "Add Current Movie to a Bouquet", BF(self.VVZXrb, [fPath]))
27288:   else : FF28n1(self, "Path not found !", 1500)
27289:  def VVZXrb(self, pathLst):
27290:   return CCMvE7.VVvoK9(pathLst)
27291:  def VVLm66(self):
27292:   picker = CCMvE7(self, self, "Add FTP Media to Bouquet", self.VV6eYa)
27293:  def VV6eYa(self):
27294:   VV57TX = CC3rDi(self.session).VV57TX
27295:   return CCMvE7.VVvoK9([VV57TX], rType=VVPxk5.split(":", 1)[0])
27296:  def VVMxOs(self):
27297:   ok = False
27298:   if self.VVxrPx:
27299:    self.VVxrPx = False
27300:    txt = "Auto-Repeat OFF"
27301:    ok = True
27302:   else:
27303:    seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt = CCqWM2.VVVxSJ(self)
27304:    if seekable and durVal > 0:
27305:     if durVal >= 60:
27306:      self.VVxrPx = True
27307:      txt = "Auto-Repeat ON"
27308:      ok = True
27309:     else: txt = "Too short (min = 1 minute)"
27310:    else: txt = "Cannot Auto-Repeat"
27311:   if self.VVxrPx : self["myPlayRpt"].show()
27312:   else    : self["myPlayRpt"].hide()
27313:   self.VVCWQ4(txt, highlight=ok)
27314:  def VV5s1h(self, pos):
27315:   scrSize = getDesktop(0).size()
27316:   scrW = scrSize.width()
27317:   scrH = scrSize.height()
27318:   x  = (scrW - self.instance.size().width()) / 2.0
27319:   if pos == 0 : y = (scrH - self.instance.size().height() - 20)
27320:   else  : y = 20
27321:   self.instance.move(ePoint(int(x), int(y)))
27322:   if not pos == CFG.playerPos.getValue():
27323:    FFjt1c(CFG.playerPos, pos)
27324:   self.animate = CCMdqL(self)
27325:  def VVWBSu(self):
27326:   self.session.openWithCallback(self.VVL63G, CCfpAm, self)
27327:  def VV8O6K(self):
27328:   if self.shown:
27329:    s = self.VVGrMh()
27330:    if s._posTxt and s._durTxt : self.VVWBSu()
27331:    else      : self.VVCWQ4("No duration Info. !")
27332:  def VVL63G(self, reason):
27333:   if reason == "subtCancel":
27334:    return
27335:   self.VVXkRr()
27336:   txt = ""
27337:   if   reason == "subtExit" : pass
27338:   elif reason == "subtCancel" : pass
27339:   elif reason == "subtInval" : txt = "Invalid srt file"
27340:   elif reason == "subtZapUp" : self.VVuSeV(True)
27341:   elif reason == "subtZapDn" : self.VVuSeV(False)
27342:   elif reason == "longPlay" : self.VVRchb()
27343:   elif reason == "pause"  : self.VVgu5Z()
27344:   elif reason == "audio"  : self.VVT1cG(True)
27345:   elif reason == "subtitle" : self.VVT1cG(False)
27346:   else      : txt = reason
27347:   if txt:
27348:    FF28n1(self, txt, 2000)
27349:  def VVPr1F(self):
27350:   if self.VVU7zm:
27351:    self.VVMpAl()
27352:    self.VVhB9S(self.VVv4Yb)
27353:   elif not self.session.nav.getCurrentlyPlayingServiceReference():
27354:    self.VVOkVn()
27355:   elif self.shown:
27356:    if CCfpAm.VVjvxF(self): self.VVWBSu()
27357:    elif self.shown       : self.VVD7p5()
27358:   else:
27359:    self.VVXkRr()
27360:  def VVyiuk(self):
27361:   CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVvrVY, VVAfO9=self.VVAfO9, cbFnc=self.VVZABq)
27362:  def VVOkVn(self):
27363:   CCYrUm.VVGvmp()
27364:  def VVgu5Z(self):
27365:   try: InfoBar.instance.playpauseService()
27366:   except: pass
27367:   self.VVCWQ4("Toggling Play/Pause ...")
27368:  def VV4nOY(self):
27369:   try: InfoBar.instance.unPauseService()
27370:   except: pass
27371:  def VVMpAl(self):
27372:   try:
27373:    if self.VVU7zm:
27374:     self.VVU7zm = False
27375:     self["myPlayMov"].hide()
27376:     self["myPlaySkp"].hide()
27377:   except:
27378:    pass
27379:  def VVkvpy(self, direc):
27380:   seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt = CCqWM2.VVVxSJ(self)
27381:   if percVal == 100:
27382:    self.VVCWQ4(self.resetMediaTxt)
27383:   elif seekable and durVal > 0:
27384:    if not self.VVU7zm:
27385:     self.VVU7zm = True
27386:     self["myPlayMov"].show()
27387:     self["myPlaySkp"].show()
27388:     self.VV8Ook = posVal + direc * self.VVBGpu()
27389:    else:
27390:     self.VV8Ook += direc * self.VVBGpu()
27391:     self.VV8Ook = FFsRWN(self.VV8Ook, 0, durVal)
27392:    minLeft = self["myPlayBar"].getPosition()[0] - 1
27393:    maxLeft = self["myPlayBarBG"].getPosition()[0] + self["myPlayBarBG"].instance.size().width() - self["myPlayMov"].instance.size().width() + 1
27394:    left = int(FFjFSv(self.VV8Ook, 0, durVal, minLeft, maxLeft))
27395:    self["myPlayMov"].instance.move(ePoint(left, int(self["myPlayMov"].getPosition()[1])))
27396:    self["myPlaySkp"].setText(FFFHEC(self.VV8Ook))
27397:    self.VVv4Yb = self.VV8Ook * 90000.0
27398:  def VVmuJn(self, val):
27399:   if not self.VVGLaR == val:
27400:    self.VVGLaR = val
27401:    self["myPlayJmp"].setText(self.VVxPj0())
27402:    FFjt1c(CFG.playerJumpMin, self.VVGLaR)
27403:   self.VVCWQ4("Changed Seek Time to : %d%s" % (val, self.VVIWzX()))
27404:  def VVxPj0(self):
27405:   return "Seek=%d%s" % (self.VVGLaR, self.VVIWzX())
27406:  def VVIWzX(self) : return "s"   if self.VVGLaR == 10 else "m"
27407:  def VVT6Ma(self): return "sec" if self.VVGLaR == 10 else "min"
27408:  def VVBGpu(self) : return 10    if self.VVGLaR == 10 else self.VVGLaR * 60
27409:  def VV7Pt6(self):
27410:   chSt = chStTxt = ""
27411:   if "VVfaPN_VAL" in globals():
27412:    global VVfaPN_VAL
27413:    chSt = VVfaPN_VAL
27414:    if chSt != CCo1b7.VVaGf1:
27415:     chStTxt = chSt
27416:   seekSt = ""
27417:   try:
27418:    inst = InfoBar.instance
27419:    seekSt = {inst.SEEK_STATE_PAUSE: "PAUSED", inst.SEEK_STATE_EOF: "END", inst.SEEK_STATE_PLAY: "Playing"}.get(inst.seekstate, "")
27420:    if chSt == CCo1b7.VV26Iy:
27421:     seekSt = chSt
27422:   except:
27423:    pass
27424:   return seekSt, chSt, chStTxt
27425:  def VVea74(self):
27426:   self.VVCWQ4("Reading Cut-List ...")
27427:   FFIElK(self.VVG7Sr)
27428:  def VVG7Sr(self):
27429:   s = self.VVGrMh()
27430:   if s._percVal == 100:
27431:    self.VVCWQ4(self.resetMediaTxt)
27432:    return
27433:   cList = self.VV4AOH()
27434:   VV3wat = []
27435:   title = "Cut List"
27436:   src = 0
27437:   fPath, fDir, fName = CClYaF.VV4zSS(self)
27438:   if cList:
27439:    canPreview = True
27440:    for pts, what in cList:
27441:     txt = FFFHEC(int(pts) / 90000.0)
27442:     if   what == 0 : t = "In"
27443:     elif what == 1 : t = "Out"
27444:     elif what == 2 : t = "Mark"
27445:     elif what == 3 : t = "Last"
27446:     else   : t = ""
27447:     if t: txt += "   %s" % t
27448:     VV3wat.append((txt, pts))
27449:   elif self["myPlayBlu"].getVisible():
27450:    if fPath:
27451:     VV3wat = CC6u6z.VVFs8l(fPath)
27452:    elif s.VVZcRP and s.VV1wIO:
27453:     path, headers = CC6u6z.VVmdd5(s.VVZcRP, s.VV1wIO)
27454:     if path:
27455:      VV3wat = CC6u6z.VVFs8l(path, headers)
27456:    if VV3wat:
27457:     title = "Chapters"
27458:    elif s._durVal > 20:
27459:     for i in range(0, 5):
27460:      pts = min(max((s._durVal * 90000 // 4) * i, 5 * 90000), (s._durVal - 10) * 90000.0)
27461:      subj = "   %s" % (("Start", "1st Quarter", "Half way", "3rd Quarter", "End")[i])
27462:      VV3wat.append((FFFHEC(pts / 90000.0) + subj, pts))
27463:    fName, fTxt, VV1wIO, VVu06s = CCzUSd.VVwtlp(self.session)
27464:    if fName:
27465:     d = CCzUSd.VV0NUN(CCzUSd.VVc5Po(fName))
27466:     if d: VV3wat.append((FFFHEC(d["pos"] / 90000.0) + FFjt5L("   Resume Point", VVFuwR), d["pos"]))
27467:    VV3wat.sort(key=lambda x: x[1])
27468:   if VV3wat:
27469:    wDir = "%s_Chapters/" % fPath
27470:    VV7tND = FFLFTC(self, self.VVh1Cz, VV3wat=VV3wat, title=title, width=1200, VVyRCy=5, VVdrEC=(350, 0), cornerPicFnc=BF(self.VV2ovz, wDir))
27471:    lst = []
27472:    for txt, ref in VV3wat:
27473:     picF, tm = self.VVMuZk(wDir, txt)
27474:     if picF and not FFCyVu(picF):
27475:      lst.append((picF, tm))
27476:    self.VVU0YF = (VV7tND, title, wDir, len(lst), 0, False)
27477:    iThread(name="ajp_chap", target=BF(self.VVfTw0, lst, wDir, fPath)).start()
27478:   else:
27479:    self.VVCWQ4("No Cut-List !")
27480:  def VVh1Cz(self, pts=None):
27481:   self.VVU0YF = None
27482:   if pts:
27483:    self.VVhB9S(pts)
27484:  def VVfTw0(self, lst, wDir, fPath):
27485:   VV7tND, title, wDir, totPics, cnt, done = self.VVU0YF
27486:   if FFpwZS("mkdir -p '%s';" % wDir):
27487:    for picF, tm in lst:
27488:     if not VV7tND:
27489:      break
27490:     cnt += 1
27491:     self.VVU0YF = VV7tND, title, wDir, totPics, cnt, done
27492:     FFpwZS("ffmpeg -hide_banner -ss %s -i '%s' -frames:v 1 -vf scale=350:-1 '%s'" % (tm, fPath, picF))
27493:   self.VVU0YF = VV7tND, title, wDir, totPics, cnt, True
27494:  def VV2ovz(self, wDir, VV7tND, txt, ref, ndx):
27495:   picF, tm = self.VVMuZk(wDir, txt)
27496:   return picF
27497:  def VVMuZk(self, wDir, txt):
27498:   span = iSearch(r"^(\d\d:\d\d:\d\d)", txt)
27499:   if span:
27500:    tm = span.group(1)
27501:    picF = "%s%s.jpg" % (wDir, tm.replace(":", ""))
27502:    return picF, tm
27503:   return "" ,""
27504:  def VVk55g(self):
27505:   if self.VVU0YF:
27506:    try:
27507:     VV7tND, title, wDir, totPics, cnt, done = self.VVU0YF
27508:     if   done   : self.VVU0YF = None
27509:     elif totPics >= cnt : title += FFjt5L("   %s/%s" % (cnt, totPics), VVo7S9)
27510:     if VV7tND:
27511:      VV7tND.FFTmHZ(title)
27512:      txt, ref, ndx = VV7tND.VVnGzV()
27513:      picF, tm = self.VVMuZk(wDir, txt)
27514:      if not VV7tND.VVcOjd() and FFCyVu(picF):
27515:       VV7tND.VVacFr(picF)
27516:    except:
27517:     pass
27518:  def VV4AOH(self):
27519:   try: return InfoBar.instance.cut_list or []
27520:   except: return []
27521:  def VVzX0n(self) : self.VVmtpO(1)
27522:  def VVJup6(self) : self.VVmtpO(-1)
27523:  def VVmtpO(self, direc):
27524:   try:
27525:    seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt = CCqWM2.VVVxSJ(self)
27526:    if percVal == 100:
27527:     self.VVCWQ4(self.resetMediaTxt)
27528:    elif durVal > 0:
27529:     maxPts = (durVal - posVal- 10) * 90000.0
27530:     pts = direc * self.VVBGpu() * 90000.0
27531:     pts = min(maxPts, pts)
27532:     self.VV4nOY()
27533:     inst = InfoBar.instance
27534:     inst.doSeekRelative(int(pts))
27535:     inst.hide()
27536:     if   direc > 0 : txt = "Forawrd"
27537:     else   : txt = "Rewind"
27538:     txt += " (%d %s) ..." % (self.VVGLaR, self.VVT6Ma())
27539:     self.VVCWQ4(txt)
27540:   except:
27541:    self.VVCWQ4("Cannot jump")
27542:  def VVhB9S(self, pts, txt=""):
27543:   self.VVCWQ4(txt or "Changing Time ...")
27544:   self.VV4nOY()
27545:   try:
27546:    InfoBar.instance.doSeek(int(pts))
27547:   except:
27548:    pass
27549:  def VVrnc2(self):
27550:   s = self.VVGrMh()
27551:   if s._percVal < 100:
27552:    self.VVhB9S(90000, "Jumping to Start ...")
27553:   else:
27554:    fName, fTxt, s.VV1wIO, VVu06s = CCzUSd.VVwtlp(self.session)
27555:    FFwgGB(CCzUSd.VVc5Po(fName))
27556:    self.VVMpAl()
27557:    self.VVHTNd()
27558:  def VVmYut(self):
27559:   seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt = CCqWM2.VVVxSJ(self)
27560:   if seekable and durVal > 20:
27561:    self.VVhB9S((durVal - 10) * 90000.0, "Jumping to end ...")
27562:   else:
27563:    self.VVCWQ4("Movie is too short ...")
27564:  def VVFlpV(self):
27565:   try:
27566:    service = self.session.nav.getCurrentService()
27567:    info = service and service.info()
27568:    if info:
27569:     val = info.getInfo(iServiceInformation.sBuffer)
27570:     if val and val > 0 and not val == 100:
27571:      return "Buffering %d %%" % val
27572:   except:
27573:    pass
27574:   return ""
27575:  def VVuSeV(self, isUp):
27576:   if self.VVEBd5:
27577:    self.VVCWQ4("Starting Service ...")
27578:    FFIElK(BF(self.VVJrr9, isUp))
27579:   else:
27580:    self.VVCWQ4("Zap Disabled !")
27581:  def VVJrr9(self, isUp):
27582:   self.VVMpAl()
27583:   self["myPlayCc"].hide()
27584:   self["myPlayAud"].hide()
27585:   if self.zapFnc:
27586:    VVPxk5 = self.zapFnc(1 if isUp else -1)
27587:    self.VVmqIY(VVPxk5, "")
27588:   elif self.VVwqHQ:
27589:    self.VV56DF(isUp)
27590:   else:
27591:    if "/timeshift/" in CC3rDi(self.session).VVZcRP:
27592:     c1, c2 = VVwdUw, VV1fx4
27593:     self.VVCWQ4(c1 + "To zap, click " + c2 + self.VVArDB + c1 + " then " + c2 + "Play Latest")
27594:    else:
27595:     try:
27596:      if isUp : InfoBar.instance.zapDown()
27597:      else : InfoBar.instance.zapUp()
27598:     except:
27599:      pass
27600:     self.VVZvgO()
27601:     self.VVYWev()
27602:  def VVmqIY(self, chUrl, txt):
27603:   if txt:
27604:    self.VVCWQ4(txt)
27605:    FFIElK(BF(self.VVdQSL, chUrl))
27606:   else:
27607:    self.VVdQSL(chUrl)
27608:  def VVdQSL(self, chUrl):
27609:   FFnfiC(self.session, chUrl)
27610:   self.VVYWev()
27611:  def VVYWev(self):
27612:   self.VVb70o = 0
27613:   self.VVZABq()
27614:  def VV56DF(self, isUp):
27615:   CCkEI5_inatance, VV6A99, mode = self.VVwqHQ
27616:   if isUp : VV6A99.VVIRjv()
27617:   else : VV6A99.VVgexy()
27618:   colList = VV6A99.VV5crm()
27619:   VVAfO9 = ""
27620:   if mode == "localIptv":
27621:    VV1wIO, chUrl = CCkEI5_inatance.VVIHV3(VV6A99, colList)
27622:   elif mode == "localServer":
27623:    VV1wIO, chUrl, VVAfO9 = CCkEI5_inatance.VVJlyo(VV6A99, colList, isUp)
27624:   elif isinstance(mode, int):
27625:    VV1wIO, chUrl, VVAfO9 = CCkEI5_inatance.VVYAch(mode, VV6A99, colList)
27626:   elif any(x in mode for x in ("itv", "vod", "series")):
27627:    VV1wIO, chUrl, VVAfO9 = CCkEI5_inatance.VVsQmE(mode, VV6A99, colList)
27628:   else:
27629:    self.VVCWQ4("Cannot Zap")
27630:    return
27631:   self.VVAfO9 = VVAfO9
27632:   self.VVmqIY(chUrl, "")
27633:  def VVU96j(self, chUrl, endRef="", VVAfO9=""):
27634:   self.endRef = endRef
27635:   self.VVAfO9 = VVAfO9
27636:   self.VVmqIY(chUrl, "Starting Service ..." if chUrl else "")
27637:  def VVZvgO(self, forceRefresh=False):
27638:   try:
27639:    if not forceRefresh:
27640:     seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt = CCqWM2.VVVxSJ(self)
27641:     if posTxt:
27642:      return
27643:    VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(self)
27644:    if not self.VVgBJL(VVPxk5, VV1wIO, VVZcRP, VVfaDB):
27645:     return
27646:    if forceRefresh or "j.php" in VVZcRP:
27647:     self.VVCWQ4("Refreshing Portal ...")
27648:     FFIElK(self.VVytqm)
27649:   except:
27650:    pass
27651:  def VVytqm(self):
27652:   self.VVepQx = self.VVIguo(self.session)
27653:  def VVqe3J(self):
27654:   VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(self)
27655:   if not VVZcRP or FFUl6q(VVZcRP):
27656:    self.VVCWQ4("Not a Catch-up TV")
27657:    return
27658:   self.VVCWQ4("Checking Catch-up ...")
27659:   uHost = uUser = uPass = streamId = ""
27660:   ok_fnc = None
27661:   if "chCode=" in VVZcRP:
27662:    span = iSearch(r"(http.+)\/(.+)\/(.+)\/(\d+)\?play_token.+", VVZcRP)
27663:    if span: uHost, uUser, uPass, streamId = span.groups()
27664:   else:
27665:    if "/timeshift/" in VVZcRP:
27666:     span = iSearch(r"(.+)\/timeshift\/(.+)\/(.+)\/(.+)\/(.+)\/(\d+)", VVZcRP, IGNORECASE)
27667:     if span:
27668:      uHost, uUser, uPass = span.group(1), span.group(2), span.group(3)
27669:      streamId = span.group(6)
27670:      ndx = VV1wIO.find(" >> ")
27671:      if ndx > -1:
27672:       VV1wIO = VV1wIO[:ndx]
27673:    else:
27674:     uType, uHost, uUser, uPass, streamId, uChName = CCkEI5.VVNeuG(VVZcRP)
27675:   if all([uHost, uUser, uPass, streamId]):
27676:    qUrl = "%s/player_api.php?username=%s&password=%s" % (uHost, uUser, uPass)
27677:    ok_fnc  = BF(self.VVsFe5, VVPxk5, VV1wIO, streamId, uHost, uUser, uPass)
27678:    CCkEI5.VVvSue(self, qUrl, VV1wIO, streamId, ok_fnc, rst_fnc=self.VVZABq)
27679:   else:
27680:    self.VVCWQ4("Cannot process this channel")
27681:  def VVsFe5(self, VVPxk5, VV1wIO, streamId, uHost, uUser, uPass, VV6A99, title, txt, colList):
27682:   pTitle, sTime, dur = colList[4], colList[6], colList[8]
27683:   VV6A99.cancel()
27684:   span = iSearch(r"(\d{4}-\d{2}-\d{2})\s(\d{2}):(\d{2})", sTime)
27685:   if span:
27686:    sTime = span.group(1) + ":" + span.group(2) + "-" + span.group(3)
27687:    chUrl = "%s/timeshift/%s/%s/%s/%s/%s.ts" % (uHost, uUser, uPass, dur, sTime, streamId)
27688:    chUrl = chUrl.replace(":", "%3a")
27689:    chUrl = "%s:%s:%s >> %s" % (VVPxk5, chUrl, VV1wIO, pTitle)
27690:    self.VVmqIY(chUrl, "Changing Program ...")
27691:   else:
27692:    self.VVCWQ4("Incorrect Timestamp !")
27693:  def VVT1cG(self, isAudio):
27694:   aud, sub = CCvjVs.VVHlVI(self.session), CCvjVs.VVbjRo()
27695:   if isAudio:
27696:    if aud < 1:
27697:     self.VVCWQ4("No Audio Tracks")
27698:     return
27699:   else:
27700:    if sub < 1:
27701:     self.VVCWQ4("No Subtitles")
27702:     return
27703:   try:
27704:    inst = InfoBar.instance
27705:    if inst:
27706:     from Screens.AudioSelection import AudioSelection, SubtitleSelection
27707:     if isAudio : self.session.open(AudioSelection, infobar=inst)
27708:     else  : self.session.open(SubtitleSelection, inst)
27709:   except:
27710:    pass
27711:  @staticmethod
27712:  def VVO1c1(session, mode=None):
27713:   if   mode == "VV9RX6"   : FFdXBl(session, reopen=True)
27714:   elif mode == "VV3NZB"  : session.open(CCkEI5)
27715:   elif mode == "VVmZ3h" : session.open(CC6F0F)
27716:   elif mode == "VVEAiH" : session.open(CClYaF, VVAHYe=True)
27717:  @staticmethod
27718:  def VVHc02(session, **kwargs):
27719:   session.openWithCallback(BF(CCqWM2.VVO1c1, session), CCqWM2, **kwargs)
27720: class CC032e(Screen):
27721:  def __init__(self, session, title="", VVsWSA="Continue?", VV4Moq=True, VVAgUy=False):
27722:   self.skin, self.VVfOli = FFiNEe(VVUcno, 1200, 800, 50, 20, 20, "
27723:   self.session = session
27724:   self["myLine"] = Label()
27725:   self.VVsWSA = VVsWSA
27726:   self.VVAgUy = VVAgUy
27727:   self.maxHeight = 0
27728:   no  = ("No" , "no" )
27729:   yes = ("Yes", "yes")
27730:   if VV4Moq : VV3wat = [no , yes]
27731:   else   : VV3wat = [yes, no ]
27732:   FFZMxC(self, title, VV3wat=VV3wat, addLabel=True)
27733:   FFHlAU(self,
27734:   {
27735:    "ok" : self.VVPr1F ,
27736:    "cancel": self.cancel ,
27737:    "red" : self.cancel ,
27738:   })
27739:   self.onShown.append(self.VV7OzD)
27740:  def VV7OzD(self):
27741:   self.onShown.remove(self.VV7OzD)
27742:   self.maxHeight = self.instance.size().height()
27743:   self["myLabel"].setText("\n%s\n" % self.VVsWSA)
27744:   if self.VVAgUy:
27745:    self["myLabel"].instance.setHAlign(0)
27746:   self.VVRgu6()
27747:   FF4IPF(self["myMenu"], fg="#08ffff00", bg="#08223333")
27748:   try: self["myMenu"].instance.setHAlign(1)
27749:   except: FFzKEr(self["myMenu"], 35)
27750:   FFJmzh(self, self["myMenu"])
27751:  def VVPr1F(self):
27752:   item = self["myMenu"].l.getCurrentSelection()[1]
27753:   if item is not None:
27754:    if   item == "no" : self.close(False)
27755:    elif item == "yes" : self.close(True)
27756:   else:
27757:    self.close(False)
27758:  def cancel(self):
27759:   self.close(False)
27760:  def VVRgu6(self):
27761:   vGap = 60 if CC674y.VV1LWx() else 0
27762:   winW = self.instance.size().width()
27763:   winH = self.instance.size().height()
27764:   labelW = self["myLabel"].instance.size().width()
27765:   labelH = self["myLabel"].instance.size().height()
27766:   textSize= self["myLabel"].instance.calculateSize()
27767:   diff = textSize.height() - labelH + vGap
27768:   winNewH = winH + diff
27769:   if winNewH < winH:
27770:    screenSize = getDesktop(0).size()
27771:    self["myLabel"].instance.resize(eSize(*(labelW, labelH + diff)))
27772:    self.instance.resize(eSize(*(winW, winNewH)))
27773:    self.instance.move(ePoint((screenSize.width() - winW) // 2, (screenSize.height() - winNewH) // 2))
27774:    names = [ "myMenu", "myLine" ]
27775:    for name in names:
27776:     try:
27777:      obj = self[name]
27778:      pos = obj.getPosition()
27779:      obj.instance.move(ePoint(pos[0], pos[1] + diff))
27780:     except:
27781:      pass
27782: class CCUwDo(Screen, CCLAzj):
27783:  def __init__(self, session, title="", VV3wat=None, width=1000, height=850, VVwdmN=30, VVW5y5="", VVyRCy=1, VVptue=0.15, VVy8OB=False, VVOa1G=None, VVJbOd=None, VVHGnw=None, VVwJOl=None, VVB4pu=None, VVaTeF=None, cornerPicFnc=None, VVdrEC=(0, 0), VVU8mZ=False, VVlaGv=False, VVtboQ=None, VVCkuB=True, VVwltY="
27784:   if   VVy8OB and VVJbOd : VV0Ay7 = 2
27785:   elif VVy8OB     : VV0Ay7 = 1
27786:   elif VVJbOd    : VV0Ay7 = 3
27787:   else      : VV0Ay7 = 0
27788:   self.skin, self.VVfOli = FFiNEe(VVWp3I, width, height, 50, 40, 30, VVwltY, VVkxBG, VVwdmN, VVeFSs=40, VVptue=VVptue, VV0Ay7=VV0Ay7, VVdrEC=VVdrEC)
27789:   self.session   = session
27790:   self.VVW5y5   = VVW5y5
27791:   self.VVyRCy   = VVyRCy
27792:   self.VVy8OB    = VVy8OB
27793:   self.VVOa1G   = VVOa1G
27794:   self.VVJbOd   = VVJbOd
27795:   self.VVHGnw   = VVHGnw
27796:   self.VVwJOl  = VVwJOl
27797:   self.VVB4pu  = ("Delete File", BF(self.VV6mkY, VVtboQ)) if not VVtboQ is None else VVB4pu
27798:   self.VVaTeF   = VVaTeF
27799:   self.cornerPicFnc  = cornerPicFnc
27800:   self.VVU8mZ  = VVU8mZ
27801:   self.VVlaGv  = VVlaGv
27802:   self.VVoCB2   = VVoCB2
27803:   self.Title    = title
27804:   FFZMxC(self, title, VV3wat=VV3wat)
27805:   CCLAzj.__init__(self)
27806:   FFHlAU(self,
27807:   {
27808:    "ok"  : self.VVPr1F    ,
27809:    "menu"  : self.VVfcZX   ,
27810:    "cancel" : self.cancel    ,
27811:    "info"  : self.VVGXgk   ,
27812:    "red"  : self.VVnQ7v   ,
27813:    "green"  : self.VVm2cy   ,
27814:    "yellow" : self.VVrlp9   ,
27815:    "blue"  : self.VVg0jV   ,
27816:    "pageUp" : self.VVeXFp ,
27817:    "chanUp" : self.VVeXFp ,
27818:    "pageDown" : self.VVQ0fH  ,
27819:    "chanDown" : self.VVQ0fH  ,
27820:    "0"   : BF(self.VV3WBT, 0) ,
27821:    "1"   : BF(self.VV3WBT, 1) ,
27822:    "2"   : BF(self.VV3WBT, 2) ,
27823:    "3"   : BF(self.VV3WBT, 3) ,
27824:    "4"   : BF(self.VV3WBT, 4) ,
27825:    "5"   : BF(self.VV3WBT, 5) ,
27826:    "6"   : BF(self.VV3WBT, 6) ,
27827:    "7"   : BF(self.VV3WBT, 7) ,
27828:    "8"   : BF(self.VV3WBT, 8) ,
27829:    "9"   : BF(self.VV3WBT, 9)
27830:   })
27831:   if VVCkuB:
27832:    CCKg9B(self, self["myMenu"])
27833:   self.onShown.append(self.VV7OzD)
27834:   self.onClose.append(self.onExit)
27835:  def VV7OzD(self):
27836:   self.onShown.remove(self.VV7OzD)
27837:   FF4IPF(self["myMenu"], bg=self.VVoCB2)
27838:   FF2GM8(self, VVyRCy=self.VVyRCy)
27839:   FF6W0I(self)
27840:   self.VV004I(self["keyRed"]  , self.VVHGnw )
27841:   self.VV004I(self["keyGreen"] , self.VVwJOl )
27842:   self.VV004I(self["keyYellow"] , self.VVB4pu )
27843:   self.VV004I(self["keyBlue"]  , self.VVaTeF )
27844:   if self.VVW5y5      : self["myBar"].setText("  %s" % self.VVW5y5)
27845:   elif not self["keyRed"].getVisible(): self["myBar"].setText("  OK = Select")
27846:   else        : self["myBar"].setText("")
27847:   FFWgBS(self)
27848:   if self.cornerPicFnc:
27849:    self.VVyR0w(self.VV1WUE)
27850:  def onExit(self):
27851:   self["myMenu"].onSelectionChanged = []
27852:  def VV004I(self, btnObj, btnFnc):
27853:   if btnFnc:
27854:    FFRLNq(btnObj, btnFnc[0])
27855:  def VVyR0w(self, fnc, callFnc=True):
27856:   self["myMenu"].onSelectionChanged.append(fnc)
27857:   if callFnc:
27858:    fnc()
27859:  def VV1WUE(self):
27860:   item = self.VVnGzV()
27861:   if item:
27862:    txt, ref, ndx = item
27863:    picF = self.cornerPicFnc(self, txt, ref, ndx)
27864:    if FFCyVu(picF):
27865:     if self.VVacFr(picF):
27866:      return
27867:   self.VVTOb9()
27868:  def VVoXgh(self, fnc=None):
27869:   self.VVwJOl = fnc
27870:   if fnc : self.VV004I(self["keyGreen"], self.VVwJOl)
27871:   else : self["keyGreen"].hide()
27872:  def VV3WBT(self, digit):
27873:   digit = str(digit)
27874:   VV3wat = self["myMenu"].list
27875:   for ndx, item in enumerate(VV3wat):
27876:    if len(item) == 2:
27877:     span = iSearch(r"^\[(\d)\]\s.+", FFzBfi(item[0]), IGNORECASE)
27878:     if span and span.group(1) == digit:
27879:      self.VVx2yy(ndx)
27880:      self.VVPr1F()
27881:      break
27882:  def VVnGzV(self):
27883:   obj = self["myMenu"].l
27884:   ref = obj.getCurrentSelection()[1]
27885:   if ref is not None:
27886:    txt = obj.getCurrentSelection()[0]
27887:    ndx = obj.getCurrentSelectionIndex()
27888:    return (txt, ref, ndx)
27889:   else:
27890:    return None
27891:  def VVPr1F(self):
27892:   item = self.VVnGzV()
27893:   if item:
27894:    txt, ref, ndx = item
27895:    if self.VVOa1G:
27896:     self.VVOa1G((self, txt, ref, ndx))
27897:    else:
27898:     if self.VVU8mZ: self.close((txt, ref, ndx))
27899:     else     : self.close(ref)
27900:  def VVfcZX(self):
27901:   if self.VVy8OB: self.close("VVy8OB")
27902:  def VVGXgk(self):
27903:   item = self.VVnGzV()
27904:   if self.VVJbOd and item:
27905:    txt, ref, ndx = item
27906:    self.VVJbOd(self, txt, ref, ndx)
27907:  def cancel(self):
27908:   self.close(None)
27909:  def VVnQ7v(self)  : self.VVF95v(self.VVHGnw)
27910:  def VVm2cy(self) : self.VVF95v(self.VVwJOl)
27911:  def VVrlp9(self) : self.VVF95v(self.VVB4pu)
27912:  def VVg0jV(self) : self.VVF95v(self.VVaTeF)
27913:  def VVF95v(self, btnFnc):
27914:   if btnFnc:
27915:    item = self["myMenu"].l.getCurrentSelection()[1]
27916:    fnc = btnFnc[1]
27917:    fnc(self, item)
27918:    if self.VVlaGv:
27919:     self.cancel()
27920:  def VV478W(self):
27921:   ndx = self["myMenu"].getSelectedIndex()
27922:   VV3wat = self["myMenu"].list
27923:   VV3wat.pop(ndx)
27924:   if len(VV3wat) > 0: self["myMenu"].setList(VV3wat)
27925:   else    : self.close()
27926:  def VVKjBW(self, data):
27927:   ndx = self["myMenu"].getSelectedIndex()
27928:   VV3wat = self["myMenu"].list
27929:   VV3wat[ndx] = data
27930:   self["myMenu"].setList(VV3wat)
27931:  def VV6mkY(self, basePath, menuObj, fName):
27932:   FFRMYv(self, BF(self.VVs4p7, basePath + fName), "Delete this file ?\n\n%s" % fName, title=self.Title)
27933:  def VVs4p7(self, path):
27934:   FFwgGB(path)
27935:   if FFCyVu(path) : FF28n1(self, "Not deleted", 1000)
27936:   else    : self.VV478W()
27937:  def VVG6OZ(self):
27938:   return self["myMenu"].list
27939:  def VV35XX(self):
27940:   return [x[1] for x in self["myMenu"].list if len(x) > 1]
27941:  def VVkSNR(self, VV3wat):
27942:   if len(VV3wat) > 0:
27943:    newList = []
27944:    for item in VV3wat:
27945:     newList.append((item, item))
27946:    self["myMenu"].setList(newList)
27947:    FF2GM8(self, VVyRCy=self.VVyRCy)
27948:   else:
27949:    self.close("")
27950:  def FFTmHZ(self, txt):
27951:   self["myTitle"].setText("  %s  " % txt)
27952:  def VVzEkM(self, txt):
27953:   self["myBar"].setText("  %s  " % txt)
27954:  def VV5HD3(self, newRow, isSort=False):
27955:   lst = self["myMenu"].list
27956:   lst.append(newRow)
27957:   if isSort:
27958:    lst.sort(key=lambda x: x[0].lower())
27959:   self["myMenu"].setList(lst)
27960:   FF2GM8(self, VVyRCy=self.VVyRCy)
27961:   for ndx, item in enumerate(self["myMenu"].list):
27962:    if item[1] == newRow[1]:
27963:     self["myMenu"].moveToIndex(ndx)
27964:     break
27965:  def VVT8gV(self, isUp):
27966:   ndx = self["myMenu"].getSelectionIndex()
27967:   if   isUp and ndx > 0         : newIndex = ndx - 1
27968:   elif not isUp and ndx < len(self["myMenu"].list) - 1 : newIndex = ndx + 1
27969:   else             : return None
27970:   newList = self["myMenu"].list
27971:   newList.insert(newIndex, newList.pop(ndx))
27972:   self["myMenu"].moveToIndex(newIndex)
27973:   newList = []
27974:   for item in self["myMenu"].list:
27975:    newList.append(item[0])
27976:   return newList
27977:  def VVx2yy(self, ndx):
27978:   self["myMenu"].moveToIndex(ndx)
27979:  def VVVZJD(self, refTxt):
27980:   for ndx, item in enumerate(self["myMenu"].list):
27981:    if len(item) > 1 and refTxt == item[1]:
27982:     self.VVx2yy(ndx)
27983:     break
27984:  def VVyQ6Y(self, txt):
27985:   for ndx, item in enumerate(self["myMenu"].list):
27986:    if txt == item[0]:
27987:     self.VVx2yy(ndx)
27988:     break
27989:  def VVeXFp(self) : self["myMenu"].moveToIndex(0)
27990:  def VVQ0fH(self) : self["myMenu"].moveToIndex(len(self["myMenu"].list) - 1)
27991: class CCnES5(Screen, CCLAzj):
27992:  def __init__(self, session, title="", width=1600, height=900, VVllEU=50, VViIEz=10, VVYUmm=5, header=None, VVGape=None, VVLIqP=None, VV3cHe=None, VVwdmN=26, VVW5y5="", VVCNdI="", VV8LLn=False, VVpCEu=False, VVlXgq=3000, VViWgK=False, VVp4wm=True, VVb5gJ=None, VVHPI7=False, VViZ3s=0, VVoGCy=None, VVp1bQ=None, VVdrEC=(0, 0), VVu1YM=None, VV2ytr=None, VVdHJK=None, VVwWmA=None, VVwSzI=None, VVScQz=None, VV4QTJ=None, VV2x9J=None, VVCOpO=None, VVu8qI=None, VVlJfJ=None, VVGuQE=None, VVC51D=-1, VVKDPJ=0, VVMfsO=0, VVSLOq=None, VVwltY="
27993:   VVpCEu = VVpCEu or VVKDPJ == 1
27994:   barH = 1 if VVpCEu else 40
27995:   self.skin, self.VVfOli = FFiNEe(VVvJlJ, width, height, VVllEU, VViIEz, VVYUmm, VVwltY, VVkxBG, 26, VVeFSs=barH, VV0Ay7=2, VVptue=0.6, VVdrEC=VVdrEC)
27996:   self.session    = session
27997:   self.Title     = title
27998:   self.header     = header
27999:   self.VVGape     = VVGape
28000:   self.VV2BDe    = len(VVGape[0])
28001:   self.VViZ3s   = VViZ3s
28002:   self.VVoGCy    = VVoGCy
28003:   self.VVp1bQ   = VVp1bQ
28004:   self.VVo5oS    = VVp1bQ[0] if VVp1bQ else -1
28005:   self.VV5638 = False
28006:   self.VVHPI7   = VVHPI7
28007:   self.VVw0f2   = 0.01
28008:   self.VVWFVJ   = 0.02
28009:   self.VVdOlT = 0.03
28010:   self.VVrDCa   = 1
28011:   self.VV3cHe = VV3cHe
28012:   self.VVKAGT   = []
28013:   self.VVu1YM   = VVu1YM
28014:   self.VVbfjm   = None
28015:   self.VV2ytr   = VV2ytr
28016:   self.VVwWmA   = VVwWmA
28017:   self.VVwSzI   = VVwSzI
28018:   self.VVScQz  = VVScQz
28019:   self.VV4QTJ   = VV4QTJ
28020:   self.VV2x9J    = VV2x9J
28021:   self.VVCOpO   = VVCOpO
28022:   self.VVDpzd   = None
28023:   self.VVu8qI  = VVu8qI
28024:   self.VVlJfJ   = VVlJfJ
28025:   self.VVdHJK   = VVdHJK
28026:   self.VVC51D    = VVC51D
28027:   self.VVKDPJ   = VVKDPJ
28028:   self.VVMfsO    = VVMfsO
28029:   self.VVLIqP    = VVLIqP
28030:   self.VVj2Pf    = -1
28031:   self.VVGuQE    = VVGuQE
28032:   self.VVwdmN    = FFqCn5(VVwdmN)
28033:   self.VVW5y5    = VVW5y5
28034:   self.VVCNdI    = VVCNdI
28035:   self.VV8LLn    = VV8LLn
28036:   self.VVlXgq     = VVlXgq
28037:   self.VViWgK    = VViWgK
28038:   self.VVp4wm    = VVp4wm
28039:   self.VVb5gJ    = VVb5gJ or {}
28040:   self.VV8c7y    = FFGrBZ(self.VVwdmN, self.VVfOli["VVptue"])
28041:   self.scrollBarWidth   = self.VVfOli["scrollBarW"]
28042:   self.VVwltY    = VVwltY
28043:   self.VVkxBG      = VVkxBG
28044:   self.VVEGV6    = FFRUST(VVEGV6)
28045:   self.VVemyB    = FFRUST(VVemyB)
28046:   self.VVoRat    = VVoRat
28047:   self.VVJKqd    = FFRUST(VVJKqd)
28048:   self.VVLf28   = VVLf28
28049:   self.VVbcr0   = FFRUST(VVbcr0)
28050:   self.VVZrqm    = FFRUST(VVZrqm)
28051:   self.VVX9AA    = FFRUST(VVX9AA)
28052:   self.VVrZk6   = FFRUST(VVrZk6)
28053:   self.VVG9pi  = FFRUST(VVG9pi)
28054:   self.VVXWPu  = False
28055:   self.VVEHSR   = 0
28056:   self.VVH8fj   = FFRUST("#04764354")
28057:   self.VVSLOq  = VVSLOq or CFG.lastFindGeneral
28058:   self.VVcqGs  = False
28059:   self.VVJ6ki  = False
28060:   self.VVGxei  = False
28061:   self.VVez0o = False
28062:   self.VVMayE  = False
28063:   self.VV5FKY = CCnES5.VVmxDV(0, 0, 20, 20, LoadPixmap(VVIp2p + "tick.png"))
28064:   self.VVaqq6 = CCnES5.VVmxDV(0, 0, 1, 1, LoadPixmap(VVIp2p + "tick_1x1.png"))
28065:   FFZMxC(self, title)
28066:   CCLAzj.__init__(self)
28067:   if VVpCEu:
28068:    self["myLine"].hide()
28069:   self["myTableH"] = MenuList([], True, eListboxPythonMultiContent)
28070:   self["myTable"]  = MenuList([], True, eListboxPythonMultiContent)
28071:   self["myTotSel"] = Label("Sel = 0")
28072:   self["myTotSel"].hide()
28073:   FFHlAU(self,
28074:   {
28075:    "ok"  : self.VVDFgE  ,
28076:    "red"  : self.VV1uSG  ,
28077:    "green"  : self.VVZgYJ ,
28078:    "yellow" : self.VVKn4v ,
28079:    "blue"  : self.VVJAg1  ,
28080:    "menu"  : self.VV4lOw ,
28081:    "info"  : self.VVyogT  ,
28082:    "cancel" : self.VV1hTi  ,
28083:    "up"  : self.VVgexy    ,
28084:    "down"  : self.VVIRjv  ,
28085:    "left"  : self.VVLlE3   ,
28086:    "right"  : self.VVSYHQ  ,
28087:    "next"  : self.VVFkgI  ,
28088:    "last"  : self.VVtvpP  ,
28089:    "home"  : self.VVE9rg  ,
28090:    "pageUp" : self.VVE9rg  ,
28091:    "chanUp" : self.VVE9rg  ,
28092:    "end"  : self.VVMjPT  ,
28093:    "pageDown" : self.VVMjPT  ,
28094:    "chanDown" : self.VVMjPT
28095:   })
28096:   CCKg9B(self, self["myTable"], colNum=self.VVMfsO)
28097:   self.onShown.append(self.VV7OzD)
28098:   self.onClose.append(self.onExit)
28099:  def VV7OzD(self):
28100:   self.onShown.remove(self.VV7OzD)
28101:   FF6W0I(self)
28102:   if self.VVW5y5:
28103:    self.VVO1tN(self.VVW5y5)
28104:   if self.VVKDPJ:
28105:    self["keyMenu"].hide()
28106:    x, y = self["keyMenu"].getPosition()
28107:    self["keyInfo"].instance.move(ePoint(x, y))
28108:   try:
28109:    self.VVpxGx()
28110:   except Exception as e:
28111:    FFdw58(self, str(e), title=self.Title)
28112:    self.close(None)
28113:  def onExit(self):
28114:   self["myTable"].onSelectionChanged = []
28115:  def VVpxGx(self):
28116:   FFWgBS(self)
28117:   self.VV004I(self.VVwWmA , self["keyRed"])
28118:   self.VV004I(self.VVwSzI , self["keyGreen"])
28119:   self.VV004I(self.VVScQz, self["keyYellow"])
28120:   self.VV004I(self.VV4QTJ , self["keyBlue"])
28121:   if self.VVu1YM:
28122:    if   not self["keyRed"].getVisible() : self.VVbfjm = self["keyRed"]
28123:    elif not self["keyBlue"].getVisible() : self.VVbfjm = self["keyBlue"]
28124:    else         : self.VVbfjm = None
28125:    if self.VVbfjm and self.VVu1YM[0]:
28126:     self.VVbfjm.show()
28127:     self.VVbfjm.setText("OK = %s" % self.VVu1YM[0])
28128:     FFZ0AC(self.VVbfjm, "#11000000")
28129:   if self.VVCNdI and not self["keyBlue"].getVisible():
28130:    self["keyBlue"].show()
28131:    self["keyBlue"].setText(self.VVCNdI)
28132:    FFZ0AC(self["keyBlue"], "#11000000")
28133:   self["myTableH"].l.setSelectionClip(eRect(0, 0, 0, 0))
28134:   FFK4PQ(self["myTableH"], "#00555500", 2)
28135:   self["myTableH"].l.setItemHeight(self.VV8c7y)
28136:   self["myTableH"].l.setFont(0, gFont(VVNhAq, self.VVwdmN))
28137:   self["myTable"].l.setItemHeight(self.VV8c7y)
28138:   self["myTable"].l.setFont(0, gFont(VVNhAq, self.VVwdmN))
28139:   try:
28140:    self["myTable"].instance.setScrollbarSliderBorderWidth(0)
28141:   except:
28142:    pass
28143:   w = self["myTable"].instance.size().width()
28144:   h = self["myTable"].instance.size().height()
28145:   pos = self["myTable"].getPosition()
28146:   if self.header and not self.VV8LLn:
28147:    self["myTableH"].instance.resize(eSize(*(w, self.VV8c7y)))
28148:    self["myTable"].instance.move(ePoint(pos[0], pos[1] + self.VV8c7y))
28149:    self["myTable"].instance.resize(eSize(*(w, h - self.VV8c7y)))
28150:   h = self["myTable"].instance.size().height()
28151:   pos = self["myTable"].getPosition()
28152:   part= self["myTable"].instance.size().height() % self.VV8c7y
28153:   half= int(part / 2)
28154:   self["myTable"].instance.resize(eSize(*(w, h - part)))
28155:   self["myTable"].instance.move(ePoint(pos[0], pos[1] + half))
28156:   if self.header:
28157:    pos = self["myTableH"].getPosition()
28158:    self["myTableH"].instance.move(ePoint(pos[0], pos[1] + half))
28159:   menuWidth = self["myTable"].instance.size().width()
28160:   gapX = 0
28161:   if self.VV8c7y * len(self.VVGape) > self["myTable"].instance.size().height():
28162:    menuWidth = menuWidth - int(self.scrollBarWidth) - 5
28163:    gapX = int(self.scrollBarWidth) - 5
28164:   if not self.VV3cHe:
28165:    self.VV3cHe = ([float(100.0 / self.VV2BDe)] * self.VV2BDe)
28166:   self.VVKAGT = list(self.VV3cHe)
28167:   if not self.VVKAGT:
28168:    self.VVKAGT = [menuWidth // self.VV2BDe] * self.VV2BDe
28169:   else:
28170:    for i, item in enumerate(self.VVKAGT):
28171:     self.VVKAGT[i] = int(item * menuWidth / 100)
28172:   if not self.VVLIqP : self.VVLIqP = [LEFT | RT_VALIGN_CENTER] * self.VV2BDe
28173:   else     : self.VVLIqP = [x | RT_VALIGN_CENTER for x in self.VVLIqP]
28174:   half = int(self.VV8c7y / 2.0)
28175:   if self.header : gapY = self["myTableH"].getPosition()[1] + half
28176:   else   : gapY = self["myTable"].getPosition()[1] - half
28177:   self.VVKe51(gapX, gapY)
28178:   self.VVfmej()
28179:   if self.VV2x9J:
28180:    self.VV2x9J(self)
28181:  def VV004I(self, btnFnc, btn):
28182:   if btnFnc : FFRLNq(btn, btnFnc[0])
28183:   else  : FFRLNq(btn, "")
28184:  def VVfmej(self, onlyHeader=False, showProgBar=True, fromRefresh=False):
28185:   if self.header:
28186:    sortedFg = self.VVG9pi if self.VV5638 else self.VVrZk6
28187:    self["myTableH"].setList([self.VVPuKm(0, self.header, self.VVZrqm, self.VVX9AA, None, self.VVX9AA, sortedFg)])
28188:   if onlyHeader:
28189:    return
28190:   tot = len(self.VVGape)
28191:   if showProgBar and tot > self.VVlXgq:
28192:    CCh3tv.VV7Nf4(self, VVLL7M="Loading Table ( %s row%s ) ..." % (tot, FFcacr(tot)), endTitle="Loading channels ...", VVIZBP=CCh3tv.VVgJkc, titleBg="#11222222", bodyBg="#11222222", barBg="#06446677"
28193:        , VVixvy  =  BF(self.VVja0t, True, fromRefresh)
28194:        , VVbYwR = self.VVTs5z )
28195:   else:
28196:    self.VVja0t(False, fromRefresh)
28197:  def VVja0t(self, showProgBar, fromRefresh, VVXyP6=None):
28198:   try:
28199:    if showProgBar:
28200:     VVXyP6.VVq8NF(len(self.VVGape))
28201:    self["myTable"].list = []
28202:    for c, row in enumerate(self.VVGape):
28203:     if showProgBar:
28204:      if not VVXyP6 or VVXyP6.isCancelled:
28205:       return
28206:      VVXyP6.VVxtQs(1)
28207:     self["myTable"].list.append(self.VVPuKm(c, row, self.VVEGV6, self.VVemyB, self.VVoRat, self.VVJKqd, None))
28208:    self.VVGape = []
28209:    self["myTable"].setList(self["myTable"].list)
28210:    if self.VVC51D > -1:
28211:     self["myTable"].moveToIndex(self.VVC51D)
28212:    if self.VVKDPJ and not fromRefresh:
28213:     tableH = self["myTable"].instance.size().height()
28214:     rowsH = self.VV8c7y * len(self["myTable"].list)
28215:     if rowsH < tableH:
28216:      diff = tableH - rowsH
28217:      newH = self.instance.size().height() - diff
28218:      screenSize = getDesktop(0).size()
28219:      width = self.instance.size().width()
28220:      self.instance.resize(eSize(*(width, newH)))
28221:      self.instance.move(ePoint((screenSize.width() - width) // 2, (screenSize.height() - newH) // 2))
28222:      names = [ "keyRed", "keyGreen", "keyYellow", "keyBlue", "myBar", "myLine" ]
28223:      for name in names:
28224:       obj = self[name]
28225:       pos = obj.getPosition()
28226:       obj.instance.move(ePoint(pos[0], pos[1] - diff))
28227:      FF9sDw(self, width, newH)
28228:    if self.VVCOpO:
28229:     self.VVF95v(self.VVCOpO, None)
28230:    if self.VVDpzd:
28231:     self.VVF95v(self.VVDpzd, None)
28232:     self.VVDpzd = None
28233:   except AttributeError as attrErr:
28234:    pass
28235:   except Exception as e:
28236:    try:
28237:     FFdw58(self, str(e), title=self.Title)
28238:     self.close()
28239:    except:
28240:     pass
28241:  def VVTs5z(self, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
28242:   if not VVRI6P:
28243:    self.close()
28244:  def VVPuKm(self, keyIndex, columns, VVEGV6, VVemyB, VVoRat, VVJKqd, VVrZk6):
28245:   row = [keyIndex]
28246:   if VVoRat:
28247:    VVoRat = FFRUST(VVoRat)
28248:   posX = 0
28249:   for ndx, entry in enumerate(columns):
28250:    if not VVrZk6:
28251:     textColor = VVEGV6
28252:    elif VVrZk6 and (ndx in self.VVb5gJ and self.VVb5gJ[ndx] == self.VViZ3s) or ndx == self.VViZ3s:
28253:     textColor = VVrZk6
28254:    else:
28255:     textColor = VVEGV6
28256:    while iMatch(r"^\s*
28257:     span = iSearch(r"\s*
28258:     if span:
28259:      c = FFRUST(span.group(2))
28260:      if span.group(1) == "f" : textColor = c
28261:      else     : VVemyB = c
28262:      entry = span.group(3)
28263:    if not self.VViWgK and self.VVLIqP[ndx] & LEFT:
28264:     entry = " " + entry + " "
28265:    row.append(CCnES5.VVNynG(  posX, 0
28266:              , self.VVKAGT[ndx], self.VV8c7y
28267:              , 0
28268:              , self.VVLIqP[ndx]
28269:              , entry
28270:              , textColor
28271:              , VVemyB
28272:              , VVoRat or textColor
28273:              , VVJKqd
28274:              , self.VVLf28
28275:              , self.VVbcr0
28276:              ))
28277:    posX += self.VVKAGT[ndx]
28278:   if not VVrZk6:
28279:    if self.VVoGCy:
28280:     VVzIFKCol, picFnc, pathCol = self.VVoGCy
28281:     if   picFnc : png = picFnc(columns)
28282:     elif pathCol: png = columns[pathCol].strip()
28283:     else  : png = ""
28284:     if png.startswith("/"):
28285:      try:
28286:       pngX = sum(self.VVKAGT[:VVzIFKCol])
28287:       row.append(CCnES5.VVmxDV(pngX+2, VVzIFKCol+2, self.VVKAGT[VVzIFKCol]-4, self.VV8c7y-4, LoadPixmap(png)))
28288:      except:
28289:       pass
28290:    if self.VVp1bQ:
28291:     pCol, vCol, pW, pH = self.VVp1bQ
28292:     perc = int(columns[vCol])
28293:     pX = sum(self.VVKAGT[:pCol])
28294:     w = int(pW / 100.0 * self.VVKAGT[pCol])
28295:     h = int(pH / 100.0 * self.VV8c7y)
28296:     x = pX + (self.VVKAGT[pCol] - w) // 2
28297:     y = (self.VV8c7y - h) // 2
28298:     row.append(CCnES5.VV86Ng(x, y, w, h, perc, 1, FFRUST("
28299:    row.append(self.VVaqq6)
28300:   return row
28301:  def VVyogT(self):
28302:   rowData = self.VV0d86()
28303:   if rowData:
28304:    title, txt, colList = rowData
28305:    if self.VV2ytr:
28306:     fnc  = self.VV2ytr[1]
28307:     params = self.VV2ytr[2]
28308:     fnc(self, title, txt, colList)
28309:    else:
28310:     FF4lCP(self, txt, title)
28311:  def VVDFgE(self):
28312:   if   self.VVXWPu : self.VVTQDs(self.VVGTqU(), mode=2)
28313:   elif self.VVu1YM  : self.VVF95v(self.VVu1YM, None)
28314:   else      : self.VVyogT()
28315:  def VV1uSG(self) : self.VVF95v(self.VVwWmA , self["keyRed"])
28316:  def VVZgYJ(self) : self.VVF95v(self.VVwSzI , self["keyGreen"])
28317:  def VVKn4v(self): self.VVF95v(self.VVScQz , self["keyYellow"])
28318:  def VVJAg1(self) : self.VVF95v(self.VV4QTJ , self["keyBlue"])
28319:  def VVF95v(self, buttonFnc, btnObj):
28320:   if btnObj and not btnObj.getVisible():
28321:    return
28322:   if buttonFnc:
28323:    if len(buttonFnc) > 3 and buttonFnc[3]:
28324:     FF28n1(self, buttonFnc[3])
28325:     FFIElK(BF(self.VV0sfZ, buttonFnc))
28326:    else:
28327:     self.VV0sfZ(buttonFnc)
28328:  def VV0sfZ(self, buttonFnc):
28329:   fnc   = buttonFnc[1]
28330:   params  = buttonFnc[2]
28331:   rowData = self.VV0d86()
28332:   if rowData:
28333:    title, txt, colList = rowData
28334:    if not params : fnc(self, title, txt, colList)
28335:    else   : fnc(self, *params)
28336:  def VVTQDs(self, ndx, mode=0, movDn=True):
28337:   try:  row = self["myTable"].list[ndx]
28338:   except: row = None
28339:   if row:
28340:    isSelected = row[1][10] == self.VVH8fj
28341:    if mode == 0 or (mode == 2 and isSelected):
28342:     bg = self.VVemyB
28343:     if isSelected:
28344:      self.VVEHSR -= 1
28345:    else:
28346:     bg = self.VVH8fj
28347:     if not isSelected:
28348:      self.VVEHSR += 1
28349:    self.VVdus6()
28350:    if isSelected: self["myTable"].list[ndx][-1] = self.VVaqq6
28351:    else   : self["myTable"].list[ndx][-1] = self.VV5FKY
28352:    for col in range(1, len(row)):
28353:     cols = list(row[col])
28354:     if cols[0] == eListboxPythonMultiContent.TYPE_TEXT:
28355:      cols[10] = bg
28356:     row[col] = tuple(cols)
28357:    self["myTable"].l.invalidate()
28358:    if movDn and self.VVGTqU() < len(self["myTable"].list) - 1:
28359:     self.VVIRjv()
28360:    if self.VVlJfJ:
28361:     self.VVlJfJ(self)
28362:  def VVdus6(self): self["myTotSel"].setText("Sel = %d" % self.VVEHSR)
28363:  def VVtrFZ(self)  : FFimQ3(self, BF(self.VVuUxo, True ), title="Selecting all ..."  )
28364:  def VV3Ezh(self) : FFimQ3(self, BF(self.VVuUxo, False), title="Unselecting all ...")
28365:  def VVuUxo(self, isSel=True):
28366:   if isSel:
28367:    bg = self.VVH8fj
28368:    self.VVEHSR = len(self["myTable"].list)
28369:    self.VV8lnC(True)
28370:   else:
28371:    bg = self.VVemyB
28372:    self.VVEHSR = 0
28373:   self.VVdus6()
28374:   for ndx, row in enumerate(self["myTable"].list):
28375:    isPainted = row[1][10] == self.VVH8fj
28376:    if (isSel and not isPainted) or (not isSel and isPainted):
28377:     for col in range(1, len(row)):
28378:      cols = list(self["myTable"].list[ndx][col])
28379:      if cols[0] == eListboxPythonMultiContent.TYPE_TEXT:
28380:       cols[10] = bg
28381:      self["myTable"].list[ndx][col] = tuple(cols)
28382:    if isSel: self["myTable"].list[ndx][-1] = self.VV5FKY
28383:    else : self["myTable"].list[ndx][-1] = self.VVaqq6
28384:   self["myTable"].l.invalidate()
28385:   if self.VVlJfJ:
28386:    self.VVlJfJ(self)
28387:  def VV8lnC(self, isOn):
28388:   self.VVXWPu = isOn
28389:   if isOn:
28390:    color = "#01883366"
28391:    self["myTotSel"].show()
28392:    self["keyMenu"].hide()
28393:    if self.VVcqGs and self.VVu1YM and self.VVbfjm:
28394:     self.VVbfjm.setText("OK = Select")
28395:    if self.VVJ6ki and self.VVwWmA: self["keyRed"].hide()
28396:    if self.VVGxei and self.VVwSzI: self["keyGreen"].hide()
28397:    if self.VVez0o and self.VVScQz: self["keyYellow"].hide()
28398:    if self.VVMayE and self.VV4QTJ: self["keyBlue"].hide()
28399:   else:
28400:    color = self.VVwltY
28401:    self["myTotSel"].hide()
28402:    self["keyMenu"].show()
28403:    if self.VVcqGs and self.VVu1YM and self.VVbfjm:
28404:     self.VVbfjm.setText("OK = %s" % self.VVu1YM[0])
28405:    if self.VVJ6ki and self.VVwWmA: self["keyRed"].show()
28406:    if self.VVGxei and self.VVwSzI: self["keyGreen"].show()
28407:    if self.VVez0o and self.VVScQz: self["keyYellow"].show()
28408:    if self.VVMayE and self.VV4QTJ: self["keyBlue"].show()
28409:   FFZ0AC(self["myTitle"], color)
28410:   FFZ0AC(self["myBar"]  , color)
28411:   if self.VVlJfJ:
28412:    self.VVlJfJ(self)
28413:  def VVK7k6(self, ndx):
28414:   w = self.VV3cHe[ndx]
28415:   return VVBvqf > 1 or (w > self.VVrDCa or w == self.VVw0f2 or w == self.VVdOlT) and ndx != self.VVo5oS
28416:  def VV8scN(self, ndx):
28417:   w = self.VV3cHe[ndx]
28418:   return VVBvqf > 1 or (w > self.VVrDCa or w == self.VVdOlT) and ndx != self.VVo5oS
28419:  def VVhSHf(self, ndx):
28420:   w = self.VV3cHe[ndx]
28421:   return VVBvqf > 1 or (w > self.VVrDCa or w == self.VVWFVJ) and ndx != self.VVo5oS and ndx not in self.VVb5gJ.keys()
28422:  def VV0d86(self):
28423:   item = self["myTable"].getCurrent()
28424:   if item:
28425:    colList = []
28426:    txt = ""
28427:    tot = 0
28428:    for i in range(self.VV2BDe):
28429:     colTxt = item[i + 1][7].strip()
28430:     colList.append(colTxt)
28431:     if self.VVK7k6(i):
28432:      tot += 1
28433:      if self.header : name = self.header[i].strip()
28434:      else   : name = "Column-%d" % (i + 1)
28435:      txt += "%s\t: %s\n" % (name, colTxt)
28436:    if tot == 1:
28437:     txt = colList[0]
28438:    rowNum = "Row Number\t: %d of %d" % (item[0] + 1, len(self["myTable"].list))
28439:    return rowNum, txt, colList
28440:   else:
28441:    return None
28442:  def VV1hTi(self):
28443:   if self.VVXWPu:
28444:    self.VVW3QY()
28445:   else:
28446:    if self.VVu8qI : self.VVu8qI(self)
28447:    else     : self.close(None)
28448:  def cancel(self):
28449:   self.close(None)
28450:  def VVpVUj(self):
28451:   return self["myTitle"].getText().strip()
28452:  def VVeVZB(self):
28453:   return self.header
28454:  def VV0ZtI(self, title):
28455:   self.Title = title
28456:   self["myTitle"].setText("  " + title.strip() + "  ")
28457:  def VVO1tN(self, txt):
28458:   self["myBar"].setText("  %s  " % txt)
28459:  def VVVBcI(self, title, color=None):
28460:   self["myBar"].setText("  " + title.strip() + "  ")
28461:   if color:
28462:    FFGUI5(self["myBar"], color)
28463:  def VVoNlW(self, txt):
28464:   FF28n1(self, txt)
28465:  def VV6fGE(self, txt, Time=1000):
28466:   FF28n1(self, txt, Time)
28467:  def VVH7zy(self): self["keyRed"].show()
28468:  def VVeezy(self): self["keyRed"].hide()
28469:  def VVsd6P(self): self["keyGreen"].show()
28470:  def VVucBj(self): self["keyGreen"].hide()
28471:  def VVbpCf(self): self["keyBlue"].show()
28472:  def VVuDSc(self): self["keyBlue"].hide()
28473:  def VVQ7id(self): self["keyYellow"].show()
28474:  def VVAHUl(self): self["keyYellow"].hide()
28475:  def VVOOzr(self): return self["keyGreen"].visible
28476:  def VVrmMb(self):
28477:   FF28n1(self)
28478:  def VVIOX6(self, fnc, callFnc=True):
28479:   self["myTable"].onSelectionChanged.append(fnc)
28480:   if callFnc:
28481:    fnc()
28482:  def VVbyOe(self):
28483:   return len(self["myTable"].list)
28484:  def VVGTqU(self):
28485:   return self["myTable"].l.getCurrentSelectionIndex()
28486:  def VVn1uo(self):
28487:   return len(self["myTable"].list)
28488:  def VViNen(self):
28489:   return self.VVXWPu
28490:  def VVc5NH(self):
28491:   return self.VVEHSR
28492:  def VVL66W(self):
28493:   self.VV8lnC(True)
28494:  def VVW3QY(self):
28495:   self.VV3Ezh()
28496:   self.VV8lnC(False)
28497:  def VV5Kmd(self):
28498:   curRow = self["myTable"].l.getCurrentSelectionIndex()
28499:   self["myTable"].moveToIndex(curRow + 1)
28500:  def VVcAYi(self, colNum):
28501:   if colNum < self.VV2BDe:
28502:    if self.header : subj = self.header[colNum]
28503:    else   : subj = ""
28504:    lst = set()
28505:    for item in self["myTable"].list:
28506:     lst.add(item[colNum + 1][7])
28507:    return subj, str(len(lst))
28508:   else:
28509:    return "", ""
28510:  def VVlPyS(self):
28511:   txt  = "Total Rows\t: %d\n\n" % self.VVbyOe()
28512:   txt += FFGEAF("Total Unique Items", VVz22H)
28513:   for i in range(self.VV2BDe):
28514:    if self.VVK7k6(i):
28515:     name, tot = self.VVcAYi(i)
28516:     txt +=  "%s\t: %s\n" % (name, tot)
28517:   FF4lCP(self, txt)
28518:  def VVeE40(self, colNum, isStrip=True):
28519:   item = self["myTable"].getCurrent()
28520:   if item : return item[colNum + 1][7].strip() if isStrip else item[colNum + 1][7]
28521:   else : return None
28522:  def VV5crm(self):
28523:   return self.VVMADj(self["myTable"].l.getCurrentSelectionIndex())
28524:  def VVMADj(self, rowNdx):
28525:   colList = []
28526:   item = self["myTable"].list[rowNdx]
28527:   if item:
28528:    for i in range(1, self.VV2BDe + 1):
28529:     colList.append(item[i][7].strip())
28530:   return colList
28531:  def VVMqQ9(self, newList, newTitle="", VV5YRVMsg=True, VVDpzd=None, isSort=True):
28532:   fnc = BF(self.VVov9N, newList, newTitle, VV5YRVMsg, VVDpzd, isSort)
28533:   if VV5YRVMsg : FFimQ3(self, fnc, title="Refreshing ...")
28534:   else   : fnc()
28535:  def VVov9N(self, newList, newTitle, VV5YRVMsg, VVDpzd, isSort):
28536:   try: fake = self.VVHPI7
28537:   except: return
28538:   if newTitle:
28539:    self.VV0ZtI(newTitle)
28540:   if newList:
28541:    self.VVGape = newList
28542:    if VVDpzd:
28543:     self.VVDpzd = ("", VVDpzd, [])
28544:    isNum = False
28545:    if self.VVHPI7 and self.VViZ3s == 0:
28546:     isNum = True
28547:    else:
28548:     for cols in self.VVGape:
28549:      if not FFajKn(cols[self.VViZ3s]): break
28550:     else:
28551:      isNum = True
28552:    if isSort:
28553:     patt = r"^\s*
28554:     if isNum: self.VVGape.sort(key=lambda x: int(x[self.VViZ3s][12:])  if iMatch(patt, x[0]) else int(x[self.VViZ3s]) , reverse=self.VV5638)
28555:     else : self.VVGape.sort(key=lambda x: x[self.VViZ3s][12:].lower() if iMatch(patt, x[0]) else x[self.VViZ3s].lower() , reverse=self.VV5638)
28556:    self.VVfmej(showProgBar=False, fromRefresh=True)
28557:   else:
28558:    FFdw58(self, "Cannot refresh list", title=self.Title)
28559:    self.cancel()
28560:  def VV1MqZ(self, row, moveCurs=True):
28561:   row = self["myTable"].list.append(self.VVPuKm(self.VVn1uo(), row, self.VVEGV6, self.VVemyB, self.VVoRat, self.VVJKqd, None))
28562:   self["myTable"].l.setList(self["myTable"].list)
28563:   if moveCurs: self.VVMjPT()
28564:  def VVtM2v(self):
28565:   self["myTable"].list.pop(self.VVGTqU())
28566:   if len(self["myTable"].list) > 0: self["myTable"].l.setList(self["myTable"].list)
28567:   else       : self.close()
28568:  def VViSLW(self, data):
28569:   ndx = self.VVGTqU()
28570:   newRow = self.VVPuKm(ndx, data, self.VVEGV6, self.VVemyB, self.VVoRat, self.VVJKqd, None)
28571:   if newRow:
28572:    self["myTable"].list[ndx] = newRow
28573:    self.VVKFLG()
28574:    return True
28575:   else:
28576:    return False
28577:  def VVFKAn(self, tDict):
28578:   ndx = self.VVGTqU()
28579:   for colNum, val in tDict.items():
28580:    txt = str(val)
28581:    if not self.VViWgK and self.VVLIqP[ndx] & LEFT:
28582:     txt = " %s " % txt.strip()
28583:    col = list(self["myTable"].list[ndx][colNum + 1])
28584:    col[7] = txt
28585:    self["myTable"].list[ndx][colNum + 1] = tuple(col)
28586:   self.VVKFLG()
28587:  def VVEOou(self, ndx, data):
28588:   if ndx >=0 and ndx < len(self["myTable"].list):
28589:    newRow = self.VVPuKm(ndx, data, self.VVEGV6, self.VVemyB, self.VVoRat, self.VVJKqd, None)
28590:    if newRow:
28591:     self["myTable"].list[ndx] = newRow
28592:     self.VVKFLG()
28593:  def VVmMYI(self, rowNdx, colNDx, part, val):
28594:   row = self["myTable"].list[rowNdx]
28595:   col = list(row[colNDx + 1])
28596:   if col[0] == eListboxPythonMultiContent.TYPE_TEXT:
28597:    if col[part] != val:
28598:     col[part] = val
28599:     row[colNDx + 1] = tuple(col)
28600:     self["myTable"].list[rowNdx] = row
28601:     self.VVKFLG()
28602:  def VVKFLG(self):
28603:   self["myTable"].l.invalidate()
28604:  def VV8IgX(self, colNum=0):
28605:   for ndx, item in enumerate(self["myTable"].list):
28606:    lst = list(self["myTable"].list[ndx][colNum + 1])
28607:    lst[7] = str(ndx + 1)
28608:    self["myTable"].list[ndx][colNum + 1] = tuple(lst)
28609:   self["myTable"].l.setList(self["myTable"].list)
28610:  def VVn5CC(self, colNum, textToFind, VVwb7n=False):
28611:   for i in range(len(self["myTable"].list)):
28612:    item = self["myTable"].list[i][colNum + 1][7].strip()
28613:    if textToFind in item:
28614:     self["myTable"].moveToIndex(i)
28615:     break
28616:   else:
28617:    if VVwb7n:
28618:     FF28n1(self, "Not found", 1000)
28619:  def VVPkdw(self, colDict, VVwb7n=False):
28620:   for i in range(len(self["myTable"].list)):
28621:    for colNum, txt in colDict.items():
28622:     if not txt == self["myTable"].list[i][colNum + 1][7].strip():
28623:      break
28624:    else:
28625:     self["myTable"].moveToIndex(i)
28626:     return
28627:   if VVwb7n:
28628:    FF28n1(self, "Not found", 1000)
28629:   return False
28630:  def VVrc5p(self, colNum):
28631:   tList = []
28632:   for i in range(len(self["myTable"].list)):
28633:    item = self["myTable"].list[i][colNum + 1][7].strip()
28634:    tList.append(item)
28635:   return tList
28636:  def VVSkYx(self, colNum):
28637:   for i in range(len(self["myTable"].list)):
28638:    if not FFajKn(self["myTable"].list[i][colNum + 1][7].strip()):
28639:     return False
28640:   return True
28641:  def VVf3uT(self, colNum, isStrip=True):
28642:   tList = []
28643:   for ndx, row in enumerate(self["myTable"].list):
28644:    if row[1][10] == self.VVH8fj:
28645:     item = self["myTable"].list[ndx][colNum + 1][7]
28646:     if isStrip: item = item.strip()
28647:     tList.append(item)
28648:   return tList
28649:  def VV6LTe(self):
28650:   if self.VVEHSR:
28651:    for ndx, row in enumerate(self["myTable"].list):
28652:     if row[1][10] == self.VVH8fj:
28653:      return ndx
28654:   return -1
28655:  def VVbF9W(self):
28656:   tList = []
28657:   for ndx, row in enumerate(self["myTable"].list):
28658:    if row[1][10] == self.VVH8fj:
28659:     item = self["myTable"].list[ndx]
28660:     colList = []
28661:     for i in range(1, self.VV2BDe + 1):
28662:      colList.append(item[i][7].strip())
28663:     tList.append(colList)
28664:   return tList
28665:  def VVvlf4(self, ndx):
28666:   row = self["myTable"].list[ndx]
28667:   if row[1][10] == self.VVH8fj : return True
28668:   else        : return False
28669:  def VVrrm9(self):
28670:   for ndx, row in enumerate(self["myTable"].list):
28671:    item = self["myTable"].list[ndx]
28672:    colList = []
28673:    for i in range(1, self.VV2BDe + 1):
28674:     colTxt = item[i][7].strip()
28675:     colList.append(colTxt)
28676:    yield colList
28677:  def VV4lOw(self):
28678:   if self.VVdHJK:
28679:    self.VV0sfZ(self.VVdHJK)
28680:    return
28681:   if not self["keyMenu"].getVisible() or self.VVKDPJ:
28682:    return
28683:   txt  = self.VVSLOq.getValue()
28684:   curRow = self.VVGTqU()
28685:   totRows = len(self["myTable"].list)
28686:   itemOf = lambda cond, p1, p2: (p1, p2) if cond else (p1, )
28687:   VV3wat1, VV0mqE = CCoErY.VVHRan(self, False, False)
28688:   VV3wat = []
28689:   VV3wat.append(itemOf(txt and curRow < totRows - 1 , "Find Next\t\t>"     , "findNext"  ))
28690:   VV3wat.append(itemOf(txt and curRow > 0   , "Find Previous\t\t<"    , "findPrev"  ))
28691:   VV3wat.append(("Find ...\t\t%s" % (FFjt5L(txt, VVGCYL) if txt else ""), "findNew"   ))
28692:   VV3wat.append(itemOf(bool(VV3wat1)    , "Find (from Filter) ..."   , "filter"   ))
28693:   if self.header:
28694:    VV3wat.append(VVAL3j)
28695:    VV3wat.append(("Table Statistcis"            , "tableStat"  ))
28696:   VV3wat.append(VVAL3j)
28697:   VV3wat.append((FFjt5L("Export Table to .html"     , VVz22H) , "VVIOR0" ))
28698:   VV3wat.append((FFjt5L("Export Table to .csv"     , VVz22H) , "VV4tSX" ))
28699:   VV3wat.append((FFjt5L("Export Table to .txt (Tab Separated)", VVz22H) , "VVIDeL" ))
28700:   if self.VVp4wm:
28701:    sList = []
28702:    tot  = 0
28703:    for i in range(self.VV2BDe):
28704:     if self.VVhSHf(i):
28705:      tot += 1
28706:      if self.header : name = self.header[i]
28707:      else   : name = "Column-%d" % (i + 1)
28708:      sList.append(("Sort by : %s" % name, i))
28709:    if tot:
28710:     VV3wat.append(VVAL3j)
28711:     if tot == 1 : VV3wat.append(("Sort", sList[0][1]))
28712:     else  : VV3wat += sList
28713:   VVaTeF = ("Keys Help", self.VV1eoq)
28714:   FFLFTC(self, self.VV0nVg, VV3wat=VV3wat, VVwdmN=28,title=self.VVpVUj(), VVaTeF=VVaTeF)
28715:  def VV0nVg(self, item=None):
28716:   if item is not None:
28717:    if   item == "findNext"  : self.VV5pGB()
28718:    elif item == "findPrev"  : self.VV5pGB(isPrev=True)
28719:    elif item == "findNew"  : self.VVrkXJ()
28720:    elif item == "filter"  : self.VVmqJH()
28721:    elif item == "tableStat" : self.VVlPyS()
28722:    elif item == "VVIOR0": self.VVIOR0()
28723:    elif item == "VV4tSX" : self.VV4tSX()
28724:    elif item == "VVIDeL" : self.VVIDeL()
28725:    else:
28726:     if self.VViZ3s == item: self.VV5638 = not self.VV5638
28727:     else      : self.VViZ3s, self.VV5638 = item, False
28728:     if self.VVHPI7 and self.VViZ3s == 0 or self.VVSkYx(item):
28729:      self["myTable"].list.sort(key=lambda x: int(x[item + 1][7]), reverse=self.VV5638)
28730:     else:
28731:      self["myTable"].list.sort(key=lambda x: x[item + 1][7].lower(), reverse=self.VV5638)
28732:     self["myTable"].l.setList(self["myTable"].list)
28733:     self.VVfmej(onlyHeader=True)
28734:  def VV1eoq(self, VV7tND, path):
28735:   FFw2rR(self, "_help_table", "Table (Keys Help)")
28736:  def VVgexy(self) : self["myTable"].up()
28737:  def VVIRjv(self): self["myTable"].down()
28738:  def VVLlE3(self) : self["myTable"].pageUp()
28739:  def VVSYHQ(self): self["myTable"].pageDown()
28740:  def VVE9rg(self)  : self["myTable"].moveToIndex(0)
28741:  def VVMjPT(self)  : self["myTable"].moveToIndex(len(self["myTable"].list) - 1)
28742:  def VVrqBw(self, rowNdx): self["myTable"].moveToIndex(rowNdx)
28743:  def VVFkgI(self):
28744:   if self.VVSLOq.getValue():
28745:    if self.VVGTqU() == len(self["myTable"].list) - 1 : FF28n1(self, "End reached", 1000)
28746:    else              : self.VV5pGB()
28747:   else:
28748:    FF28n1(self, 'Set "Find" in Menu', 1500)
28749:  def VVtvpP(self):
28750:   if self.VVSLOq.getValue():
28751:    if self.VVGTqU() == 0 : FF28n1(self, "Top reached", 1000)
28752:    else       : self.VV5pGB(isPrev=True)
28753:   else:
28754:    FF28n1(self, 'Set "Find" in Menu', 1500)
28755:  def VVuKIQ(self, txt):
28756:   FFjt1c(self.VVSLOq, txt)
28757:  def VVrkXJ(self):
28758:   FF4z45(self, self.VV2Zcr, title="Find in Table", defaultText=self.VVSLOq.getValue(), message="Enter Text:")
28759:  def VV2Zcr(self, VVRD20):
28760:   if not VVRD20 is None:
28761:    txt = VVRD20.strip()
28762:    self.VVuKIQ(txt)
28763:    if VVRD20: self.VV5pGB(reset=True)
28764:    else  : FF28n1(self, "Nothing to find !", 1500)
28765:  def VVmqJH(self):
28766:   VV3wat, VV0mqE = CCoErY.VVHRan(self, False, False)
28767:   VVB4pu = ("Edit Filter", BF(self.VVpfQ8, VV0mqE))
28768:   if VV3wat : FFLFTC(self, self.VVeuZu, VV3wat=VV3wat, VVB4pu=VVB4pu, title="Find from Filter")
28769:   else  : FF28n1(self, "Filter Error !", 1500)
28770:  def VVeuZu(self, item=None):
28771:   if item is not None:
28772:    txt = item.strip()
28773:    if txt:
28774:     self.VVuKIQ(txt)
28775:     self.VV5pGB(reset=True)
28776:    else:
28777:     FF28n1(self, "No entry !", 1500)
28778:  def VVpfQ8(self, VV0mqE, selectionObj, sel):
28779:   if FFCyVu(VV0mqE) : CCyMCP(self, VV0mqE, VVbYwR=None)
28780:   else       : FF8Wsn(self, VV0mqE)
28781:   selectionObj.cancel()
28782:  def VV5pGB(self, reset=False, isPrev=False):
28783:   curRow = self.VVGTqU()
28784:   totRows = len(self["myTable"].list)
28785:   if   reset : row1, row2, steps = 0, totRows, 1
28786:   elif isPrev : row1, row2, steps = curRow - 1, -1, -1
28787:   else  : row1, row2, steps = curRow + 1, totRows, 1
28788:   tupl, asPrefix = CCoErY.VVPBNm(self.VVSLOq.getValue())
28789:   if tupl:
28790:    for i in range(row1, row2, steps):
28791:     line = self["myTable"].list[i][self.VVMfsO + 1][7]
28792:     line = line.strip().lower()
28793:     if asPrefix:
28794:      if line.startswith(tupl):
28795:       self.VVrqBw(i)
28796:       break
28797:     elif any(x in line for x in tupl):
28798:      self.VVrqBw(i)
28799:      break
28800:    else:
28801:     FF28n1(self, "Not found", 1000)
28802:   else:
28803:    FF28n1(self, "Check your query", 1500)
28804:  @FFOAKH()
28805:  def VVIDeL(self):
28806:   expFile = self.VVjFfb() + ".txt"
28807:   with open(expFile, "w") as f:
28808:    filteredHeader = self.VVQID2()
28809:    if filteredHeader:
28810:     f.write("\t".join(filteredHeader) + "\n")
28811:    for i in range(len(self["myTable"].list)):
28812:     row = self.VVMADj(i)
28813:     newRow = []
28814:     for ndx, col in enumerate(row):
28815:      if self.VV8scN(ndx):
28816:       col = self.VVfO2i(col)
28817:       col = col.replace("\n", " _ ")
28818:       newRow.append(col)
28819:     f.write("\t".join(newRow) + "\n")
28820:   self.VVcBrS(expFile)
28821:  @FFOAKH()
28822:  def VV4tSX(self):
28823:   expFile = self.VVjFfb() + ".csv"
28824:   with open(expFile, "w") as f:
28825:    filteredHeader = self.VVQID2()
28826:    if filteredHeader:
28827:     f.write(",".join(filteredHeader) + "\n")
28828:    pattern = "^[0-9a-fA-F]*$"
28829:    for i in range(len(self["myTable"].list)):
28830:     row = self.VVMADj(i)
28831:     newRow = []
28832:     for ndx, col in enumerate(row):
28833:      if self.VV8scN(ndx):
28834:       if iMatch(pattern, col) : prefix = "'"
28835:       else     : prefix = ""
28836:       col = self.VVfO2i(col)
28837:       col = col.replace(",", ";").replace("\n", " _ ")
28838:       newRow.append(prefix + col)
28839:     f.write(",".join(newRow) + "\n")
28840:   self.VVcBrS(expFile)
28841:  @FFOAKH()
28842:  def VVIOR0(self):
28843:   title = FFzBfi(self.VVpVUj()).replace("\t", "&nbsp;" * 4)
28844:   txt   = '<!DOCTYPE html>\n'
28845:   txt  += '<html>\n'
28846:   txt  += ' <head>\n'
28847:   txt  += ' <meta charset="utf-8">\n'
28848:   txt  += ' <meta name="viewport" content="width=device-width, initial-scale=1.0">\n'
28849:   txt  += ' <TITLE>%s - %s (%s)</TITLE>\n' % (title, VVh9hj, VVJ6zn)
28850:   txt  += ' <style>\n'
28851:   txt  += '  table { font-family: arial, sans-serif; border-collapse: collapse; width: 100%; }\n'
28852:   txt  += '  td,th { border: 1px solid #dddddd; text-align: left; padding: 5px; }\n'
28853:   txt  += '  td { font-size: 0.8em; }\n'
28854:   txt  += '  th { color:#006000; background-color:#FFFFaa; font-size: 1.2em; }\n'
28855:   txt  += '  tr:nth-child(even) { background-color: #f8f8f8; }\n'
28856:   txt  += ' </style>\n'
28857:   txt  += ' </head>\n'
28858:   txt  += ' <body>\n'
28859:   txt  += '  <h2 style="color:#006000;">%s</h2>\n' % title
28860:   txt  += '  <table>\n'
28861:   txt  +=     '#colgroup#'
28862:   txt  += '   <tr>#tableHead#</tr>\n'
28863:   txt2  = '  <table>\n'
28864:   txt2 += ' </body>\n'
28865:   txt2 += '</html>\n'
28866:   tableHead  = ""
28867:   filteredHeader = self.VVQID2()
28868:   if filteredHeader:
28869:    for col in filteredHeader:
28870:     tableHead += '<th>%s</th>' % col
28871:   txt = txt.replace("
28872:   colgroup = ""
28873:   if self.VV3cHe:
28874:    colgroup += '   <colgroup>'
28875:    for ndx, w in enumerate(self.VV3cHe):
28876:     if self.VV8scN(ndx):
28877:      colgroup += '<col style="width: %d%s;" />' % (w, "%")
28878:    colgroup += "</colgroup>\n"
28879:   txt = txt.replace("#colgroup#", colgroup)
28880:   expFile = self.VVjFfb() + ".html"
28881:   with open(expFile, "w") as f:
28882:    f.write(txt)
28883:    for i in range(len(self["myTable"].list)):
28884:     row = self.VVMADj(i)
28885:     newRow = "   <tr>"
28886:     for ndx, col in enumerate(row):
28887:      if self.VV8scN(ndx):
28888:       col = self.VVfO2i(col)
28889:       newRow += '<td>%s</td>' % col
28890:     newRow += "</tr>\n"
28891:     f.write(newRow)
28892:    f.write(txt2)
28893:   self.VVcBrS(expFile)
28894:  def VVQID2(self):
28895:   newRow = []
28896:   if self.header:
28897:    for ndx, col in enumerate(self.header):
28898:     if self.VV8scN(ndx):
28899:      newRow.append(col.strip())
28900:   return newRow
28901:  def VVfO2i(self, col):
28902:   if col.count(":") > 8:
28903:    col = col.replace(":", "_")
28904:    col = col.rstrip("_")
28905:   col = iSub(r"(
28906:   return FFzBfi(col)
28907:  def VVjFfb(self):
28908:   fileName = iSub(r"[^0-9a-zA-Z]+", "_", FFzBfi(self.VVpVUj()))
28909:   fileName = fileName.replace("__", "_")
28910:   expFile  = FFeAlZ() + fileName + "_" + FFjTQe()
28911:   return expFile
28912:  def VVcBrS(self, expFile):
28913:   if self.VVGuQE and FFCyVu(expFile):
28914:    self.VVGuQE(self, expFile)
28915:   FFipXT(self, "File exported to:\n\n%s" % expFile, title=self.VVpVUj())
28916:  @staticmethod
28917:  def VVNynG(x, y, w, h, fnt, flg, txt, fg, bg, sFg, sBg, bW, bC):
28918:   return (eListboxPythonMultiContent.TYPE_TEXT, x, y, w, h, fnt, flg, txt, fg, sFg, bg, sBg, bW, bC)
28919:  @staticmethod
28920:  def VVmxDV(x, y, w, h, png, bg=None, bgSel=None):
28921:   typ = eListboxPythonMultiContent.TYPE_PIXMAP_ALPHATEST
28922:   if VVGpHg: return (typ, x, y, w, h, png, bg, bgSel, VVGpHg | CENTER)
28923:   else   : return (typ, x, y, w, h, png, bg, bgSel)
28924:  @staticmethod
28925:  def VV86Ng(x, y, w, h, percent, bW, fg):
28926:   return (eListboxPythonMultiContent.TYPE_PROGRESS, x, y, w, h, int(percent), bW, fg)
28927: class CCWhOL():
28928:  def __init__(self, pixmap, VVAfO9, VVemyB, fncCb_ok, fncCb_fail):
28929:   self.pixmap   = pixmap
28930:   self.picInst  = pixmap.instance
28931:   self.VVAfO9  = VVAfO9
28932:   self.VVemyB  = VVemyB or "#2200002a"
28933:   self.fncCb_ok  = fncCb_ok
28934:   self.fncCb_fail  = fncCb_fail
28935:   self.FFgrjX  = FFgrjX()
28936:   global VV8oe7
28937:   VV8oe7 = True
28938:   self.picInst.setPixmap(None)
28939:  def VVcRk2(self):
28940:   from enigma import ePicLoad
28941:   self.picLoad  = ePicLoad()
28942:   self.picload_conn = None
28943:   if not all((self.pixmap, self.VVAfO9, FFCyVu(self.VVAfO9))):
28944:    return False
28945:   sz = self.picInst.size()
28946:   self.picLoad.setPara((sz.width(), sz.height(), 1, 1, False, 1, self.VVemyB))
28947:   try:
28948:    if self.FFgrjX:
28949:     res = self.picLoad.startDecode(self.VVAfO9, False)
28950:     if res == 0:
28951:      return self.VVnX2S()
28952:     else:
28953:      del self.picLoad
28954:      return False
28955:    else:
28956:     try:
28957:      self.picload_conn = self.picLoad.PictureData.connect(self.VVIvYQ)
28958:     except:
28959:      self.picLoad.PictureData.get().append(self.VVIvYQ)
28960:     res = self.picLoad.startDecode(self.VVAfO9)
28961:     return True if res == 0 else False
28962:   except:
28963:    return False
28964:  def VVIvYQ(self, pInfo=""):
28965:   ok = self.VVnX2S()
28966:  def VVnX2S(self):
28967:   ok = False
28968:   ptr = self.picLoad.getData()
28969:   if ptr is not None:
28970:    try:
28971:     self.picInst.setPixmap(ptr)
28972:     ok = True
28973:    except:
28974:     pass
28975:   del self.picLoad
28976:   self.picload_conn = None
28977:   if ok and self.fncCb_ok   : self.fncCb_ok()
28978:   if not ok and self.fncCb_fail: self.fncCb_fail()
28979:   global VV8oe7
28980:   VV8oe7 = False
28981:   return ok
28982: class CCf8zb(Screen):
28983:  def __init__(self, session, VVPq2Z, title="", showGrnMsg="", fileList=None, VVBGsZ=0, fakePath=None, cbFnc=None, menuFnc=None):
28984:   scrW, scrH = FFrPd1()
28985:   w = 1700
28986:   h = int(min(w * scrH / scrW + 51, 1040))
28987:   self.skin, self.VVfOli = FFiNEe(VVsVfC, w, h, 30, 0, 0, "
28988:   self.session  = session
28989:   self.Title   = title
28990:   self["myPic"]  = Pixmap()
28991:   self.VVPq2Z = VVPq2Z
28992:   self.showGrnMsg  = showGrnMsg
28993:   self.fileList  = fileList
28994:   self.VVBGsZ  = VVBGsZ
28995:   self.fakePath  = fakePath
28996:   self.cbFnc   = cbFnc
28997:   self.menuFnc  = menuFnc
28998:   FFZMxC(self)
28999:   FFHlAU(self,
29000:   {
29001:    "ok" : self.VVfXzC    ,
29002:    "red" : self.VVfXzC    ,
29003:    "cancel": self.VVfXzC    ,
29004:    "info" : self.VVWbNl  ,
29005:    "menu" : self.VV7mRc  ,
29006:    "up" : BF(self.VVBvTF, -1),
29007:    "down" : BF(self.VVBvTF,  1),
29008:    "left" : BF(self.VVBvTF, -1),
29009:    "right" : BF(self.VVBvTF,  1)
29010:   })
29011:   self.onShown.append(self.VV7OzD)
29012:   self.onClose.append(self.onExit)
29013:  def VV7OzD(self):
29014:   self.onShown.remove(self.VV7OzD)
29015:   FF6W0I(self)
29016:   self.VVBB5b()
29017:  def VVfXzC(self):
29018:   if VV8oe7:
29019:    FFDuEn(self)
29020:    FFjADj(self, "Closing ...")
29021:    FFOKt0(self, 1000, self.close)
29022:   else:
29023:    self.close("")
29024:  def VVBB5b(self):
29025:   self.VVkvel()
29026:   if os.path.isfile(self.VVPq2Z) and CCHmnm.VVMyky(self.VVPq2Z) == "pic" and FFXhoc(self.VVPq2Z) > 0:
29027:    if not FF0TBx(self["myPic"], self.VVPq2Z, fncCb_ok=self.VVa9hZ, fncCb_fail=self.VVGGrW):
29028:     self.VVGGrW()
29029:   else:
29030:    self.VVGGrW()
29031:  def VVa9hZ(self):
29032:   if self.showGrnMsg:
29033:    FF1mVE(self, self.showGrnMsg, 1500)
29034:  def VVGGrW(self):
29035:   if not FFkDgm(self["myPic"], "noPic"):
29036:    FFdw58(self, "Cannot view picture file:\n\n%s" % self.VVPq2Z)
29037:    self.close()
29038:  def VVBvTF(self, direc):
29039:   if self.fileList:
29040:    oldNdx = self.VVBGsZ
29041:    self.VVBGsZ += direc
29042:    if direc == -1 and self.VVBGsZ < 0      : self.VVBGsZ = len(self.fileList) - 1
29043:    if direc ==  1 and self.VVBGsZ > len(self.fileList) - 1 : self.VVBGsZ = 0
29044:    if not oldNdx == self.VVBGsZ:
29045:     fName = self.fileList[self.VVBGsZ][1]
29046:     self.VVPq2Z = FFoWxR(os.path.dirname(self.VVPq2Z)) + fName
29047:     self.VVBB5b()
29048:  def onExit(self):
29049:   if self.cbFnc:
29050:    if self.fileList: self.cbFnc(self.VVPq2Z, self.fileList[self.VVBGsZ][0])
29051:    else   : self.cbFnc(self.VVPq2Z)
29052:  def VVWbNl(self):
29053:   txt = "%s:\n  %s" % (FFjt5L("Path", VVFuwR), self.fakePath or self.VVPq2Z)
29054:   size, sizeTxt, resTxt, form, mode = CC6u6z.VV5h28(self.VVPq2Z)
29055:   if any((size, sizeTxt, resTxt, form, mode)):
29056:    txt += "\n\n%s:\n" % FFjt5L("Properties", VVFuwR)
29057:    if sizeTxt: txt += "  File Size\t: %s\n" % sizeTxt
29058:    if resTxt : txt += "  Dimensions\t: %s\n" % resTxt
29059:    if form   : txt += "  Format\t: %s\n"  % form
29060:    if mode   : txt += "  Mode\t: %s\n"   % mode
29061:   FF4lCP(self, txt, title="File Information")
29062:  def VV7mRc(self):
29063:   if self.menuFnc:
29064:    self.menuFnc(self)
29065:  def VVkvel(self):
29066:   if self.fileList: title = "%d/%d : %s" % (self.VVBGsZ + 1, len(self.fileList), self.fileList[self.VVBGsZ][1])
29067:   elif self.Title : title = self.Title
29068:   else   : title = os.path.basename(self.VVPq2Z)
29069:   self["myTitle"].setText("  %s  " % title)
29070:  @staticmethod
29071:  def VVjnMn(SELF, VVPq2Z, **kwargs):
29072:   SELF.session.open(CCf8zb, VVPq2Z, **kwargs)
29073: class CCcV1i(Screen):
29074:  def __init__(self, session, mviFile=None):
29075:   self.skin, self.VVfOli = FFiNEe(VVlrZA, 400, 55, 30, 0, 0, "#22004455", "#00ff0000", 30)
29076:   self.session  = session
29077:   self.mviFile  = mviFile
29078:   FFZMxC(self, "Click Cancel to exit", addCloser=True)
29079:   self.onShown.append(self.VV7OzD)
29080:   self.onClose.append(self.onExit)
29081:  def VV7OzD(self):
29082:   self.onShown.remove(self.VV7OzD)
29083:   self.curServ = CC3rDi(self.session).servRef
29084:   self.session.nav.stopService()
29085:   if FFpwZS("showiframe %s" % self.mviFile):
29086:    self.instance.move(ePoint(20, 20))
29087:   else:
29088:    self.close(-1)
29089:  def onExit(self):
29090:   if self.curServ:
29091:    self.session.nav.playService(self.curServ, checkParentalControl=False, forceRestart=False)
29092:  @staticmethod
29093:  def VVKb3z(SELF, mviFile):
29094:   SELF.session.openWithCallback(BF(CCcV1i.VVDWvz, SELF), CCcV1i, mviFile)
29095:  @staticmethod
29096:  def VVDWvz(SELF, reason=None):
29097:   if reason == -1: FFdw58(SELF, "Error while viewing mvi file.", title="MVI Viewer")
29098: class CCJaSw(Screen, ConfigListScreen):
29099:  def __init__(self, session):
29100:   self.skin, self.VVfOli = FFiNEe(VVibAL, 1400, 1075, 50, 15, 15, "#11201010", "#11101010", 28, VVeFSs=40, VV0Ay7=1, VVptue=0.1)
29101:   self.session  = session
29102:   self.Title   = "%s Settings" % VVh9hj
29103:   FFZMxC(self, title=self.Title)
29104:   FFRLNq(self["keyGreen"], "Save")
29105:   sep = SEP * 3
29106:   lst = []
29107:   lst.append(getConfigListEntry("Show in Main Menu"         , CFG.showInMainMenu   ))
29108:   lst.append(getConfigListEntry("Show in Extensions Menu"        , CFG.showInExtensionMenu  ))
29109:   lst.append(getConfigListEntry("Show in Channel List Context Menu"     , CFG.showInChannelListMenu  ))
29110:   lst.append(getConfigListEntry("Show in Events Info Menu"       , CFG.EventsInfoMenu   ))
29111:   lst.append(getConfigListEntry("Input Type"           , CFG.keyboard     ))
29112:   lst.append(getConfigListEntry("Exit-Button Action (in File Manager and FTP)"  , CFG.FileManagerExit   ))
29113:   lst.append(getConfigListEntry("Player Bar Hotkey"         , CFG.hotkey_signal    ))
29114:   lst.append(getConfigListEntry("Screenshot"           , CFG.screenshotFType   ))
29115:   lst.append(getConfigListEntry("Subtitle Files Encoding Priority"     , CFG.subtDefaultEnc   ))
29116:   lst.append(getConfigListEntry(sep             ,         ))
29117:   lst.append(getConfigListEntry("Default IPTV Reference Type (defines the player)" , CFG.iptvAddToBouquetRefType ))
29118:   lst.append(getConfigListEntry("Auto Reset Frozen IPTV Channels"      , CFG.autoResetFrozenIptvChan ))
29119:   lst.append(getConfigListEntry("Skip Adults Channels (from IPTV Server)"    , CFG.hideIptvServerAdultWords ))
29120:   lst.append(getConfigListEntry("Remove IPTV Channel Name Prefix (|EN| , |AR|Drama|)" , CFG.hideIptvServerChannPrefix ))
29121:   lst.append(getConfigListEntry("Portal Servers Connection Timeout (seconds)"   , CFG.portalConnTimeout   ))
29122:   lst.append(getConfigListEntry("IPTV Hosts Files Path (Playlist, Portal, M3U)"  , CFG.iptvHostsMode    ))
29123:   lst.append(getConfigListEntry(sep             ,         ))
29124:   lst.append(getConfigListEntry("Auto Resume (Movies)"        , CFG.resumeMovies    ))
29125:   lst.append(getConfigListEntry("Local Movies and IPTV Download Path"     , CFG.MovieDownloadPath   ))
29126:   lst.append(getConfigListEntry("PIcons Path"           , CFG.PIconsPath    ))
29127:   lst.append(getConfigListEntry("Custom Menu Path"         , CFG.customMenuPath   ))
29128:   lst.append(getConfigListEntry(sep             ,         ))
29129:   lst.append(getConfigListEntry("Main Working Path (Backup/Restore/Screenshot/etc.)" , CFG.backupPath    ))
29130:   ConfigListScreen.__init__(self, lst, session)
29131:   self.VVFslJ()
29132:   self.onShown.append(self.VV7OzD)
29133:  def VVFslJ(self):
29134:   kList = {
29135:     "ok" : self.VVPr1F   ,
29136:     "green" : self.VVTUim ,
29137:     "menu" : self.VVhAm1 ,
29138:     "cancel": self.VVMrMS
29139:     }
29140:   kLeft = kRight = None
29141:   try:
29142:    from Components.config import ConfigSubList, KEY_LEFT as kLeft, KEY_RIGHT as kRight
29143:   except:
29144:    try:
29145:     from Components.config import ConfigSubList, ACTIONKEY_LEFT as kLeft, ACTIONKEY_RIGHT as kRight
29146:    except:
29147:     pass
29148:   if not (kLeft == kRight == None):
29149:    kList["left"] = BF(self["config"].handleKey, kLeft)
29150:    kList["right"] = BF(self["config"].handleKey, kRight)
29151:    try:
29152:     kList["chanUp"]  = self["config"].pageUp
29153:     kList["chanDown"] = self["config"].pageDown
29154:    except:
29155:     try:
29156:      kList["chanUp"]  = BF(self["config"].VVfqOq, 0)
29157:      kList["chanDown"] = BF(self["config"].VVfqOq, len(self["config"].list) - 1)
29158:     except:
29159:      pass
29160:    FFHlAU(self, kList, name="config_actions")
29161:   else:
29162:    FFHlAU(self, kList, name="actions")
29163:  def VV7OzD(self):
29164:   self.onShown.remove(self.VV7OzD)
29165:   FF6W0I(self)
29166:   FF4IPF(self["config"])
29167:   FF2GM8(self, self["config"])
29168:   FFWgBS(self)
29169:   self["config"].onSelectionChanged.append(self.VVmlpt)
29170:   self.VVmlpt()
29171:   FFZ0AC(self["keyRed"], "#11000000")
29172:   self["keyRed"].show()
29173:  def VVmlpt(self):
29174:   cfg = self["config"].getCurrent()[1]
29175:   if isinstance(cfg, ConfigDirectory) and cfg != CFG.subtDefaultEnc: txt = "Change Path"
29176:   else                : txt = "Show Choices"
29177:   self["keyRed"].setText("OK = %s" % txt)
29178:  def VVPr1F(self):
29179:   title, item = self["config"].getCurrent()
29180:   if item:
29181:    if   item == CFG.iptvHostsMode   : self.VV2dbz()
29182:    elif item == CFG.MovieDownloadPath   : self.VVbZOL(item, self["config"].getCurrent()[0])
29183:    elif item == CFG.subtDefaultEnc   : self.VVhA1A()
29184:    elif isinstance(item, ConfigDirectory) : self.VVpWVN(item)
29185:    else         : CCJaSw.VV5YpJ(self, item, title, width=1100)
29186:  @staticmethod
29187:  def VV5YpJ(SELF, confItem, title, lst=None, cbFnc=None, isSave=False, width=800):
29188:   if not lst:
29189:    if   isinstance(confItem, ConfigYesNo)  : lst = [(True, "ON"), (False, "OFF")]
29190:    elif isinstance(confItem, ConfigSelectionNumber):
29191:     lst = confItem.choices.choices
29192:     if not isinstance(lst[0], tuple)  : lst = [(x, x) for x in lst]
29193:    elif isinstance(confItem, ConfigSelection) : lst = confItem.choices.choices
29194:    elif isinstance(confItem, ConfigInteger) : lst = [(x, str(x)) for x in range(confItem.limits[0][0], confItem.limits[0][1] + 1, 1)]
29195:    else          : return
29196:   curNdx = defNdx = -1
29197:   VV3wat = []
29198:   for ndx, item in enumerate(lst):
29199:    if len(item) == 1:
29200:     val, txt = ("dum",SEP)
29201:    else:
29202:     val, txt = item
29203:     if   val == confItem.value : curNdx, txt = ndx, VVGCYL + txt
29204:     elif val == confItem.default: defNdx, txt = ndx, VV1fx4 + txt
29205:    VV3wat.append((txt, val))
29206:   if defNdx == -1: defNdx = curNdx
29207:   VVaTeF  = ("Current", BF(CCJaSw.VVdGKX, curNdx))
29208:   VVB4pu = ("Default", BF(CCJaSw.VVdGKX, defNdx))
29209:   VV7tND = FFLFTC(SELF, BF(CCJaSw.VVgdRW, confItem, cbFnc, isSave), VV3wat=VV3wat, width=width, VVB4pu=VVB4pu, VVaTeF=VVaTeF, title=title, VVwltY="#22221111", VVkxBG="#22110011", VVoCB2="#11550000")
29210:   VV7tND.VVx2yy(curNdx)
29211:  @staticmethod
29212:  def VVgdRW(confItem, cbFnc, isSave, item=None):
29213:   if not item == None:
29214:    confItem.setValue(item)
29215:    if isSave: FFjt1c(confItem, item)
29216:    if cbFnc: cbFnc()
29217:  @staticmethod
29218:  def VVdGKX(ndx, selectionObj, item):
29219:   selectionObj.VVx2yy(ndx)
29220:  @staticmethod
29221:  def VVFUB7(confItem, lst):
29222:   for ndx, item in enumerate(lst):
29223:    if item[0] == confItem.value:
29224:     return ndx
29225:   return -1
29226:  def VVbZOL(self, item, title):
29227:   tot = CCHRcZ.VVY2Xw()
29228:   if tot : FFdw58(self, "Cannot change while downloading.", title=title)
29229:   else : self.VVpWVN(item)
29230:  def VVhA1A(self):
29231:   curEnc = CFG.subtDefaultEnc.getValue()
29232:   lst = CC7ocD.VVZyMn(self, "", curEnc)
29233:   if lst:
29234:    VVB4pu = ("Default", self.VVyHwq)
29235:    VVaTeF  = ("Current", self.VVgGob)
29236:    VV7tND = FFLFTC(self, self.VVN3C2, title="Select Priority Encoding", VV3wat=lst, width=1000, height=1000, VVaTeF=VVaTeF, VVB4pu=VVB4pu, VVwltY="#22220000", VVkxBG="#22220000", VVU8mZ=True)
29237:    VV7tND.VVVZJD(curEnc)
29238:  def VVN3C2(self, item=None):
29239:   if item:
29240:    txt, enc, ndx = item
29241:    CFG.subtDefaultEnc.setValue(enc)
29242:  def VVyHwq(self, VV7tND, item): VV7tND.VVVZJD(VV9iuh)
29243:  def VVgGob(self, VV7tND, item): VV7tND.VVVZJD(CFG.subtDefaultEnc.getValue())
29244:  def VV2dbz(self):
29245:   VV3wat = []
29246:   VV3wat.append(("Auto Find" , "auto"))
29247:   VV3wat.append(("Custom Path" , "cust"))
29248:   FFLFTC(self, self.VVFyRH, VV3wat=VV3wat, title="IPTV Hosts Files Path")
29249:  def VVFyRH(self, item=None):
29250:   if item:
29251:    if item == "auto":
29252:     CFG.iptvHostsMode.setValue(VVSBbs)
29253:    elif item == "cust":
29254:     VVAkuK = self.VVCBk1()
29255:     if VVAkuK : self.VVU2OV(VVAkuK)
29256:     else  : self.session.openWithCallback(self.VVtsPG, BF(CClYaF, mode=CClYaF.VV9N82, VV1pbK="/"))
29257:  def VVU2OV(self, VVAkuK):
29258:   VVu8qI = self.VVDwcU
29259:   VVwWmA = ("Remove"  , self.VVE7KC , [])
29260:   VVScQz = ("Add "  , self.VV2ql5, [])
29261:   header   = ("Directory" , "Remarks" )
29262:   widths   = (80   , 20  )
29263:   VVLIqP  = (LEFT   , LEFT  )
29264:   FFUQ0v(self, None, title="IPTV Hosts Search Paths", header=header, VVGape=VVAkuK, width=1200, height=700, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVu8qI=VVu8qI, VVwWmA=VVwWmA, VVScQz=VVScQz
29265:     , VVwltY="#22220000", VVkxBG="#22110000", VVemyB="#22110011", VVJKqd="#11223025", VVbcr0="#0a333333", VVX9AA="#11400040")
29266:  def VVDwcU(self, VV6A99):
29267:   if CFG.iptvHostsDirs.getValue():
29268:    CFG.iptvHostsMode.setValue(VVoeMl)
29269:   VV6A99.cancel()
29270:  def VVtsPG(self, path):
29271:   if path:
29272:    FFjt1c(CFG.iptvHostsDirs, FFoWxR(path.strip()))
29273:    VVAkuK = self.VVCBk1()
29274:    if VVAkuK : self.VVU2OV(VVAkuK)
29275:    else  : FF28n1(self, "Cannot add dir", 1500)
29276:  def VVnmPl(self):
29277:   lst = CFG.iptvHostsDirs.getValue().split(",")
29278:   lst = list(set(list(map(str.strip, lst))))
29279:   if len(lst) == 0 or len(lst[0]) == 0 or lst[0] == VVSBbs:
29280:    return []
29281:   return lst
29282:  def VVCBk1(self):
29283:   lst = self.VVnmPl()
29284:   if lst:
29285:    VVAkuK = []
29286:    for Dir in lst:
29287:     VVAkuK.append((Dir, "#f#0000ff00#Dir exists" if VVmJwX(Dir) else "#f#00ffa000#Not found"))
29288:    VVAkuK.sort(key=lambda x: x[0].lower())
29289:    return VVAkuK
29290:   else:
29291:    return []
29292:  def VV2ql5(self, VV6A99, title, txt, colList):
29293:   sDir = parent = os.path.abspath(os.path.join(colList[0], os.pardir))
29294:   self.session.openWithCallback(BF(self.VVXVbD, VV6A99)
29295:          , BF(CClYaF, mode=CClYaF.VV9N82, VV1pbK=sDir))
29296:  def VVXVbD(self, VV6A99, path):
29297:   if path:
29298:    path = FFoWxR(path.strip())
29299:    if self.VVO7zz(VV6A99, path):
29300:     FF28n1(VV6A99, "Already added", 1500)
29301:    else:
29302:     lst = self.VVnmPl()
29303:     lst.append(path)
29304:     FFjt1c(CFG.iptvHostsDirs, ",".join(lst))
29305:     VVAkuK = self.VVCBk1()
29306:     VV6A99.VVMqQ9(VVAkuK, VVDpzd=BF(self.VV6ZuM, path))
29307:  def VV6ZuM(self, path, VV6A99, title, txt, colList):
29308:   self.VVO7zz(VV6A99, path)
29309:  def VVO7zz(self, VV6A99, path):
29310:   for ndx, row in enumerate(VV6A99.VVrrm9()):
29311:    if row[0].strip() == path.strip():
29312:     VV6A99.VVrqBw(ndx)
29313:     return True
29314:   return False
29315:  def VVE7KC(self, VV6A99, title, txt, colList):
29316:   path = colList[0]
29317:   FFRMYv(self, BF(self.VVUWxc, VV6A99), "Remove this path from list?\n\n%s" % path, title="Remove path from list")
29318:  def VVUWxc(self, VV6A99):
29319:   row = VV6A99.VV5crm()
29320:   path, rem = row[0], row[1]
29321:   VVAkuK = []
29322:   lst = []
29323:   for ndx, row in enumerate(VV6A99.VVrrm9()):
29324:    tPath, tRem = row[0].strip(), row[1].strip()
29325:    if not path == tPath:
29326:     lst.append(tPath)
29327:     VVAkuK.append((tPath, tRem))
29328:   if len(VVAkuK) > 0:
29329:    FFjt1c(CFG.iptvHostsDirs, ",".join(lst))
29330:    VV6A99.VVMqQ9(VVAkuK)
29331:    FF28n1(VV6A99, "Deleted", 1500)
29332:   else:
29333:    FFjt1c(CFG.iptvHostsMode, VVSBbs)
29334:    FFjt1c(CFG.iptvHostsDirs, "")
29335:    VV6A99.cancel()
29336:    FFIElK(BF(FF28n1, self, "Changed to Auto-Find", 1500))
29337:  def VVpWVN(self, configObj):
29338:   sDir = configObj.getValue()
29339:   self.session.openWithCallback(BF(self.VVNRVS, configObj)
29340:          , BF(CClYaF, mode=CClYaF.VV9N82, VV1pbK=sDir))
29341:  def VVNRVS(self, configObj, path):
29342:   if len(path) > 0:
29343:    configObj.setValue(path)
29344:  def VVMrMS(self):
29345:   for x in self["config"].list:
29346:    if len(x) == 2 and FFI3NO(x[1]):
29347:     FFRMYv(self, self.VVTUim, "Save Changes ?", callBack_No=self.cancel, title=self.Title)
29348:     break
29349:   else:
29350:    self.cancel()
29351:  def VVTUim(self):
29352:   for x in self["config"].list:
29353:    if len(x) == 2 and FFI3NO(x[1]):
29354:     x[1].save()
29355:   self.VV62UD()
29356:   self.close()
29357:  def cancel(self):
29358:   for x in self["config"].list:
29359:    try:
29360:     x[1].cancel()
29361:    except:
29362:     pass
29363:   self.close()
29364:  def VVhAm1(self):
29365:   c1, c2, c3 = VVz22H, VVJEMb, VVFuwR
29366:   VV3wat = []
29367:   VV3wat.append(("Change Text Color Scheme (fix Transparent Text)", "changeColorScheme" ))
29368:   VV3wat.append(VVAL3j)
29369:   VV3wat.append((c1 + "Reset %s Settings" % VVh9hj, "VVUISm"))
29370:   VV3wat.append(VVAL3j)
29371:   VV3wat.append((c2 + "Backup %s Settings" % VVh9hj , "VV7sMA"))
29372:   VV3wat.append((c2 + "Restore %s Settings" % VVh9hj, "VV0J44"))
29373:   VV3wat.append(VVAL3j)
29374:   if CFG.checkForUpdateAtStartup.getValue() : txt, ref = "Disable", "disableChkUpdate"
29375:   else          : txt, ref = "Enable", "enableChkUpdate"
29376:   VV3wat.append((c3 + '%s Checking for Update' % txt, ref    ))
29377:   VV3wat.append((c3 + "Reinstall %s" % VVh9hj , "VVf1nm" ))
29378:   VV3wat.append((c3 + "Update %s" % VVh9hj  , "VViYWX"  ))
29379:   FFLFTC(self, self.VVBIPF, VV3wat=VV3wat, title="Config. Options")
29380:  def VVBIPF(self, item=None):
29381:   if item:
29382:    title = "%s Settings" % VVh9hj
29383:    if  item == "changeColorScheme": self.session.open(CCuTnL)
29384:    elif item == "VVUISm"  : FFRMYv(self, BF(self.VVUISm, True), "Clear all settings (including File Manager bookmarks) ?", title=title)
29385:    elif item == "VV7sMA" : self.VV7sMA()
29386:    elif item == "VV0J44" : self.VV0J44()
29387:    elif item == "enableChkUpdate" : FFjt1c(CFG.checkForUpdateAtStartup, True)
29388:    elif item == "disableChkUpdate" : FFjt1c(CFG.checkForUpdateAtStartup, False)
29389:    elif item == "VVf1nm" : self.VV6QXl(True )
29390:    elif item == "VViYWX"  : self.VV6QXl(False)
29391:  def VV7sMA(self):
29392:   path = "%sajpanel_settings_%s" % (FF0cqc(), FFjTQe())
29393:   FF7ymp("grep .%s. %s > %s" % (VVh9hj, VVfBVj, path))
29394:   FFipXT(self, "Saved to file:\n\n%s" % path, title="Export %s Settings" % VVh9hj)
29395:  @FFOAKH("Searching for Settings ...")
29396:  def VV0J44(self):
29397:   title = "Import %s Settings" % VVh9hj
29398:   name  = "ajpanel_settings_"
29399:   files = FF3xOt("find / %s -iname '%s*' | grep %s" % (FF5W9s(1), name, name))
29400:   if files:
29401:    err = CClYaF.VV8isu(files)
29402:    if err:
29403:     FFRMYv(self, BF(self.VVU3uB, title), "No valid settings files found !\n\nLocate Manually ?", title=title)
29404:    else:
29405:     try:
29406:      files = sorted(files, key=lambda t: -os.stat(t).st_mtime)
29407:     except Exception as e:
29408:      FFdw58(self, "Error:\n\n%s" % str(e), title=title)
29409:      return
29410:     VV3wat = []
29411:     for line in files:
29412:      VV3wat.append((line, line))
29413:     FFLFTC(self, BF(self.VV6Pjm, title), title=title, VV3wat=VV3wat, width=1200, VVtboQ="")
29414:   else:
29415:    FFdw58(self, "No settings files found !", title=title)
29416:  def VVU3uB(self, title, path=None):
29417:   sDir = "/"
29418:   for path in (FF0cqc(), "/media/usb/", "/media/hdd/", "/media/"):
29419:    if VVmJwX(path):
29420:     sDir = path
29421:     break
29422:   self.session.openWithCallback(BF(self.VV6Pjm, title), BF(CClYaF, VV1gDA="ajpSet", VV1pbK=sDir))
29423:  def VV6Pjm(self, title, path=None):
29424:   if path:
29425:    if VVmJwX(path):
29426:     lines  = FFL19l(path)
29427:     self.VVUISm()
29428:     for line in lines:
29429:      name, _, val = line.partition("=")
29430:      try:
29431:       confItem = eval(name)
29432:       if confItem is not None:
29433:        if   isinstance(confItem, ConfigInteger)  : val = int(val)
29434:        elif isinstance(confItem, ConfigSelectionNumber): val = int(val)
29435:        elif isinstance(confItem, ConfigYesNo)   : val = { "true": True, "false": False }.get(val.lower())
29436:        if not val is None:
29437:         confItem.setValue(val)
29438:         confItem.save()
29439:      except:
29440:       pass
29441:     FFzcnD(self)
29442:     self.VV62UD()
29443:     FF1mVE(self, "Done", 1500)
29444:    else:
29445:     FF8Wsn(self, path, title=title)
29446:  def VVUISm(self, exit=False):
29447:   for (key, cfg) in CFG.content.items.items():
29448:    cfg.setValue(cfg.default)
29449:   for x in self["config"].list:
29450:    try:
29451:     x[1].save()
29452:    except:
29453:     pass
29454:   FFzcnD()
29455:   self.VV62UD()
29456:   if exit:
29457:    self.close()
29458:  def VV62UD(self):
29459:   configfile.save()
29460:   self.VVUF0w(CFG.showInExtensionMenu.getValue(), iPlugins.getPlugins(PluginDescriptor.WHERE_EXTENSIONSMENU), [FFsfSz(), FFttL1(), FF2aef(), FFQRKB(), FFT9Fx(), FFYbQt(), FFpUEE(), FF2V0Y()])
29461:   self.VVUF0w(CFG.EventsInfoMenu.getValue(), iPlugins.getPlugins(PluginDescriptor.WHERE_EVENTINFO), [ FFxu4x() ])
29462:  @staticmethod
29463:  def VVUF0w(setVal, pluginList, dList):
29464:   try:
29465:    if setVal:
29466:     for item in dList:
29467:      if not item in pluginList:
29468:       iPlugins.addPlugin(item)
29469:    else:
29470:     for item in dList:
29471:      if item in pluginList:
29472:       iPlugins.removePlugin(item)
29473:   except:
29474:    pass
29475:   FF2Wqb()
29476:  @FFOAKH("Checking Server ...")
29477:  def VV6QXl(self, force):
29478:   title = "%s %s (from server)" % ("Reinstall" if force else "Update", VVh9hj)
29479:   curVer, webVer, url, isHigher, err = CCJaSw.VVq06s()
29480:   if   err    : FFdw58(self, err, title)
29481:   elif isHigher or force : FFRMYv(self, BF(self.VVkpNq, webVer, url, title, force), "%s v%s and Restart ?" % ("Reinstall" if force else "Upgrade to", webVer), title=title)
29482:   else     : FFipXT(self, FFjt5L("No update required.", VVSGsk) + "\n\nCurrent Version = v%s\n\nWeb Version = v%s" % (curVer, webVer), title)
29483:  @FFOAKH()
29484:  def VVkpNq(self, webVer, url, title, force):
29485:   fName = "enigma2-plugin-extensions-ajpanel_v%s_all_no_restart.%s" % (webVer, "deb" if FFgrjX() else "ipk")
29486:   path, err = FFx9uM(url + fName, fName, timeout=2)
29487:   if path:
29488:    if force: cmd = FF5sZa(VVj9MD, path)
29489:    else : cmd = FF5sZa(VVD9EU, path)
29490:    if cmd:
29491:     cmd = "%s && echo -e '\nSUCCESSFUL' || echo -e '\nERROR FOUND !'; rm -rf '%s'" % (cmd, path)
29492:     FFbi5l(self, cmd, title=title, VVtByE=self.VVgC9w)
29493:    else:
29494:     FFfone(self, title=title)
29495:   else:
29496:    FFdw58(self, err, title=title)
29497:  def VVgC9w(self, consObj):
29498:   txt = "SUCCESSFUL"
29499:   if txt in consObj.VV6VWc():
29500:    FFDuEn(consObj)
29501:    consObj.VV2pQl(consObj.VV6VWc().replace(txt, FFjt5L(txt, VVSGsk)))
29502:    FF28n1(consObj, "Restarting ...")
29503:    FFOKt0(self, 3000, BF(CCp90q.VV6bHp, self))
29504:  @staticmethod
29505:  def VVq06s():
29506:   url = CCJaSw.VVYs9i()
29507:   curVer = VVJ6zn
29508:   path, err = FFx9uM(url + "version", "ajp_tmp.ver", timeout=2)
29509:   if err or not FFCyVu(path):
29510:    return curVer, "", url, False, "Cannot get version file from server."
29511:   else:
29512:    webVer = FFYVq0(path)
29513:    FFwgGB(path)
29514:    cVer, wVer, isHigher = CCeSkW.VV2PRQ(curVer, webVer)
29515:    return cVer, wVer, url, isHigher, ""
29516:  @staticmethod
29517:  def VVCcoN(): return "https://github.com/AMAJamry/AJPanel"
29518:  @staticmethod
29519:  def VVYs9i(): return "https://raw.githubusercontent.com/AMAJamry/AJPanel/main/"
29520: class CCuTnL(Screen):
29521:  def __init__(self, session):
29522:   self.skin, self.VVfOli = FFiNEe(VVnUU2, 1200, 620, 50, 20, 0, "#22002020", "#22001122", 30)
29523:   self.cursorPos = VVHByN
29524:   self.Title  = "Select Color Scheme (for areas with mixed-color text)"
29525:   self.session = session
29526:   FFZMxC(self, title=self.Title)
29527:   sp = "    "
29528:   self["myColorF"] = Label()
29529:   for i in range(4):
29530:    txt = "\n"
29531:    txt += self.VV5iNL(r"\c00FFFFFF", i) + sp + "WHITE\n"
29532:    txt += self.VV5iNL(r"\c00888888", i) + sp + "GREY\n"
29533:    txt += self.VV5iNL(r"\c005A5A5A", i) + sp + "DARK GREY\n"
29534:    txt += self.VV5iNL(r"\c00FF0000", i) + sp + "RED\n"
29535:    txt += self.VV5iNL(r"\c00FF5000", i) + sp + "ORANGE\n"
29536:    txt += self.VV5iNL(r"\c00FFFF00", i) + sp + "YELLOW\n"
29537:    txt += self.VV5iNL(r"\c00FFFFAA", i) + sp + "B. YELLOW\n"
29538:    txt += self.VV5iNL(r"\c0000FF00", i) + sp + "GREEN\n"
29539:    txt += self.VV5iNL(r"\c000066FF", i) + sp + "BLUE\n"
29540:    txt += self.VV5iNL(r"\c0000FFFF", i) + sp + "CYAN\n"
29541:    txt += self.VV5iNL(r"\c00FA55E7", i) + sp + "PURPLE\n"
29542:    txt += self.VV5iNL(r"\c00FF8F5F", i) + sp + "PEACH\n"
29543:    self["myColor%s" % i] = Label(txt)
29544:   FFHlAU(self,
29545:   {
29546:    "ok" : self.VVPr1F ,
29547:    "green" : self.VVPr1F ,
29548:    "left" : self.VVziFC ,
29549:    "right" : self.VVLe1s ,
29550:    "cancel": self.close
29551:   })
29552:   self.onShown.append(self.VV7OzD)
29553:  def VV7OzD(self):
29554:   self.onShown.remove(self.VV7OzD)
29555:   self.VVvOga()
29556:  def VVPr1F(self):
29557:   if self.cursorPos == 0 : txt = "No Colors"
29558:   else     : txt = "Color Scheme-%d" % self.cursorPos
29559:   FFRMYv(self, self.VVnh6o, "Change to : %s" % txt, title=self.Title)
29560:  def VVnh6o(self):
29561:   FFjt1c(CFG.mixedColorScheme, self.cursorPos)
29562:   global VVHByN
29563:   VVHByN = self.cursorPos
29564:   self.VVHizC()
29565:   self.close()
29566:  def VVziFC(self):
29567:   self.cursorPos -= 1
29568:   if self.cursorPos < 0:
29569:    self.cursorPos = 3
29570:   self.VVvOga()
29571:  def VVLe1s(self):
29572:   self.cursorPos += 1
29573:   if self.cursorPos > 3:
29574:    self.cursorPos = 0
29575:   self.VVvOga()
29576:  def VVvOga(self):
29577:   left = []
29578:   for i in range(4):
29579:    left.append(self["myColor%s" % i].getPosition()[0])
29580:   left = left[self.cursorPos] - 4
29581:   top = self["myColor0"].getPosition()[1] - 4
29582:   self.cursorPos
29583:   self["myColorF"].instance.move(ePoint(left, top))
29584:  @staticmethod
29585:  def VV5iNL(color, mode):
29586:   if   mode == 1 : return color
29587:   elif mode == 2 : return color.replace("A", "9").replace("B", "9").replace("C", "9").replace("D", "9").replace("E", "9").replace("F", "9")
29588:   elif mode == 3 : return color.replace("A", ":").replace("B", ";").replace("C", "<").replace("D", "=").replace("E", ">").replace("F", "?")
29589:   else   : return ""
29590:  @staticmethod
29591:  def VVsAua(color):
29592:   if VV1fx4: return "\\" + color
29593:   else    : return ""
29594:  @staticmethod
29595:  def VVHizC():
29596:   global VVo7S9, VVA4XU, VVYjI5, VVyFI2, VVz22H, VVIH76, VV9nWG, VVMibI, VVSGsk, VVJEMb, VV1fx4, VVFuwR, VVGCYL, VVZtfx, VVcPtB, VVwdUw
29597:   VVwdUw   = CCuTnL.VV5iNL(r"\c00FFFFFF", VVHByN)
29598:   VVA4XU    = CCuTnL.VV5iNL(r"\c00888888", VVHByN)
29599:   VVo7S9  = CCuTnL.VV5iNL(r"\c005A5A5A", VVHByN)
29600:   VVMibI    = CCuTnL.VV5iNL(r"\c00FF0000", VVHByN)
29601:   VVYjI5   = CCuTnL.VV5iNL(r"\c00FF5000", VVHByN)
29602:   VVyFI2   = CCuTnL.VV5iNL(r"\c00FFBB66", VVHByN)
29603:   VV1fx4   = CCuTnL.VV5iNL(r"\c00FFFF00", VVHByN)
29604:   VVFuwR = CCuTnL.VV5iNL(r"\c00FFFFAA", VVHByN)
29605:   VVSGsk   = CCuTnL.VV5iNL(r"\c0000FF00", VVHByN)
29606:   VVJEMb  = CCuTnL.VV5iNL(r"\c00AAFFAA", VVHByN)
29607:   VV9nWG    = CCuTnL.VV5iNL(r"\c000066FF", VVHByN)
29608:   VVGCYL    = CCuTnL.VV5iNL(r"\c0000FFFF", VVHByN)
29609:   VVZtfx  = CCuTnL.VV5iNL(r"\c00AAFFFF", VVHByN)
29610:   VVcPtB   = CCuTnL.VV5iNL(r"\c00FA55E7", VVHByN)
29611:   VVz22H    = CCuTnL.VV5iNL(r"\c00FF8F5F", VVHByN)
29612:   VVIH76  = CCuTnL.VV5iNL(r"\c00FFC0C0", VVHByN)
29613: CCuTnL.VVHizC()
29614: class CCMvE7():
29615:  VVkelS  = "666"
29616:  VVZ6bs   = "888"
29617:  def __init__(self, SELF, VVOhqh, title, VV00CZ, VVFjhV=""):
29618:   self.SELF     = SELF
29619:   self.VVOhqh   = VVOhqh
29620:   self.Title     = title
29621:   self.VV00CZ   = VV00CZ
29622:   self.VVFjhV    = VVFjhV
29623:   self.VV7tND   = None
29624:   self.VVjO4U()
29625:  def VVjO4U(self):
29626:   VV3wat = CCMvE7.VVlHzq()
29627:   bNames = [x[0] for x in VV3wat if len(x) == 2]
29628:   if VV3wat:
29629:    VVB4pu = ("Create New", BF(self.VVHgG8, bNames))
29630:    self.VV7tND = FFLFTC(self.SELF, self.VV12l2, VV3wat=VV3wat, title=self.Title, VVB4pu=VVB4pu, VVU8mZ=True, VVwltY="#22222233", VVkxBG="#22222233")
29631:   else:
29632:    self.VVHgG8("")
29633:  def VV12l2(self, item):
29634:   if item:
29635:    bName, bRef, ndx = item
29636:    self.VVpiBp(bName, bRef)
29637:   else:
29638:    CCMvE7.VVw0of(self)
29639:  def VVHgG8(self, bNames, selectionObj=None, item=None):
29640:   name = self.VVFjhV
29641:   if not name:
29642:    name = "Bouquet1"
29643:    c = 1
29644:    while name in bNames:
29645:     c += 1
29646:     name = "Bouquet%s" % c
29647:   FF4z45(self.SELF, BF(self.VVR10D), defaultText=name, title="Create New Bouquet", message="Enter Bouquet Name:")
29648:  def VVR10D(self, bName):
29649:   if bName:
29650:    bName = bName.strip()
29651:    if bName:
29652:     if self.VV7tND:
29653:      self.VV7tND.cancel()
29654:     self.VVpiBp(bName, "")
29655:    else:
29656:     FF28n1(self.VV7tND, "Incorrect Bouquet Name !", 2000)
29657:     CCMvE7.VVw0of(self)
29658:  def VVpiBp(self, bName, bRef):
29659:   FFimQ3(self.VVOhqh, BF(self.VVKzWp, bName, bRef), title="Adding Services ...")
29660:  def VVKzWp(self, bName, bRef):
29661:   CCMvE7.VVPJK0(self.SELF, self.Title, bName, bRef, self.VV00CZ())
29662:  @staticmethod
29663:  def VVw0of(classObj):
29664:   del classObj
29665:  @staticmethod
29666:  def VVPJK0(SELF, title, bName, bRef, servRefLst, showRes=True):
29667:   if not servRefLst:
29668:    FFdw58(SELF, "No services to add !", title=title)
29669:    return
29670:   tvBouquetFile = VVQe79 + "bouquets.tv"
29671:   if not FFCyVu(tvBouquetFile):
29672:    FF8Wsn(SELF, tvBouquetFile, title=title)
29673:    return
29674:   if bRef:
29675:    bFile = CCMvE7.VV896q(bRef)
29676:    bPath = VVQe79 + bFile
29677:   else:
29678:    fName = CCkEI5.VVPjQO(bName)
29679:    bFile = "userbouquet.%s.tv" % fName
29680:    bPath = VVQe79 + bFile
29681:    num   = 0
29682:    while FFCyVu(bPath):
29683:     num += 1
29684:     bFile = "userbouquet.%s_%d.tv" % (fName, num)
29685:     bPath = VVQe79 + bFile
29686:    with open(bPath, "w") as f:
29687:     f.write("#NAME %s\n" % bName)
29688:   FFJvhj(bPath)
29689:   with open(bPath, "a") as f:
29690:    for chUrl in servRefLst:
29691:     serv = eServiceReference(chUrl)
29692:     VV1wIO = serv and serv.getName() or ""
29693:     try:
29694:      VV1wIO = VV1wIO.encode("UTF-8", "replace").decode()
29695:     except:
29696:      VV1wIO = FFWEt2(VV1wIO, r"?")
29697:     f.write("
29698:     f.write("#DESCRIPTION %s\n" % VV1wIO)
29699:   if not bRef and FFCyVu(bPath):
29700:    FFJvhj(tvBouquetFile)
29701:    with open(tvBouquetFile, "a") as f:
29702:     f.write('#SERVICE 1:7:1:0:0:0:0:0:0:0:FROM BOUQUET "%s" ORDER BY bouquet\n' % bFile)
29703:   totPicons = 0
29704:   piconPath = CCafIt.VVjkKT()
29705:   for chUrl in servRefLst:
29706:    span = iSearch(r"((?:[A-Fa-f0-9]+:){10})", chUrl.rstrip(":"))
29707:    if span:
29708:     serv = eServiceReference(chUrl)
29709:     if serv:
29710:      picon = piconPath + span.group(1).strip(":").replace(":", "_").upper() + ".png"
29711:      fPath = serv.getPath()
29712:      fNameNoExt = os.path.splitext(serv.getPath())[0]
29713:      for ext in ("png", "jpg", "bmp", "gif", "jpe", "jpeg"):
29714:       poster = "%s.%s" % (fNameNoExt, ext)
29715:       if FFCyVu(poster):
29716:        totPicons += 1
29717:        FFpwZS("cp -f '%s' '%s'" % (poster, picon))
29718:        FFpwZS(CCvjVs.VVQ9GP(picon))
29719:        break
29720:   FFfpyJ()
29721:   if showRes:
29722:    txt  = "Bouquet Name\t\t: %s\n"  % bName
29723:    txt += "Added Services\t\t: %d\n" % len(servRefLst)
29724:    if totPicons:
29725:     txt += "Added PIcons\t\t: %s" % totPicons
29726:    FF4lCP(SELF, txt, title=title)
29727:  @staticmethod
29728:  def VVCROO(bName):
29729:   mode = CCLSIv.VVK7hm(default=-1)
29730:   modeTxt = "tv" if mode == 0 else "radio"
29731:   fName = CCkEI5.VVPjQO(bName)
29732:   bFile = "userbouquet.%s.%s" % (fName, modeTxt)
29733:   num   = 0
29734:   while FFCyVu(VVQe79 + bFile):
29735:    num += 1
29736:    bFile = "userbouquet.%s_%d.%s" % (fName, num, modeTxt)
29737:   with open(VVQe79 + bFile, "w") as f:
29738:    f.write("#NAME %s\n" % bName)
29739:   mainBFile = "%sbouquets.%s" % (VVQe79, modeTxt)
29740:   if FFCyVu(mainBFile):
29741:    FFJvhj(mainBFile)
29742:    with open(mainBFile, "a") as f:
29743:     f.write('#SERVICE 1:7:1:0:0:0:0:0:0:0:FROM BOUQUET "%s" ORDER BY bouquet\n' % bFile)
29744:  @staticmethod
29745:  def VV3r6m(ref, bName):
29746:   bFile = CCMvE7.VV896q(ref)
29747:   ok = False
29748:   if bFile:
29749:    bFile = VVQe79 + bFile
29750:    if FFCyVu(bFile):
29751:     lines = FFL19l(bFile, keepends=True)
29752:     with open(bFile, "w") as f:
29753:      for line in lines:
29754:       if line.startswith("#NAME "):
29755:        f.write("#NAME %s\n" % bName)
29756:        ok = True
29757:       else:
29758:        f.write(line)
29759:   return ok
29760:  @staticmethod
29761:  def VVlHzq(mode=2, showTitle=True, prefix="", onlyIptv=False):
29762:   VV3wat = []
29763:   if mode in (0, 2): VV3wat.extend(CCMvE7.VVYHtq(0, showTitle, prefix, onlyIptv))
29764:   if mode in (1, 2): VV3wat.extend(CCMvE7.VVYHtq(1, showTitle, prefix, onlyIptv))
29765:   return VV3wat
29766:  @staticmethod
29767:  def VVYHtq(mode, showTitle, prefix, onlyIptv):
29768:   VV3wat = []
29769:   lst = CCMvE7.VV161E(mode)
29770:   if onlyIptv:
29771:    lst = CCMvE7.VVHwDB(lst)
29772:   if lst:
29773:    if showTitle:
29774:     VV3wat.append(FF0bQE("TV Bouquets" if mode == 0 else "Radio Bouquets"))
29775:    if prefix:
29776:     for item in lst : VV3wat.append((item[0], prefix + item[0]))
29777:    else:
29778:     for item in lst : VV3wat.append((item[0], item[1].toString()))
29779:   return VV3wat
29780:  @staticmethod
29781:  def VVHwDB(lst):
29782:   fLst = CCkEI5.VVjMS6(onlyFileName=True)
29783:   newLst = []
29784:   if fLst:
29785:    for item in lst:
29786:     span = iSearch(r".+(userbouquet\..+\.(tv|radio))", item[1].toString())
29787:     if span and span.group(1) in fLst:
29788:      newLst.append(item)
29789:   return newLst
29790:  @staticmethod
29791:  def VVnZ35():
29792:   lst = CCMvE7.VV161E(0)
29793:   lst.extend(CCMvE7.VV161E(1))
29794:   return lst
29795:  @staticmethod
29796:  def VV161E(mode=0):
29797:   bList = []
29798:   VVCy6c = InfoBar.instance
29799:   VVFp6v = VVCy6c and VVCy6c.servicelist
29800:   if VVFp6v:
29801:    curMode = VVFp6v.mode
29802:    CCMvE7.VVJqMl(VVFp6v, mode)
29803:    bList.extend(VVFp6v.getBouquetList() or [])
29804:    CCMvE7.VVJqMl(VVFp6v, curMode)
29805:   return bList
29806:  @staticmethod
29807:  def VVJqMl(VVFp6v, mode):
29808:   if not mode == VVFp6v.mode:
29809:    if   mode == 0: VVFp6v.setModeTv()
29810:    elif mode == 1: VVFp6v.setModeRadio()
29811:  @staticmethod
29812:  def VVBTuE(isAll=True, onlyMain=False):
29813:   bLst = []
29814:   inst = InfoBar.instance
29815:   if inst:
29816:    csel = inst.servicelist
29817:    if csel:
29818:     root = csel.bouquet_root
29819:     VVX5XV = eServiceCenter.getInstance()
29820:     if onlyMain:
29821:      info = VVX5XV.info(root)
29822:      if info:
29823:       bLst.append((info.getName(root), root.toString()))
29824:     else:
29825:      list = VVX5XV and VVX5XV.list(root)
29826:      if list:
29827:       while True:
29828:        s = list.getNext()
29829:        if not s.valid():
29830:         break
29831:        if isAll or (s.flags & eServiceReference.isDirectory and not s.flags & eServiceReference.isInvisible):
29832:         info = VVX5XV.info(s)
29833:         if info:
29834:          bLst.append((info.getName(s), s.toString()))
29835:   return bLst
29836:  @staticmethod
29837:  def VVHtVA():
29838:   lst = []
29839:   types = ('*.*.tv', '*.*.radio')
29840:   for f in types:
29841:    lst.extend(iGlob(VVQe79 + f))
29842:   return lst
29843:  @staticmethod
29844:  def VV896q(bRef):
29845:   span = iSearch(r'BOUQUET\s+"(.+)"\s+ORDER', bRef, IGNORECASE)
29846:   if span : return span.group(1)
29847:   else : return ""
29848:  @staticmethod
29849:  def VVsEnx(ref, dstFile):
29850:   dstFile = VVQe79 + dstFile
29851:   if FFCyVu(dstFile):
29852:    FFJvhj(dstFile)
29853:    bLine = ""
29854:    VVs2Wm = CCMvE7.VV896q(ref)
29855:    if VVs2Wm:
29856:     span = iSearch(r"\.(.+)\.(tv|radio)", VVs2Wm, IGNORECASE)
29857:     if span:
29858:      fName, fType = span.group(1), span.group(2)
29859:      newName = "userSubBouquet.%s.%s" % (fName, fType)
29860:      num = 0
29861:      while FFCyVu(VVQe79 + newName):
29862:       num += 1
29863:       newName = "userSubBouquet.%s_%d.%s" % (fName, num, fType)
29864:      subFile = VVQe79 + newName
29865:      FFpwZS("cp -f '%s%s' '%s'" % (VVQe79, VVs2Wm, subFile))
29866:      if FFCyVu(subFile):
29867:       bLine = '1:7:1:0:0:0:0:0:0:0:FROM BOUQUET "%s" ORDER BY bouquet' % newName
29868:    else:
29869:     bLine = ref
29870:    if bLine:
29871:     if FFCyVu(dstFile):
29872:      with open(dstFile, "a") as f:
29873:       f.write("#SERVICE %s\n" % bLine)
29874:      return True
29875:   return False
29876:  @staticmethod
29877:  def VVvNtR():
29878:   try:
29879:    fName = CCMvE7.VV896q(InfoBar.instance.servicelist.getRoot().toString())
29880:    path = "%s%s" % (VVQe79, fName)
29881:    if FFCyVu(path):
29882:     return path
29883:   except:
29884:    pass
29885:   return ""
29886:  @staticmethod
29887:  def VVCWrE():
29888:   path = CCMvE7.VVvNtR()
29889:   if path:
29890:    txt = FFYVq0(path, maxSize=300)
29891:    span = iSearch(r"
29892:    if span:
29893:     return span.group(1).strip()
29894:   return ""
29895:  @staticmethod
29896:  def VVqZTI(mode=0):
29897:   return FFZcDI(InfoBar.instance.servicelist.getRoot(), mode)
29898:  @staticmethod
29899:  def VVykzu():
29900:   lst = []
29901:   for b in CCMvE7.VVnZ35():
29902:    bName = b[0]
29903:    bRef  = b[1].toString()
29904:    path = VVQe79 + CCMvE7.VV896q(bRef)
29905:    if FFCyVu(path):
29906:     lines = FFL19l(path)
29907:     for line in lines:
29908:      if line.startswith("
29909:       if not line.startswith("#SERVICE 1:64:"):
29910:        break
29911:     else:
29912:      if not "userbouquet.favourites." in bRef:
29913:       lst.append((bName, bRef))
29914:   return lst
29915:  @staticmethod
29916:  def VVAZ5l(SID, stripRType):
29917:   if stripRType: return r"(?:[A-Fa-f0-9]+:)((?:[A-Fa-f0-9]+:){2}%s:(?:[A-Fa-f0-9]+:){6})" % SID
29918:   else   : return r"((?:[A-Fa-f0-9]+:){3}%s:(?:[A-Fa-f0-9]+:){6})" % SID
29919:  @staticmethod
29920:  def VVc8iI(SID="", stripRType=False):
29921:   if SID : patt = CCMvE7.VVAZ5l(SID, stripRType)
29922:   else : patt = r"((?:[A-Fa-f0-9]+:){10})"
29923:   lst = []
29924:   for b in CCMvE7.VVnZ35():
29925:    for service in FFZcDI(b[1]):
29926:     span = iSearch(patt, service[0])
29927:     if span:
29928:      lst.append(span.group(1).upper())
29929:   return lst
29930:  @staticmethod
29931:  def VVit2n():
29932:   patt = r"((?:[A-Fa-f0-9]+:){10})http.+"
29933:   lst = []
29934:   for b in CCMvE7.VVnZ35():
29935:    for service in FFZcDI(b[1]):
29936:     span = iSearch(patt, service[0])
29937:     if span:
29938:      lst.append(span.group(1).upper().rstrip(":"))
29939:   return lst
29940:  @staticmethod
29941:  def VVIjNS():
29942:   patt = r"((?:[A-Fa-f0-9]+:){10})http.+"
29943:   lst = []
29944:   for b in CCMvE7.VVnZ35():
29945:    for service in FFZcDI(b[1]):
29946:     span = iSearch(patt, service[0])
29947:     if span:
29948:      lst.append((span.group(1).upper().rstrip(":"), service[1]))
29949:   return lst
29950:  @staticmethod
29951:  def VVIGWw(rType, SID, refLst, startId, startNS):
29952:   for Id in range(max(6, startId), 65535):
29953:    hexId = ("%1x" % Id).upper()
29954:    for NS in range(startNS, 65535):
29955:     hexNS = ("FFF%04x" % NS).upper()
29956:     tRef = "0:1:%s:%s:%s:%s:0:0:0:" % (SID, hexId, hexId, hexNS)
29957:     if not tRef in refLst:
29958:      VVPxk5 = "%s:0:1:%s:%s:%s:%s:0:0:0:" % (rType, SID, hexId, hexId, hexNS)
29959:      if NS < 65535 - 1: NS += 1
29960:      else    : NS, Id = 6, Id + 1
29961:      return VVPxk5, Id, NS
29962:   return "", 0, 0
29963:  @staticmethod
29964:  def VVvoK9(pathLst, rType=""):
29965:   refLst = CCMvE7.VVc8iI(CCMvE7.VVkelS, stripRType=True)
29966:   chUrlLst = []
29967:   startId  = startNS = 0
29968:   rType  = rType or CFG.iptvAddToBouquetRefType.getValue()
29969:   for path in pathLst:
29970:    VVPxk5, startId, startNS = CCMvE7.VVIGWw(rType, CCMvE7.VVkelS, refLst, startId, startNS)
29971:    if VVPxk5:
29972:     VV1wIO = os.path.splitext(os.path.basename(path))[0].replace("-", " ").replace("_", " ").replace(".", " ")
29973:     chUrl = "%s%s:%s" % (VVPxk5, path, VV1wIO)
29974:     chUrlLst.append(chUrl)
29975:    else:
29976:     break
29977:   return chUrlLst
29978: class CClYaF(Screen, CCLAzj):
29979:  VV4Ihm   = 0
29980:  VVQTL1  = 1
29981:  VV9N82  = 2
29982:  VVkJTs = 3
29983:  VVR977  = 4
29984:  VVufQt    = 20
29985:  VVoPwh   = 0
29986:  VVFST7   = 1
29987:  VVoQmo   = 2
29988:  def __init__(self, session, VV1pbK="/", mode=VV4Ihm, VVqlNR="Select", width=1400, height=920, VVwdmN=30, VVwltY="#22001111", VVkxBG="#22000000", pickTitleBG="#11001144", pickBodyBG="#08002244", VVoCB2="#06004444", VVAHYe=False, VVHYTc="", VV1gDA="", VVIC7J=False):
29989:   self.skin, self.VVfOli = FFiNEe(VVWp3I, width, height, 30, 40, 20, VVwltY, VVkxBG, VVwdmN, VVeFSs=40, VV0Ay7=2, VVdrEC=(0, 0))
29990:   self.session   = session
29991:   self.VVwltY   = VVwltY
29992:   self.VVkxBG    = VVkxBG
29993:   self.pickTitleBG  = pickTitleBG
29994:   self.pickBodyBG   = pickBodyBG
29995:   FFZMxC(self)
29996:   FFRLNq(self["keyRed"] , "Exit")
29997:   FFRLNq(self["keyYellow"], "More Options")
29998:   FFRLNq(self["keyBlue"] , "Bookmarks")
29999:   CCLAzj.__init__(self, gapX=10, gapY=10)
30000:   self.VVJcJg  = 1000
30001:   self.mode    = mode
30002:   self.VVqlNR = VVqlNR
30003:   self.VVHYTc   = VVHYTc
30004:   self.VV1gDA  = VV1gDA
30005:   self.VVAHYe   = VVAHYe
30006:   self.VVpP2Y  = None
30007:   self.VVsw6F   = 300
30008:   self.VVoCB2   = VVoCB2
30009:   self.VVJuPG = False
30010:   self.VVIC7J   = VVIC7J
30011:   self.lastViewedPic  = ""
30012:   VV2mDa = None
30013:   if VV1gDA:
30014:    self.mode = self.VVkJTs
30015:    if   VV1gDA == "srt"  : VV2mDa = (r"^.*\.srt$"    , IGNORECASE)
30016:    elif VV1gDA == "ajpSet" : VV2mDa = (r"^.*\/ajpanel_settings_" , 0    )
30017:    elif VV1gDA == "poster" : VV2mDa = (r"^.*\.(jpg|png)$"    , IGNORECASE)
30018:    elif VV1gDA == "pkgCtrl": VV2mDa = (r"^.*\/(control|preinst|prerm|postinst|postrm)$", 0)
30019:    elif VV1gDA == "movies" : VV2mDa = (r"^.*\.(%s)$" % "|".join(CCHmnm.VViatp()["mov"]), IGNORECASE)
30020:    elif VV1gDA == "custMnu": VV2mDa = (r"^.*\/ajpanel_menu.*\.xml$", 0)
30021:    else       : VV2mDa = None
30022:   if self.VVbA0M():
30023:    FFRLNq(self["keyRed"], "Cancel")
30024:   if   self.VVHYTc       : VV1aG0, self.VV1pbK = True , FFx9pN(self.VVHYTc, True) or "/"
30025:   elif self.VVAHYe        : VV1aG0, self.VV1pbK = True , CClYaF.VV4zSS(self)[1] or "/"
30026:   elif self.mode == self.VV4Ihm  : VV1aG0, self.VV1pbK = True , CFG.browserStartPath.getValue()
30027:   elif self.mode == self.VV9N82 : VV1aG0, self.VV1pbK = False, VV1pbK
30028:   elif self.mode == self.VVkJTs : VV1aG0, self.VV1pbK = True , VV1pbK
30029:   elif self.mode == self.VVR977 : VV1aG0, self.VV1pbK = True , VV1pbK
30030:   else           : VV1aG0, self.VV1pbK = True , VV1pbK
30031:   self.VV1pbK = FFoWxR(self.VV1pbK)
30032:   self["myMenu"] = CCHmnm(  directory   = None
30033:          , VV2mDa = VV2mDa
30034:          , VV1aG0   = VV1aG0
30035:          , VVodaQ = True
30036:          , enableWrapAround = True
30037:          , VVVljT   = self.VVfOli["width"]
30038:          , VVwdmN   = self.VVfOli["VVgbF2"]
30039:          , VV8c7y  = self.VVfOli["bodyLineH"] )
30040:   FFHlAU(self,
30041:   {
30042:    "ok"  : self.VVPr1F    ,
30043:    "red"  : self.VVih5U   ,
30044:    "green"  : self.VVzToM  ,
30045:    "yellow" : self.VV8SuT  ,
30046:    "blue"  : self.VVwrew ,
30047:    "menu"  : self.VVrEFW  ,
30048:    "info"  : self.VVRg33  ,
30049:    "cancel" : self.VV59x5    ,
30050:    "fav"  : self.VVkOZB,
30051:    "back"  : self.VV0CD0   ,
30052:    "pageUp" : self.VV0CD0   ,
30053:    "chanUp" : self.VV0CD0   ,
30054:    "pageDown" : self.VV3ycX  ,
30055:    "chanDown" : self.VV3ycX  ,
30056:    "last"  : self.VVE9rg   ,
30057:    "next"  : self.VVMjPT
30058:   })
30059:   CCKg9B(self, self["myMenu"])
30060:   self.onShown.append(self.VV7OzD)
30061:   self.onClose.append(self.onExit)
30062:   self["myMenu"].onSelectionChanged.append(self.VVHrZx)
30063:   global VVyg7B
30064:   VVyg7B = True
30065:  def onExit(self):
30066:   self["myMenu"].onSelectionChanged = []
30067:   if self.mode == self.VV4Ihm:
30068:    FFYDZ6("VVyg7B")
30069:  def VV7OzD(self):
30070:   self.onShown.remove(self.VV7OzD)
30071:   self.onShown.append(self.VVHrZx)
30072:   FF6W0I(self)
30073:   FF4IPF(self["myMenu"], bg=self.VVoCB2)
30074:   FFWgBS(self)
30075:   self.VVJcJg = self["keyInfo"].getPosition()[0] - 40
30076:   if self.VVbA0M():
30077:    FFRLNq(self["keyGreen"], self.VVqlNR)
30078:    self.VVT9IH(self.VVFST7)
30079:   self.VVHrZx()
30080:   w  = self["myMenu"].instance.size().width()
30081:   h  = self["myMenu"].instance.size().height()
30082:   pos  = self["myMenu"].getPosition()
30083:   part = self["myMenu"].instance.size().height() % self.VVfOli["bodyLineH"]
30084:   half = int(part / 2)
30085:   self["myMenu"].instance.resize(eSize(*(w, h - part)))
30086:   self["myMenu"].instance.move(ePoint(pos[0], pos[1] + half))
30087:   if self.VVqBVd(self.VV1pbK) > self.VVsw6F: FFimQ3(self, self.VV7ESp, title="Changing directory...")
30088:   else              : self.VV7ESp()
30089:  def VV7ESp(self):
30090:   if self.VVHYTc : self.VVPeow(FFoWxR(self.VVHYTc) if os.path.isdir(self.VVHYTc) else self.VVHYTc)
30091:   elif self.VVAHYe : self.VV64Kx(chDir=False)
30092:   else    : self["myMenu"].VVf5s1(self.VV1pbK)
30093:  def VVbA0M(self):
30094:   return self.mode in (self.VV9N82, self.VVkJTs, self.VVR977)
30095:  def VVrqBw(self, rowNdx):
30096:   self["myMenu"].moveToIndex(rowNdx)
30097:  @FFOAKH("Refreshing list ...")
30098:  def VVcPTN(self, moveTo=""):
30099:   isSel = self["myMenu"].VVs0ks()
30100:   if not isSel: self.VVdcm6(False)
30101:   if moveTo: self.VVWh2y(moveTo)
30102:   FF2Wqb()
30103:  def VVFGYD(self, saved):
30104:   if saved: self.VVcPTN()
30105:  def VVqBVd(self, path):
30106:   try:
30107:    return len(os.listdir(path))
30108:   except:
30109:    return 0
30110:  def VVPr1F(self, isUp=False):
30111:   if self.VVJuPG:
30112:    if self.mode == self.VVkJTs and os.path.isdir(self.VV5pAO(self.VVQlTC())):
30113:     FF28n1(self, "Files only", 500)
30114:    elif self["myMenu"].VVRH7p(isUp):
30115:     self.VVoBrJ()
30116:    else:
30117:     FF28n1(self, "Cannot select item", 500)
30118:   elif self["myMenu"].VV2bmH(): self.VVn2Lq()
30119:   else       : self.VVSrgT()
30120:  def VV0CD0(self):
30121:   if self.VVJuPG:
30122:    self.VVPr1F(isUp=True)
30123:   else:
30124:    self["myMenu"].moveToIndex(0)
30125:    if self["myMenu"].VVe2l0():
30126:     self.VVn2Lq()
30127:  def VV3ycX(self):
30128:   if self.VVJuPG:
30129:    self.VVPr1F(isUp=False)
30130:   elif self["myMenu"].VV2bmH() and self["myMenu"].getSelectionIndex() > 0:
30131:    self.VVn2Lq()
30132:  def VVE9rg(self) : self["myMenu"].moveToIndex(0)
30133:  def VVMjPT(self) : self["myMenu"].moveToIndex(len(self["myMenu"].list) - 1)
30134:  def VVn2Lq(self, isDirUp=False):
30135:   if self["myMenu"].VV2bmH():
30136:    if not self["myMenu"].getSelection() is None: path = self["myMenu"].getSelection()[0]
30137:    else          : path = self.VV5pAO(self.VVQlTC())
30138:    if self.VVqBVd(path) > self.VVsw6F : FFimQ3(self, self.VVVknA, title="Changing directory...")
30139:    else           : self.VVVknA()
30140:  def VVVknA(self):
30141:   self["myMenu"].descent()
30142:   self.VVHrZx()
30143:  def VV59x5(self):
30144:   if   self.VVJuPG     : self.VVdcm6(False, True)
30145:   elif CFG.FileManagerExit.getValue() == "e" : self.VVih5U()
30146:   else          : self.VV0CD0()
30147:  def VVih5U(self):
30148:   if FFmZaT(self): reutrn
30149:   if VV8oe7:
30150:    FFDuEn(self)
30151:    FFjADj(self, "Closing ...")
30152:    FFOKt0(self, 1000, self.close)
30153:   else:
30154:    self.close("")
30155:  def VVk14D(self):
30156:   FFw2rR(self, "_help_fman", "File Manager (Keys)")
30157:  def VVzToM(self):
30158:   if self["keyGreen"].getVisible():
30159:    if self.VVIC7J and self.VVJuPG:
30160:     lst = []
30161:     path = self["myMenu"].VVWyCw()
30162:     for row in self["myMenu"].list:
30163:      if row[2][6]:
30164:       lst.append(os.path.join(path, row[0][0]))
30165:     if lst : self.close(lst)
30166:     else : FF28n1(self, "Nothing selected", 500)
30167:    else:
30168:     path = self.VV5pAO(self.VVQlTC())
30169:     isDir = os.path.isdir(path)
30170:     chkFile = False
30171:     if   self.mode == self.VV9N82 : self.close(path)
30172:     elif self.mode == self.VVkJTs : chkFile = True
30173:     elif self.mode == self.VVR977 :
30174:      if isDir: self.close(path)
30175:      else : chkFile = True
30176:     if chkFile:
30177:      if os.path.isfile(path) : self.close(path)
30178:      else     : FF28n1(self, "Cannot access this file", 1000)
30179:  @FFOAKH("Calculating size ...")
30180:  def VVRg33(self):
30181:   path = self.VV5pAO(self.VVQlTC())
30182:   param = self.VViUa8(path)
30183:   if not param:
30184:    FFdw58(self, "Cannot access information !")
30185:    return
30186:   def VVVuRT(key, val, color=""):
30187:    lineTxt = "%s\t: %s\n" % (key, str(val))
30188:    return FFjt5L(lineTxt, color) if color else lineTxt
30189:   c1, c2, c3, c4, c5 = VVIH76, VVFuwR, VVJEMb, VVwdUw, VVZtfx
30190:   path, typeStr, typeChar, iNode, permUser, permGroup, permOther, permExtra, hLinks, owner, group, size, slTarget, slBroken, hLinkedFiles = param
30191:   mnt_fs = mnt_typ = ""
30192:   contents = totSize = usedSize = freeSize = availSize = ""
30193:   if typeChar == "d":
30194:    exclude = r"-type d \( -ipath '/media' -o -ipath '/mnt' -o -ipath '*boot*' -o -ipath '*/ba' \) -prune -o"
30195:    result = FFTKR0("totDirs=$(find '%s' %s -type d -print | wc -l); totFiles=$(find '%s' %s ! -type d | wc -l); echo $totDirs','$totFiles" % (path, exclude, path, exclude))
30196:    if iMatch("^[0-9]*,[0-9]*", result):
30197:     parts = result.split(",")
30198:     contents += VVVuRT("Directories" , format(int(parts[0]), ',d'), c4)
30199:     contents += VVVuRT("Files"   , format(int(parts[1]), ',d'), c4)
30200:    if os.path.ismount(path):
30201:     inf = CClYaF.VVR33x().get(FFoWxR(os.path.realpath(path)), "")
30202:     if inf:
30203:      mnt_fs, mnt_typ, isNet = inf
30204:     typeStr += " (Mount)"
30205:     total, used, free, avail, err = CClYaF.VVdlF7(path)
30206:     totSize, usedSize, freeSize, availSize = [CClYaF.VV99gM(x) for x in (total, used, free, avail)]
30207:    else:
30208:     usedSize = CClYaF.VV99gM(FF4oMa(path))
30209:   else:
30210:    usedSize = CClYaF.VV99gM(size)
30211:   if len(path) < 58 : pathTxt = path
30212:   else    : pathTxt = "\n" + path
30213:   pathTxt = pathTxt+ "\n"
30214:   if slBroken : fileTime = self.VVnGz0(path)
30215:   else  : fileTime = self.VV84uw(path)
30216:   txt = ""
30217:   txt += VVVuRT("Path"    , pathTxt, c1)
30218:   txt += VVVuRT("Type"    , typeStr, c2)
30219:   if mnt_fs and mnt_typ:
30220:    txt += VVVuRT("Files System" , mnt_fs, c2)
30221:    txt += VVVuRT("VFS Type"  , mnt_typ, c2)
30222:   if len(slTarget) > 0:
30223:    txt += VVVuRT("Target"   , slTarget)
30224:   if os.path.ismount(path):
30225:    txt += VVVuRT("Total Size"  , "%s" % totSize, c3)
30226:    txt += VVVuRT("Used Size"  , "%s" % usedSize, c3)
30227:    txt += VVVuRT("Free Size"  , "%s" % freeSize, c3)
30228:    if free != avail: txt += VVVuRT("Available Size" , "%s" % availSize, c3)
30229:   else:
30230:    txt += VVVuRT("Size"   , "%s" % usedSize, c3)
30231:   txt += contents
30232:   txt += "\n"
30233:   txt += VVVuRT("Owner"    , owner, c5)
30234:   txt += VVVuRT("Group"    , group, c5)
30235:   txt += VVVuRT("Perm. (User)"  , permUser, c5)
30236:   txt += VVVuRT("Perm. (Group)"  , permGroup, c5)
30237:   txt += VVVuRT("Perm. (Other)"  , permOther, c5)
30238:   if len(permExtra) > 0:
30239:    txt += VVVuRT("Perm. (Ext.)" , permExtra)
30240:   txt += "\n"
30241:   txt += VVVuRT("iNode"    , iNode)
30242:   txt += VVVuRT("Hard Links"   , hLinks)
30243:   txt += fileTime
30244:   if hLinkedFiles:
30245:    txt += "\n%s\nHard Linked Files (files with same iNode)\n%s\n" % (SEP, SEP)
30246:    txt += hLinkedFiles
30247:   txt += self.VVvXL8(path)
30248:   txt += CC6u6z.VVZKCF(path)
30249:   FF4lCP(self, txt, height=1000, titleBg="#22001010", VVemyB="#11000a1a")
30250:  def VViUa8(self, path):
30251:   path = path.strip()
30252:   path = FFVc4H(path)
30253:   result = FFTKR0("FILE='%s'; BROKEN=$(if [ ! -e \"$FILE\" ]; then echo 'yes'; else echo 'no'; fi); LINE=$(ls -lid \"$FILE\" 2> /dev/null); PARAM=$(echo $LINE | awk '{print $1\",\"$2\",\"$3\",\"$4\",\"$5\",\"$6}'); SLINK=$(echo $LINE | awk '{$1=$2=$3=$4=$5=$6=$7=$8=$9=\"\";print}'  | sed 's/ -> /,/g' | xargs); echo $PARAM','$BROKEN','$SLINK" % path)
30254:   parts = result.split(",")
30255:   if not all(parts):
30256:    return None
30257:   if len(parts) > 7:
30258:    iNode  = parts[0]
30259:    perm  = parts[1]
30260:    hLinks  = parts[2]
30261:    owner  = parts[3]
30262:    group  = parts[4]
30263:    size  = parts[5]
30264:    slBroken = parts[6]
30265:    fName  = parts[7]
30266:    slTarget = ""
30267:    if len(parts) > 8:
30268:     slTarget = parts[8]
30269:    size = int(size)
30270:    def VVjuol(perm, start, end):
30271:     val = perm[start : end]
30272:     p  = { "---": "0" , "--x": "1" , "-w-": "2" , "-wx": "3" , "r--": "4" , "r-x": "5" , "rw-": "6" , "rwx": "7" , "+": "ACL" }
30273:     if val in p : return "%s\t%s" % (val, p[val])
30274:     else  : return val
30275:    permUser = VVjuol(perm, 1, 4)
30276:    permGroup = VVjuol(perm, 4, 7)
30277:    permOther = VVjuol(perm, 7, 10)
30278:    permExtra = VVjuol(perm, 10, 100)
30279:    typeChar = perm[0:1]
30280:    typeStr = {"-":"File", "b":"Block Device File", "c":"Character Device File", "d":"Directory", "e":"External Link", "l":"Symbolic Link", "n":"Network File", "p":"Named Pipe", "s":"Local Socket File"}.get(typeChar, "Unknown")
30281:    if "yes" in slBroken:
30282:     slBroken = True
30283:     typeStr  = "Broken Symlink (target not found)"
30284:    else:
30285:     slBroken = False
30286:    hLinkedFiles = ""
30287:    if typeChar != "d" and int(hLinks) > 1:
30288:     hLinkedFiles = FFQ45w("find / %s -inum %s -print0 2> /dev/null | xargs -0 ls -i 2> /dev/null | grep %s | awk '{$1=\"\"; print $0}' | awk '{$1=$1};1'" % (FF5W9s(0, ["/dev", "/hdd", "/newroot", "/sys/class"]), iNode, iNode))
30289:    return path, typeStr, typeChar, iNode, permUser, permGroup, permOther, permExtra, hLinks, owner, group, size, slTarget, slBroken, hLinkedFiles
30290:   else:
30291:    return None
30292:  def VVvXL8(self, path):
30293:   txt  = ""
30294:   res  = FFTKR0("lsattr -d %s" % path)
30295:   span = iSearch(r"([acdeijstuACDST-]{13})\s", res, IGNORECASE)
30296:   if span:
30297:    res = span.group(1)
30298:    tDict = {"a": "Append only", "c": "Compressed", "d": "No dump", "e": "Extent format", "i": "Immutable", "j": "Data journalling", "s": "Secure deletion (s)", "t": "Tail-merging", "u": "Undeletable", "A": "No atime updates", "C": "No copy on write", "D": "Synchronous directory updates", "S": "Synchronous updates", "T": "Top of directory hierarchy", "h": "Huge file", "E": "Compression error", "I": "Indexed directory", "X": "Compression raw access", "Z": "Compressed dirty file"}
30299:    lst = []
30300:    for key, val in tDict.items():
30301:     if key in res:
30302:      lst.append("%s  ( %s )\n" % (val, key))
30303:    if lst:
30304:     lst.sort()
30305:     for item in lst:
30306:      txt += "    %s" % item
30307:     txt = "\n%s\n%s" % (FFjt5L("File Attributes:", VVcPtB), txt)
30308:   return txt
30309:  def VV84uw(self, path):
30310:   txt = "\n"
30311:   txt += "Access time\t: %s\n" % FFTS4w(os.path.getatime(path))
30312:   txt += "Modified time\t: %s\n" % FFTS4w(os.path.getmtime(path))
30313:   txt += "Change time\t: %s\n" % FFTS4w(os.path.getctime(path))
30314:   return txt
30315:  def VVnGz0(self, path):
30316:   txt = "\n"
30317:   txt += "Access time\t: %s\n" % FFTKR0("stat -c %%x '%s'" % path).replace(".000000000", "")
30318:   txt += "Modified time\t: %s\n" % FFTKR0("stat -c %%y '%s'" % path).replace(".000000000", "")
30319:   txt += "Change time\t: %s\n" % FFTKR0("stat -c %%z '%s'" % path).replace(".000000000", "")
30320:   return txt
30321:  def VV5pAO(self, currentSel):
30322:   currentDir  = self["myMenu"].VVWyCw()
30323:   if currentDir is None:
30324:    path = currentSel
30325:   elif currentSel is None:
30326:    path = currentDir
30327:   else:
30328:    if currentSel == "/":
30329:     path = currentDir
30330:    else:
30331:     if not self["myMenu"].VV2bmH():
30332:      path = currentDir + currentSel
30333:     else:
30334:      if len(currentDir) > len(currentSel):
30335:       path = currentDir
30336:      else:
30337:       path = currentSel
30338:   return str(path)
30339:  def VV21cx(self):
30340:   return self["myMenu"].VVWyCw() or self.VV5pAO(self.VVQlTC())
30341:  def VVQlTC(self):
30342:   sel = self["myMenu"].getSelection()
30343:   if sel : return sel[0]
30344:   else : return None
30345:  def VVHrZx(self):
30346:   path = self.VV5pAO(self.VVQlTC())
30347:   self["myTitle"].setText("  " + path)
30348:   if self["myTitle"].instance:
30349:    textW = self["myTitle"].instance.calculateSize().width()
30350:    if textW > self.VVJcJg:
30351:     length = len(path)
30352:     tmpPath = path[4:]
30353:     for i in range(length, 40, -1):
30354:      self["myTitle"].setText("  .." + tmpPath)
30355:      textW = self["myTitle"].instance.calculateSize().width()
30356:      if textW > self.VVJcJg: tmpPath = tmpPath[1:]
30357:      else       : break
30358:   self.VVzqwr()
30359:   if self.mode == self.VV4Ihm:
30360:    if len(path) > 0: self["keyMenu"].show()
30361:    else   : self["keyMenu"].hide()
30362:   self["keyGreen"].hide()
30363:   if self.VVbA0M():
30364:    if self.VVJuPG:
30365:     if self["myMenu"].VVhxM5() > 0:
30366:      self["keyGreen"].show()
30367:    else:
30368:     if self.mode == self.VVkJTs:
30369:      if os.path.isfile(path):
30370:       self["keyGreen"].show()
30371:     else:
30372:      self["keyGreen"].show()
30373:   FFOKt0(self, 30, self.VVYKse)
30374:  def VVYKse(self):
30375:   path = self.VV5pAO(self.VVQlTC())
30376:   if path != self.lastViewedPic:
30377:    self.VVacFr(path)
30378:    self.lastViewedPic = path
30379:  def VVrEFW(self):
30380:   c1, c2, c3 = VVIH76, VVFuwR, VVZtfx
30381:   totSel = 0
30382:   menuW = 1000
30383:   title = "Options"
30384:   VV3wat= []
30385:   path = self.VV5pAO(self.VVQlTC())
30386:   isLink = os.path.islink(path)
30387:   if self.VVJuPG:
30388:    menuW = 850
30389:    totSel = self["myMenu"].VVhxM5()
30390:    if totSel > 0:
30391:     if iTar:
30392:      txt1 = "Archive to .tar.gz"
30393:      txt2 = " (Preserve Path Structure)"
30394:      title = "Options  (%d item%s)" % (totSel, FFcacr(totSel))
30395:      VV3wat.append((c1 + txt1      , "VVH6Ci1"  ))
30396:      VV3wat.append((c1 + txt1 + txt2    , "VVH6Ci2"  ))
30397:      VV3wat.append(VVAL3j)
30398:     VV3wat.append(("[6] Copy"       , "copyFileOrDir" ))
30399:     VV3wat.append(("[7] Move"       , "moveFileOrDir" ))
30400:     VV3wat.append(("[8] %sDELETE" % VVz22H , "VV49nJ"  ))
30401:    else:
30402:     FF28n1(self, "Nothing selected", 700)
30403:     return
30404:   elif self.VVbA0M():
30405:    VV3wat.append(("Properties", "properties" ))
30406:    VV3wat.append(VVAL3j)
30407:    VV3wat.append((c3 + "Create New Directory (in current directory)" , "createNewDir"))
30408:   else:
30409:    menuW = 1050
30410:    path  = self.VV5pAO(self.VVQlTC())
30411:    isEditable = self["myMenu"].VVK4p4()
30412:    if not FFq2rn(path):
30413:     FFdw58(self, "Cannot access this object.")
30414:     return
30415:    VV3wat.append(("Properties", "properties"))
30416:    if os.path.isdir(path):
30417:     addSep = True
30418:     if FFx9pN(path, True) in (VVUytA, VVhDOZ):
30419:      VV3wat.append(VVAL3j)
30420:      VV3wat.append((c1 + "Show Related Package", "VVKeBf"))
30421:      addSep = False
30422:     if isEditable:
30423:      if addSep:
30424:       VV3wat.append(VVAL3j)
30425:      VV3wat.append((c1 + "Archive/Package Tools", "VVwKHY_dir"))
30426:      addSep = False
30427:    elif os.path.isfile(path):
30428:     selFile = self.VVQlTC()
30429:     isArch = selFile.endswith((".tar", ".gz", ".tar.bz2", "tar.xz", "tar.zst", ".zip", ".rar", ".7z"))
30430:     if not isArch:
30431:      VV3wat.append((c1 + "Archive ...", "VVwKHY_file"))
30432:     isText = False
30433:     txt = ""
30434:     if isArch:
30435:      VV3wat.extend(self.VVEMIT(path, True))
30436:     elif selFile.endswith((".ipk", ".deb")) :
30437:      txt = "Package Tools"
30438:     elif selFile.endswith((".m3u", ".m3u8")):
30439:      VV3wat.extend(self.VVhJGC(True))
30440:     elif selFile.endswith((".sh", ".py", ".pyo", ".pyc")):
30441:      VV3wat.extend(self.VVAEUh(path, True))
30442:      isText = selFile.endswith((".sh", ".py"))
30443:     elif selFile.endswith(".svg"):
30444:      pass
30445:     elif not isLink and selFile.endswith(".tif"):
30446:      VV3wat.append((c2 + "Save as ...", "VVpeV4"))
30447:     elif not isLink and self["myMenu"].VVMyky(path) == "pic":
30448:      VV3wat.append(VVAL3j)
30449:      VV3wat.append((c2 + "Set as PIcon (for current channel)", "VVxzz6" ))
30450:      path = self.VV5pAO(self.VVQlTC())
30451:      VV3wat.append(VVAL3j)
30452:      VV3wat.append((c2 + "Rotate Image", "VVL2ZB"   ))
30453:      VV3wat.append((c2 + "Flip Image" , "VVImxq"   ))
30454:      VV3wat.append((c2 + "Save as ..." , "VVpeV4" ))
30455:      VV3wat.append(VVAL3j)
30456:      VV3wat.append((c2 + "Convert to Base64 String", "VVOiJy" ))
30457:      if FFayeZ("ffmpeg") and selFile.lower().endswith((".jpg", ".png")):
30458:       VV3wat.append((c2 + "Convert to MVI (1280 x 720 )", "VV2if2Hd" ))
30459:       VV3wat.append((c2 + "Convert to MVI (1920 x 1080)", "VV2if2Fhd" ))
30460:     elif selFile.endswith((".py", ".xml", ".txt", ".htm", ".html", ".cfg", ".conf")) or not CClYaF.VVgIOw(path):
30461:      VV3wat.append(VVAL3j)
30462:      VV3wat.append((c2 + "View"     , "textView_def"))
30463:      VV3wat.append((c2 + "View (Select Encoder)" , "textView_enc"))
30464:      VV3wat.append((c2 + "Edit"     , "text_Edit" ))
30465:      isText = True
30466:     elif selFile.endswith(CClYaF.VVI46y(addDot=True)):
30467:      if selFile.endswith(".mvi"):
30468:       if FFayeZ("showiframe"):
30469:        VV3wat.append(VVAL3j)
30470:        VV3wat.append((c2 + "View as Bootlogo (will interrupt the playing service)", "viewAsBootlogo"))
30471:       if FFayeZ("ffmpeg"):
30472:        VV3wat.append((c2 + "Convert to jpg", "mv2jpg"))
30473:        VV3wat.append((c2 + "Convert to png", "mv2png"))
30474:      else:
30475:       VV3wat.append(VVAL3j)
30476:       VV3wat.append((c2 + "Add Media File to a Bouquet"    , "VV2Fo30" ))
30477:       VV3wat.append((c2 + "Add all Media in Directory to a Bouquet" , "VV2Fo31" ))
30478:       VV3wat.append((c2 + "Play with ..."       , "playWith"    ))
30479:     if isText:
30480:      VV3wat.append((c1 + "Save as UTF-8 ..."      , "textSave_encUtf8"))
30481:      VV3wat.append((c1 + "Save as other Encoding ..."    , "textSave_encOthr"))
30482:      VV3wat.append((c1 + "Convert Line-Breaks to Unix Format..." , "VVEDRf" ))
30483:     if len(txt) > 0:
30484:      VV3wat.append(VVAL3j)
30485:      VV3wat.append((c1 + txt, "VVSrgT"))
30486:    VV3wat.append(VVAL3j)
30487:    VV3wat.append(("[4] Create SymLink", "VV6ZhN"))
30488:    if isEditable:
30489:     VV3wat.append(("[5] Rename"      , "VVTxpl" ))
30490:     VV3wat.append(("[6] Copy"       , "copyFileOrDir" ))
30491:     VV3wat.append(("[7] Move"       , "moveFileOrDir" ))
30492:     VV3wat.append(("[8] %sDELETE" % VVz22H , "VVRs0f" ))
30493:     if FFCyVu(path):
30494:      VV3wat.append(VVAL3j)
30495:      perm = oct(os.stat(path).st_mode)[-3:]
30496:      if   perm == "644" : show644, show755, show777 = False, True , True
30497:      elif perm == "755" : show644, show755, show777 = True , False , True
30498:      elif perm == "777" : show644, show755, show777 = True , True , False
30499:      else    : show644, show755, show777 = True , True , True
30500:      chmodTxt = "Change Permissions (from %s to " % perm
30501:      if show644 : VV3wat.append((chmodTxt + "644)", "chmod644"))
30502:      if show755 : VV3wat.append((chmodTxt + "755)", "chmod755"))
30503:      if show777 : VV3wat.append((chmodTxt + "777)", "chmod777"))
30504:    VV3wat.append(VVAL3j)
30505:    VV3wat.append((c3 + "Create New File (in current directory)"  , "createNewFile"))
30506:    VV3wat.append((c3 + "Create New Directory (in current directory)" , "createNewDir" ))
30507:    fPath, fDir, fName = CClYaF.VV4zSS(self)
30508:    if fPath:
30509:     VV3wat.append(VVAL3j)
30510:     VV3wat.append((c2 + "Go to Current Movie Dir", "VV64Kx"))
30511:   FFLFTC(self, self.VVdSby, width=menuW, height=1050, title=title, VV3wat=VV3wat, VVptue=0.01, VVCkuB=False, VVwltY="#00101020", VVkxBG="#00101A2A")
30512:  def VVdSby(self, item=None):
30513:   if item is not None:
30514:    path = self.VV5pAO(self.VVQlTC())
30515:    if   item == "VVH6Ci1"    : self.VVH6Ci(False)
30516:    elif item == "VVH6Ci2"    : self.VVH6Ci(True)
30517:    elif item == "copyFileOrDir"   : self.VVhrqo(False)
30518:    elif item == "moveFileOrDir"   : self.VVhrqo(True)
30519:    elif item == "VV49nJ"    : self.VV49nJ()
30520:    elif item == "properties"    : self.VVRg33()
30521:    elif item == "VVKeBf"  : self.VVKeBf(path)
30522:    elif item == "VVwKHY_dir" : self.VVwKHY(path, True)
30523:    elif item == "VVwKHY_file" : self.VVwKHY(path, False)
30524:    elif item == "VVJf2H"  : self.VVJf2H(path)
30525:    elif item == "VVmefC"  : self.VVmefC(path)
30526:    elif item == "2gz"       : self.VVCQLE(path, "gz")
30527:    elif item == "2xz"       : self.VVCQLE(path, "xz")
30528:    elif item.startswith("extract_")  : self.VVuG0S(path, item)
30529:    elif item.startswith("script_")   : self.VVCNY7(path, item)
30530:    elif item.startswith("m3u_")   : self.VVGWWo(path, item)
30531:    elif item.startswith("textView_def") : FFaOUK(self, path)
30532:    elif item.startswith("textView_enc") : self.VVIS6B(path)
30533:    elif item.startswith("text_Edit")  : CCyMCP(self, path, VVbYwR=self.VVFGYD)
30534:    elif item.startswith("textSave_encUtf8"): self.VVJVpo(path, "Save as UTF-8"   , True)
30535:    elif item.startswith("textSave_encOthr"): self.VVJVpo(path, "Save as Other Encoding", False)
30536:    elif item.startswith("VVEDRf") : self.VVEDRf(path)
30537:    elif item == "viewAsBootlogo"   : self.VVuVqJ(path, True)
30538:    elif item == "mv2jpg"     : self.VV72l5(path, 0)
30539:    elif item == "mv2png"     : self.VV72l5(path, 1)
30540:    elif item == "VV2Fo30" : self.VV2Fo3(path, False)
30541:    elif item == "VV2Fo31" : self.VV2Fo3(path, True)
30542:    elif item == "playWith"     : self.VVi42l(path)
30543:    elif item == "VVxzz6" : self.VVxzz6(path)
30544:    elif item == "VVL2ZB"   : self.VVL2ZB(path)
30545:    elif item == "VVImxq"    : self.VVImxq(path)
30546:    elif item == "VVpeV4" : self.VVpeV4(path)
30547:    elif item == "VV2if2Hd"   : self.VV2if2(path, False)
30548:    elif item == "VV2if2Fhd"   : self.VV2if2(path, True)
30549:    elif item == "VVOiJy"   : self.VVOiJy(path)
30550:    elif item == "VV6ZhN"   : self.VV6ZhN(path)
30551:    elif item == "VVTxpl"   : self.VVTxpl(path)
30552:    elif item == "VVRs0f"   : self.VVRs0f(path)
30553:    elif item == "chmod644"     : self.VVtQrS(path, "644")
30554:    elif item == "chmod755"     : self.VVtQrS(path, "755")
30555:    elif item == "chmod777"     : self.VVtQrS(path, "777")
30556:    elif item == "createNewFile"   : self.VVeGt3(path, True)
30557:    elif item == "createNewDir"    : self.VVeGt3(path, False)
30558:    elif item == "VV64Kx"   : self.VV64Kx()
30559:    elif item == "VVSrgT"    : self.VVSrgT()
30560:  def VVSrgT(self):
30561:   if self.mode == self.VVkJTs and not self.VV1gDA == "poster":
30562:    return
30563:   path = self.VV5pAO(self.VVQlTC())
30564:   if os.path.isfile(path):
30565:    cat = self["myMenu"].VVMyky(path)
30566:    if   cat == "pic"        : self.VVwyCv(path)
30567:    elif cat == "txt"        : FFaOUK(self, path)
30568:    elif cat == "m3u"        : self.VVJ8wl(path)
30569:    elif cat in ("scr", "py")      : self.VVCqHG(path)
30570:    elif cat in ("tar", "rar", "zip", "p7z", "zst") : self.VVbiYO(path)
30571:    elif cat in ("ipk", "deb")      : self.VV8nL2(path)
30572:    elif cat in ("mov", "mus")      : self.VVuVqJ(path)
30573:    elif not CClYaF.VVgIOw(path)  : FFaOUK(self, path)
30574:  @FFOAKH()
30575:  def VVwyCv(self, path):
30576:   VVBGsZ = 0
30577:   curFile = os.path.basename(path)
30578:   lst = []
30579:   for ndx, item in enumerate(self["myMenu"].list):
30580:    if not item[0][1]:
30581:     category = self["myMenu"].VVMyky(item[1][7])
30582:     if category == "pic":
30583:      if curFile == item[1][7]:
30584:       VVBGsZ = len(lst)
30585:      lst.append((ndx, item[1][7]))
30586:   CCf8zb.VVjnMn(self, path, fileList=lst, VVBGsZ=VVBGsZ, cbFnc=self.VVtSUs)
30587:  def VVtSUs(self, path, ndx):
30588:   self["myMenu"].moveToIndex(ndx)
30589:  def VVuVqJ(self, path, asLogo=False):
30590:   if asLogo : CCcV1i.VVKb3z(self, path)
30591:   else  : FFimQ3(self, BF(self.VVTWR0, self, path), title="Playing Media ...")
30592:  def VVwrew(self):
30593:   if self["keyBlue"].getVisible():
30594:    VVGape = self.VV4sOH()
30595:    if VVGape:
30596:     path = self.VV5pAO(self.VVQlTC())
30597:     enableGreenBtn = False if path in self.VV4sOH() else True
30598:     newList = []
30599:     for line in VVGape:
30600:      newList.append((line, line))
30601:     VVHGnw  = ("Delete"    , self.VV3M4h    )
30602:     VVwJOl  = ("Add Current Dir"   , BF(self.VVrbvp, path) ) if enableGreenBtn else None
30603:     VVB4pu = ("Move Up"     , self.VVbkqS    )
30604:     VVaTeF  = ("Move Down"   , self.VVoA0n    )
30605:     self.VVpP2Y = FFLFTC(self, self.VVXwm6, width=1200, title="Bookmarks", VV3wat=newList, VVyRCy=10 ,VVHGnw=VVHGnw, VVwJOl=VVwJOl, VVB4pu=VVB4pu, VVaTeF=VVaTeF, VVwltY="#00000022", VVkxBG="#00000022")
30606:  def VV3M4h(self, VV7tND=None, path=None):
30607:   VVGape = self.VV4sOH()
30608:   if VVGape:
30609:    while path in VVGape:
30610:     VVGape.remove(path)
30611:    self.VVHCxf(VVGape)
30612:   if self.VVpP2Y:
30613:    self.VVpP2Y.VVkSNR(VVGape)
30614:    self.VVpP2Y.VVoXgh(("Add Current Dir", BF(self.VVrbvp, path)))
30615:   else:
30616:    FF28n1(self, "Removed", 800)
30617:   self.VVzqwr()
30618:  def VVrbvp(self, path, VV7tND=None, item=None):
30619:   VVGape = self.VV4sOH()
30620:   if len(VVGape) >= self.VVufQt:
30621:    FFdw58(SELF, "Max bookmarks reached (max=%d)." % self.VVufQt)
30622:   elif not path in VVGape:
30623:    if not os.path.isdir(path):
30624:     path = FFx9pN(path, True)
30625:    newList = [path] + VVGape
30626:    self.VVHCxf(newList)
30627:    if self.VVpP2Y:
30628:     self.VVpP2Y.VVkSNR(newList)
30629:     self.VVpP2Y.VVoXgh()
30630:    else:
30631:     FF28n1(self, "Added", 800)
30632:   self.VVzqwr()
30633:  def VVbkqS(self, selectionObj, path):
30634:   if self.VVpP2Y:
30635:    VVGape = self.VVpP2Y.VVT8gV(True)
30636:    if VVGape:
30637:     self.VVHCxf(VVGape)
30638:  def VVoA0n(self, selectionObj, path):
30639:   if self.VVpP2Y:
30640:    VVGape = self.VVpP2Y.VVT8gV(False)
30641:    if VVGape:
30642:     self.VVHCxf(VVGape)
30643:  def VVXwm6(self, path=None):
30644:   if path:
30645:    path = FFoWxR(path)
30646:    self.VVPGjz(path)
30647:   self.VVHrZx()
30648:  @FFOAKH("Changing directory ...")
30649:  def VVPGjz(self, path):
30650:   self["myMenu"].VVf5s1(path)
30651:   self["myMenu"].moveToIndex(0)
30652:  def VV4sOH(self):
30653:   line = CFG.browserBookmarks.getValue().strip()
30654:   while " ," in line : line.replace(" ,", ",")
30655:   while ", " in line : line.replace(", ", ",")
30656:   if   "," in line : return line.split(",")
30657:   elif len(line) > 0 : return [line]
30658:   else    : return []
30659:  def VV2doE(self):
30660:   return True if VV4sOH() else False
30661:  def VVHCxf(self, VVGape):
30662:   line = ",".join(VVGape)
30663:   FFjt1c(CFG.browserBookmarks, line)
30664:  def VVPeow(self, path):
30665:   if FFCyVu(path):
30666:    fDir  = FFoWxR(os.path.dirname(path))
30667:    if fDir:
30668:     self["myMenu"].VVf5s1(fDir)
30669:    fName = os.path.basename(path)
30670:    for ndx, item in enumerate(self["myMenu"].list):
30671:     if fName == item[0][0]:
30672:      self["myMenu"].moveToIndex(ndx)
30673:      break
30674:   else:
30675:    FF28n1(self, "Not found", 1000)
30676:  def VVWh2y(self, moveTo):
30677:   for ndx, item in enumerate(self["myMenu"].list):
30678:    if moveTo == item[0][0]:
30679:     self["myMenu"].moveToIndex(ndx)
30680:     break
30681:  def VV64Kx(self, chDir=True):
30682:   fPath, fDir, fName = CClYaF.VV4zSS(self)
30683:   self.VVPeow(fPath)
30684:  def VV8SuT(self):
30685:   path = self.VV5pAO(self.VVQlTC())
30686:   isAdd = False if path in self.VV4sOH() else True
30687:   dirTxt = "Selected" if os.path.isdir(path) else "Current"
30688:   c1, c2, c3 = VVGCYL, VVJEMb, VVFuwR
30689:   VV3wat = []
30690:   VV3wat.append(("Find Files ..." , "find"))
30691:   VV3wat.append(("Sort ..."   , "sort"))
30692:   VV3wat.append(VVAL3j)
30693:   if isAdd: VV3wat.append((c1 + "Add %s Dir to Bookmarks"  % dirTxt, "addBM"))
30694:   else : VV3wat.append((c1 + "Remove %s Dir from Bookmarks" % dirTxt, "remBM"))
30695:   VV3wat.append(    (c2 + 'Set %s Dir as "Startup Dir"' % dirTxt, "start"))
30696:   VV3wat.append(VVAL3j)
30697:   VV3wat.append(("Keys (Shortcuts)", "help"))
30698:   if self.mode == self.VV4Ihm or self.VVIC7J:
30699:    VV3wat.append(VVAL3j)
30700:    if self.VVJuPG: VV3wat.append( (c3 + "Disable Multi-Select ", "multiOff"))
30701:    else     : VV3wat.append( (c3 + "Enable Multi-Select"  , "multiOn" ))
30702:    VV3wat.append(       (c3 + "Select all"    , "selAll"  ))
30703:   FFLFTC(self, BF(self.VVgNCz, path), width=750, title="More Options", VV3wat=VV3wat, VVwltY="#00221111", VVkxBG="#00221111")
30704:  def VVgNCz(self, path, item):
30705:   if item:
30706:    if   item == "find"  : self.VV66GN(path)
30707:    elif item == "sort"  : self.VVOKeQ()
30708:    elif item == "addBM" : self.VVrbvp(path)
30709:    elif item == "remBM" : self.VV3M4h(None, path)
30710:    elif item == "help"  : self.VVk14D()
30711:    elif item == "start" : self.VVyATn(path)
30712:    elif item == "multiOn" : self.VVdcm6(True)
30713:    elif item == "multiOff" : self.VVdcm6(False)
30714:    elif item == "selAll" : self.VVdcm6(True, True)
30715:  def VVdcm6(self, isOn, isAll=False):
30716:   self.VVJuPG = isOn
30717:   if isAll or not isOn:
30718:    FFimQ3(self, BF(self["myMenu"].VV0y0E, isOn, self.mode, cbFnc=self.VVoBrJ), title="Selecting ..." if isOn else "Unselecting ...")
30719:   if isOn      : color = self.VVoQmo
30720:   elif self.VVbA0M() : color = self.VVFST7
30721:   else      : color = self.VVoPwh
30722:   self.VVT9IH(color)
30723:   self.VVHrZx()
30724:  def VVoBrJ(self):
30725:   self["keyBlue"].setText(self.VV9gXI())
30726:  def VVT9IH(self, mode=0):
30727:   if   mode == self.VVFST7 : titBg, bodBg = self.pickTitleBG, self.pickBodyBG
30728:   elif mode == self.VVoQmo: titBg, bodBg = "#01883366", "#11002233"
30729:   else        : titBg, bodBg = self.VVwltY, self.VVkxBG
30730:   FFZ0AC(self["myTitle"], titBg)
30731:   FFZ0AC(self["myBar"], titBg)
30732:   FFZ0AC(self["myBody"], bodBg)
30733:   FFZ0AC(self["myMenu"], bodBg)
30734:   if self.VVJuPG: bg, txt = "#01883366", self.VV9gXI()
30735:   else     : bg, txt = VVq9cv[3], "Bookmarks"
30736:   FFRLNq(self["keyBlue"], txt)
30737:   FFZ0AC(self["keyBlue"], bg)
30738:   self.VVzqwr()
30739:  def VV9gXI(self):
30740:   return "Selected Items = %d" % self["myMenu"].VVhxM5()
30741:  def VVzqwr(self):
30742:   if self.VV4sOH() or self.VVJuPG: self["keyBlue"].show()
30743:   else            : self["keyBlue"].hide()
30744:  def VV66GN(self, path):
30745:   VV3wat = []
30746:   VV3wat.append(("Find in Current Directory"    , "findCur"  ))
30747:   VV3wat.append(("Find in Current Directory (recursive)" , "findCurR" ))
30748:   VV3wat.append(("Find in all Storage Systems"    , "findAll"  ))
30749:   FFLFTC(self, BF(self.VVqodg, path), width=700, title="Find File/Pattern", VV3wat=VV3wat, VVU8mZ=True, VVlaGv=True, VVwltY="#00221111", VVkxBG="#00221111")
30750:  def VVqodg(self, path, item):
30751:   if item:
30752:    title, item, ndx = item
30753:    if   item == "findCur" : self.VVYU75(0, path, title)
30754:    elif item == "findCurR" : self.VVYU75(1, path, title)
30755:    elif item == "findAll" : self.VVYU75(2, path, title)
30756:  def VVYU75(self, mode, path, title):
30757:   if CFG.lastFileManFindPatt.getValue(): txt = CFG.lastFileManFindPatt.getValue()
30758:   else         : txt = "*.ipk"
30759:   FF4z45(self, BF(self.VVHYs3, mode, path, title), defaultText=txt, title=title, message="Enter Name/Pattern:")
30760:  def VVHYs3(self, mode, path, title, filePatt):
30761:   if filePatt is not None:
30762:    filePatt = filePatt.strip()
30763:    FFjt1c(CFG.lastFileManFindPatt, filePatt)
30764:    badLst = filePatt.replace(" ", "") in ("*.*", "*.", ".*")
30765:    if not filePatt : FF28n1(self, "No entery", 1500)
30766:    elif badLst  : FF28n1(self, "Too many file !", 1500)
30767:    else   : self.VVHQ9b(mode, path, title, filePatt)
30768:  @FFOAKH("Searching ...")
30769:  def VVHQ9b(self, mode, path, title, filePatt):
30770:   lst = FFycDu("find '%s' %s -type f -iname '%s' %s -print 2> /dev/null" % ("/" if mode==2 else path, FF5W9s(0), filePatt, "-maxdepth 1" if mode == 0 else ""))
30771:   if lst:
30772:    err = CClYaF.VV8isu(lst)
30773:    if err:
30774:     FFdw58(self, err)
30775:    else:
30776:     for ndx, path in enumerate(lst):
30777:      lst[ndx] = (os.path.basename(path), os.path.dirname(path))
30778:     lst.sort(key=lambda x: x[0].lower())
30779:     header = ("File", "Directory" )
30780:     widths = (50 , 50   )
30781:     VV2ytr = (""     , self.VVPxbj , [])
30782:     VVwSzI = ("Go to File Location", self.VV9Bbn  , [])
30783:     FFUQ0v(self, None, title="%s : %s" % (title, filePatt), header=header, VVGape=lst, VV3cHe=widths, VVwdmN=26, VV2ytr=VV2ytr, VVwSzI=VVwSzI)
30784:   else:
30785:    FFjADj(self, "Not found !", 2000)
30786:  def VV9Bbn(self, VV6A99, title, txt, colList):
30787:   path = os.path.join(colList[1], colList[0])
30788:   if FFCyVu(path):
30789:    VV6A99.cancel()
30790:    self.VVPeow(path)
30791:   else:
30792:    FF28n1(VV6A99, "Path not found !", 1000)
30793:  def VVPxbj(self, VV6A99, title, txt, colList):
30794:   txt = "%s\n%s\n\n" % (FFjt5L("File:"  , VVFuwR), colList[0])
30795:   txt += "%s\n%s"  % (FFjt5L("Directory:", VVFuwR), FFoWxR(colList[1]))
30796:   FF4lCP(VV6A99, txt, title=title)
30797:  def VVOKeQ(self):
30798:   nameAlpMode, nameAlpTxt, nameNumMode, nameNumTxt , dateMode, dateTxt, typeMode, typeTxt, txt = self["myMenu"].VVdj0P()
30799:   VV3wat = []
30800:   VV3wat.append(("Name\t%s" % nameAlpTxt, "nameAlp"))
30801:   VV3wat.append(("Name\t%s" % nameNumTxt, "nameNum"))
30802:   VV3wat.append(("Date\t%s" % dateTxt, "dateAlp"))
30803:   VV3wat.append(("Type\t%s" % typeTxt, "typeAlp"))
30804:   VVaTeF = ("Mix", BF(self.VV4ICR, True))
30805:   FFLFTC(self, BF(self.VV6Mt1, False), VVW5y5=txt, width=650, title="Sort Options", VV3wat=VV3wat, VVaTeF=VVaTeF, VVlaGv=True, VVwltY="#00221111", VVkxBG="#00221111")
30806:  def VV4ICR(self, isMix, VV7tND, item):
30807:   self.VV6Mt1(True, item)
30808:  def VV6Mt1(self, isMix, item):
30809:   if item:
30810:    nameAlpMode, nameAlpTxt, nameNumMode, nameNumTxt , dateMode, dateTxt, typeMode, typeTxt, txt = self["myMenu"].VVdj0P()
30811:    if   item == "nameAlp": mode, isNum =  nameAlpMode, False
30812:    elif item == "nameNum": mode, isNum =  nameNumMode, True
30813:    elif item == "dateAlp": mode, isNum =  dateMode , False
30814:    elif item == "typeAlp": mode, isNum =  typeMode , False
30815:    else      : return
30816:    FFimQ3(self, BF(self["myMenu"].VVhNXg, mode, isMix, isNum), title="Sorting ... ")
30817:  def VVkOZB(self):
30818:   path = self.VV5pAO(self.VVQlTC())
30819:   self.VVyATn(path)
30820:  def VVyATn(self, path):
30821:   if not os.path.isdir(path):
30822:    path = FFx9pN(path, True)
30823:   FFjt1c(CFG.browserStartPath, path)
30824:   FF1mVE(self, "Saved as Startup", 1500)
30825:  def VVEMIT(self, path, calledFromMenu):
30826:   color = VVFuwR if calledFromMenu else ""
30827:   VV3wat = []
30828:   if path.endswith(".gz") and not path.endswith(".tar.gz") or path.endswith(".xz") and not path.endswith(".tar.xz"):
30829:    VV3wat.append((color + "Extract Here", "VVe9C1"))
30830:   else:
30831:    if path.endswith(".zst") and not FFayeZ("unzstd"):
30832:     return []
30833:    if calledFromMenu: VV3wat.append(VVAL3j)
30834:    VV3wat.append((color + "List Archived Files", "extract_listFiles"))
30835:    VV3wat.append(VVAL3j)
30836:    VV3wat.append((color + 'Extract to "%s"' % self.VVrERF(os.path.basename(path)) , "extract_toDir"  ))
30837:    VV3wat.append((color + 'Extract to Root Directory "/"  (recommended for plugins)'  , "extract_toRoot"  ))
30838:    VV3wat.append((color + "Extract Here"             , "extract_here"  ))
30839:    if iTar and iZip:
30840:     if path.endswith(".zip"):
30841:      if not calledFromMenu: VV3wat.append(VVAL3j)
30842:      VV3wat.append((color + "Convert .zip to .tar.gz", "VVJf2H" ))
30843:     elif path.endswith(".tar.gz"):
30844:      if not calledFromMenu: VV3wat.append(VVAL3j)
30845:      VV3wat.append((color + "Convert .tar.gz to .zip", "VVmefC" ))
30846:    if path.endswith((".tar.gz", ".tar.xz", ".tar.zst")):
30847:     VV3wat.append(VVAL3j)
30848:     if   path.endswith(".gz"): VV3wat.append((color + "Convert to .tar.xz", "2xz"))
30849:     elif path.endswith(".xz"): VV3wat.append((color + "Convert to .tar.gz", "2gz"))
30850:     elif path.endswith(".zst"):
30851:      cond = FFayeZ("zstd")
30852:      VV3wat.append(FFsLU5("Convert to .tar.gz", "2gz", cond, color))
30853:      VV3wat.append(FFsLU5("Convert to .tar.xz", "2xz", cond, color))
30854:   return VV3wat
30855:  def VVbiYO(self, path):
30856:   title = "Archived File Options"
30857:   VV3wat = self.VVEMIT(path, False)
30858:   if VV3wat : FFLFTC(self, BF(self.VVuG0S, path), title=title, VV3wat=VV3wat, width=1050)
30859:   else  : FFRMYv(self, BF(self.VVQHS8, self), 'Missing "zstd" package.\n\nInstall "zstd" ?')
30860:  @staticmethod
30861:  def VVQHS8(SELF):
30862:   cmd = FF5sZa(VVwFAi, "zstd")
30863:   if cmd : FFbi5l(SELF, cmd, title="Installing zstd")
30864:   else : FFfone(SELF)
30865:  def VVuG0S(self, path, item=None):
30866:   if item is not None:
30867:    if   item == "VVe9C1"         : self.VVe9C1(item, path)
30868:    elif item == "extract_listFiles"        : self.VV1zd9(path)
30869:    elif item == "VVJf2H" and path.endswith(".zip")  : self.VVJf2H(path)
30870:    elif item == "VVmefC" and path.endswith(".tar.gz") : self.VVmefC(path)
30871:    elif item == "2gz"             : self.VVCQLE(path, "gz")
30872:    elif item == "2xz"             : self.VVCQLE(path, "xz")
30873:    elif path.endswith((".zip", ".rar", ".7z"))      : self.VVsCrT(item, path)
30874:    else               : self.VVbl04(item, path)
30875:  def VVrERF(self, path, addSep=False):
30876:   for ext in (".tar.gz", ".tar.xz", ".tar.bz2", ".tar.zst"):
30877:    if path.endswith(ext):
30878:     print(len(ext))
30879:     return path[:-len(ext)]
30880:   return os.path.splitext(path)[0]
30881:  def VV1zd9(self, path):
30882:   ext = os.path.splitext(os.path.basename(path))[1]
30883:   linux_sep = "echo -e %s;" % SEP
30884:   if ext in (".zip", ".rar", ".7z"):
30885:    if   ext == ".zip": mainC, totC, instC = "unzip -l", "tail -n 1 | awk '{ print $2 }'"     , FFMAzK("unzip", "unzip", "Unzip")
30886:    elif ext == ".rar": mainC, totC, instC = "unrar l" , "tail -n 2 | grep -v \"^$\" | awk '{ print $2 }'" , FFMAzK("unrar", "unrar", "Unrar")
30887:    elif ext == ".7z" : mainC, totC, instC = "7za l" , "tail -n 1 | awk '{ print $5 }'"     , FFMAzK("7za", "p7zip", "P7Zip")
30888:    listC = "%s '%s'" % (mainC, path)
30889:    tooMany = "Will only show first and last 100 files..."
30890:    cmd  = linux_sep
30891:    cmd += instC
30892:    cmd += 'if [ "$allOK" -eq "1" ]; then '
30893:    cmd += " TOTF=$(%s | %s);" % (listC, totC)
30894:    cmd += " echo ''; echo 'Archived Files :'$TOTF;"
30895:    cmd +=   linux_sep
30896:    cmd += " if [ $TOTF -gt 300 ]; then"
30897:    cmd += "  echo -e '%s' %s;"  % (tooMany, FFSPDv(tooMany, VV1fx4))
30898:    cmd +=    linux_sep
30899:    cmd += "  %s | head -n 100;" % listC
30900:    cmd += "  echo ''; echo ' ... MANY LINES COME HERE ... '; echo '';"
30901:    cmd += "  echo '';"
30902:    cmd += "  %s | tail -n 100;" % listC
30903:    cmd += " else"
30904:    cmd += "  %s;" % listC
30905:    cmd += " fi;"
30906:    cmd += "fi;"
30907:   else:
30908:    cmd  = "echo -e 'Archive:\n%s\n\n';" % path
30909:    cmd += "totFiles=$(tar -tf '%s' | wc -l);" % path
30910:    cmd += "if (( $totFiles > 300 )); then moreInf='  ... Will list the first 300 only ...'; else moreInf=''; fi;"
30911:    cmd += "echo -e '\n%s\n--- Contents (Total='$totFiles')'$moreInf'\n%s';" % (SEP, SEP)
30912:    cmd += "tar -tf '%s' | head -n300;" % path
30913:    cmd += "if (( $totFiles > 300 )); then echo '\n... Only the first 300 are listed ...'; fi;"
30914:   cmd += "echo '';"
30915:   cmd += linux_sep
30916:   FFXD60(self, cmd)
30917:  @FFOAKH("Extracting ...")
30918:  def VVe9C1(self, item, path):
30919:   title = os.path.basename(path)
30920:   res = FFTKR0("RES=$(%s -dk '%s') && echo ok || echo $RES" % ("gzip" if path.endswith("gz") else "xz", path))
30921:   if res == "ok":
30922:    FFipXT(self, "Extracted File:\n\n%s" % path[:-3], title=title)
30923:    self.VVcPTN()
30924:   else:
30925:    FFdw58(self, "Error:\n\n%s" % res, title=title)
30926:  def VVbl04(self, item, path):
30927:   fName = os.path.basename(path)
30928:   lastP = FFxtW5(self.VVrERF(path))
30929:   parent = FFx9pN(path, False)
30930:   if   item == "extract_toDir" : destP, txt = lastP , " to : %s" % lastP
30931:   elif item == "extract_toRoot" : destP, txt = "/"  , ' to Root Directory ("/")'
30932:   elif item == "extract_here"  : destP, txt = parent, " Here"
30933:   else       : return
30934:   FFRMYv(self, BF(self.VVzvHe, item, path, fName, lastP, parent, destP), "Extract %s ?" % txt, title="File : %s" % fName)
30935:  def VVzvHe(self, item, path, fName, lastP, parent, destP):
30936:   if item == "extract_toDir":
30937:    cmd  = "cd '%s';" % parent
30938:    cmd += FFb2oQ("mkdir '%s'"   % lastP)
30939:    cmd += 'if [ -d "%s" ]; then '  % lastP
30940:    cmd += " tar -xf '%s' -C '%s';" % (path, lastP)
30941:    cmd += "else"
30942:    cmd += " echo -e 'Cannot create directory:\n%s';" % lastP
30943:    cmd += "fi"
30944:    destTxt = " : \n\n%s" % os.path.join(parent, destP)
30945:   elif item == "extract_toRoot":
30946:    cmd  = "cd '%s';" % parent
30947:    cmd += "tar -C / -xf '%s'" % path
30948:    destTxt = ' Root Directory ("/")'
30949:   elif item == "extract_here":
30950:    cmd  = "cd '%s';" % parent
30951:    cmd += "tar -xf '%s'" % path
30952:    destTxt = ": \n\n%s" % os.path.join(parent, destP)
30953:   res = FFQ45w(cmd)
30954:   if res : FF4lCP(self, "Error while extracting:\n\n%s\n\n%s\n\nError:\n\n%s" % (fName, SEP, res), isErr=True)
30955:   else : FFipXT(self, "Successfully Extracted to%s" % destTxt, title=fName)
30956:   self.VVcPTN()
30957:  def VVsCrT(self, item, path):
30958:   fName = os.path.basename(path)
30959:   FFRMYv(self, BF(self.VVV2Ta, item, path, fName), "Extract file ?\n\n%s" % fName)
30960:  def VVV2Ta(self, item, path, fName):
30961:   parent  = FFx9pN(path, False)
30962:   destPath = self.VVrERF(path)
30963:   archCmd  = ""
30964:   if path.endswith(".zip"):
30965:    cmd = FFMAzK("unzip", "unzip", "Unzip")
30966:    if   item == "extract_toDir" : archCmd += " cd '%s'; [ ! -d '%s' ] && mkdir '%s';" % (parent,destPath, destPath)
30967:    elif item == "extract_toRoot": destPath = "/"
30968:    elif item == "extract_here"  : destPath = parent
30969:    archCmd += " unzip -o -q '%s' -d '%s' > /dev/null;" % (path, destPath)
30970:   elif path.endswith(".rar"):
30971:    cmd = FFMAzK("unrar", "unrar", "Unrar")
30972:    if   item == "extract_toDir" : destPath = FFoWxR(destPath)
30973:    elif item == "extract_toRoot" : destPath = "/"
30974:    elif item == "extract_here"  : destPath = parent
30975:    archCmd += " unrar x -o+ '%s' '%s' > /dev/null;" % (path, destPath)
30976:   elif path.endswith(".7z"):
30977:    cmd = FFMAzK("7za", "p7zip", "P7Zip")
30978:    if   item == "extract_toDir" : destPath = destPath
30979:    elif item == "extract_toRoot" : destPath = "/"
30980:    elif item == "extract_here"  : destPath = parent
30981:    archCmd += "7za x '%s' -o'%s' -y > /dev/null;" % (path, destPath)
30982:   cmd += 'if [ "$allOK" -eq "1" ]; then '
30983:   cmd += "echo '';"
30984:   cmd += "echo 'Extracting content ...';"
30985:   cmd +=   archCmd
30986:   cmd += " echo -e 'Done.\n\nExtracted to:\n%s\n' %s;" % (destPath, FFSPDv(destPath, VVSGsk))
30987:   cmd += "fi;"
30988:   FFZQVC(self, cmd, VVoasw=self.VVcPTN)
30989:  def VVCqHG(self, path):
30990:   FFLFTC(self, BF(self.VVCNY7, path), title="File Options", VV3wat=self.VVAEUh(path))
30991:  def VVAEUh(self, path, addSep=False):
30992:   isText = path.endswith((".sh", ".py"))
30993:   c1 = VVFuwR
30994:   VV3wat = []
30995:   if addSep: VV3wat.append(VVAL3j)
30996:   if isText: VV3wat.append((c1 + "View"  , "script_View"  ))
30997:   VV3wat.append((c1 + "Execute in Terminal" , "script_Execute" ))
30998:   if isText: VV3wat.append((c1 + "Edit"  , "script_Edit"  ))
30999:   if VVBvqf:
31000:    VV3wat.append(VVAL3j)
31001:    VV3wat.append((VVYjI5 + "Fix SH", "VVNUmp"))
31002:   return VV3wat
31003:  def VVCNY7(self, path, item=None):
31004:   if item is not None:
31005:    if   item == "script_View"  : FFaOUK(self, path)
31006:    elif item == "script_Execute" : FFRMYv(self, BF(FFimQ3, self, BF(self.session.openWithCallback, self.VVcPTN, CCtzVm, VVGd7m=path)), "Run File ?\n\n%s" % os.path.basename(path))
31007:    elif item == "script_Edit"  : CCyMCP(self, path, VVbYwR=self.VVFGYD)
31008:    elif item == "VVNUmp"  : self.VVNUmp(path)
31009:  def VVNUmp(self, path):
31010:   txt = FFYVq0(path)
31011:   var, ev, scr = txt.partition("eval")
31012:   if ev:
31013:    outF = path + "__.sh"
31014:    var, scr = var.strip(), scr.strip()
31015:    if FF7ymp("%s\necho -e %s > '%s'" % (var, scr, outF)):
31016:     FFipXT(self, "Saved to:\n\n%s" % outF)
31017:     self.VVcPTN()
31018:    else: FFdw58(self, "Converstion Error")
31019:   else: FFdw58(self, "No Eval")
31020:  def VVhJGC(self, addSep=False):
31021:   VV3wat = []
31022:   if addSep:
31023:    VV3wat.append(VVAL3j)
31024:   VV3wat.append((VVFuwR + "Play / Browse Channels", "m3u_Browse" ))
31025:   VV3wat.append((VVFuwR + "Edit"     , "m3u_Edit" ))
31026:   VV3wat.append((VVFuwR + "View"     , "m3u_View" ))
31027:   return VV3wat
31028:  def VVJ8wl(self, path):
31029:   FFLFTC(self, BF(self.VVGWWo, path), title="M3U/M3U8 File Options", VV3wat=self.VVhJGC(), width=550)
31030:  def VVGWWo(self, path, item=None):
31031:   if item is not None:
31032:    if   item == "m3u_Browse" : CCjZbZ(self, CCjZbZ.VVry11, m3uF=path)
31033:    elif item == "m3u_Edit"  : CCyMCP(self, path, VVbYwR=self.VVFGYD)
31034:    elif item == "m3u_View"  : FFaOUK(self, path)
31035:  def VVIS6B(self, path):
31036:   if FFCyVu(path) : FFimQ3(self, BF(CC7ocD.VV9PZW, self, path, BF(self.VVV4zJ, path)), title="Loading Codecs ...")
31037:   else    : FF8Wsn(self, path)
31038:  def VVV4zJ(self, path, item=None):
31039:   if item:
31040:    FFaOUK(self, path, encLst=item)
31041:  def VVJVpo(self, path, title, asUtf8):
31042:   if FFCyVu(path) : FFimQ3(self, BF(CC7ocD.VV9PZW, self, path, BF(self.VV7GCL, path, title, asUtf8), title="Original Encoding"), title="Loading Codecs ...")
31043:   else    : FF8Wsn(self, path)
31044:  def VV7GCL(self, path, title, asUtf8, fromEnc=None):
31045:   if fromEnc:
31046:    if asUtf8: self.VVTVQR(path, title, fromEnc, "UTF-8")
31047:    else  : CC7ocD.VViA40(self, BF(self.VVTVQR, path, title, fromEnc), title="Convert to Encoding")
31048:  def VVTVQR(self, path, title, fromEnc, toEnc):
31049:   if toEnc:
31050:    if not FFCyVu(path):
31051:     FF28n1(self, "Cannot open file", 2000)
31052:     return
31053:    try:
31054:     outFile = "%s_%s%s" % (path, toEnc, os.path.splitext(path)[1])
31055:     with ioOpen(path, "r", encoding=fromEnc) as src:
31056:      BLOCK_1MB = 1048576
31057:      with ioOpen(outFile, "w", encoding=toEnc) as dest:
31058:       while True:
31059:        cont = src.read(BLOCK_1MB)
31060:        if not cont:
31061:         break
31062:        dest.write(cont)
31063:      txt  = FFjt5L("Successful\n\n", VVSGsk)
31064:      txt += FFjt5L("From Encoding (%s):\n" % fromEnc, VV1fx4)
31065:      txt += "%s\n\n" % path
31066:      txt += FFjt5L("To Encoding (%s):\n" % toEnc, VV1fx4)
31067:      txt += "%s\n\n" % outFile
31068:      FF4lCP(self, txt, title=title)
31069:    except:
31070:     FFwgGB(outFile)
31071:     FFdw58(self, 'Cannot encode the file:\n%s\n\nFrom "%s" to "%s"' % (path, fromEnc, toEnc), title=title)
31072:    self.VVcPTN()
31073:  def VVEDRf(self, path):
31074:   title = "File Line-Break Conversion"
31075:   FFRMYv(self, BF(self.VVzzZ9, path, title), "Convert Line-Breaks to Unix for the file:\n\n%s" % path, title=title)
31076:  def VVzzZ9(self, path, title):
31077:   if FFCyVu:
31078:    with open(path, 'rb') as f:
31079:     data = f.read()
31080:    done = False
31081:    if data:
31082:     CRLF, LF, To = b"\r\n", b"\r", b"\n"
31083:     totCRLF = data.count(CRLF)
31084:     totLF = data.count(LF)
31085:     if totCRLF or totLF:
31086:      done = True
31087:      with open(path, 'wb') as f:
31088:       f.write(data.replace(CRLF, To).replace(LF, To))
31089:    if done : txt = "%s\n\n%s" % (FFjt5L("File converted:", VVSGsk), path)
31090:    else : txt = "Nothing to convert in:\n\n%s" % path
31091:    FFipXT(self, txt, title=title)
31092:   else:
31093:    FF8Wsn(self, path, title=title)
31094:  def VVtQrS(self, path, newChmod):
31095:   FFRMYv(self, BF(self.VVArlz, path, newChmod), "Change Permission to %s ?\n\n%s" % (newChmod, os.path.basename(path)))
31096:  def VVArlz(self, path, newChmod):
31097:   cmd = "chmod %s '%s' %s" % (newChmod, path, VV1jg5)
31098:   result = FFTKR0(cmd)
31099:   if result == "Successful" : FFipXT(self, result)
31100:   else      : FFdw58(self, result)
31101:  def VV6ZhN(self, path):
31102:   parent = FFx9pN(path, False)
31103:   self.session.openWithCallback(self.VVDhOg, BF(CClYaF, mode=CClYaF.VV9N82, VV1pbK=parent, VVqlNR="Create Symlink here"))
31104:  def VVDhOg(self, newPath):
31105:   if len(newPath) > 0:
31106:    target = self.VV5pAO(self.VVQlTC())
31107:    target = FFVc4H(target)
31108:    linkName = FFxtW5(target)
31109:    dotIndex = linkName.find(".")
31110:    if dotIndex > -1:
31111:     linkName = linkName[:dotIndex]
31112:    newPath = FFoWxR(newPath)
31113:    link = newPath + linkName
31114:    if   os.path.islink(FFVc4H(link)) : txt = ""
31115:    elif os.path.ismount(link)     : txt = "MOUNT:"
31116:    elif os.path.isfile(link)     : txt = "FILE:"
31117:    elif os.path.isdir(link)     : txt = "DIRECTORY:"
31118:    else          : txt = ""
31119:    if len(txt) > 0:
31120:     FFdw58(self, "Name already used for %s\n\n%s" % (txt, link))
31121:     return
31122:    txt  = "-> TARGET:\n%s\n\n" % target
31123:    txt += "<- LINK:\n%s"  % link
31124:    FFRMYv(self, BF(self.VVMng9, target, link), "Create Soft Link ?\n\n%s" % txt, VVAgUy=True)
31125:  def VVMng9(self, target, link):
31126:   cmd = 'LINK="%s"; if [ -e "$LINK" ]; then rm "$LINK"; fi; ln -sfv "%s" "%s" &>/dev/null %s' % (link, target, link, VV1jg5)
31127:   result = FFTKR0(cmd)
31128:   if result == "Successful" : FFipXT(self, result)
31129:   else      : FFdw58(self, result)
31130:  def VVTxpl(self, path):
31131:   lastPart = FFxtW5(path)
31132:   FF4z45(self, BF(self.VVhyfF, path), title="Rename", defaultText=lastPart, message="Enter New Name:")
31133:  def VVhyfF(self, path, VVRD20):
31134:   if VVRD20:
31135:    parent = FFx9pN(path, True)
31136:    if os.path.isdir(path):
31137:     path = FFVc4H(path)
31138:    newName = parent + VVRD20
31139:    cmd = "mv '%s' '%s' %s" % (path, newName, VV1jg5)
31140:    if VVRD20:
31141:     if os.path.basename(path) != VVRD20:
31142:      message = "%s\n\nTo:\n\n%s" % (path, newName)
31143:      FFRMYv(self, BF(self.VViAkt, cmd), message, title="Rename file?")
31144:     else:
31145:      FFdw58(self, "Cannot use same name!", title="Rename")
31146:  def VViAkt(self, cmd):
31147:   result = FFTKR0(cmd)
31148:   if "Fail" in result:
31149:    FFdw58(self, result)
31150:   self.VVcPTN()
31151:  def VVH6Ci(self, preserve):
31152:   title="Archive to .tar.gz"
31153:   CCh3tv.VV7Nf4(self, VVLL7M=title, titleBg="#22003344", bodyBg="#22001122"
31154:       , VVixvy  = BF(self.VVdTnh, title, preserve)
31155:       , VVbYwR = BF(self.VVPk1o, title))
31156:  def VVdTnh(self, title, preserve, VVXyP6):
31157:   totSel = self["myMenu"].VVhxM5()
31158:   totOk = totFail = 0
31159:   VVXyP6.VVq8NF(totSel)
31160:   VVXyP6.VVNc18 = ["", totSel, totOk, totFail, ""]
31161:   VVXyP6.VVaks5("Prepareing targz file")
31162:   VVXgOC = self["myMenu"].VVWyCw()
31163:   lastPart = FFxtW5(VVXgOC) or "archive"
31164:   outF = os.path.join(VVXgOC, lastPart + ".tar.gz")
31165:   c = 0
31166:   while FFCyVu(outF):
31167:    c += 1
31168:    outF = os.path.join(VVXgOC, lastPart + "_%d.tar.gz" % c)
31169:   totOk = totFail = 0
31170:   path = ""
31171:   try:
31172:    with iTar.open(outF, mode="w:gz") as tarF:
31173:     for row in self["myMenu"].list:
31174:      if not VVXyP6 or VVXyP6.isCancelled:
31175:       return
31176:      if row[2][6]:
31177:       VVXyP6.VVxtQs(1)
31178:       name  = FFVc4H(row[0][0])
31179:       lastPath = FFxtW5(name)
31180:       path  = os.path.join(VVXgOC, name)
31181:       tarF.add(path, arcname=None if preserve else lastPath)
31182:       totOk += 1
31183:       if VVXyP6:
31184:        VVXyP6.VVNc18 = [outF, totSel, totOk, totFail, path]
31185:        VVXyP6.VVK5RO(totOk, lastPath)
31186:   except:
31187:    totFail += 1
31188:    if VVXyP6:
31189:     VVXyP6.VVNc18 = [outF, totSel, totOk, totFail, path]
31190:  def VVPk1o(self, title, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
31191:   outF, totSel, totOk, totFail, path = VVNc18
31192:   txt  = "%s:\n%s\n\n"   % (FFjt5L("Output File", VVSGsk), outF)
31193:   txt += "Total\t: %d\n"  % totSel
31194:   txt += "Archived\t: %d\n" % totOk
31195:   if totFail   : txt += FFjt5L("Failed\t: %d\n" % totFail, VVz22H)
31196:   if not VVRI6P: txt += "%s\n%s" % (FFjt5L("\nCancelled while copying:", VVz22H), path)
31197:   FF4lCP(self, txt, title=title)
31198:   self.VVcPTN()
31199:  @FFOAKH()
31200:  def VVhrqo(self, isMove):
31201:   lst = []
31202:   srcDir = self["myMenu"].VVWyCw()
31203:   totSel = self["myMenu"].VVhxM5()
31204:   if totSel == 0:
31205:    ndx = self["myMenu"].l.getCurrentSelectionIndex()
31206:    row = self["myMenu"].list[ndx]
31207:    lst = [FFxtW5(row[0][0])]
31208:   else:
31209:    for row in self["myMenu"].list:
31210:     if row[2][6]:
31211:      lst.append(FFxtW5(row[0][0]))
31212:   if lst:
31213:    sDir = CFG.lastCopyMoveDir.getValue() or self["myMenu"].VVWyCw()
31214:    self.session.openWithCallback(BF(self.VVPOxl, isMove, lst, srcDir), BF(CClYaF, mode=CClYaF.VV9N82, VV1pbK=sDir, VVqlNR="Move to here" if isMove else "Paste here"))
31215:   else:
31216:    FFjADj(self, "Nothing selected", 1500)
31217:  def VVPOxl(self, isMove, lst, srcDir, dstDir):
31218:   if dstDir:
31219:    FFjt1c(CFG.lastCopyMoveDir, dstDir)
31220:    FFimQ3(self, BF(self.session.openWithCallback, self.VVKtUM, CCZCVj, isMove, lst, srcDir, dstDir))
31221:  def VVKtUM(self):
31222:   self.VVcPTN()
31223:  def VV49nJ(self):
31224:   tot = self["myMenu"].VVhxM5()
31225:   FFRMYv(self, self.VVezeB, "Delete %d item%s ?" % (tot, FFcacr(tot)), title="Delete Selection")
31226:  @FFOAKH("Deleting ...", clearMsg=False)
31227:  def VVezeB(self):
31228:   path = self["myMenu"].VVWyCw()
31229:   for row in self["myMenu"].list:
31230:    if row[2][6]:
31231:     FFOzbr(os.path.join(path, row[0][0]))
31232:   FF28n1(self)
31233:   self.VVcPTN()
31234:  def VVRs0f(self, path):
31235:   typ = FFTWKU(path)
31236:   FFRMYv(self, BF(self.VVOGp8, path), "%s\n\nDelete %s ?" % (path, typ), title="Delete %s" % typ)
31237:  @FFOAKH("Deleting ...", clearMsg=False)
31238:  def VVOGp8(self, path):
31239:   FFOzbr(path)
31240:   FF28n1(self)
31241:   self.VVcPTN()
31242:  def VVeGt3(self, path, isFile):
31243:   VVXgOC = self.VV21cx()
31244:   if isFile:
31245:    name = CClYaF.VVVDVC(VVXgOC, "file")
31246:   else:
31247:    fPath, fExt = os.path.splitext(path)
31248:    if fPath and fExt and not VVmJwX(fPath) : name = os.path.basename(fPath)
31249:    else          : name = CClYaF.VVVDVC(VVXgOC, "dir")
31250:   self.VVEcgH(VVXgOC, name, isFile)
31251:  def VVEcgH(self, VVXgOC, name, isFile):
31252:   subj = "File" if isFile else "Directory"
31253:   title = "Create New %s" % subj
31254:   FF4z45(self, BF(self.VVRRa2, VVXgOC, name, isFile, title), title=title, defaultText=name, message="Enter %s Name:" % subj)
31255:  def VVRRa2(self, VVXgOC, name, isFile, title, nName):
31256:   if not nName or not nName.strip(): return
31257:   nName = nName.strip()
31258:   path = os.path.join(VVXgOC, nName)
31259:   if nName != FFOu5Y(nName):
31260:    self.VVEcgH(VVXgOC, nName, isFile)
31261:    FFdw58(self, "Unallowed characters in name", title)
31262:   elif FFCyVu(path):
31263:    self.VVEcgH(VVXgOC, nName, isFile)
31264:    FFdw58(self, "Already exists:\n\n%s" % VVXgOC, title)
31265:   else:
31266:    if isFile: cmd = "touch '%s' %s" % (path, VV1jg5)
31267:    else  : cmd = "mkdir '%s' %s" % (path, VV1jg5)
31268:    result = FFTKR0(cmd)
31269:    if not "Successful" in result:
31270:     FFdw58(self, result, title)
31271:    self.VVcPTN(moveTo=os.path.basename(path) if isFile else FFoWxR(path))
31272:  def VV8nL2(self, path):
31273:   c1, c2, c3, c4 = VVJEMb, VVFuwR, VVIH76, VVA4XU
31274:   VV3wat = []
31275:   VV3wat.append((c1 + "List Package Files"         , "VVI3xN"     ))
31276:   VV3wat.append((c1 + "Package Information"         , "package_Info"     ))
31277:   VV3wat.append(VVAL3j)
31278:   VV3wat.append((c2 + "Install Package"          , "VVtZVo_CheckVersion" ))
31279:   VV3wat.append((c2 + "Install Package (force reinstall)"     , "VVtZVo_ForceReinstall" ))
31280:   VV3wat.append((c2 + "Install Package (force overwrite)"     , "VVtZVo_ForceOverwrite" ))
31281:   VV3wat.append((c2 + "Install Package (force downgrade)"     , "VVtZVo_ForceDowngrade" ))
31282:   VV3wat.append((c2 + "Install Package (ignore failed dependencies)"  , "VVtZVo_IgnoreDepends" ))
31283:   VV3wat.append(VVAL3j)
31284:   VV3wat.append((c3 + "Remove Related Package"        , "VVGjSm_ExistingPackage" ))
31285:   VV3wat.append((c3 + "Remove Related Package (force remove)"    , "VVGjSm_ForceRemove"  ))
31286:   VV3wat.append((c3 + "Remove Related Package (ignore failed dependencies)" , "VVGjSm_IgnoreDepends" ))
31287:   VV3wat.append(VVAL3j)
31288:   VV3wat.append(("Generate Feed Listing Info."        , "VV2eko"    ))
31289:   VV3wat.append(("Convert to %s" % ("DEB" if path[-3:] == "ipk" else "IPK") , "VVcd3p1"     ))
31290:   VV3wat.append(("Convert to .tar.gz %s(data part only)" % c4    , "VVcd3p2"     ))
31291:   VV3wat.append(("Extract Files"           , "VVtTVH"     ))
31292:   VV3wat.append(("Unbuild Package"           , "VVfaxL"     ))
31293:   FFLFTC(self, BF(self.VVJKZj, path), VV3wat=VV3wat, VVwdmN=28, height=1000)
31294:  def VVJKZj(self, path, item=None):
31295:   if item is not None:
31296:    if   item == "VVI3xN"      : self.VVI3xN(path)
31297:    elif item == "package_Info"      : FFimQ3(self, BF(CCeSkW.VVLFsP, self, path))
31298:    elif item == "VVtZVo_CheckVersion"  : self.VVtZVo(path, VVwFAi     )
31299:    elif item == "VVtZVo_ForceReinstall" : self.VVtZVo(path, VVj9MD )
31300:    elif item == "VVtZVo_ForceOverwrite" : self.VVtZVo(path, VVD9EU )
31301:    elif item == "VVtZVo_ForceDowngrade" : self.VVtZVo(path, VVRA2G )
31302:    elif item == "VVtZVo_IgnoreDepends" : self.VVtZVo(path, VVA8Es )
31303:    elif item == "VVGjSm_ExistingPackage" : self.VVGjSm(path, VVAdjB    )
31304:    elif item == "VVGjSm_ForceRemove"  : self.VVGjSm(path, VV9Fg4 )
31305:    elif item == "VVGjSm_IgnoreDepends"  : self.VVGjSm(path, VVYJEp )
31306:    elif item == "VV2eko"     : self.VV2eko(path)
31307:    elif item == "VVcd3p1"     : self.VVcd3p(path, False)
31308:    elif item == "VVcd3p2"     : self.VVcd3p(path, True)
31309:    elif item == "VVtTVH"     : self.VVtTVH(path)
31310:    elif item == "VVfaxL"     : self.VVfaxL(path)
31311:  def VVI3xN(self, path):
31312:   cTxt = lambda x: " echo -e '\n%s' %s;" % (x, FFSPDv(x, VV1fx4))
31313:   txt  = FFjt5L("Package File:\n", VV1fx4)
31314:   txt += "%s\n\n" % path
31315:   txt += FFjt5L("Contents\n", VV1fx4)
31316:   txt += "\n".join(FF3xOt("ar -t '%s';" % path))
31317:   FF4lCP(self, txt)
31318:  def VV2eko(self, path):
31319:   if CCeSkW.VVq71e(self):
31320:    txt, mTime = CCeSkW.VVy0xB(path)
31321:    pFile = "%s-Packages-File.txt" % path
31322:    tFile = "%s-Packages.stamps.txt" % path
31323:    with open(pFile, "w") as pF: pF.write("%s\n" % txt)
31324:    with open(tFile, "w") as tF: tF.write("%s\n" % mTime)
31325:    self.VVcPTN()
31326:    txt  = "Result files:\n\n"
31327:    txt += "%s\n\n" % os.path.basename(pFile)
31328:    txt += "%s" % os.path.basename(tFile)
31329:    FF4lCP(self, txt)
31330:  def VVtTVH(self, path):
31331:   dest = FFx9pN(path, True) + os.path.basename(path)[:-4]
31332:   cmd  =  FFvQ9y()
31333:   cmd += 'if [ "$allOK" -eq "1" ]; then '
31334:   cmd +=    FFb2oQ("mkdir '%s'" % dest)
31335:   cmd +=    FFb2oQ("cd '%s'" % dest)
31336:   cmd += "  echo 'Extrcting files ...';"
31337:   cmd += "  ar -xo '%s';" % path
31338:   cmd += "  echo -e 'Done.\n';"
31339:   cmd += "  echo -e 'Output Directory:\n%s' %s;" % (dest, FFSPDv(dest, VVSGsk))
31340:   cmd += "fi;"
31341:   FFbi5l(self, cmd, VVoasw=self.VVcPTN)
31342:  def VVfaxL(self, path):
31343:   outP = path + "_"
31344:   VVtdm0 = "DEBIAN" if path.endswith(".deb") else "CONTROL"
31345:   binCmd = "&& rm -f \"$FILE\";"
31346:   dataCmd = "\"$FILE\" -C '%s' && rm -f \"$FILE\";" % outP
31347:   contCmd = "\"$FILE\" -C \"$CONTPATH\" && rm -f \"$FILE\";"
31348:   zstCmd = "--use-compress-program=unzstd"
31349:   zstErr = "NOTE: zstd not installed to decompress :"
31350:   cmd  = FFvQ9y()
31351:   cmd += 'if [ "$allOK" -eq "1" ]; then '
31352:   cmd += "  rm -rf '%s' > /dev/null 2>&1;" % outP
31353:   cmd += "  mkdir '%s';"      % outP
31354:   cmd += "  CONTPATH='%s/%s';"    % (outP, VVtdm0)
31355:   cmd += '  mkdir "$CONTPATH";'
31356:   cmd += "  cd '%s';"       % outP
31357:   cmd += "  echo 'Unpacking ...';"
31358:   cmd += "  ar -x '%s';"      % path
31359:   cmd += "  FILE='%s/debian-binary';  [ -f \"$FILE\" ]             %s"  % (outP, binCmd)
31360:   cmd += "  FILE='%s/data.tar.gz';    [ -f \"$FILE\" ] && tar -xzf %s"  % (outP, dataCmd)
31361:   cmd += "  FILE='%s/control.tar.gz'; [ -f \"$FILE\" ] && tar -xzf %s"  % (outP, contCmd)
31362:   cmd += "  FILE='%s/data.tar.xz';    [ -f \"$FILE\" ] && tar -xJf %s"  % (outP, dataCmd)
31363:   cmd += "  FILE='%s/control.tar.xz'; [ -f \"$FILE\" ] && tar -xJf %s"  % (outP, contCmd)
31364:   if FFayeZ("unzstd"):
31365:    cmd += "  FILE='%s/data.tar.zst';   [ -f \"$FILE\" ] && tar %s -xf  %s" % (outP, zstCmd, dataCmd)
31366:    cmd += "  FILE='%s/control.tar.zst';[ -f \"$FILE\" ] && tar %s -xf  %s" % (outP, zstCmd, contCmd)
31367:   else:
31368:    cmd += "  FILE='%s/data.tar.zst';   [ -f \"$FILE\" ] && echo '%s data.tar.zst' %s;" % (outP, zstErr, FFSPDv(zstErr, VVYjI5))
31369:    cmd += "  FILE='%s/control.tar.zst';[ -f \"$FILE\" ] && echo '%s control.tar.zst' %s;" % (outP, zstErr, FFSPDv(zstErr, VVYjI5))
31370:   cmd += "  echo -e 'Done.\n';"
31371:   cmd += "  echo -e '\nOutput Directory:\n%s' %s;" % (outP, FFSPDv(outP, VVSGsk))
31372:   cmd += "fi;"
31373:   FFbi5l(self, cmd, VVoasw=self.VVcPTN)
31374:  def VVcd3p(self, path, toTar):
31375:   if CCeSkW.VVq71e(self):
31376:    outF = path[:-3]
31377:    if toTar:
31378:     title = "Convert to tar.gz"
31379:     outF += "tar.gz"
31380:    elif path.endswith(".ipk"):
31381:     title = "Convert to DEB"
31382:     outF += "deb"
31383:    else:
31384:     title = "Convert to IPK"
31385:     outF += "ipk"
31386:    if FFCyVu(path):
31387:     fnc = BF(self.VVlbUI, path, outF, toTar, title)
31388:     if FFCyVu(outF) : FFRMYv(self, fnc, "File already exists:\n\n%s\n\nOverwrite ?" % os.path.basename(outF))
31389:     else    : fnc()
31390:    else:
31391:     FF8Wsn(self, path)
31392:  @FFOAKH("Converting ...")
31393:  def VVlbUI(self, path, outF, toTar, title):
31394:   wDir = "/tmp/ajp_tmpDir"
31395:   def VVs0FP():
31396:    FFpwZS("rm -rf '%s'" % wDir)
31397:   def VVQ5VQ(txt):
31398:    FFdw58(self, txt, title=title)
31399:   def VVOujN():
31400:    FFipXT(self, "Converted to:\n\n%s" % outF, title=title)
31401:    VVs0FP()
31402:    self.VVcPTN()
31403:   VVs0FP()
31404:   FFpwZS("rm -f '%s'" % outF)
31405:   if not FFpwZS("mkdir -p '%s';" % wDir):
31406:    VVQ5VQ("Cannot create working dir.")
31407:    return
31408:   if not FFpwZS("cd '%s'; ar -x '%s'" % (wDir, path)):
31409:    VVQ5VQ("Cannot extract package files.")
31410:    return
31411:   files = FF3xOt("find '%s' -type f" % wDir)
31412:   if files:
31413:    for fil in files:
31414:     if   fil.endswith(".gz"): tool = "gzip"
31415:     elif fil.endswith(".xz"): tool = "xz"
31416:     else     : tool = ""
31417:     if tool:
31418:      if not FF7ymp("which %s" % tool):
31419:       VVQ5VQ("You need to install : %s" % tool)
31420:       return
31421:      if not FF7ymp("%s -d '%s'" % (tool, fil)):
31422:       VVQ5VQ("Cannot decompress file:\n\n%s" % os.path.basename(fil))
31423:       return
31424:   else:
31425:    VVQ5VQ("No files extracted from package.")
31426:    return
31427:   if toTar:
31428:    fName = os.path.basename(path)
31429:    dFile = os.path.join(wDir, "data.tar")
31430:    if FFCyVu(dFile):
31431:     if FF7ymp("gzip < '%s' > '%s'" % (dFile, outF)):
31432:      VVOujN()
31433:     else:
31434:      VVQ5VQ("Cannot create .tar.gz file for:\n\n%s" % fName)
31435:    else:
31436:     VVQ5VQ("No data in package file:\n\n%s" % fName)
31437:    return
31438:   tool = "gzip" if outF.endswith("ipk") else "xz"
31439:   for fil in FF3xOt("find '%s' -type f" % wDir):
31440:    if fil.endswith(".tar"):
31441:     if not FF7ymp("%s '%s'" % (tool, fil)):
31442:      VVQ5VQ("Cannot compress file:\n\n%s" % os.path.basename(fil))
31443:      return
31444:   files = FF3xOt("find '%s' -type f" % wDir)
31445:   if not files :
31446:    VVQ5VQ("Not enough files in package.")
31447:    return
31448:   debF = ctrlF = dataF = ""
31449:   for fil in files:
31450:    fName = os.path.splitext(os.path.basename(fil))[0]
31451:    if   fName == "debian-binary" : debF = fil
31452:    elif fName == "control.tar"  : ctrlF = fil
31453:    elif fName == "data.tar"  : dataF = fil
31454:   if   not debF : err = "debian-binary"
31455:   elif not ctrlF : err = "control"
31456:   elif not dataF : err = "data"
31457:   else   : err = ""
31458:   if err :
31459:    VVQ5VQ("Missing '%s' file." % err)
31460:    return
31461:   if FFpwZS("ar -r '%s' '%s' '%s' '%s'" % (outF, debF, ctrlF, dataF)):
31462:    VVOujN()
31463:   else:
31464:    VVQ5VQ("Cannot create package ('ar' failed).")
31465:  def VVtZVo(self, path, cmdOpt):
31466:   cmd = FF5sZa(cmdOpt, path)
31467:   if cmd:
31468:    cmd = "%s && echo -e '\nSUCCESSFUL' || echo -e '\nERROR FOUND !'" % cmd
31469:    FFRMYv(self, BF(FFbi5l, self, cmd, VVoasw=FF2Wqb), "Install Package ?\n\n%s" % os.path.basename(path))
31470:   else:
31471:    FFfone(self)
31472:  @FFOAKH()
31473:  def VVGjSm(self, path, cmdOpt):
31474:   infCmd = FF5sZa(VVaS8u, path)
31475:   if not infCmd:
31476:    FFfone(self)
31477:    return
31478:   pkg = FFQ45w("%s | grep Package" % infCmd)
31479:   pkg = pkg.partition(":")[2].strip()
31480:   if not pkg:
31481:    FFdw58(self, "Cannot read Package Name from file.")
31482:    return
31483:   if CCeSkW.VVvDqA(pkg):
31484:    cmd = FF5sZa(cmdOpt, pkg)
31485:    FFRMYv(self, BF(FFbi5l, self, cmd, VVoasw=FF2Wqb), "Remove Package:\n\n%s" % pkg)
31486:   else:
31487:    FFdw58(self, "Package not installed:\n( %s )\n\nFrom file:\n%s" % (pkg, os.path.basename(path)))
31488:  @FFOAKH()
31489:  def VVKeBf(self, path):
31490:   title = FFxtW5(path)
31491:   pkg, err = CCeSkW.VVV8mM(path)
31492:   if pkg : CCeSkW.VVLFsP(self, pkg, title)
31493:   else : FFdw58(self, "No package info.", title)
31494:  def VVwKHY(self, path, isDir):
31495:   txt1 = "Archive to "
31496:   txt2 = "Archive (Preserve Path Structure) to "
31497:   VV3wat = []
31498:   VV3wat.append(("%s.tar"  % txt1 , "archDir_tar"  ))
31499:   VV3wat.append(("%s.tar.gz" % txt1 , "archDir_tar_gz" ))
31500:   VV3wat.append(("%s.tar.xz" % txt1 , "archDir_tar_xz" ))
31501:   VV3wat.append(("%s.tar.bz2" % txt1 , "archDir_tar_bz2" ))
31502:   VV3wat.append(("%s.zip"  % txt1 , "archDir_zip"  ))
31503:   VV3wat.append(VVAL3j)
31504:   VV3wat.append(("%s.tar"  % txt2 , "archPath_tar" ))
31505:   VV3wat.append(("%s.tar.gz" % txt2 , "archPath_tar_gz" ))
31506:   VV3wat.append(("%s.tar.xz" % txt2 , "archPath_tar_xz" ))
31507:   VV3wat.append(("%s.tar.bz2" % txt2 , "archPath_tar_bz2"))
31508:   VV3wat.append(("%s.zip"  % txt2 , "archPath_zip" ))
31509:   if isDir and not self.VVJuPG:
31510:    VV3wat.append(VVAL3j)
31511:    VV3wat.append(('Convert to "ipk" Package', "convertDirToIpk" ))
31512:    VV3wat.append(('Convert to "deb" Package', "convertDirToDeb" ))
31513:   if isDir: c1, c2, title = "#11003322", "#11002222", "Archive Directory"
31514:   else : c1, c2, title = "#11003344", "#11002244", "Archive File"
31515:   FFLFTC(self, BF(self.VVOcev, path, isDir, title), VV3wat=VV3wat, title=title, VVwltY=c1, VVkxBG=c2)
31516:  def VVOcev(self, path, isDir, title, item):
31517:   if item is not None:
31518:    if   item == "archDir_tar"  : self.VVXyc1(title, path, isDir, ".tar" , False)
31519:    elif item == "archDir_tar_gz" : self.VVXyc1(title, path, isDir, ".tar.gz" , False)
31520:    elif item == "archDir_tar_xz" : self.VVXyc1(title, path, isDir, ".tar.xz" , False)
31521:    elif item == "archDir_tar_bz2" : self.VVXyc1(title, path, isDir, ".tar.bz2", False)
31522:    elif item == "archDir_zip"  : self.VVXyc1(title, path, isDir, ".zip" , False)
31523:    elif item == "archPath_tar"  : self.VVXyc1(title, path, isDir, ".tar" , True)
31524:    elif item == "archPath_tar_gz" : self.VVXyc1(title, path, isDir, ".tar.gz" , True)
31525:    elif item == "archPath_tar_xz" : self.VVXyc1(title, path, isDir, ".tar.xz" , True)
31526:    elif item == "archPath_tar_bz2" : self.VVXyc1(title, path, isDir, ".tar.bz2", True)
31527:    elif item == "archPath_zip"  : self.VVXyc1(title, path, isDir, ".zip" , True)
31528:    elif item == "convertDirToIpk" : self.VVNgAR(path, False)
31529:    elif item == "convertDirToDeb" : self.VVNgAR(path, True)
31530:  def VVNgAR(self, path, VVyCS0):
31531:   self.session.openWithCallback(self.VVcPTN, CCxz86, path=path, VVyCS0=VVyCS0)
31532:  def VVXyc1(self, title, path, isDir, fileExt, preserveDirStruct):
31533:   parent  = FFx9pN(path, True)
31534:   lastPart = FFxtW5(path)
31535:   archFile = lastPart + fileExt
31536:   resultFile = parent + archFile
31537:   if preserveDirStruct:
31538:    archFile = resultFile
31539:    targetDir = parent + lastPart
31540:   else:
31541:    targetDir = lastPart
31542:   if isDir: outFile, srcTxt = archFile , "Source Directory"
31543:   else : outFile, srcTxt = resultFile , "Source File"
31544:   if   fileExt == ".tar"  : archCmd, toolCmd = "tar -cvf"  , "allOK='1';"
31545:   elif fileExt == ".tar.gz" : archCmd, toolCmd = "tar -cvzf" , "allOK='1';"
31546:   elif fileExt == ".tar.xz" : archCmd, toolCmd = "tar -cvJf" , FFKbNE()
31547:   elif fileExt == ".tar.bz2" : archCmd, toolCmd = "tar -cvjf" , FFMAzK("bzip2" , "bzip2" , "BZip2" )
31548:   elif fileExt == ".zip"  : archCmd, toolCmd = "zip -r"  , FFMAzK("zip" , "zip"  , "Zip"  )
31549:   if preserveDirStruct:
31550:    if archCmd.startswith("tar") and targetDir.startswith("/") : archCmd = "%s '%s' -C / '%s';" % (archCmd, outFile, targetDir[1:])
31551:    else              : archCmd = "%s '%s' '%s';"    % (archCmd, outFile, targetDir)
31552:   else:
31553:    if isDir: archCmd = "cd '%s'; %s '../%s' *;" % (path, archCmd, outFile)
31554:    else : archCmd = "cd '%s'; %s '%s' '%s';" % (parent, archCmd, outFile, os.path.basename(path))
31555:   failed = "Process failed !"
31556:   sep  = " echo -e '%s';" % SEP
31557:   cmd  = toolCmd
31558:   cmd += 'if [ "$allOK" -eq "1" ]; then '
31559:   cmd += " echo -e 'Archiving ...\n';"
31560:   cmd +=   sep
31561:   cmd +=   FFb2oQ("rm -f '%s'" % archFile)
31562:   cmd +=   archCmd
31563:   cmd += " cd '%s';"      % parent
31564:   cmd +=   sep
31565:   cmd += " if [ $? -ne 0 ]; then "
31566:   cmd += "  echo -e '\n%s\n' %s;"   % (failed, FFSPDv(failed, VVyFI2))
31567:   cmd += "  rm -f '%s' > /dev/null 2>&1;" % archFile
31568:   cmd += " elif [ -f '%s' ]; then "  % archFile
31569:   cmd += "  chmod 644 '%s';"    % archFile
31570:   cmd += "  echo -e '\nDONE\n';"
31571:   cmd += "  echo -e '%s:' %s;"   % (srcTxt, FFSPDv(srcTxt, VVGCYL))
31572:   cmd += "  echo -e '%s\n';"    % path
31573:   cmd += "  echo -e '%s:' %s;"   % ("Output", FFSPDv("Output", VVSGsk))
31574:   cmd += "  echo -e '%s\n';"    % outFile
31575:   cmd += " else"
31576:   cmd += "  echo -e '\n%s\n' %s;"   % (failed, FFSPDv(failed, VVYjI5))
31577:   cmd += "  rm -f '%s' > /dev/null 2>&1;" % archFile
31578:   cmd += " fi;"
31579:   cmd +=   sep
31580:   cmd += "fi;"
31581:   FFIdSm(self, cmd, VVoasw=self.VVcPTN, title=title)
31582:  def VV2Fo3(self, path, isAll):
31583:   if isAll: title, pathLst = "Add all Media in Directory to a Bouquet", CClYaF.VVhadP(FFx9pN(path, True))
31584:   else : title, pathLst = "Add Media File to a Bouquet"   , [path]
31585:   picker = CCMvE7(self, self, title, BF(self.VVZXrb, pathLst))
31586:  def VVZXrb(self, pathLst):
31587:   return CCMvE7.VVvoK9(pathLst)
31588:  def VVJf2H(self, VVTiJ2):
31589:   title = "Convert .zip to .tar.gz"
31590:   if iZip.is_zipfile(VVTiJ2):
31591:    tarPath = os.path.splitext(VVTiJ2)[0] + ".tar.gz"
31592:    fnc  = BF(self.VVuyIo, VVTiJ2, tarPath, title)
31593:    if FFCyVu(tarPath) : FFRMYv(self, fnc, "File already exists:\n\n%s\n\nOverwrite ?" % os.path.basename(tarPath), title=title)
31594:    else     : fnc()
31595:   else:
31596:    FFdw58(self, "Invalid zip file:\n\n%s" % os.path.basename(VVTiJ2), title=title)
31597:  @FFOAKH("Converting ...")
31598:  def VVuyIo(self, VVTiJ2, tarPath, title):
31599:   try:
31600:    with iZip.ZipFile(VVTiJ2) as zipF:
31601:     with iTar.open(tarPath, "w:gz") as tarF:
31602:      for zipInfo in zipF.infolist():
31603:       tarInfo = iTar.TarInfo(name=zipInfo.filename)
31604:       tarInfo.size = zipInfo.file_size
31605:       try: tarInfo.mtime = mktime(tuple(list(zipInfo.date_time) + [-1, -1, -1]))
31606:       except: tarInfo.mtime = mktime((2025, 1, 1, 0, 0, 0, -1, -1, -1))
31607:       tarF.addfile(tarinfo=tarInfo, fileobj=zipF.open(zipInfo.filename))
31608:    ok = True
31609:   except:
31610:    ok = False
31611:   if ok and FFCyVu(tarPath):
31612:    FF4lCP(self, "Done\n\nSource File\t: %s\nOutput File\t: %s" % (os.path.basename(VVTiJ2), os.path.basename(tarPath)), title=title)
31613:    self.VVcPTN()
31614:   else:
31615:    FFwgGB(tarPath)
31616:    FFdw58(self, "Error while converting.", title=title)
31617:  def VVmefC(self, tarPath):
31618:   title = "Convert .tar.gz to .zip"
31619:   if iTar.is_tarfile(tarPath):
31620:    VVTiJ2 = tarPath[:-7] + ".zip"
31621:    fnc  = BF(self.VV3B8l, tarPath, VVTiJ2, title)
31622:    if FFCyVu(VVTiJ2) : FFRMYv(self, fnc, "File already exists:\n\n%s\n\nOverwrite ?" % os.path.basename(VVTiJ2), title=title)
31623:    else     : fnc()
31624:   else:
31625:    FFdw58(self, "Invalid tar file:\n\n%s" % os.path.basename(tarPath), title=title)
31626:  @FFOAKH("Converting ...")
31627:  def VV3B8l(self, tarPath, VVTiJ2, title):
31628:   try:
31629:    with iTar.open(tarPath) as tar:
31630:     with iZip.ZipFile(VVTiJ2, mode='w', compression=iZip.ZIP_DEFLATED) as zipF:
31631:      for mem in tar.getmembers():
31632:       if mem.isfile():
31633:        mtime = datetime.fromtimestamp(mem.mtime)
31634:        try: zipInfo = iZip.ZipInfo(filename=mem.name, date_time=(mtime.year, mtime.month, mtime.day, mtime.hour, mtime.minute, mtime.second))
31635:        except: zipInfo = iZip.ZipInfo(filename=mem.name, date_time=(2025, 1, 1, 0, 0, 0))
31636:        zipF.writestr(zipInfo, tar.extractfile(mem).read(), compress_type=iZip.ZIP_DEFLATED)
31637:    ok = True
31638:   except:
31639:    ok = False
31640:   if ok and FFCyVu(tarPath):
31641:    FF4lCP(self, "Done\n\nSource File\t: %s\nOutput File\t: %s" % (os.path.basename(tarPath), os.path.basename(VVTiJ2)), title=title)
31642:    self.VVcPTN()
31643:   else:
31644:    FFwgGB(VVTiJ2)
31645:    FFdw58(self, "Error while converting.", title=title)
31646:  @FFOAKH("Converting ...")
31647:  def VVCQLE(self, path, ext2):
31648:   title = "Convert to .%s" % ext2
31649:   p1, ext1 = os.path.splitext(path)
31650:   p2 = "%s.%s" % (p1, ext2)
31651:   if   ext1 == ".zst" : cmd1 = "zstd"
31652:   elif ext1 == ".xz" : cmd1 = "xz"
31653:   else    : cmd1 = "gzip"
31654:   cmd2 = ext2 if ext2 == "xz" else "gzip"
31655:   cmd  = FFb2oQ("rm -f '%s'" % p2)
31656:   cmd += "%s -d < '%s' | %s > '%s'" % (cmd1, path, cmd2, p2)
31657:   if FF7ymp(cmd):
31658:    FFipXT(self, "Result:\n\n%s" % os.path.basename(p2), title=title)
31659:    self.VVcPTN()
31660:   else:
31661:    FFdw58(self, "Could not convert:\n\n%s" % path, title=title)
31662:  @FFOAKH()
31663:  def VV2if2(self, path, isFhd):
31664:   size = "1920x1080" if isFhd else "1280x720"
31665:   title = "Convert to MVI (%s)" % size
31666:   Dir  = FFoWxR(os.path.dirname(path))
31667:   filName = os.path.splitext(os.path.basename(path))[0]
31668:   m1v  = "%s%s_%s.m1v" % (Dir, filName, size)
31669:   mvi  = "%s%s_%s.mvi" % (Dir, filName, size)
31670:   FFpwZS("rm -f '%s' '%s'" % (m1v, mvi))
31671:   if FFpwZS("ffmpeg -i '%s' -r 25 -b:v 20000 -s %s '%s'" % (path, size, m1v)) and FFCyVu(m1v):
31672:    FFpwZS("mv -f '%s' '%s'" % (m1v, mvi))
31673:    self.VVcPTN()
31674:    FFipXT(self, "Converted to:\n\n%s" % os.path.basename(mvi), title=title)
31675:   else:
31676:    FFdw58(self, "Cannot convert this file !", title=title)
31677:  def VVL2ZB(self, path):
31678:   VV3wat, title, degS = [], "Rotate Image", str(u"\u00b0")
31679:   if CC6u6z.VV181X(self, title, False, install=True):
31680:    for i in range(90, 360, 90): VV3wat.append(("%s%s" % (i, degS), str(i)))
31681:    VV3wat.append(VVAL3j)
31682:    for i in range(1, 360): VV3wat.append(("%s%s" % (i, degS), str(i)))
31683:    VVaTeF = ("Expand", BF(self.VVBhnp, path, title))
31684:    FFLFTC(self, BF(self.VVjH68, path, title), VV3wat=VV3wat, width=700, VVaTeF=VVaTeF, VVlaGv=True, VVW5y5="OK = Same Size", title=title)
31685:  def VVBhnp(self, path, title, VV7tND, angle):
31686:   self.VVjH68(path, title, angle, rotExp=True)
31687:  def VVImxq(self, path):
31688:   VV3wat, title = [], "Flip Image"
31689:   if CC6u6z.VV181X(self, title, False, install=True):
31690:    VV3wat.append(("Horizontally" , "h"))
31691:    VV3wat.append(("Vertically" , "v"))
31692:    FFLFTC(self, BF(self.VVjH68, path, title), VV3wat=VV3wat, width=500, title=title)
31693:  @FFOAKH()
31694:  def VVjH68(self, path, title, item, rotExp=False):
31695:   if not item: return
31696:   rotTxt = "rotated_%s%s" % (item, "_exp" if rotExp else "")
31697:   flpTxt = "flipped_"
31698:   try:
31699:    from PIL import Image, ImageOps
31700:    im = Image.open(path)
31701:    if   item == "h" : res, im = flpTxt + "H", ImageOps.mirror(im)
31702:    elif item == "v" : res, im = flpTxt + "V", ImageOps.flip(im)
31703:    else    : res, im = rotTxt  , im.rotate(-int(item), expand=rotExp, resample=3)
31704:    fil, ext = os.path.splitext(path)
31705:    outF = "%s_%s%s" % (fil, res, ext)
31706:    im.save(outF)
31707:    self.VVcPTN()
31708:    FFipXT(self, "Saved to:\n\n%s" % outF, title=title)
31709:   except Exception as e:
31710:    FFdw58(self, str(e), title=title)
31711:  def VVpeV4(self, path):
31712:   title = "Save as"
31713:   if CC6u6z.VV181X(self, title, False, install=True):
31714:    fil, ext = os.path.splitext(path)
31715:    VV3wat = []
31716:    for s in ("png", "jpg", "gif", "tif", "bmp"):
31717:     VV3wat.append((s, ) if s == ext[1:] else (s, s))
31718:    FFLFTC(self, BF(self.VVgOjh, path, title), VV3wat=VV3wat, width=500, title=title)
31719:  @FFOAKH()
31720:  def VVgOjh(self, path, title, dstExt):
31721:   if not dstExt: return
31722:   try:
31723:    from PIL import Image, ImageSequence
31724:    im = Image.open(path)
31725:    outTyp = "RGBA" if dstExt == "png" else "RGB"
31726:    srcF, srcExt = os.path.splitext(path)
31727:    if srcExt in (".tif", ".gif"):
31728:     txt = "Saved tif Frames:\n\n"
31729:     name = "page" if srcExt == ".tif" else "frame"
31730:     for i, page in enumerate(ImageSequence.Iterator(im), start=1):
31731:      outF = "%s_%s_%03d.%s" % (path, name, i, dstExt)
31732:      page = page.convert(outTyp)
31733:      page.save(outF)
31734:      txt += "  %s\n" % os.path.basename(outF)
31735:     self.VVcPTN()
31736:     FF4lCP(self, txt, title=title)
31737:    else:
31738:     im = im.convert(outTyp)
31739:     outF = "%s.%s" % (srcF, dstExt)
31740:     fnc = BF(self.VVHG7m, title, im, outF)
31741:     if FFCyVu(outF) : FFRMYv(self, fnc, "Overwrite existing file ?\n\n%s" % outF, title=title)
31742:     else    : fnc()
31743:   except Exception as e:
31744:    FFdw58(self, str(e), title=title)
31745:  def VVHG7m(self, title, im, outF):
31746:   try:
31747:    im.save(outF)
31748:    self.VVcPTN()
31749:    FFipXT(self, "Saved to:\n\n%s" % outF, title=title)
31750:   except Exception as e:
31751:    FFdw58(self, str(e), title=title)
31752:  @FFOAKH()
31753:  def VV72l5(self, path, mode):
31754:   ext = "png" if mode == 1 else "jpg"
31755:   title = "Convert to %s" % ext
31756:   outF = path[:-3] + ext
31757:   FFwgGB(outF)
31758:   res = FFQ45w('ffmpeg -hide_banner -i "%s" -frames:v 1 "%s"' % (path, outF))
31759:   if FFCyVu(outF):
31760:    FFipXT(self, "Saved to:\n\n%s" % outF, title=title)
31761:    self.VVcPTN()
31762:   elif "unhandled version" in res : FFdw58(self, "Your ffmpeg cannot handle mvi.", title=title)
31763:   else       : FFdw58(self, "Conversion Error", title=title)
31764:  @FFOAKH()
31765:  def VVOiJy(self, path):
31766:   title = "Convert to Base64 String"
31767:   try:
31768:    ext = os.path.splitext(path)[1][1:].lower().replace("jpg", "jpeg")
31769:    outF = os.path.join(os.path.dirname(path), os.path.basename(path) + "_base64.txt")
31770:    with open(path, "rb") as f: b64 = b64encode(f.read()).decode()
31771:    with open(outF, "w") as f: f.write("data:image/%s;base64,%s" % (ext, b64))
31772:    FFipXT(self, "Saved to : %s\n\n" % outF, title=title)
31773:    self.VVcPTN()
31774:   except Exception as e:
31775:    FFdw58(self, str(e), title=title)
31776:  def VVxzz6(self, path):
31777:   title = "Set as PIcon for current channel"
31778:   pPath = CCafIt.VVjkKT()
31779:   if VVmJwX(pPath):
31780:    if CC6u6z.VV181X(self, title, False, cbFnc=BF(self.VVxzz6, path)):
31781:     picon = "%s%s.png" % (pPath, CC3rDi(self.session).VVXbok.strip(":").replace(":", "_").upper())
31782:     VV3wat = []
31783:     for item in ((50,30),(96,64),(100,60),(220,132),(400,160),(400,240),(500,300)):
31784:      VV3wat.append(("%d x %d" % (item), item))
31785:     VVJbOd = self.VVNcbR
31786:     VVaTeF = ("Stretch", BF(self.VVvLyr, title, path, picon))
31787:     VV7tND = FFLFTC(self, BF(self.VVkdu9, title, path, picon, False), VV3wat=VV3wat, width=700, title='PIcon Max. Size', VVJbOd=VVJbOd, VVaTeF=VVaTeF, VVW5y5="OK = Fit within size")
31788:     VV7tND.VVx2yy(3)
31789:   else:
31790:    FFdw58(self, "PIcons path not found:\n\n%s\n\n( You can change it in Settings )" % pPath, title=title)
31791:  def VVvLyr(self, title, path, picon, selectionObj, item):
31792:   self.VVkdu9(title, path, picon, True, item)
31793:   selectionObj.cancel()
31794:  def VVkdu9(self, title, path, picon, stretch, sz=None):
31795:   if sz:
31796:    try:
31797:     from PIL import Image
31798:     im = Image.open(path)
31799:     if stretch: im = im.resize(sz, Image.ANTIALIAS)
31800:     else   : im.thumbnail(sz)
31801:     im.save(picon)
31802:     CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVvrVY)
31803:    except Exception as e:
31804:     FFdw58(self, "Image Processing error:\n\n%s" % e)
31805:  def VVNcbR(self, VV7tND, txt, ref, ndx):
31806:   FFw2rR(self, "_help_resize", "Picture File Resizing")
31807:  def VVi42l(self, path):
31808:   CCkEI5.VVMYQY(self, BF(self.VVgZQF, path))
31809:  def VVgZQF(self, path, rType=None):
31810:   if rType:
31811:    FFimQ3(self, BF(self.VVTWR0, self, path, rType), title="Playing Media ...")
31812:  @staticmethod
31813:  def VVTWR0(SELF, path, rType=""):
31814:   if   rType     : prefix = rType
31815:   elif path.endswith(".ts") : prefix = "1"
31816:   else      : prefix = CFG.iptvAddToBouquetRefType.getValue()
31817:   VVPxk5 = "%s:%s%s" % (prefix, "0:" * 9, path)
31818:   CCqWM2.VVHc02(SELF.session, VVEBd5=False, VVdxwH=False, VVaHNe=VVPxk5)
31819:  @staticmethod
31820:  def VV4zSS(SELF):
31821:   serv = SELF.session.nav.getCurrentlyPlayingServiceReference()
31822:   fPath = serv and serv.getPath()
31823:   if fPath and FFCyVu(fPath):
31824:    fDir, fName = os.path.split(fPath)
31825:    return fPath, FFoWxR(fDir), fName
31826:   return "", "", ""
31827:  @staticmethod
31828:  def VVdlF7(path):
31829:   try:
31830:    st = os.statvfs(path)
31831:    total = st.f_frsize * st.f_blocks
31832:    used = st.f_frsize * (st.f_blocks - st.f_bfree)
31833:    free = st.f_frsize * st.f_bfree
31834:    avail = st.f_frsize * st.f_bavail
31835:    return total, used, free, avail, ""
31836:   except Exception as e:
31837:    return 0, 0, 0, 0, str(e)
31838:  @staticmethod
31839:  def VV99gM(size, mode=0):
31840:   txt = CClYaF.VVAi2d(size)
31841:   if size >= 1024 :
31842:    commaSize = format(size, ',d')
31843:    if mode == 1: return "%s (%s)"   % (txt, commaSize)
31844:    if mode == 2: return "%s (%s)"   % (commaSize, txt)
31845:    if mode == 3: return "%s (%s)"   % (size, txt)
31846:    if mode == 4: return "%s"    % txt
31847:    else  : return "%s  ( %s bytes )" % (txt, commaSize)
31848:   else:
31849:    return txt
31850:  @staticmethod
31851:  def VVAi2d(bytes):
31852:   kilo, unit = 1024.0, ("B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB")
31853:   if bytes < kilo:
31854:    return "%d B" % bytes
31855:   i = int(iFloor(iLog(bytes, 1024)))
31856:   s = str("%.2f" % (bytes / (kilo ** i))).rstrip(".0")
31857:   return "%s %s" % (s, unit[i])
31858:  @staticmethod
31859:  def VVgIOw(path):
31860:   rangeList = list(range(0x20, 0x100))
31861:   try:
31862:    with open(path, 'rb') as f:
31863:     bytes = f.read(1024)
31864:    textchars = bytearray({7,8,9,10,12,13,27} | set(rangeList) - {0x7f})
31865:    return bool(bytes.translate(None, textchars))
31866:   except:
31867:    return True
31868:  @staticmethod
31869:  def VVSOog(SELF, path, title=""):
31870:   try:
31871:    with ioOpen(path, "r", encoding="UTF-8") as f:
31872:     txt = f.read()
31873:    return True
31874:   except:
31875:    if title:
31876:     FFdw58(SELF, "File is not in 'UTF-8' Encoding:\n\n%s" % path, title=title.strip())
31877:    return False
31878:  @staticmethod
31879:  def VVI46y(addDot=False):
31880:   tDict = CCHmnm.VViatp()
31881:   lst = list(tDict["mov"])
31882:   lst.extend(list(tDict["mus"]))
31883:   if addDot: lst = ["." + x for x in lst]
31884:   return tuple(lst)
31885:  @staticmethod
31886:  def VVhadP(path):
31887:   lst = []
31888:   for ext in CClYaF.VVI46y():
31889:    lst.extend(FFkzic(path, "*.%s" % ext))
31890:   return sorted(lst, key=FFgEff(FFa9eD))
31891:  @staticmethod
31892:  def VVJ1XA(path):
31893:   return FFpwZS("tar -tzf '%s'" % path)
31894:  @staticmethod
31895:  def VVuTcL(path):
31896:   path = os.path.abspath(path)
31897:   while not os.path.ismount(path):
31898:    path = os.path.dirname(path)
31899:   return path
31900:  @staticmethod
31901:  def VVR33x(addTrailingSlash=True):
31902:   Dict = {}
31903:   for line in FFL19l("/proc/mounts"):
31904:    parts = line.split(" ")
31905:    if len(parts) > 2:
31906:     fs, mp, typ = parts[:3]
31907:     if addTrailingSlash and os.path.isdir(mp):
31908:      mp = FFoWxR(mp)
31909:     isNet = ":" in fs or fs.startswith("//")
31910:     Dict[mp] = (fs, typ, isNet)
31911:   return Dict
31912:  @staticmethod
31913:  def VVOBE5():
31914:   lst = []
31915:   for key, val in CClYaF.VVR33x().items():
31916:    if val[2]: lst.append(key)
31917:   return lst
31918:  @staticmethod
31919:  def VV8isu(lst, fromFind=True):
31920:   if len(lst) == 1 and lst[0] == VVfDY7:
31921:    return VVfDY7
31922:   elif fromFind:
31923:    for line in lst:
31924:     span = iSearch(r"find:\s*(.+):\s*Input\/output error", line, IGNORECASE)
31925:     if span:
31926:      return 'Filesystem Error in:\n\n%s' % span.group(1)
31927:   for ln in lst:
31928:    if not ln.startswith("/"): return "Error: %s" % ln
31929:   return ""
31930:  @staticmethod
31931:  def VVVDVC(path, name):
31932:   c = 0
31933:   newNm = name
31934:   while VVmJwX(os.path.join(path, newNm)):
31935:    c += 1
31936:    newNm = "%s%s" % (name, c)
31937:   return newNm
31938: class CCHmnm(MenuList):
31939:  VVY06p   = 0
31940:  VVGwB9   = 1
31941:  VVg9Rj   = 2
31942:  VVVUY9   = 3
31943:  VV2gkr   = 4
31944:  VVYQP6   = 5
31945:  VVYWUJ   = 6
31946:  VVoTQa   = 7
31947:  VVoQ0w   = "<List of Storage Devices>"
31948:  VVXivL  = "<Parent Directory>"
31949:  VV4dV3   = 0
31950:  VVS98t   = 1
31951:  VVPC3A = 2
31952:  VVPZRP  = 3
31953:  VVzq0M   = 4
31954:  VV8NQQ   = 5
31955:  FILE_TYPE_LINK   = 6
31956:  VVP8p8  = 7
31957:  PROHIBITED_FILES  = ["/%s/" % x for x in ("DEBIAN","bin","boot","dev","etc","hdd","home","lib","media","mnt","network","proc","run","sbin","sys","tmp","usr","var")]
31958:  def __init__(self, enableWrapAround=False, directory="/", VVEpbW=True, VV1aG0=True, VVodaQ=True, VV2mDa=None, VVWIJv=False, VVwbd9=False, isTop=False, VVa3hn=None, VVVljT=1000, VVwdmN=30, VV8c7y=30):
31959:   MenuList.__init__(self, list, enableWrapAround, eListboxPythonMultiContent)
31960:   self.VVEpbW  = VVEpbW
31961:   self.VV1aG0    = VV1aG0
31962:   self.VVodaQ  = VVodaQ
31963:   self.VV2mDa  = VV2mDa
31964:   self.VVWIJv   = VVWIJv or []
31965:   self.VVwbd9   = VVwbd9 or []
31966:   self.isTop     = isTop
31967:   self.additional_extensions = VVa3hn
31968:   self.VVVljT    = VVVljT
31969:   self.VVwdmN    = VVwdmN
31970:   self.VV8c7y    = VV8c7y
31971:   self.VVX5XV   = eServiceCenter.getInstance()
31972:   self.mountpoints   = []
31973:   self.networkMounts   = CClYaF.VVOBE5()
31974:   self.current_directory  = None
31975:   self.current_mountpoint  = None
31976:   self.multiSelect_color  = FFRUST("#11ff4444")
31977:   self.l.setFont(0, gFont(VVNhAq, self.VVwdmN))
31978:   self.l.setItemHeight(self.VV8c7y)
31979:   self.png_mntN   = CCHmnm.VVKUQG("mntN")
31980:   self.png_mntL   = CCHmnm.VVKUQG("mntL")
31981:   self.png_mem   = CCHmnm.VVKUQG("mem")
31982:   self.png_usb   = CCHmnm.VVKUQG("usb")
31983:   self.png_fil   = CCHmnm.VVKUQG("fil")
31984:   self.png_dir   = CCHmnm.VVKUQG("dir")
31985:   self.png_dirup   = CCHmnm.VVKUQG("dirup")
31986:   self.png_slwfil   = CCHmnm.VVKUQG("slwfil")
31987:   self.png_slbfil   = CCHmnm.VVKUQG("slbfil")
31988:   self.png_slwdir   = CCHmnm.VVKUQG("slwdir")
31989:   self.VVjChm()
31990:   self.VVf5s1(directory)
31991:  @staticmethod
31992:  def VVKUQG(category):
31993:   return LoadPixmap("%s%s.png" % (VVIp2p, category), getDesktop(0))
31994:  @staticmethod
31995:  def VViatp():
31996:   return {"pic":("bmp","gif","jpe","jpeg","jpg","png","svg"),"mov":("3g2","3gp","asf","avi","divx","flv","ifo","iso","m2ts","m4v","mkv","mod","mov","mp4","mpe","mpeg","mpg","mts","mvi","ogm","ogv","pva","rm","rmvb","stream","ts","vob","webm","wmv","wtv","h264","h265","mjpeg","mk3d","mks","xvid"),"mus":("aac","ac3","alac","amr","ape","au","dts","flac","m2a","m4a","mid","mka","mp2","mp3","oga","ogg","wav","wave","wma","wv","m4b","m4p","mpc","wpl"),"txt":("cfg","conf","htm","html","txt","xml"),"py":("py","pyo","pyc"),"tar":("bz2","gz","tar","xz"),"rar":("rar",),"zip":("zip",),"p7z":("7z",),"zst":("zst",),"ipk":("ipk",),"deb":("deb",),"scr":("sh",),"m3u":("m3u","m3u8")}
31997:  def VVnyoE(self, name, absolute=None, isDir=False, typ=None, png=None):
31998:   if absolute and isDir:
31999:    path = absolute
32000:    path = FFVc4H(path)
32001:    if os.path.islink(path) and not name in (self.VVoQ0w, self.VVXivL):
32002:     png = self.png_slwdir
32003:     name += FFjt5L(" -> " , VV1fx4) + FFjt5L(os.readlink(path), VVSGsk)
32004:   tableRow = [ (absolute, isDir, typ) ]
32005:   tableRow.append((eListboxPythonMultiContent.TYPE_TEXT, self.VV8c7y + 10, 0, self.VVVljT, self.VV8c7y, 0, LEFT | RT_VALIGN_CENTER, name))
32006:   if png is not None:
32007:    tableRow.append(CCnES5.VVmxDV(0, 2, self.VV8c7y-4, self.VV8c7y-4, png))
32008:   return tableRow
32009:  @staticmethod
32010:  def VVMyky(path):
32011:   ext = os.path.splitext(path)[1]
32012:   if ext:
32013:    ext = ext.lstrip(".").lower()
32014:    for cat, lst in CCHmnm.VViatp().items():
32015:     if ext in lst:
32016:      return cat
32017:   return ""
32018:  def VVjChm(self):
32019:   self.mountpoints = [os.path.join(p.mountpoint, "") for p in harddiskmanager.getMountedPartitions()]
32020:   self.mountpoints.sort(reverse=True)
32021:  def VVMaWM(self, file):
32022:   file = os.path.join(os.path.realpath(file), "")
32023:   for m in self.mountpoints:
32024:    if file.startswith(m):
32025:     return m
32026:   return False
32027:  def VV2lMp(self, file):
32028:   if os.path.realpath(file) == file:
32029:    return self.VVMaWM(file)
32030:   else:
32031:    if file[-1] == "/":
32032:     file = file[:-1]
32033:    mp = self.VVMaWM(file)
32034:    last = file
32035:    file = os.path.dirname(file)
32036:    while last != "/" and mp == self.VVMaWM(file):
32037:     last = file
32038:     file = os.path.dirname(file)
32039:    return os.path.join(last, "")
32040:  def getSelection(self):
32041:   if self.l.getCurrentSelection() is None:
32042:    return None
32043:   return self.l.getCurrentSelection()[0]
32044:  def VVRH7p(self, isUp):
32045:   ndx = self.l.getCurrentSelectionIndex()
32046:   row = self.list[ndx]
32047:   bg = self.multiSelect_color if row[2][6] == None else None
32048:   ndx = self.getSelectionIndex()
32049:   if isUp:
32050:    if ndx > 0:
32051:     self.moveToIndex(self.getSelectionIndex() - 1)
32052:   else:
32053:    if ndx < len(self.list) - 1:
32054:     self.moveToIndex(self.getSelectionIndex() + 1)
32055:   iconData = self.VVkjkG(row, bg)
32056:   if iconData:
32057:    row[2] = iconData
32058:    self.l.setList(self.list)
32059:    return True
32060:   else:
32061:    return False
32062:  def VV0y0E(self, isSel, fManMode, cbFnc):
32063:   bg = self.multiSelect_color if isSel else None
32064:   if isSel and fManMode in (CClYaF.VVkJTs, CClYaF.VV9N82):
32065:    VVXgOC = self.VVWyCw()
32066:    for ndx, row in enumerate(self.list):
32067:     if row[0][0]:
32068:      path = os.path.join(VVXgOC, row[0][0])
32069:      isDir = os.path.isdir(path)
32070:      if fManMode == CClYaF.VVkJTs and not isDir or fManMode == CClYaF.VV9N82 and isDir:
32071:       iconData = self.VVkjkG(row, bg)
32072:       if iconData:
32073:        row[2] = iconData
32074:   else:
32075:    for ndx, row in enumerate(self.list):
32076:     iconData = self.VVkjkG(row, bg)
32077:     if iconData:
32078:      row[2] = iconData
32079:   self.l.setList(self.list)
32080:   cbFnc()
32081:  def VVkjkG(self, row, bg):
32082:   if self.VVsyuA(row):
32083:    iconData = list(row[2])
32084:    iconData[6] = bg
32085:    iconData[7] = bg
32086:    return tuple(iconData)
32087:   else:
32088:    return None
32089:  def VVsyuA(self, row):
32090:   if not row[0][0] in self.mountpoints:
32091:    if   row[0][2] in (self.VV8NQQ, self.FILE_TYPE_LINK): return True
32092:    elif row[0][2] == self.VVzq0M:
32093:     if   VVWe5f           : return True
32094:     elif not row[0][0] in self.PROHIBITED_FILES    : return True
32095:   return False
32096:  def VVK4p4(self):
32097:   return self.VVsyuA(self.list[self.l.getCurrentSelectionIndex()])
32098:  def VVhxM5(self):
32099:   tot = 0
32100:   for row in self.list:
32101:    if row[2][6]:
32102:     tot += 1
32103:   return tot
32104:  def VVuXHI(self, dir, parents):
32105:   dir = os.path.realpath(dir)
32106:   for p in parents:
32107:    if dir.startswith(p):
32108:     return True
32109:   return False
32110:  def VVf5s1(self, directory, selItem=None):
32111:   self.list = []
32112:   directories = []
32113:   files = []
32114:   if self.current_directory is None:
32115:    if directory and self.VVodaQ:
32116:     self.current_mountpoint = self.VV2lMp(directory)
32117:    else:
32118:     self.current_mountpoint = None
32119:   self.current_directory = directory
32120:   if directory is None:
32121:    if self.VVodaQ:
32122:     for p in harddiskmanager.getMountedPartitions():
32123:      path = os.path.join(p.mountpoint, "")
32124:      if path not in self.VVwbd9 and not self.VVuXHI(path, self.VVWIJv):
32125:       if path == "/" : png = self.png_mem
32126:       else   : png = self.png_usb
32127:       self.list.append(self.VVnyoE(name=p.description, absolute=path, isDir=True, typ=self.VV4dV3, png=png))
32128:     path = "/"
32129:     if path not in self.VVwbd9 and not self.VVuXHI(path, self.VVWIJv):
32130:      for item in self.list:
32131:       if path == item[0][0]:
32132:        break
32133:      else:
32134:       self.list.append(self.VVnyoE(name="INTERNAL FLASH", absolute="/", isDir=True, typ=self.VVS98t, png=self.png_mem))
32135:   else:
32136:    if FFCyVu(directory):
32137:     try:
32138:      files = os.listdir(directory)
32139:     except:
32140:      files = []
32141:     tmpfiles = files[:]
32142:     for x in tmpfiles:
32143:      tPath = directory + x
32144:      if os.path.isdir(tPath):
32145:       directories.append(tPath + "/")
32146:       files.remove(x)
32147:      elif not FFq2rn(tPath):
32148:       files.remove(x)
32149:   if directory is not None and self.VVEpbW and not self.isTop:
32150:    if directory == self.current_mountpoint and self.VVodaQ:
32151:     self.list.append(self.VVnyoE(name=self.VVoQ0w, absolute=None, isDir=True, typ=self.VVPC3A, png=self.png_dirup))
32152:    elif (directory != "/") and not (self.VVwbd9 and self.VVMaWM(directory) in self.VVwbd9):
32153:     self.list.append(self.VVnyoE(name=self.VVXivL, absolute='/'.join(directory.split('/')[:-2]) + '/', isDir=True, typ=self.VVPZRP, png=self.png_dirup))
32154:   if self.VVEpbW:
32155:    for x1 in directories:
32156:     if not (self.VVwbd9 and self.VVMaWM(x1) in self.VVwbd9) and not self.VVuXHI(x1, self.VVWIJv):
32157:      name = x1.split('/')[-2]
32158:      x2 = FFoWxR(os.path.realpath(x1))
32159:      if os.path.ismount(x2):
32160:       if   x2 in self.mountpoints  : png = self.png_usb
32161:       elif x2 in self.networkMounts : png = self.png_mntN
32162:       else       : png = self.png_mntL
32163:      else        : png = self.png_dir
32164:      self.list.append(self.VVnyoE(name=name, absolute=x1, isDir=True, typ=self.FILE_TYPE_LINK if os.path.islink(FFVc4H(x1)) else self.VVzq0M, png=png))
32165:   if self.VV1aG0:
32166:    for x in files:
32167:     path = directory + x
32168:     name = x
32169:     png  = self.png_fil
32170:     if os.path.islink(FFVc4H(path)):
32171:      try:
32172:       target = os.readlink(path)
32173:       if FFCyVu(target):
32174:        png = self.png_slwfil
32175:        name += FFjt5L(" -> " , VV1fx4) + FFjt5L(target, VVSGsk)
32176:       else:
32177:        png = self.png_slbfil
32178:        name += FFjt5L(" -> " , VV1fx4) + FFjt5L(target, VVYjI5)
32179:      except:
32180:       png = self.png_slbfil
32181:     elif "." in name:
32182:      category = self.VVMyky(name)
32183:      if category:
32184:       png = LoadPixmap("%s%s.png" % (VVIp2p, category))
32185:     elif not FFq2rn(path):
32186:      png = LoadPixmap("%serr.png" % VVIp2p)
32187:     if (self.VV2mDa is None) or iCompile(self.VV2mDa[0], flags=self.VV2mDa[1]).search(path):
32188:      self.list.append(self.VVnyoE(name=name, absolute=x , isDir=False, typ=self.VV8NQQ, png=png))
32189:   if self.VVodaQ and len(self.list) == 0:
32190:    self.list.append(self.VVnyoE(name=FFjt5L("No USB connected", VVA4XU), absolute=None, isDir=False, typ=self.VVP8p8, png=self.png_usb))
32191:   self.l.setList(self.list)
32192:   self.VVhNXg()
32193:   if selItem is not None:
32194:    i = 0
32195:    self.moveToIndex(0)
32196:    for x in self.list:
32197:     p = x[0][0]
32198:     if isinstance(p, eServiceReference): p = p.getPath()
32199:     if p == selItem: self.moveToIndex(i)
32200:     i += 1
32201:  def VVWyCw(self):
32202:   return self.current_directory
32203:  def VV2bmH(self):
32204:   if self.getSelection() is None:
32205:    return False
32206:   return self.getSelection()[1]
32207:  def VVe2l0(self):
32208:   return self.VViSlA() and self.VVWyCw()
32209:  def VViSlA(self):
32210:   return self.list[0][1][7] in (self.VVoQ0w, self.VVXivL)
32211:  def descent(self):
32212:   if self.getSelection() is None:
32213:    return
32214:   self.VVf5s1(self.getSelection()[0], self.current_directory)
32215:  def VVvQmA(self):
32216:   if self.getSelection() is None:
32217:    return None
32218:   x = self.getSelection()[0]
32219:   if isinstance(x, eServiceReference):
32220:    x = x.getPath()
32221:   return x
32222:  def execBegin(self):
32223:   harddiskmanager.on_partition_list_change.append(self.VVMrsl)
32224:  def execEnd(self):
32225:   harddiskmanager.on_partition_list_change.remove(self.VVMrsl)
32226:  def VVMrsl(self, action, device):
32227:   self.VVjChm()
32228:   if self.current_directory is None:
32229:    self.VVs0ks()
32230:  def VVs0ks(self):
32231:   tDict = {}
32232:   for row in self.list:
32233:    if row[2][6]:
32234:     tDict[row[0][0]] = 1
32235:   fName = self.VVvQmA()
32236:   self.VVf5s1(self.current_directory, fName if fName and FFCyVu(os.path.join(self.current_directory, fName)) else None)
32237:   isSel = 0
32238:   if tDict:
32239:    for row in self.list:
32240:     if tDict.get(row[0][0], 0):
32241:      row[2] = list(row[2])
32242:      row[2][6] = row[2][7] = self.multiSelect_color
32243:      row[2] = tuple(row[2])
32244:      isSel = 1
32245:    self.l.setList(self.list)
32246:   return isSel
32247:  def VVdj0P(self):
32248:   mode = CFG.browserSortMode.getValue()
32249:   mix  = CFG.browserSortMix.getValue()
32250:   sAZ, sZA, s09, s90, sNO, sON = "A > Z", "Z > A", "0 > 9", "9 > 0", "New > Old", "Old > New"
32251:   if mode == self.VVY06p : nameAlpMode, nameAlpTxt = self.VVGwB9, sZA
32252:   else       : nameAlpMode, nameAlpTxt = self.VVY06p, sAZ
32253:   if mode == self.VVg9Rj : nameNumMode, nameNumTxt = self.VVVUY9, s90
32254:   else       : nameNumMode, nameNumTxt = self.VVg9Rj, s09
32255:   if mode == self.VV2gkr : dateMode, dateTxt = self.VVYQP6, sON
32256:   else       : dateMode, dateTxt = self.VV2gkr, sNO
32257:   if mode == self.VVYWUJ : typeMode, typeTxt = self.VVoTQa, sZA
32258:   else       : typeMode, typeTxt = self.VVYWUJ, sAZ
32259:   if   mode in (self.VVY06p, self.VVGwB9): txt = "Name (%s)" % (sAZ if mode == self.VVY06p else sZA)
32260:   elif mode in (self.VVg9Rj, self.VVVUY9): txt = "Name (%s)" % (s09 if mode == self.VVY06p else s90)
32261:   elif mode in (self.VV2gkr, self.VVYQP6): txt = "Date (%s)" % (sNO if mode == self.VV2gkr else sON)
32262:   elif mode in (self.VVYWUJ, self.VVoTQa): txt = "Type (%s)" % (sAZ if mode == self.VVYWUJ else sZA)
32263:   if mix:
32264:    txt += " .. Mixed"
32265:   return nameAlpMode, nameAlpTxt, nameNumMode, nameNumTxt, dateMode, dateTxt, typeMode, typeTxt, "Cur = by %s" % txt
32266:  def VVhNXg(self, mode=None, isMix=False, isNum=False):
32267:   if not mode is None:
32268:    FFjt1c(CFG.browserSortMode, mode)
32269:    FFjt1c(CFG.browserSortMix, isMix)
32270:   if self.list:
32271:    if self.VViSlA() : item0, topRow = 1, self.list[0]
32272:    else    : item0, topRow = 0, None
32273:    mode = CFG.browserSortMode.getValue()
32274:    isMix = CFG.browserSortMix.getValue()
32275:    if mode in (self.VVY06p, self.VVGwB9):
32276:     rev = True if mode == self.VVGwB9 else False
32277:     if isMix: self.list = sorted(self.list[item0:], key=lambda x: x[1][7]         , reverse=rev)
32278:     else : self.list = sorted(self.list[item0:], key=lambda x: (x[0][1] if rev else not x[0][1], x[1][7]), reverse=rev)
32279:    elif mode in (self.VVg9Rj, self.VVVUY9):
32280:     rev = True if mode == self.VVVUY9 else False
32281:     self.list = sorted(self.list[item0:], key=FFgEff(BF(self.VVMJna, isMix, rev)), reverse=rev)
32282:    elif mode in (self.VV2gkr, self.VVYQP6):
32283:     rev = True if mode == self.VVYQP6 else False
32284:     self.list = sorted(self.list[item0:], key=FFgEff(BF(self.VVJXRa, isMix)), reverse=rev)
32285:    else:
32286:     rev = True if mode == self.VVoTQa else False
32287:     if isMix: self.list = sorted(self.list[item0:], key=lambda x: os.path.splitext(x[1][7])[1]            , reverse=rev)
32288:     else : self.list = sorted(self.list[item0:], key=lambda x: (x[0][1] if rev else not x[0][1], os.path.splitext(x[1][7])[1], x[1][7]) , reverse=rev)
32289:    if topRow:
32290:     self.list.insert(0, topRow)
32291:    self.l.setList(self.list)
32292:  def VVMJna(self, mix, rev, p1, p2):
32293:   dir1, name1 = p1[0][1], p1[1][7]
32294:   dir2, name2 = p2[0][1], p2[1][7]
32295:   if mix:
32296:    return FFa9eD(name1.lower(), name2.lower())
32297:   else:
32298:    if rev: dir1, dir2 = dir2, dir1
32299:    return FFyH6N(dir2, dir1) or FFa9eD(name1, name2)
32300:  def VVJXRa(self, mix, p1, p2):
32301:   dir1 = p1[0][1]
32302:   dir2 = p2[0][1]
32303:   if mix or dir1 == dir2:
32304:    path1 = "" if dir1 else self.current_directory
32305:    path2 = "" if dir2 else self.current_directory
32306:    try:
32307:     stat1 = os.stat(path1 + p1[0][0])
32308:     stat2 = os.stat(path2 + p2[0][0])
32309:     if mix : return FFyH6N(stat2.st_ctime, stat1.st_ctime)
32310:     else : return FFyH6N(dir2, dir1) or FFyH6N(stat2.st_ctime, stat1.st_ctime)
32311:    except:
32312:     pass
32313:   return 0
32314: class CC1FS2(Screen):
32315:  def __init__(self, session, defFG="", defBG="", onlyBG=False, isBgMode=True):
32316:   self.skin, self.VVfOli = FFiNEe(VVrQU9, 900, 700, 35, 10, 14, "
32317:   self.session  = session
32318:   self.onlyBG   = onlyBG
32319:   self.Title   = "Color"
32320:   self.VVQ3Dp  = 6
32321:   self.VVsHeH  = 8
32322:   self.VVGape   = []
32323:   self.curRow   = 0
32324:   self.curCol   = 0
32325:   self.isBgMode  = isBgMode
32326:   self.defFG   = self.VVjn8i(defFG, "#00FFFFFF")
32327:   self.defBG   = self.VVjn8i(defBG, "#11000000")
32328:   self.transpFg  = int(self.defFG[1:3], 16)
32329:   self.transpBg  = int(self.defBG[1:3], 16)
32330:   self.colors   = (   ("FFFFFF", "FFC0C0", "FFE0C0", "FFFFC0", "C0FFC0", "C0FFFF", "C0C0FF", "FFC0FF")
32331:         , ("E0E0E0", "FF8080", "FFC080", "FFFF80", "80FF80", "80FFFF", "8080FF", "FF80FF")
32332:         , ("C0C0C0", "FF0000", "FF8000", "FFFF00", "00FF00", "00FFFF", "0000FF", "FF00FF")
32333:         , ("808080", "C00000", "C04000", "C0C000", "00C000", "00C0C0", "0000C0", "C000C0")
32334:         , ("404040", "800000", "804000", "808000", "008000", "008080", "000080", "800080")
32335:         , ("000000", "400000", "804040", "404000", "004000", "004040", "000040", "400040")
32336:         )
32337:   FFZMxC(self, self.Title)
32338:   self["keyRed"].show()
32339:   FFRLNq(self["keyGreen"] , "< > Transp.")
32340:   FFRLNq(self["keyYellow"], "Foreground")
32341:   FFRLNq(self["keyBlue"] , "Background")
32342:   if self.onlyBG:
32343:    self["keyYellow"].hide()
32344:    self["keyBlue"].hide()
32345:   for row in range(self.VVQ3Dp):
32346:    for col in range(self.VVsHeH):
32347:     self["myColor%d%d" % (row, col)] = Label()
32348:   self["myColorPtr"] = Label()
32349:   self["myColorTst"] = Label("This is a test message.\n0123456789")
32350:   FFHlAU(self,
32351:   {
32352:    "ok"   : self.VVxY7G     ,
32353:    "green"   : self.VVxY7G     ,
32354:    "yellow"  : BF(self.VVrkD4, False)  ,
32355:    "blue"   : BF(self.VVrkD4, True)  ,
32356:    "up"   : self.VVx0di       ,
32357:    "down"   : self.VVDBsZ      ,
32358:    "left"   : self.VVziFC      ,
32359:    "right"   : self.VVLe1s      ,
32360:    "last"   : BF(self.VVOXz3, -5) ,
32361:    "next"   : BF(self.VVOXz3, 5) ,
32362:    "cancel"  : BF(self.close, None, None)
32363:   })
32364:   self.onShown.append(self.VV7OzD)
32365:  def VV7OzD(self):
32366:   self.onShown.remove(self.VV7OzD)
32367:   for row in range(self.VVQ3Dp):
32368:    for col in range(self.VVsHeH):
32369:     FFZ0AC(self["myColor%d%d" % (row, col)], "#11%s" % self.colors[row][col])
32370:   c = "#11333333"
32371:   FFZ0AC(self["keyRed"] , c)
32372:   FFZ0AC(self["keyGreen"] , c)
32373:   self.VV5Mg7()
32374:   self.VV1EGy()
32375:   FF7hy1(self["myColorTst"], self.defFG, self.defBG)
32376:   self.VVD5ah(0, 0)
32377:  def VVjn8i(self, color, defColor):
32378:   color = color.upper()
32379:   span = iSearch(r"([
32380:   if span : return color
32381:   else : return defColor
32382:  def VV1EGy(self):
32383:   for row in range(self.VVQ3Dp):
32384:    for col in range(self.VVsHeH):
32385:     color = self.colors[row][col]
32386:     found = False
32387:     if self.isBgMode:
32388:      if self.defBG[3:] == self.colors[row][col]:
32389:       found = True
32390:     else:
32391:      if self.defFG[3:] == self.colors[row][col]:
32392:       found = True
32393:     if found:
32394:      self.curRow = row
32395:      self.curCol = col
32396:      self.VVD5ah(0, 0)
32397:      return
32398:  def VVxY7G(self):
32399:   self.close(self.defFG, self.defBG)
32400:  def VVx0di(self): self.VVD5ah(-1, 0)
32401:  def VVDBsZ(self): self.VVD5ah(1, 0)
32402:  def VVziFC(self): self.VVD5ah(0, -1)
32403:  def VVLe1s(self): self.VVD5ah(0, 1)
32404:  def VVD5ah(self, row, col):
32405:   self.curRow += row
32406:   self.curCol += col
32407:   if   self.curRow > self.VVQ3Dp -1 : self.curRow = 0
32408:   elif self.curRow < 0     : self.curRow = self.VVQ3Dp - 1
32409:   if   self.curCol > self.VVsHeH -1 : self.curCol = 0
32410:   elif self.curCol < 0     : self.curCol = self.VVsHeH - 1
32411:   color = self.VVb26C()
32412:   self["keyRed"].setText(color)
32413:   if self.isBgMode: self.defBG = color
32414:   else   : self.defFG = color
32415:   gap = int(self.VVfOli["VVSZWt"] / 2)
32416:   pos = self["myColor%d%d" % (self.curRow, self.curCol)].getPosition()
32417:   self["myColorPtr"].instance.move(ePoint(pos[0] - gap - 2, pos[1] - gap - 2))
32418:   self.VVGQuK()
32419:  def VV5Mg7(self):
32420:   self["myTitle"].setText("  %s %s" % ("Background" if self.isBgMode else "Foreground", self.Title))
32421:  def VVGQuK(self):
32422:   color = self.VVb26C()
32423:   if self.isBgMode: FFZ0AC(self["myColorTst"], color)
32424:   else   : FFGUI5(self["myColorTst"], color)
32425:  def VVrkD4(self, isBg):
32426:   if not self.onlyBG:
32427:    self.isBgMode = isBg
32428:    self.VV5Mg7()
32429:    self.VV1EGy()
32430:  def VVOXz3(self, val):
32431:   if self.isBgMode: self.transpBg = FFsRWN(self.transpBg + val, 0, 255)
32432:   else   : self.transpFg = FFsRWN(self.transpFg + val, 0, 255)
32433:   self. VVD5ah(0, 0)
32434:  def VVU80K(self):
32435:   if self.isBgMode: return hex(self.transpBg)[2:].zfill(2)
32436:   else   : return hex(self.transpFg)[2:].zfill(2)
32437:  def VVb26C(self):
32438:   return ("#%s%s" % (self.VVU80K(), self.colors[self.curRow][self.curCol])).upper()
32439: class CCfpAm(Screen, CCwklK):
32440:  def __init__(self, session, playerObj=None):
32441:   self.skin, self.VVfOli = FFiNEe(VVspuu, 1860, 1030, 20, 20, 30, "#33002233", "#33002233", 25, VV0Ay7=2)
32442:   self.session   = session
32443:   self.playerObj   = playerObj
32444:   self.VVeEaQ  = eTimer()
32445:   self.VVOAGe  = eTimer()
32446:   self.VVxJJL  = eTimer()
32447:   self.VVoJze = eTimer()
32448:   self.subtLinesTable  = None
32449:   self.subtLinesTableNdx = -1
32450:   self.subtList   = []
32451:   self.curSubtFullData = None
32452:   self.lastSubtInfo  = ""
32453:   self.lastSubtFile  = ""
32454:   self.lastSubtEnc  = ""
32455:   self.settingShown  = False
32456:   self.CursorPos   = 0
32457:   self.Title    = "Subtitle Settings"
32458:   self.VV7tND  = None
32459:   self.subtMenuFromPlayer = True
32460:   if FFgrjX() and CC674y.VVSwko() in ("Gemini", "Dream-Elite"):
32461:    self.VVfJF0 = 400
32462:    self.VV0Ov6 = 0.4
32463:   else:
32464:    self.VVfJF0 = 50
32465:    self.VV0Ov6 = 0.18
32466:   self.minDelay, self.maxDelay = self.VVmwD5()
32467:   self.diac    = u"\u0610\u0611\u0612\u0613\u0614\u0615\u0616\u0617\u0618\u0619\u061a\u064b\u064c\u064d\u064e\u064f\u0650\u0651\u0652\u0653\u0654\u0655\u0656\u0657\u0658\u0659\u065a\u065b\u065c\u065d\u065e\u0670\u06d6\u06d7\u06d8\u06d9\u06da\u06db\u06dc\u06df\u06e0\u06e1\u06e2\u06e3\u06e4\u06e7\u06e8\u06ea\u06eb\u06ec\u06ed"
32468:   CCwklK.__init__(self)
32469:   FFZMxC(self, title="%s%s%s" % (self.Title, " " * 10, FFjt5L("Change values with Up , Down, < , 0 , >", VVA4XU)))
32470:   self["mySubtCover"] = Label()
32471:   self.ctrlBtns = ("keyRed", "keyGreen", "keyYellow", "keyBlue")
32472:   subj = ("Reset All", "Save", "Reset Delay", "Pick Line")
32473:   for i, name in enumerate(self.ctrlBtns):
32474:    self[name] = Label(subj[i])
32475:   self["mySubtCursor"] = Label()
32476:   subj = ("Delay", "BG Trans %", "Text Color", "Text Font", "Text Size", "Alignment", "Shadow Color", "Shadow Size", "Position")
32477:   self.settingLabels = ["Del", "BGTr", "TxtFg", "TxtFnt", "TxtSiz", "Align", "ShadFg", "ShadSiz", "Pos"]
32478:   self.settingLabels1 = list(self.settingLabels)
32479:   for i, name in enumerate(self.settingLabels):
32480:    self.settingLabels[i]  = "mySubt%s"   % name
32481:    self.settingLabels1[i] = "mySubt%s1"  % name
32482:    self[self.settingLabels[i]]  = Label(subj[i])
32483:    self[self.settingLabels1[i]] = Label(subj[i])
32484:   self["mySubtFr"] = Label()
32485:   for i in range(3): self["mySubt%d"  % i] = Label()
32486:   for i in range(4): self["mySubtSep%d" % i] = Label()
32487:   for i in range(4): self["mySubtChng%d" % i] = Label()
32488:   self["mySubtChng1"].setText("Line (Left/Right) , Delay (Up/Down)")
32489:   self["myRest1"] = Label("Reset")
32490:   self.VVKKbg()
32491:   FFHlAU(self,
32492:   {
32493:    "ok"  : self.VVPr1F      ,
32494:    "cancel" : self.VVfXzC      ,
32495:    "info"  : self.VVbZLl    ,
32496:    "red"  : self.VV7y8M  ,
32497:    "green"  : self.VVUosz   ,
32498:    "yellow" : BF(self.VVRIDu, 0)  ,
32499:    "blue"  : self.VVsdgY    ,
32500:    "menu"  : self.VVkrkn      ,
32501:    "left"  : BF(self.VVuLkD, -1),
32502:    "right"  : BF(self.VVuLkD, 1) ,
32503:    "last"  : self.VVbyWX     ,
32504:    "next"  : self.VVe6KA     ,
32505:    "0"   : self.VVKUAt    ,
32506:    "up"  : self.VVx0di       ,
32507:    "down"  : self.VVDBsZ      ,
32508:    "pageUp" : BF(self.VVoC5Z, True) ,
32509:    "pageDown" : BF(self.VVoC5Z, False) ,
32510:    "chanUp" : BF(self.VVoC5Z, True) ,
32511:    "chanDown" : BF(self.VVoC5Z, False) ,
32512:    "longPlay" : BF(self.VV1XNb, "longPlay") ,
32513:    "play"  : BF(self.VV1XNb, "pause")  ,
32514:    "pause"  : BF(self.VV1XNb, "pause")  ,
32515:    "playPause" : BF(self.VV1XNb, "pause")  ,
32516:    "stop"  : BF(self.VV1XNb, "pause")  ,
32517:    "audio"  : BF(self.VV1XNb, "audio")  ,
32518:    "subtitle" : BF(self.VV1XNb, "subtitle") ,
32519:    "rewind" : BF(self.VVFHmB, "rewind") ,
32520:    "forward" : BF(self.VVFHmB, "forward") ,
32521:    "rewindDm" : BF(self.VVFHmB, "rewind") ,
32522:    "forwardDm" : BF(self.VVFHmB, "forward")
32523:   })
32524:   self.VVXAYe()
32525:   self.onShown.append(self.VV7OzD)
32526:   self.onClose.append(self.VV7Hkn)
32527:  def VVXAYe(self):
32528:   lst = []
32529:   for fil in FFkzic(resolveFilename(SCOPE_FONTS), "*.[tToO][tT][fF]"):
32530:    name = os.path.splitext(os.path.basename(fil))[0]
32531:    lst.append((fil, name))
32532:   if lst:
32533:    lst.sort(key=lambda x: x[1].lower())
32534:    default = CFG.subtTextFont.default
32535:    if default == VV8nt5:
32536:     for path, name in lst:
32537:      if "almateen" in name.lower():
32538:       default = name
32539:       break
32540:    CFG.subtTextFont = ConfigSelection(default=default, choices=lst)
32541:  def VV7OzD(self):
32542:   self.onShown.remove(self.VV7OzD)
32543:   FFWgBS(self)
32544:   FF6W0I(self)
32545:   FFK4PQ(self["myRest1"], "#000000", 3)
32546:   for i in range(3):
32547:    self["mySubt%d" % i].hide()
32548:   self.VVQjDh()
32549:   self.VVvsHp()
32550:   srtCfgPath = CCfpAm.VVXUuh(self)
32551:   FFpwZS("mv -f '%s.dis' '%s'" % (srtCfgPath, srtCfgPath))
32552:   self.VV0xaU()
32553:  def VV7Hkn(self):
32554:   self.VVeEaQ.stop()
32555:   self.VVOAGe.stop()
32556:   self.VVxJJL.stop()
32557:   self.VVoJze.stop()
32558:  def VVFBoa(self):
32559:   self.settingShown = True
32560:   for name in self.ctrlBtns: self[name].show()
32561:   for name in self.settingLabels : self[name].show()
32562:   for name in self.settingLabels1: self[name].show()
32563:   for i in range(4): self["mySubtSep%d" % i].show()
32564:   self["myTitle"].show()
32565:   self["mySubtFr"].show()
32566:   FFZ0AC(self["myBody"], "#33002233")
32567:   self["keyMenu"].show()
32568:   self["keyInfo"].show()
32569:   self["mySubtCover"].hide()
32570:   self.VVwsJV()
32571:  def VVQjDh(self):
32572:   self.settingShown = False
32573:   for name in self.ctrlBtns: self[name].hide()
32574:   for name in self.settingLabels : self[name].hide()
32575:   for name in self.settingLabels1: self[name].hide()
32576:   for i in range(4): self["mySubtSep%d" % i].hide()
32577:   self["myTitle"].hide()
32578:   self["mySubtFr"].hide()
32579:   FFZ0AC(self["myBody"], "#ff000000")
32580:   self["keyMenu"].hide()
32581:   self["keyInfo"].hide()
32582:   self["mySubtCover"].show()
32583:  def VVPr1F(self):
32584:   if self.settingShown:
32585:    confItem = self.VVymx1()[self.CursorPos]
32586:    title = self[self.settingLabels[self.CursorPos]].getText()
32587:    CCJaSw.VV5YpJ(self, confItem, title, cbFnc=self.VVo2gc)
32588:   elif self.VV1s50():
32589:    self.VVKKbg()
32590:   else:
32591:    self.close("subtExit")
32592:  def VVo2gc(self):
32593:   self.VVwsJV()
32594:   self.VVvsHp()
32595:   self.VVIE7K(True)
32596:  def VVfXzC(self):
32597:   for confItem in self.VVymx1():
32598:    if FFI3NO(confItem):
32599:     FFRMYv(self, BF(self.VVM20Q, cbFnc=self.VVeE99), "Save Changes ?", callBack_No=self.VVoE7f, title=self.Title)
32600:     break
32601:   else:
32602:    self.VVeE99()
32603:  def VVeE99(self):
32604:   if  self.settingShown   : self.VVQjDh()
32605:   elif self.VV1s50() : self.VVKKbg()
32606:   else       : self.close("subtExit")
32607:  def VVoE7f(self):
32608:   for confItem in self.VVymx1(): confItem.cancel()
32609:   if self.settingShown:
32610:    self.VVwsJV()
32611:    self.VVvsHp()
32612:    self.VVQjDh()
32613:   else:
32614:    self.close("subtExit")
32615:  def VVkrkn(self):
32616:   if self.settingShown   : self.VVYDfu()
32617:   elif self.VV1s50() : pass
32618:   else       : self.VVFBoa()
32619:  def VVuLkD(self, pos):
32620:   if self.settingShown:
32621:    self.CursorPos += pos
32622:    if   self.CursorPos > len(self.settingLabels) - 1: self.CursorPos = 0
32623:    elif self.CursorPos < 0        : self.CursorPos = len(self.settingLabels) - 1
32624:    inst = self[self.settingLabels[self.CursorPos]].instance
32625:    left = inst.position().x() - 5
32626:    inst = self["mySubtCursor"].instance
32627:    inst.move(ePoint(left, int(inst.position().y())))
32628:   else:
32629:    self.VVa6DV(pos)
32630:  def VVa6DV(self, pos):
32631:   posVal, durVal = self.VV2kXj()
32632:   if pos == -1: ndx = self.VV8JPJ(posVal)
32633:   else  : ndx = self.VVbEqG(posVal)
32634:   if   ndx < 0      : FF28n1(self, "No lines"  , 500)
32635:   elif ndx == 0      : FF28n1(self, "First line", 500)
32636:   elif ndx == len(self.subtList) - 1 : FF28n1(self, "Last line" , 500)
32637:   else:
32638:    capNum, frmSec, toSec, subtLines = self.subtList[ndx]
32639:    delay, color, allow = self.VVauIP(frmSec)
32640:    if allow:
32641:     if self.VV1s50():
32642:      self.VVRIDu(delay, True)
32643:      self.VVIE7K(force=True)
32644:     else:
32645:      self.VVoPF3(delay, frmSec)
32646:    else:
32647:     FF28n1(self, "Delay out of range", 800)
32648:  def VVPCRE(self, val):
32649:   self.VVRIDu(CFG.subtDelaySec.getValue() + val)
32650:   self.VVIE7K(force=True)
32651:  def VVoPF3(self, delay, frmSec):
32652:   self["mySubtChng2"].setText("Line Time = %s" % FFFHEC(frmSec))
32653:   self["mySubtChng3"].setText("Delay = %s second%s" % (delay, FFcacr(delay)))
32654:   for i in range(4): self["mySubtChng%d" % i].show()
32655:   self["myRest1"].show()
32656:   try: self.VVoJze_conn = self.VVoJze.timeout.connect(self.VVCQjm)
32657:   except: self.VVoJze.callback.append(self.VVCQjm)
32658:   self.VVoJze.start(100, False)
32659:  def VVCQjm(self):
32660:   if self.curSubtFullData:
32661:    capNum, frmSec, toSec, subtLines, VVBGsZ = self.curSubtFullData
32662:    if frmSec > 0 and toSec - frmSec > 0:
32663:     self["mySubtChng2"].setText("Line %s      %s" % (capNum, FFFHEC(frmSec)))
32664:     self["mySubtChng3"].setText("Delay = %s Sec" % CFG.subtDelaySec.getValue())
32665:  def VVKKbg(self):
32666:   self.VVoJze.stop()
32667:   for i in range(4): self["mySubtChng%d" % i].hide()
32668:   self["myRest1"].hide()
32669:  def VV1s50(self):
32670:   return self["mySubtChng1"].getVisible()
32671:  def VVoC5Z(self, isUp):
32672:   if not self.settingShown and not self.VV1s50():
32673:    self.close("subtZapUp" if isUp else "subtZapDn")
32674:  def VV1XNb(self, reason):
32675:   if not self.settingShown:
32676:    self.close(reason)
32677:  def VVFHmB(self, act):
32678:   if self.playerObj:
32679:    if   act == "rewind" : self.playerObj.VVJup6()
32680:    elif act == "forward" : self.playerObj.VVzX0n()
32681:  def VVbyWX(self) : self.VVFj7n(5)
32682:  def VVe6KA(self) : self.VVFj7n(6)
32683:  def VVKUAt(self) : self.VVFj7n(-1)
32684:  def VVx0di(self):
32685:   if  self.settingShown   : self.VVFj7n(1)
32686:   elif self.VV1s50() : self.VVPCRE(1)
32687:   else       : self.VVoC5Z(True)
32688:  def VVDBsZ(self):
32689:   if self.settingShown: self.VVFj7n(0)
32690:   elif self.VV1s50() : self.VVPCRE(-1)
32691:   else    : self.VVoC5Z(False)
32692:  def VVFj7n(self, direction):
32693:   if self.settingShown:
32694:    confItem = self.VVymx1()[self.CursorPos]
32695:    if direction == -1:
32696:     confItem.setValue(confItem.default)
32697:    else:
32698:     if direction in (0, 1) and confItem in (CFG.subtTextFg, CFG.subtTextFont, CFG.subtTextAlign, CFG.subtShadowColor, CFG.subtVerticalPos):
32699:      direction = 0 if direction == 1 else 1
32700:     confItem.handleKey(direction)
32701:    if confItem is CFG.subtTextAlign:
32702:     align = CFG.subtTextAlign.getValue()
32703:     boxWidth= self.instance.size().width()
32704:     for i in range(3):
32705:      inst = self["mySubt%d" % i].instance
32706:      w   = inst.calculateSize().width() + 50
32707:      if   align == "0" : left = 0
32708:      elif align == "2" : left = boxWidth - w
32709:      else    : left = int((getDesktop(0).size().width() - w) / 2.0)
32710:      inst.move(ePoint(left, int(inst.position().y())))
32711:    self.VVwsJV()
32712:    self.VVvsHp()
32713:    self.VVIE7K(True)
32714:  def VVymx1(self):
32715:   return (  CFG.subtDelaySec
32716:     , CFG.subtBGTransp
32717:     , CFG.subtTextFg
32718:     , CFG.subtTextFont
32719:     , CFG.subtTextSize
32720:     , CFG.subtTextAlign
32721:     , CFG.subtShadowColor
32722:     , CFG.subtShadowSize
32723:     , CFG.subtVerticalPos)
32724:  def VV7y8M(self):
32725:   if self.settingShown:
32726:    FFRMYv(self, self.VVT7Sd, "Reset Subtitle Settings to default ?", title=self.Title)
32727:  def VVT7Sd(self):
32728:   for confItem in self.VVymx1(): confItem.setValue(confItem.default)
32729:   self.VVM20Q()
32730:   self.VVwsJV()
32731:   self.VVvsHp()
32732:  def VVRIDu(self, delay, force=False):
32733:   if self.settingShown or self.VV1s50() or force:
32734:    FFjt1c(CFG.subtDelaySec, delay)
32735:    self.VVhAuT()
32736:    self.VVwsJV()
32737:    self.VVvsHp()
32738:    if  self.settingShown and delay == 0: FF1mVE(self, 'Reset to "0"', 800)
32739:    elif self.VV1s50()   : self.VVCQjm()
32740:  def VVSQ1n(self):
32741:   Max = CFG.subtDelayMax.getValue() * 60
32742:   CFG.subtDelaySec = ConfigSelectionNumber(default=0, stepwidth=1, min=-Max, max=Max, wraparound=False)
32743:   FFjt1c(CFG.subtDelaySec, 0)
32744:   self.minDelay, self.maxDelay = self.VVmwD5()
32745:   self.VVM20Q()
32746:   self.VVwsJV()
32747:  def VVUosz(self):
32748:   if self.settingShown:
32749:    self.VVM20Q()
32750:    self.VVQjDh()
32751:  def VVM20Q(self, cbFnc=None):
32752:   for confItem in self.VVymx1(): confItem.save()
32753:   configfile.save()
32754:   self.VVhAuT()
32755:   FF1mVE(self, "Saved")
32756:   if cbFnc:
32757:    cbFnc()
32758:  def VVwsJV(self):
32759:   cfgLst = self.VVymx1()
32760:   for i, name in enumerate(self.settingLabels1):
32761:    self[name].setText(str(cfgLst[i].getText()))
32762:  def VVvsHp(self):
32763:   path = CFG.subtTextFont.getValue()
32764:   if FFCyVu(path):
32765:    fnt = "AJP_Subtitle"
32766:    FFXcbU(path, fnt, isRepl=1)
32767:   else:
32768:    fnt = VVNhAq
32769:   lineH = 0
32770:   top = self["mySubt0"].instance.position().y()
32771:   bg = int(FFjFSv(CFG.subtBGTransp.getValue(), 0, 100, 0, 255))
32772:   try:
32773:    for i in range(3):
32774:     obj = self["mySubt%d" % i]
32775:     inst = obj.instance
32776:     if CFG.subtTextFg.getValue().startswith("#"):
32777:      FFGUI5(obj, CFG.subtTextFg.getValue())
32778:     VVgbF2 = CFG.subtTextSize.getValue()
32779:     inst.setFont(gFont(fnt, VVgbF2))
32780:     FFZ0AC(obj, "#%0.2X000000" % bg)
32781:     FFK4PQ(self["mySubt%d" % i], CFG.subtShadowColor.getValue(), int(CFG.subtShadowSize.getValue()))
32782:     lineH = FFGrBZ(VVgbF2, self.VV0Ov6)
32783:     inst.resize(eSize(*(int(inst.size().width()), lineH)))
32784:     if i > 0:
32785:      inst.move(ePoint(int(inst.position().x()), int(top + lineH * i + i * 1 )))
32786:    for i in range(1, 4):
32787:     inst = self["mySubtSep%d" % i].instance
32788:     inst.move(ePoint(int(inst.position().x()), int(top + lineH * i + i * 1 )))
32789:   except:
32790:    pass
32791:   inst = self["mySubt2"].instance
32792:   winH = inst.position().y() + inst.size().height() + 2
32793:   winW = self.instance.size().width()
32794:   self.instance.resize(eSize(*(int(winW), int(winH))))
32795:   y = int(FFjFSv(CFG.subtVerticalPos.getValue(), 0, 100, 0, FFrPd1()[1] - winH))
32796:   self.instance.move(ePoint(int(self.instance.position().x()), y))
32797:   FF9sDw(self, winW, winH)
32798:  def VVbZLl(self):
32799:   sp = "    "
32800:   txt  = "%s\n"   % FFjt5L("Subtitle File:", VVFuwR)
32801:   txt += sp + "%s\n\n" % self.lastSubtFile
32802:   txt += "%s\n"     % FFjt5L("Subtitle Settings:", VVFuwR)
32803:   txt += sp + "Encoding\t: %s\n" % (self.lastSubtEnc or "Default")
32804:   txt += sp + "Delay\t: %s sec\n" % CFG.subtDelaySec.getValue()
32805:   if self.subtList:
32806:    posVal, durVal = self.VV2kXj()
32807:    capNum1, frmSec1, toSec1, subtLines1 = self.subtList[0]
32808:    capNum2, frmSec2, toSec2, subtLines2 = self.subtList[len(self.subtList) - 1]
32809:    time1 = FFFHEC(frmSec1)
32810:    time2 = FFFHEC(toSec2)
32811:    txt += "\n"
32812:    txt += "%s\n"       % FFjt5L("Timing:", VVFuwR)
32813:    txt += sp + "Captions\t: %s - %s\n"  % (capNum1, capNum2)
32814:    txt += sp + "Subt. Time\t: %s - %s\n" % (time1, time2)
32815:    txt += sp + "Event Dur.\t: %s\n"  % FFFHEC(durVal)
32816:    txt += sp + "Progress\t: %s\n" % FFFHEC(posVal)
32817:    err = self.VVCrXT(posVal)
32818:    if err:
32819:     txt += sp + "Remarks\t: %s\n" % FFjt5L(err, VVz22H)
32820:   FF4lCP(self, txt, title="Current Subtitle")
32821:  @FFOAKH("Checking Subtitle ...", clearMsg=False)
32822:  def VV0xaU(self, path="", delay=0, enc=""):
32823:   try:
32824:    self.VVeEaQ.stop()
32825:    if path:
32826:     subtList, err = self.VVmqiE(path, enc=enc)
32827:     if err    : self.close(err)
32828:     elif not subtList : self.close("subtInval")
32829:     else    :
32830:      self.subtList = subtList
32831:      CFG.subtDelaySec.setValue(int(delay))
32832:      FFjt1c(CFG.subtDelaySec, int(delay))
32833:      self.VVwsJV()
32834:      self.VVJclP()
32835:    else:
32836:     path, delay, enc = CCfpAm.VVuuUw(self)
32837:     if path:
32838:      self.VV0xaU(path=path, delay=delay, enc=enc)
32839:     else:
32840:      self.VVYDfu()
32841:   except:
32842:    pass
32843:  def VVJclP(self):
32844:   CCfpAm.VVDjVi(None)
32845:   try: self.VVeEaQ_conn = self.VVeEaQ.timeout.connect(self.VVIE7K)
32846:   except: self.VVeEaQ.callback.append(self.VVIE7K)
32847:   self.VVeEaQ.start(500, False)
32848:   try: self.VVOAGe_conn = self.VVOAGe.timeout.connect(self.VVPIYj)
32849:   except: self.VVOAGe.callback.append(self.VVPIYj)
32850:   err = self.VVCrXT()
32851:   if err : FF1mVE(self, err)
32852:   else : FF1mVE(self, "Subtitle started", 700)
32853:  def VVCrXT(self, posVal=None):
32854:   if posVal == None:
32855:    posVal, durVal = self.VV2kXj()
32856:   capNum2, frmSec2, toSec2, subtLines2 = self.subtList[len(self.subtList) - 1]
32857:   return "Subtitle end reached" if (posVal - int(CFG.subtDelaySec.getValue()) > toSec2) else ""
32858:  def VVfaeX(self, posVal, margin=0):
32859:   capNum2, frmSec2, toSec2, subtLines2 = self.subtList[len(self.subtList) - 1]
32860:   if posVal + self.maxDelay > toSec2:
32861:    path = CCfpAm.VVXUuh(self)
32862:    FF1mVE(self, "End of subtitle reached")
32863:    return True
32864:   else:
32865:    return False
32866:  def VVYDfu(self):
32867:   c1, c2, c3, c4, c5, c6 = VVFuwR, VVJEMb, VVZtfx, VVcPtB, VVIH76, VVz22H
32868:   fPath, fDir, fName = CClYaF.VV4zSS(self)
32869:   txt1 = FFjt5L("... from Favourite Path", VVo7S9)
32870:   VV3wat = []
32871:   VV3wat.append(("Select from Favourites Path"     , "listFav"  ))
32872:   VV3wat.append(("Select from All Paths"      , "listAll"  ))
32873:   VV3wat.append((c1 + "Select from File Manager"    , "listFMan" ))
32874:   VV3wat.append(FFsLU5("Select from Current Movie Path" , "listCur", fPath, c2 ))
32875:   VV3wat.append(VVAL3j)
32876:   VV3wat.append(("Set Maximum Delay (Minutes)"     , "setMaxDelay" ))
32877:   VV3wat.append(VVAL3j)
32878:   VV3wat.append((c3 + "Set Favourite Path"      , "setFavPath" ))
32879:   VV3wat.append((c3 + "Set Auto-Find Event Name Language"  , "setFavLang" ))
32880:   VV3wat.append(VVAL3j)
32881:   VV3wat.append((c3 + "Suggest files (%s35%%%s match) %s" % (c4, c3, txt1), "sugSrt0.35"))
32882:   VV3wat.append((c3 + "Suggest files (%s50%%%s match) %s" % (c4, c3, txt1), "sugSrt0.50"))
32883:   VV3wat.append((c3 + "Suggest files (%s80%%%s match) %s" % (c4, c3, txt1), "sugSrt0.80"))
32884:   if self.settingShown:
32885:    VV3wat.append(VVAL3j)
32886:    VV3wat.append((c5 + "Change Subtitle File Encoding" , "enc"  ))
32887:    VV3wat.append(VVAL3j)
32888:    VV3wat.append((c6 + "Disable Current Subtitle"  , "disb" ))
32889:    VV3wat.append(VVAL3j)
32890:    VV3wat.append(("Help (Keys)"       , "help" ))
32891:   VVOa1G = self.VVA7Bn
32892:   FFLFTC(self, self.VVlBeI, VV3wat=VV3wat, width=900, height=1000, title='Find Subtitle "srt" File', VVOa1G=VVOa1G, VVwltY="#22001122", VVkxBG="#11000509", VVoCB2="#08554455")
32893:  def VVA7Bn(self, item=None):
32894:   if item:
32895:    VV7tND, title, item, ndx = item
32896:    self.VV7tND = VV7tND
32897:    title = FFzBfi(title).partition("...")[0].strip()
32898:    if   item == "listFav"   : self.VVGZ4w(0, title)
32899:    elif item == "listAll"   : self.VVGZ4w(1, title)
32900:    elif item == "listFMan"   : self.session.openWithCallback(self.VV3eWi, BF(CClYaF, VV1gDA="srt", VV1pbK=CFG.lastSubtFManFindDir.getValue()))
32901:    elif item == "listCur"   : self.VVGZ4w(2, title)
32902:    elif item == "setMaxDelay"  : CCJaSw.VV5YpJ(self, CFG.subtDelayMax, "Subtitle Delay Limit (Minutes)", cbFnc=self.VVSQ1n, isSave=True, width=700)
32903:    elif item == "setFavPath"  : self.session.openWithCallback(self.VVjvca, BF(CClYaF, mode=CClYaF.VV9N82, VV1pbK=CFG.subtitleFavPath.getValue()))
32904:    elif item == "setFavLang"  : CCJaSw.VV5YpJ(self, CFG.subtitleEventLang, "Event Name Search Language", cbFnc=BF(FF1mVE, self.VV7tND or self, "Saved"), isSave=True, width=700)
32905:    elif item.startswith("sugSrt") : self.VVGZ4w(3, title, coeff=float(item[6:]))
32906:    elif item == "enc":
32907:     if self.lastSubtFile and FFCyVu(self.lastSubtFile) : FFimQ3(self.VV7tND or self, BF(CC7ocD.VV9PZW, self, self.lastSubtFile, self.VVTQw2, self.lastSubtEnc or CFG.subtDefaultEnc.getValue()), title="Loading Codecs ...")
32908:     else             : FF28n1(self, "SRT File error", 1000)
32909:    elif item == "disb"    : self.VVnKGQ()
32910:    elif item == "help"    : FFw2rR(self, "_help_subt", "Subtitle (Keys)")
32911:  def VVnKGQ(self, item=None):
32912:   subtRefFile = CCfpAm.VVXUuh(self)
32913:   fPath, fDir, fName = CClYaF.VV4zSS(self)
32914:   if fPath and subtRefFile:
32915:    fPath += ".ajp"
32916:    if FFCyVu(fPath):
32917:     FFpwZS("mv -f '%s' '%s.dis'" % (fPath, fPath))
32918:   else:
32919:    FFwgGB(subtRefFile)
32920:   self.VVCnc1()
32921:   self.close("subtExit")
32922:  def VVlBeI(self, item=None):
32923:   if not self.settingShown and self.subtMenuFromPlayer:
32924:    self.close("subtCancel")
32925:  def VVCnc1(self):
32926:   self.subtMenuFromPlayer = False
32927:   if self.VV7tND: self.VV7tND.cancel()
32928:   if self.settingShown: self.VVQjDh()
32929:  def VVTQw2(self, item=None):
32930:   if item:
32931:    self.VVCnc1()
32932:    FFimQ3(self.VV7tND or self, BF(self.VV0xaU, path=self.lastSubtFile, delay=CFG.subtDelaySec.getValue(), enc=item), title="Loading Subtitle ...")
32933:  def VV3eWi(self, path):
32934:   if path:
32935:    self.VVCnc1()
32936:    FFjt1c(CFG.lastSubtFManFindDir, os.path.dirname(path))
32937:    self.VV0xaU(path=path)
32938:  def VVjvca(self, path):
32939:   if path:
32940:    FFjt1c(CFG.subtitleFavPath, path)
32941:    FF1mVE(self.VV7tND or self, "Saved")
32942:  def VVGZ4w(self, mode, title, coeff=0.25):
32943:   FFimQ3(self.VV7tND or self, BF(self.VVLDgS, mode, title, coeff), title="Searching for srt files")
32944:  def VVLDgS(self, mode, title, coeff):
32945:   evName = CC5TsO.VVMZqx(self).strip()
32946:   if mode == 3 and not evName:
32947:    FFjADj(self.VV7tND or self, "No event Name", 2000)
32948:    return
32949:   if   mode == 0: sPath = CFG.subtitleFavPath.getValue()
32950:   elif mode == 1: sPath = "/"
32951:   elif mode == 2: sPath = CClYaF.VV4zSS(self)[1]
32952:   elif mode == 3: sPath = CFG.subtitleFavPath.getValue()
32953:   srtList = FFycDu(r'find "%s" %s \( -iname "*.srt" \) | grep -i "\.srt"' % (sPath, FF5W9s(1)))
32954:   if srtList and srtList[0].startswith("find:"):
32955:    FFdw58(self, "Error in path:\n\n%s" % sPath, title=title)
32956:    return
32957:   if not srtList:
32958:    FFjADj(self.VV7tND or self, "No srt files", 1500)
32959:    return
32960:   srtList.sort(key=lambda x: x.lower())
32961:   if mode == 3:
32962:    trName = evName
32963:    if CFG.subtitleEventLang.getValue() == "s":
32964:     trName = CC5TsO.VV6IMT(evName, "en")[0] or evName
32965:    title = "%s %s\t%s %s" % (title, VVA4XU, VV1fx4, trName)
32966:    self.VVQebZ(self.VV7tND or self, BF(self.VVtLEg, mode, evName, trName, title), trName, srtList, 20, coeff)
32967:   else:
32968:    self.VVtLEg(mode, evName, "", title, srtList, "")
32969:  def VVtLEg(self, mode, evName, trName, title, srtList, err):
32970:   if mode == 3:
32971:    if not srtList: err = err or "No Similar Names"
32972:    if err:
32973:     if evName == trName : FFjADj(self.VV7tND or self, err, 2000)
32974:     else    : FFdw58(self, err, title="Event : %s" % trName)
32975:     return
32976:   VVAkuK = []
32977:   curColor = "#f#0000FF00#"
32978:   for path in srtList:
32979:    fName, Dir = os.path.basename(path), FFoWxR(os.path.dirname(path))
32980:    if self.lastSubtFile == Dir + fName:
32981:     fName, Dir = curColor + fName, curColor + Dir
32982:    VVAkuK.append((fName, Dir))
32983:   VVu1YM  = ("Select"    , self.VVyFPG        , [])
32984:   VV2ytr = (""     , self.VVZqbx          , [])
32985:   VVCOpO = (""     , BF(self.VVlNCd, self.lastSubtFile, False) , [])
32986:   VVwSzI = ("Find Current File" , BF(self.VVlNCd, self.lastSubtFile, True) , [])
32987:   header   = ("File" , "Directory" )
32988:   widths   = (60  , 40   )
32989:   FFUQ0v(self, None, title=title, header=header, VVGape=VVAkuK, VV3cHe=widths, VVwdmN=28, VVu1YM=VVu1YM, VV2ytr=VV2ytr, VVCOpO=VVCOpO, VVwSzI=VVwSzI, VVSLOq=CFG.lastFindSubtitle
32990:     , VVwltY="#11002222", VVkxBG="#22001111", VVemyB="#22001111", VVoRat="#11ffff00", VVJKqd="#11552233", VVbcr0="#22222222", VVX9AA="#11002233")
32991:  def VVZqbx(self, VV6A99, title, txt, colList):
32992:   fName, Dir = colList
32993:   FF4lCP(VV6A99, "%s\n\n%s%s" % (FFjt5L("Path:", VVFuwR), Dir, fName), title=title)
32994:  def VVlNCd(self, path, VVwb7n, VV6A99, title, txt, colList):
32995:   for ndx, row in enumerate(VV6A99.VVrrm9()):
32996:    if path == row[1].strip() + row[0].strip():
32997:     VV6A99.VVrqBw(ndx)
32998:     break
32999:   else:
33000:    if VVwb7n:
33001:     FF28n1(VV6A99, "Not in list !", 1000)
33002:  def VVyFPG(self, VV6A99, title, txt, colList):
33003:   VV6A99.cancel()
33004:   self.VVCnc1()
33005:   path = "%s%s" % (colList[1].strip(), colList[0].strip())
33006:   FFimQ3(self.VV7tND, BF(self.VV0xaU, path=path))
33007:  def VVmqiE(self, path, enc=None):
33008:   if enc and CC7ocD.VVRTBW(path, enc)      : enc = enc
33009:   elif CC7ocD.VVRTBW(path, CFG.subtDefaultEnc.getValue()): enc = CFG.subtDefaultEnc.getValue()
33010:   else                   : enc = None
33011:   if not FFCyVu(path):
33012:    return [], "File not found"
33013:   if (FFXhoc(path) > 1024 * 700):
33014:    return [], "File too big"
33015:   frmSec = toSec = bold = italic = under = 0
33016:   capNum  = ""
33017:   capFound = True
33018:   color  = ""
33019:   subtLines = []
33020:   subtList = []
33021:   lines  = FFL19l(path, encLst=enc)
33022:   lastNdx  = len(lines) - 1
33023:   for ndx, line in enumerate(lines):
33024:    line = str(line).strip()
33025:    if line:
33026:     if line.isdigit():
33027:      capNum = line
33028:     else:
33029:      span = iSearch(r'(\d{2}:\d{2}:\d{2},\d{3})\s*\-->\s*(\d{2}:\d{2}:\d{2},\d{3})', line, IGNORECASE)
33030:      if span:
33031:       p  = list(map(int, span.group(1).replace(",", ":").split(":")))
33032:       frmSec = p[0] * 3600 + p[1] * 60 + p[2] + p[3] / 1000.0
33033:       p  = list(map(int, span.group(2).replace(",", ":").split(":")))
33034:       toSec = p[0] * 3600 + p[1] * 60 + p[2] + p[3] / 1000.0
33035:       subtLines = []
33036:      else:
33037:       span = iSearch(r'<font color="(.+)">(.+)', line, IGNORECASE)
33038:       if span:
33039:        color = self.VVlzrA(span.group(1))
33040:        line = span.group(2)
33041:       if "<b>" in line: bold = 1
33042:       if "<i>" in line: italic = 1
33043:       if "<u>" in line: under = 1
33044:       line = line.replace("</font>", "").replace("</b>", "").replace("</i>", "").replace("</u>", "")
33045:       line = line.replace("<b>", "").replace("<i>", "").replace("<u>", "")
33046:       span = iSearch(r"{\\a\d}(.+)", line, IGNORECASE)
33047:       if span:
33048:        line = span.group(1)
33049:       line = self.VVtBZY(line)
33050:       subtLines.append((line.strip(), color, bold, italic, under))
33051:       if ndx == lastNdx and subtList and (toSec - frmSec) > 0 and not subtList[len(subtList) - 1] == (capNum, frmSec, toSec, subtLines):
33052:        subtList.append((capNum, frmSec, toSec, subtLines))
33053:    else:
33054:     if toSec > frmSec and subtLines:
33055:      subtList.append((capNum, frmSec, toSec, subtLines))
33056:     frmSec = toSec = bold = italic = under = 0
33057:     capNum  = ""
33058:     color  = ""
33059:     subtLines = []
33060:   if subtList:
33061:    self.lastSubtFile = path
33062:    self.lastSubtEnc  = enc
33063:    self.VVhAuT()
33064:   return subtList, ""
33065:  def VVtBZY(self, line):
33066:   line = line.replace(u"\u202A", "")
33067:   line = line.replace(u"\u202B", "")
33068:   line = line.replace(u"\u202C", "")
33069:   for char in line:
33070:    if 0x600 <= ord(char) <= 0x6FF and char in self.diac:
33071:     line = line.replace(char, "")
33072:   line = line.replace("\r", "..").replace("\n", "..")
33073:   return str(line)
33074:  def VVlzrA(self, color):
33075:   lst = { "black": "#000000", "blue": "#0000ff", "brown":"#a52a2a", "cyan":"#00ffff", "darkblue": "#0000a0", "gray":"#808080", "green":"#008000", "grey": "#808080", "lightblue":"#add8E6", "lime":"#00ff00", "magenta":"#ff00ff", "maroon":"#800000", "olive":"#808000", "orange":"#ffa500", "purple":"#800080", "red":"#ff0000", "silver":"#c0c0c0", "white":"#ffffff", "yellow":"#ffff00"}
33076:   code = lst.get(color.lower(), "")
33077:   if code:
33078:    return code
33079:   else:
33080:    span = iSearch(r"(
33081:    if span : return span.group(1)
33082:    else : return ""
33083:  def VVhAuT(self):
33084:   path = CCfpAm.VVXUuh(self)
33085:   if path:
33086:    try:
33087:     with open(path, "w") as f:
33088:      f.write("srt=%s\n" % self.lastSubtFile)
33089:      f.write("delay=%s\n" % CFG.subtDelaySec.getValue())
33090:      if self.lastSubtEnc:
33091:       f.write("enc=%s\n" % self.lastSubtEnc)
33092:    except:
33093:     pass
33094:  def VVIE7K(self, force=False):
33095:   posVal, durVal = self.VV2kXj()
33096:   err = self.VVCrXT(posVal)
33097:   if err:
33098:    return
33099:   VVBGsZ = self.VVB4vs(posVal)
33100:   if VVBGsZ < 0:
33101:    return
33102:   txtDur = 0
33103:   if posVal:
33104:    capNum, frmSec, toSec, subtLines = self.subtList[VVBGsZ]
33105:    if force or not self.lastSubtInfo == subtLines:
33106:     self.lastSubtInfo = subtLines
33107:     self.curSubtFullData = (capNum, frmSec, toSec, subtLines, VVBGsZ)
33108:     settingColor = ""
33109:     if CFG.subtTextFg.getValue().startswith("
33110:      settingColor = CFG.subtTextFg.getValue()
33111:     self.VVPIYj()
33112:     subtLines = list(subtLines)
33113:     l = len(subtLines)
33114:     for i in range(3 - len(subtLines)):
33115:      subtLines.insert(0, ("", "", 0, 0, 0))
33116:     align = CFG.subtTextAlign.getValue()
33117:     boxWidth= self.instance.size().width()
33118:     txtDur = int(toSec * 1000 - frmSec * 1000)
33119:     if txtDur > 0:
33120:      for ndx, (line, color, bold, italic, under) in enumerate(subtLines):
33121:       if line:
33122:        if   bold   : newColor = "
33123:        elif italic   : newColor = "#aaaaaa"
33124:        elif under   : newColor = "#ffffaa"
33125:        elif settingColor : newColor = settingColor
33126:        elif color   : newColor = color
33127:        else    : newColor = ""
33128:        if ndx < 3:
33129:         obj  = self["mySubt%d" % ndx]
33130:         inst = obj.instance
33131:         if newColor:
33132:          FFGUI5(obj, newColor)
33133:         obj.setText(line)
33134:         obj.show()
33135:         w = inst.calculateSize().width() + self.VVfJF0
33136:         inst.resize(eSize(*(w, inst.size().height())))
33137:         if   align == "0" : left = 0
33138:         elif align == "2" : left = boxWidth - w
33139:         else    : left = int((getDesktop(0).size().width() - w) / 2.0)
33140:         inst.move(ePoint(left, int(inst.position().y())))
33141:     if txtDur > 0:
33142:      self.VVOAGe.start(txtDur, True)
33143:  def VV2kXj(self):
33144:   seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt = CCqWM2.VVVxSJ(self)
33145:   if not durVal and not posVal:
33146:    evName, evTime, evDur, evShort, evDesc, genre, PR = CC5TsO.VVgoJl(self)
33147:    if evTime and evDur:
33148:     posVal, durVal = iTime() - evTime, evDur
33149:   return posVal, durVal
33150:  def VVB4vs(self, posVal):
33151:   if posVal > 0:
33152:    delay = CFG.subtDelaySec.getValue()
33153:    for ndx, item in enumerate(self.subtList):
33154:     frmSec = item[1] + delay
33155:     toSec = item[2] + delay
33156:     if posVal > frmSec and posVal < toSec:
33157:      return ndx
33158:   return -1
33159:  def VV8JPJ(self, posVal):
33160:   if posVal > 0:
33161:    delay = CFG.subtDelaySec.getValue()
33162:    for ndx, item in enumerate(self.subtList):
33163:     frmSec = item[1] + delay
33164:     toSec = item[2] + delay
33165:     if toSec > posVal:
33166:      return ndx -1
33167:   return -1
33168:  def VVbEqG(self, posVal):
33169:   if posVal > 0:
33170:    delay = CFG.subtDelaySec.getValue()
33171:    for ndx, item in enumerate(self.subtList):
33172:     frmSec = item[1] + delay
33173:     toSec = item[2] + delay
33174:     if frmSec > posVal:
33175:      return ndx
33176:   return -1
33177:  def VVPIYj(self):
33178:   for i in range(3):
33179:    self["mySubt%d" % i].setText("")
33180:    FFGUI5(self["mySubt%d" % i], "#00ffffff")
33181:    self["mySubt%d" % i].hide()
33182:  def VVsdgY(self):
33183:   if not self.VV1s50():
33184:    self.VVc7QB()
33185:  @FFOAKH("Loading Lines ...")
33186:  def VVc7QB(self):
33187:   VVAkuK = []
33188:   for cap, frm, to, lines in self.subtList:
33189:    firstLine = lines[0][0] if lines else ""
33190:    VVAkuK.append((cap, FFFHEC(frm), str(frm), firstLine))
33191:   if VVAkuK:
33192:    title = "Select Current Subtitle Line"
33193:    VVu8qI = self.VVx5RW
33194:    VVCOpO = (""    , self.VVCiYt , [])
33195:    VVu1YM  = ("Select"   , self.VVdVmL , [title])
33196:    VVwSzI = ("Current Line" , self.VVg4bx , [True])
33197:    VVScQz = ("Reset Delay" , self.VV4qS4 , [])
33198:    header   = ("Cap" , "Time", "Time Val", "Subtitle Text" )
33199:    widths   = (8  , 15 , 0    , 77    )
33200:    VVLIqP  = (CENTER , CENTER, CENTER , LEFT    )
33201:    VV6A99 = FFUQ0v(self, None, title=title, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=28, VVCOpO=VVCOpO, VVu8qI=VVu8qI, VVu1YM=VVu1YM, VVwSzI=VVwSzI, VVScQz=VVScQz
33202:           , VVwltY="#33002222", VVkxBG="#33001111", VVemyB="#33110011", VVoRat="#11ffff00", VVJKqd="#0a334455", VVbcr0="#22222222", VVX9AA="#33002233")
33203:    err = self.VVCrXT()
33204:    if err:
33205:     VV6A99.VVMjPT()
33206:     FF28n1(VV6A99, err, 1500)
33207:   else:
33208:    FFjADj(self, "Cannot read lines !", 2000)
33209:  def VVCiYt(self, VV6A99, title, txt, colList):
33210:   self.subtLinesTable = VV6A99
33211:   if int(CFG.subtDelaySec.getValue()):
33212:    VV6A99["keyYellow"].show()
33213:    VV6A99["keyYellow"].setText("Reset Delay (%s sec)" % CFG.subtDelaySec.getValue())
33214:   else:
33215:    VV6A99["keyYellow"].hide()
33216:   VV6A99["keyBlue"].setText("New Delay: %s sec" % CFG.subtDelaySec.getValue())
33217:   VV6A99["keyBlue"].show()
33218:   FFZ0AC(VV6A99["keyBlue"], "#22222222")
33219:   VV6A99.VVIOX6(BF(self.VV0r1T, VV6A99))
33220:   self.VVg4bx(VV6A99, False)
33221:   try: self.VVxJJL_conn = self.VVxJJL.timeout.connect(self.VVnhGm)
33222:   except: self.VVxJJL.callback.append(self.VVnhGm)
33223:   self.VVxJJL.start(500, False)
33224:  def VVx5RW(self, VV6A99):
33225:   self.VVxJJL.stop()
33226:   self.subtLinesTable  = None
33227:   self.subtLinesTableNdx = -1
33228:   VV6A99.cancel()
33229:  def VVnhGm(self):
33230:   if self.subtLinesTable:
33231:    VV6A99 = self.subtLinesTable
33232:    posVal, durVal = self.VV2kXj()
33233:    color = "#b#11551111#"
33234:    if posVal > 0:
33235:     curTime = posVal - float(CFG.subtDelaySec.getValue())
33236:     VVBGsZ = self.VVB4vs(posVal)
33237:     if VVBGsZ > -1:
33238:      if self.subtLinesTableNdx > -1:
33239:       row = VV6A99.VVMADj(self.subtLinesTableNdx)
33240:       row[0] = row[0].replace(color, "")
33241:       VV6A99.VVEOou(self.subtLinesTableNdx, row)
33242:      row = VV6A99.VVMADj(VVBGsZ)
33243:      row[0] = color + row[0]
33244:      VV6A99.VVEOou(VVBGsZ, row)
33245:      self.subtLinesTableNdx = VVBGsZ
33246:  def VVdVmL(self, VV6A99, Title):
33247:   delay, color, allow = self.VVLLr9(VV6A99)
33248:   if allow:
33249:    self.VVx5RW(VV6A99)
33250:    self.VVRIDu(delay, True)
33251:   else:
33252:    FF28n1(VV6A99, "Delay out of range", 1500)
33253:  def VVg4bx(self, VV6A99, VVwb7n, onlyColor=False):
33254:   if VV6A99:
33255:    posVal, durVal = self.VV2kXj()
33256:    if posVal > 0:
33257:     curTime = posVal - float(CFG.subtDelaySec.getValue())
33258:     VVBGsZ = self.VVB4vs(posVal)
33259:     if VVBGsZ > -1:
33260:      VV6A99.VVrqBw(VVBGsZ)
33261:     else:
33262:      ndx = self.VV8JPJ(posVal)
33263:      if ndx > -1:
33264:       VV6A99.VVrqBw(ndx)
33265:  def VV4qS4(self, VV6A99, title, txt, colList):
33266:   if VV6A99["keyYellow"].getVisible():
33267:    self.VVRIDu(0, True)
33268:    VV6A99["keyYellow"].hide()
33269:    self.VVg4bx(VV6A99, False)
33270:  def VV0r1T(self, VV6A99):
33271:   delay, color, allow = self.VVLLr9(VV6A99)
33272:   VV6A99["keyBlue"].setText("%sNew Delay: %s sec" % (color, delay))
33273:  def VVLLr9(self, VV6A99):
33274:   lineTime = float(VV6A99.VV5crm()[2].strip())
33275:   return self.VVauIP(lineTime)
33276:  def VVauIP(self, lineTime):
33277:   posVal, durVal = self.VV2kXj()
33278:   delay, color, allow = 0, "", False
33279:   if posVal > 0:
33280:    val = int(round(posVal - lineTime))
33281:    if self.minDelay <= val <= self.maxDelay: allow, color = True , VVJEMb
33282:    else          : allow, color = False, VVyFI2
33283:    delay = FFsRWN(val, self.minDelay, self.maxDelay)
33284:   return delay, color, allow
33285:  def VVmwD5(self):
33286:   lst = CFG.subtDelaySec.choices.choices
33287:   tMin = lst[0]
33288:   tMax = lst[len(lst) - 1]
33289:   if isinstance(tMin, tuple):
33290:    tMin = tMin[0]
33291:    tMax = tMax[0]
33292:   return int(tMin), int(tMax)
33293:  @staticmethod
33294:  def VVjvxF(SELF):
33295:   srtCfgPath = CCfpAm.VVXUuh(SELF)
33296:   if srtCfgPath and FFCyVu(srtCfgPath + ".dis"):
33297:    return False
33298:   path, delay, enc = CCfpAm.VVuuUw(SELF)
33299:   return True if path else False
33300:  @staticmethod
33301:  def VVuuUw(SELF):
33302:   path, delay, enc = CCfpAm.VVTsdU(SELF)
33303:   if not path:
33304:    path = CCfpAm.VVzzYc(SELF)
33305:   return path, delay, enc
33306:  @staticmethod
33307:  def VVTsdU(SELF):
33308:   srtCfgPath = CCfpAm.VVXUuh(SELF)
33309:   path = enc = ""
33310:   delay = 0
33311:   if srtCfgPath:
33312:    if FFCyVu(srtCfgPath):
33313:     lines = FFL19l(srtCfgPath)
33314:     for line in lines:
33315:      line = line.strip()
33316:      if   line.startswith("srt=") : path = line.split("=")[1].strip()
33317:      elif line.startswith("delay=") : delay = line.split("=")[1].strip()
33318:      elif line.startswith("enc=") : enc = line.split("=")[1].strip()
33319:   if path and FFCyVu(path):
33320:    try:
33321:     delay = int(delay)
33322:    except:
33323:     pass
33324:    return path, delay, enc
33325:   else:
33326:    return "", 0, ""
33327:  @staticmethod
33328:  def VVXUuh(SELF):
33329:   fPath, fDir, fName = CClYaF.VV4zSS(SELF)
33330:   if not fPath:
33331:    evName, evTime, evDur, evShort, evDesc, genre, PR = CC5TsO.VVgoJl(SELF)
33332:    if evName.strip() and evTime and evDur:
33333:     fPath = "/tmp/" + evName[:30].strip()
33334:   if not fPath:
33335:    VV1wIO = CC3rDi(SELF.session).VV1wIO.strip()
33336:    if VV1wIO:
33337:     fPath = "/tmp/" + VV1wIO
33338:   if fPath: return fPath + ".ajp"
33339:   else : return ""
33340:  @staticmethod
33341:  def VVzzYc(SELF):
33342:   bestRatio = 0
33343:   fPath, fDir, fName = CClYaF.VV4zSS(SELF)
33344:   if fName:
33345:    bestSrt = os.path.splitext(fPath)[0] + ".srt"
33346:    if FFCyVu(bestSrt):
33347:     return bestSrt
33348:    else:
33349:     movName = os.path.splitext(fName)[0]
33350:     paths = CCfpAm.VVWHup(SELF)
33351:     nm = CCwklK()
33352:     bLst, err = nm.VVUziJ(movName, paths, 1, 0.3)
33353:     if bLst:
33354:      return bLst[0]
33355:   return ""
33356:  @staticmethod
33357:  def VVWHup(SELF):
33358:   fPath, fDir, fName = CClYaF.VV4zSS(SELF)
33359:   if VVmJwX(fDir):
33360:    files = FFkzic(fDir, "*.srt")
33361:    if files:
33362:     return files
33363:   return []
33364:  @staticmethod
33365:  def VVeLpu():
33366:   try:
33367:    return InfoBar.instance.selected_subtitle
33368:   except:
33369:    try:
33370:     return InfoBar.instance.__selected_subtitle
33371:    except:
33372:     return None
33373:  @staticmethod
33374:  def VVDjVi(subt):
33375:   if subt and isinstance(subt, tuple) and len(subt) >= 4 : state = True
33376:   else             : subt, state = None, False
33377:   try:
33378:    InfoBar.instance.enableSubtitle(subt)
33379:   except:
33380:    try:
33381:     if state:
33382:      InfoBar.instance.__selected_subtitle = subt
33383:     InfoBar.instance.setSubtitlesEnable(state)
33384:    except:
33385:     pass
33386:   CCfpAm.VVKmei()
33387:  @staticmethod
33388:  def VVKmei():
33389:   try:
33390:    if config.subtitles.show.value : InfoBar.instance.subtitle_window.show()
33391:    else       : InfoBar.instance.subtitle_window.hide()
33392:   except:
33393:    pass
33394: class CCyjWK(ScrollLabel):
33395:  def __init__(self, VV0PQG, text="", VVZvtr=True):
33396:   ScrollLabel.__init__(self, text)
33397:   self.VVZvtr   = VVZvtr
33398:   self.long_text    = None
33399:   self.scrollbar    = None
33400:   self.message    = text
33401:   self.instance    = None
33402:   self.VVQz6a  = 0
33403:   self.curPos     = 0
33404:   self.pageHeight    = 0
33405:   self.pageLines    = 0
33406:   self.column     = 0
33407:   self.VVRhqH  = ""
33408:   self.VV0PQG    = VV0PQG
33409:   self.VV7u0U   = None
33410:   self.fontFamily    = None
33411:   self.VVwdmN    = None
33412:   self.parentW    = None
33413:   self.parentH    = None
33414:   self.VViW1R   = True
33415:   self.addNewLine    = True
33416:   self.maxChars    = 0
33417:   self.VVyhy1  = 50 if FFgrjX() else 0
33418:   VV0PQG["keyRedTop"]  = Label("Menu")
33419:   VV0PQG["keyGreenTop"] = Label("Reset")
33420:   VV0PQG["keyYellowTop"] = Label("Font -")
33421:   VV0PQG["keyBlueTop"] = Label("Font +")
33422:   for s in ("Red", "Green", "Yellow", "Blue"):
33423:    VV0PQG["key%sTop1" % s] = Label()
33424:   FFHlAU(VV0PQG,
33425:   {
33426:    "ok"   : VV0PQG.close  ,
33427:    "cancel"  : VV0PQG.close  ,
33428:    "menu"   : self.VVDaGE ,
33429:    "green"   : self.VVc4HF ,
33430:    "yellow"  : self.VV8AUA ,
33431:    "blue"   : self.VV7yIn ,
33432:    "up"   : self.VVLlE3   ,
33433:    "down"   : self.VVSYHQ  ,
33434:    "left"   : self.VVLlE3   ,
33435:    "right"   : self.VVSYHQ  ,
33436:    "last"   : BF(self.VVrpxr, 0) ,
33437:    "0"    : BF(self.VVrpxr, 1) ,
33438:    "next"   : BF(self.VVrpxr, 2) ,
33439:    "pageUp"  : self.VVHyNK   ,
33440:    "chanUp"  : self.VVHyNK   ,
33441:    "pageDown"  : self.VVSI5d   ,
33442:    "chanDown"  : self.VVSI5d
33443:   })
33444:  def VV5kEH(self, VV7u0U=True, VViOjF=False, VVRhqH="", addNewLine=True, hideBtns=False, maxChars=0):
33445:   self.VVRhqH = VVRhqH
33446:   self.addNewLine = addNewLine
33447:   self.maxChars = maxChars
33448:   if hideBtns:
33449:    for b in ("keyRedTop", "keyGreenTop", "keyYellowTop", "keyBlueTop", "keyRedTop1", "keyGreenTop1", "keyYellowTop1", "keyBlueTop1"):
33450:     self.VV0PQG[b].hide()
33451:   FF7hy1(self.VV0PQG["keyRedTop"], "#00FFFF55" if VVRhqH else "#00FFFFFF", "#11000000")
33452:   FFWgBS(self.VV0PQG, True)
33453:   self.VV7u0U = VV7u0U
33454:   if VViOjF:
33455:    self.long_text.setHAlign(1)
33456:   size    = self.VV0PQG.instance.size()
33457:   self.parentW  = size.width()
33458:   self.parentH  = size.height()
33459:   font    = self.long_text.getFont()
33460:   self.fontFamily  = font.family
33461:   self.VVwdmN  = font.pointSize
33462:   try:  self.scrollbar.setBorderColor(parseColor("#11555555"))
33463:   except: pass
33464:   try:  self.scrollbar.setForegroundColor(parseColor("#11AA8E48"))
33465:   except: pass
33466:   try:  self.scrollbar.setBackgroundColor(parseColor("#11111111"))
33467:   except: pass
33468:   color = self.VV0PQG.VVfOli["VVPTnB"]
33469:   FFZ0AC(self, color)
33470:  def VVYmCe(self, color):
33471:   self.long_text.setBackgroundColor(parseColor(color))
33472:  def applySkin(self, desktop, parent):
33473:   import skin
33474:   from enigma import eLabel, eSlider
33475:   self.long_text = eLabel(self.instance)
33476:   self.scrollbar = eSlider(self.instance)
33477:   skin.applyAllAttributes(self.long_text, desktop, self.skinAttributes, parent.scale)
33478:   self.pageWidth = self.long_text.size().width()
33479:   VV8c7y  = int(fontRenderClass.getInstance().getLineHeight(self.long_text.getFont())) or 30
33480:   self.pageLines = int(self.long_text.size().height() / VV8c7y)
33481:   margin   = int(VV8c7y / 6)
33482:   self.pageHeight = int(self.pageLines * VV8c7y)
33483:   self.instance.move(self.long_text.position())
33484:   self.instance.resize(eSize(self.pageWidth, self.pageHeight + margin))
33485:   w = 20
33486:   self.scrollbar.move(ePoint(self.pageWidth - w, 0))
33487:   self.scrollbar.resize(eSize(w, self.pageHeight + margin))
33488:   self.scrollbar.setOrientation(eSlider.orVertical)
33489:   self.scrollbar.setRange(0, 100)
33490:   self.scrollbar.setBorderWidth(1)
33491:   return True
33492:  def setPos(self, pos):
33493:   self.curPos = max(0, min(pos, self.VVQz6a - self.pageHeight))
33494:   self.long_text.move(ePoint(0, -self.curPos))
33495:   self.VVAmEO()
33496:  def VVLlE3(self):
33497:   if self.VVQz6a > self.pageHeight:
33498:    self.setPos(self.curPos - self.pageHeight)
33499:  def VVSYHQ(self):
33500:   if self.VVQz6a > self.pageHeight:
33501:    self.setPos(self.curPos + self.pageHeight)
33502:  def VVHyNK(self):
33503:   self.setPos(0)
33504:  def VVSI5d(self):
33505:   self.setPos(self.VVQz6a-self.pageHeight)
33506:  def VVbV7h(self):
33507:   return self.VVQz6a <= self.pageHeight or self.curPos == self.VVQz6a - self.pageHeight
33508:  def getText(self):
33509:   return self.message
33510:  def VVAmEO(self):
33511:   try:
33512:    vis = int(max(100 * self.pageHeight / self.VVQz6a, 3))
33513:    start = int((100 - vis) * self.curPos / (self.VVQz6a - self.pageHeight))
33514:    self.scrollbar.setStartEnd(start, start + vis)
33515:   except:
33516:    pass
33517:  def setText(self, text, VV47Xm=VVje9A):
33518:   old_VVbV7h = self.VVbV7h()
33519:   self.message = str(text)
33520:   if self.maxChars > 0 and len(self.message) > self.maxChars:
33521:    self.message = self.message[-self.maxChars:]
33522:    if "\n" in self.message[:100]:
33523:     self.message = self.message[self.message.index("\n"):]
33524:   if self.pageHeight:
33525:    if self.addNewLine and len(self.message.splitlines()) < self.pageLines - 2:
33526:     if not self.message.startswith("\n"):
33527:      self.message = "\n" + self.message
33528:     self.message = self.message.rstrip() + "\n"
33529:    self.long_text.setText(self.message)
33530:    self.VVQz6a = self.long_text.calculateSize().height()
33531:    if self.VVZvtr and self.VVQz6a > self.pageHeight:
33532:     self.scrollbar.show()
33533:     self.VVAmEO()
33534:     w = self.VV0PQG.VVfOli["scrollBarW"] + 5
33535:     pageWidth  = self.instance.size().width() - w
33536:     self.long_text.resize(eSize(pageWidth, self.VVQz6a))
33537:     self.VVQz6a = self.long_text.calculateSize().height()
33538:     self.long_text.resize(eSize(pageWidth, self.VVQz6a))
33539:    else:
33540:     self.scrollbar.hide()
33541:    if   VV47Xm == VV5jA8: self.setPos(0)
33542:    elif VV47Xm == VVYAtm : self.VVSI5d()
33543:    elif old_VVbV7h    : self.VVSI5d()
33544:  def appendText(self, text, VV47Xm=VVYAtm):
33545:   self.setText(self.message + str(text), VV47Xm=VV47Xm)
33546:  def VV8AUA(self):
33547:   size = int(self.long_text.getFont().pointSize * 0.8)
33548:   if size > 5:
33549:    self.VVkyRg(size)
33550:  def VV7yIn(self):
33551:   size = int(self.long_text.getFont().pointSize * 1.2)
33552:   if size < 80:
33553:    self.VVkyRg(size)
33554:  def VVc4HF(self):
33555:   self.VVkyRg(self.VVwdmN)
33556:  def VVkyRg(self, VVwdmN):
33557:   self.long_text.setFont(gFont(self.fontFamily, VVwdmN))
33558:   self.setText(self.message, VV47Xm=VVje9A)
33559:   self.VVfu0l()
33560:  def VVrpxr(self, align):
33561:   self.long_text.setHAlign(align)
33562:  def VVDaGE(self):
33563:   VV3wat = []
33564:   VV3wat.append(("%s Wrapping" % ("Disable" if self.VViW1R else "Enable"), "wrap" ))
33565:   VV3wat.append(VVAL3j)
33566:   VV3wat.append(("Align Left" , "left" ))
33567:   VV3wat.append(("Align Center" , "center" ))
33568:   VV3wat.append(("Align Right" , "right" ))
33569:   if self.VVRhqH:
33570:    VV3wat.append(VVAL3j)
33571:    VV3wat.append((FFjt5L("Save to File", VVFuwR), "save"))
33572:   VV3wat.append(VVAL3j)
33573:   VV3wat.append(("Keys (Shortcuts)", "help"))
33574:   FFLFTC(self.VV0PQG, self.VVjTXc, VV3wat=VV3wat, title="Text Option", width=500)
33575:  def VVjTXc(self, item=None):
33576:   if item:
33577:    if item == "wrap"  : self.VVOJVi()
33578:    elif item == "left"  : self.VVrpxr(0)
33579:    elif item == "center" : self.VVrpxr(1)
33580:    elif item == "right" : self.VVrpxr(2)
33581:    elif item == "save"  : self.VVxeSU()
33582:    elif item == "help"  : FFw2rR(self.VV0PQG, "_help_txt", "Text Viewer (Keys)")
33583:  def VVv22o(self, isOn):
33584:   self.VViW1R = isOn
33585:   self.long_text.setNoWrap(not isOn)
33586:  def VVOJVi(self):
33587:   self.VVv22o(not self.VViW1R)
33588:  def VVxeSU(self):
33589:   title = "%s Log File" % self.VVRhqH.capitalize()
33590:   expPath = FFeAlZ()
33591:   try:
33592:    outF = "%sAJPanel_log_%s_%s.txt" % (FFoWxR(expPath), self.VVRhqH, FFjTQe())
33593:    with open(outF, "w") as f:
33594:     f.write(FFzBfi(self.message))
33595:    FFipXT(self.VV0PQG, "Saved to:\n\n%s" % outF, title=title)
33596:   except:
33597:    FFdw58(self.VV0PQG, "Could not save to:\n\n%s" % expPath, title=title)
33598:  def VVfu0l(self, minHeight=0):
33599:   if self.VV7u0U:
33600:    VV8c7y = int(fontRenderClass.getInstance().getLineHeight(self.long_text.getFont()))
33601:    textH = min(self.pageHeight, VV8c7y * (len(self.message.splitlines()) + 1))
33602:    if textH < self.pageHeight and self.VVQz6a < self.pageHeight:
33603:     textH = max(textH, self.VVQz6a) + self.VVyhy1
33604:    self.resize(eSize(*(self.instance.size().width(), textH + 6)))
33605:    diff = self.pageHeight - textH
33606:    newH = self.parentH - diff
33607:    if diff < 0:
33608:     newH = self.parentH
33609:    if minHeight > 0:
33610:     newH = max(newH, minHeight + self.VV0PQG.VVfOli["titleH"] + self.VV0PQG.VVfOli["VVpeQE"] * 2 + 1)
33611:    screenSize = getDesktop(0).size()
33612:    self.VV0PQG.instance.resize(eSize(*(self.parentW, min(self.parentH, newH))))
33613:    self.VV0PQG.instance.move(ePoint((screenSize.width() - self.parentW) // 2, (screenSize.height() - newH) // 2))
```

## File: README.md
```markdown
1: # AJPan
```
